<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MPLS 实验1</title>
    <url>/2014/MPLS_Lab_1/</url>
    <content><![CDATA[<h1 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h1><ul>
<li>模拟器：GNS3 0.8.6</li>
<li>路由器IOS：c7200-adventerprisek9-mz.151-4.M2.image</li>
</ul>
<h1 id="GNS3实验拓扑文件："><a href="#GNS3实验拓扑文件：" class="headerlink" title="GNS3实验拓扑文件："></a>GNS3实验拓扑文件：</h1><p><a href="topology.net">拓扑文件</a></p>
<h1 id="实验拓扑："><a href="#实验拓扑：" class="headerlink" title="实验拓扑："></a>实验拓扑：</h1><p><img src="/2014/MPLS_Lab_1/topo.png"></p>
<span id="more"></span>

<h1 id="基本预配置："><a href="#基本预配置：" class="headerlink" title="基本预配置："></a>基本预配置：</h1><h2 id="R1："><a href="#R1：" class="headerlink" title="R1："></a>R1：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 1.1.1.1 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.12.1 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shut</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.15.1 255.255.255.0</span><br><span class="line">    no shut</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 1.1.1.1</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R2："><a href="#R2：" class="headerlink" title="R2："></a>R2：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 2.2.2.2 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.12.2 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.23.2 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 2.2.2.2</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R3："><a href="#R3：" class="headerlink" title="R3："></a>R3：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R3</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 3.3.3.3 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.34.3 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.23.3 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 3.3.3.3</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R4："><a href="#R4：" class="headerlink" title="R4："></a>R4：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R4</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 4.4.4.4 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.34.4 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.47.4 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 4.4.4.4</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="实验与调试（本实验仅涉及AS1中的4台路由器）："><a href="#实验与调试（本实验仅涉及AS1中的4台路由器）：" class="headerlink" title="实验与调试（本实验仅涉及AS1中的4台路由器）："></a>实验与调试（本实验仅涉及AS1中的4台路由器）：</h1><h2 id="实验1：MPLS基本配置与验证：AS1作为MPLS域，在AS1中的所有路由器上运行MPLS；"><a href="#实验1：MPLS基本配置与验证：AS1作为MPLS域，在AS1中的所有路由器上运行MPLS；" class="headerlink" title="实验1：MPLS基本配置与验证：AS1作为MPLS域，在AS1中的所有路由器上运行MPLS；"></a>实验1：MPLS基本配置与验证：AS1作为MPLS域，在AS1中的所有路由器上运行MPLS；</h2><p>可以使用命令<code>mpls label protocol &#123;ldp | tdp&#125;</code> ,来指定标签分发协议；<br>可以看到支持两种标签分发协议，LDP和TDP，默认使用LDP作为标签分发协议；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#mpls label protocol ?</span><br><span class="line"> ldp  Use LDP (default)</span><br><span class="line"> tdp  Use TDP</span><br><span class="line"></span><br><span class="line">R1(config)#mpls label protocol ldp</span><br></pre></td></tr></table></figure>
<p>可以使用命令<code>mpls ldp router-id interface [force]</code>来强制改变LDP路由ID；<br>如果不指定LDP router-id则LDP router-id选举规则同 OSPF ；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动指定R1将l0接口地址作为LDP router-id的一部分，force选项表示立即生效；</span></span><br><span class="line">R1(config)<span class="meta">#mpls ldp router-id l0 force</span></span><br></pre></td></tr></table></figure>

<p>使用接口命令<code>mpls ip</code>，在R1所有已激活的接口上启用MPLS ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#interface FastEthernet0/0</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#mpls ip</span></span><br></pre></td></tr></table></figure>

<p>可以看到在R1的loopback 0接口配置启用MPLS时，IOS日志提示回环接口不支持MPLS ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#interface Loopback0</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#mpls ip</span></span><br><span class="line">% MPLS not supported on interface Loopback0</span><br></pre></td></tr></table></figure>


<p>在R2上，使用 LDP 作为 MPLS 标签分发协议，指定 loopback 0 作为 LDP 的 <code>router-id</code>，并使用接口命令 <code>mpls ip</code> ，在适当的的接口上启用 MPLS ；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R2(config)<span class="meta">#mpls label protocol ldp</span></span><br><span class="line">R2(config)<span class="meta">#mpls ldp router-id l0 force</span></span><br><span class="line"></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#interface FastEthernet0/0</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#mpls ip</span></span><br><span class="line"></span><br><span class="line">*Mar  <span class="number">1</span> <span class="number">00</span>:<span class="number">09</span>:<span class="number">05.223</span>: %LDP<span class="number">-5</span>-NBRCHG: LDP Neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span> (<span class="number">1</span>) is UP</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到LDP邻居变化日志提示，LDP邻居已经UP，邻居为1.1.1.1:0；</span></span><br><span class="line"></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#interface FastEthernet0/1</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#mpls ip</span></span><br></pre></td></tr></table></figure>
<p>在R3上，使用LDP作为MPLS标签分发协议，指定loopback 0作为LDP的<code>router-id</code>，并使用接口命令<code>mpls ip</code>，在适当的的接口上启用MPLS；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config)#mpls label protocol ldp</span><br><span class="line">R3(config)#mpls ldp router-id l0 force</span><br><span class="line"></span><br><span class="line">R3(config-if)#interface FastEthernet0/0</span><br><span class="line">R3(config-if)#mpls ip</span><br><span class="line">R3(config-if)#interface FastEthernet0/1</span><br><span class="line">R3(config-if)#mpls ip</span><br></pre></td></tr></table></figure>

<p>在R4上，使用 LDP 作为 MPLS 标签分发协议，指定 loopback 0 作为 LDP 的<code>router-id</code>，并使用接口命令<code>mpls ip</code>，在适当的的接口上启用 MPLS ；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config)#mpls label protocol ldp</span><br><span class="line">R4(config)#mpls ldp router-id l0 force</span><br><span class="line"></span><br><span class="line">R4(config-if)#interface FastEthernet0/0</span><br><span class="line">R4(config-if)#mpls ip</span><br></pre></td></tr></table></figure>

<p><strong>抓包查看分析LDP包结构：</strong><br><img src="/2014/MPLS_Lab_1/pic1.png"><br><img src="/2014/MPLS_Lab_1/pic2.png"><br>可以看到LDP hello包使用UDP进行封装，而Keep Alive包使用TCP进行封装；</p>
<p><strong>附件：</strong><a href="LDP.pcapng">Wireshark抓包文件</a></p>
<p>在 R1 上查看启用 MPLS 的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#do show mpls interface</span><br><span class="line">Interface              IP            Tunnel   BGP Static Operational</span><br><span class="line">FastEthernet0/0        Yes (ldp)     No       No  No     Yes</span><br></pre></td></tr></table></figure>
<p>R1上只用<code>f0/0</code>启用了 MPLS ，可以看到 MPLS 使用 LDP 作为标签分发协议；</p>
<p>在R1上查看LDP邻居发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show mpls ldp discovery </span><br><span class="line"> Local LDP Identifier:</span><br><span class="line">  1.1.1.1:0</span><br><span class="line">  Discovery Sources:</span><br><span class="line">  Interfaces:</span><br><span class="line">    FastEthernet0/0 (ldp): xmit/recv</span><br><span class="line">      LDP Id: 2.2.2.2:0</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到R1本地的LDP标识符为<code>1.1.1.1:0</code>，其中LDP路由器标识符由两部分组成：<ul>
<li>其中第一部分为接口IP地址；</li>
<li>第二部分为LSR所使用的标签空间字节。如果为0则表示LSR是使用整个设备的标签空间，如果不为0则表示LSR是使用接口标签空间；</li>
</ul>
</li>
<li>还可以看出，R1在启用LDP的接口f0&#x2F;0上发现了LDP邻居;</li>
</ul>
<p>在R1上查看LDP邻居发现详细信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show mpls ldp discovery detail </span></span><br><span class="line">    Local LDP Identifier:</span><br><span class="line">    <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">    Discovery Sources:</span><br><span class="line">    Interfaces:</span><br><span class="line">        FastEthernet0/<span class="number">0</span> (ldp): xmit/recv</span><br><span class="line">            Enabled: Interface config    </span><br><span class="line">            Hello interval: <span class="number">5000</span> ms; Transport IP addr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>   <span class="comment">//Discovery hello时间间隔为5秒；</span></span><br><span class="line">            LDP Id: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span></span><br><span class="line">                Src IP addr: <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>; Transport IP addr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">                Hold time: <span class="number">15</span> sec; Proposed local/peer: <span class="number">15</span>/<span class="number">15</span> sec  <span class="comment">//Discovery保持时间为15秒；</span></span><br><span class="line">                Reachable via <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span></span><br></pre></td></tr></table></figure>
<p>在R1上查看LDP邻居关系：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show mpls ldp neighbor </span></span><br><span class="line">    Peer LDP Ident: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>; Local LDP Ident <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span><span class="number">.13634</span> - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span></span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">643</span>/<span class="number">640</span>; Downstream</span><br><span class="line">        Up time: <span class="number">09</span>:<span class="number">11</span>:<span class="number">15</span></span><br><span class="line">        LDP discovery sources:</span><br><span class="line">            FastEthernet0/<span class="number">0</span>, Src IP addr: <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span></span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">            <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>    <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span>    <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>   </span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到R1有一个LDP邻居，并且邻居标识符为2.2.2.2:0；</li>
<li>而R1本地的LDP标识符为1.1.1.1:0;TCP连接为2.2.2.2的13634端口到1.1.1.1的646端口；</li>
<li>邻居已经建立了9个小时11分15秒；</li>
<li>LDP发现源为f0&#x2F;0接口，地址为f0&#x2F;0的接口地址192.168.12.2；</li>
</ul>
<p>在R1上<code>traceroute 4.4.4.4</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#do traceroute 4.4.4.4</span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Tracing the route to <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span></span><br><span class="line">VRF info: (vrf in name/id, vrf out name/id)</span><br><span class="line">    <span class="number">1</span> <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> [MPLS: Label <span class="number">18</span> Exp <span class="number">0</span>] <span class="number">76</span> msec <span class="number">80</span> msec <span class="number">76</span> msec</span><br><span class="line">    <span class="number">2</span> <span class="number">192.168</span><span class="number">.23</span><span class="number">.3</span> [MPLS: Label <span class="number">18</span> Exp <span class="number">0</span>] <span class="number">96</span> msec <span class="number">44</span> msec <span class="number">68</span> msec</span><br><span class="line">    <span class="number">3</span> <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span> <span class="number">120</span> msec *  <span class="number">116</span> msec</span><br></pre></td></tr></table></figure>
<p>可以看到 MPLS 已经生效，<code>traceroute</code>的 ICMP 包当前正是使用 MPLS 进行转发；</p>
<h2 id="实验2：MPLS-LDP自动配置；"><a href="#实验2：MPLS-LDP自动配置；" class="headerlink" title="实验2：MPLS LDP自动配置；"></a>实验2：MPLS LDP自动配置；</h2><p>在R4上查看启用MPLS的接口详细信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#do show mpls interface detail</span></span><br><span class="line">Interface FastEthernet0/<span class="number">0</span>:</span><br><span class="line">  IP labeling <span class="title function_">enabled</span> <span class="params">(ldp)</span>: </span><br><span class="line">   Interface config</span><br><span class="line">  LSP Tunnel labeling not enabled</span><br><span class="line">  BGP labeling not enabled</span><br><span class="line">  MPLS operational</span><br><span class="line">  MTU = <span class="number">1500</span></span><br><span class="line"><span class="comment">//可以看到接口F0/0已经启用了LDP，并且是在接口下通过手动配置启用的；</span></span><br><span class="line"></span><br><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#do sh mpls ldp discovery detail</span></span><br><span class="line"> Local LDP Identifier:</span><br><span class="line"> <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span></span><br><span class="line"> Discovery Sources:</span><br><span class="line"> Interfaces:</span><br><span class="line">  FastEthernet0/<span class="number">0</span> (ldp): xmit/recv</span><br><span class="line">   Enabled: Interface config</span><br><span class="line">   Hello interval: <span class="number">5000</span> ms; Transport IP addr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> </span><br><span class="line">   LDP Id: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span></span><br><span class="line">    Src IP addr: <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span>; Transport IP addr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br><span class="line">    Hold time: <span class="number">15</span> sec; Proposed local/peer: <span class="number">15</span>/<span class="number">15</span> sec</span><br><span class="line">    Reachable via <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span></span><br><span class="line">    Password: not required, none, in use</span><br><span class="line">   Clients: IPv4</span><br><span class="line"><span class="comment">//通过查看R4的LDP邻居发现详情也可以看到接口F0/0是通过在接口下手动配置启用的MPLS LDP；</span></span><br></pre></td></tr></table></figure>

<p>禁用之前在接口下启用的MPLS：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config)#int f0/0</span><br><span class="line">R4(config-if)#no mpls ip</span><br></pre></td></tr></table></figure>

<p>在R4的OSPF路由器配置模式下启用MPLS LDP自动配置；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config)#router ospf 1</span><br><span class="line">R4(config-router)#mpls ldp autoconfig </span><br></pre></td></tr></table></figure>

<p>在R4上验证：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-router)<span class="meta">#do sh mpls interface detail</span></span><br><span class="line">Interface FastEthernet0/<span class="number">0</span>:</span><br><span class="line">  IP labeling <span class="title function_">enabled</span> <span class="params">(ldp)</span>:</span><br><span class="line">   IGP config</span><br><span class="line">  LSP Tunnel labeling not enabled</span><br><span class="line">  BGP labeling not enabled</span><br><span class="line">  MPLS operational</span><br><span class="line">  MTU = <span class="number">1500</span></span><br><span class="line"><span class="comment">//可以看到，接口F0/0现在已经启用了LDP，但现在是通过IGP自动配置的方式启用的；</span></span><br><span class="line"></span><br><span class="line">R4(config-router)<span class="meta">#do show mpls ldp discovery detail</span></span><br><span class="line"> Local LDP Identifier:</span><br><span class="line"> <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span></span><br><span class="line"> Discovery Sources:</span><br><span class="line"> Interfaces:</span><br><span class="line">  FastEthernet0/<span class="number">0</span> (ldp): xmit/recv</span><br><span class="line">   Enabled: IGP config;</span><br><span class="line">   Hello interval: <span class="number">5000</span> ms; Transport IP addr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> </span><br><span class="line">   LDP Id: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span></span><br><span class="line">    Src IP addr: <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span>; Transport IP addr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br><span class="line">    Hold time: <span class="number">15</span> sec; Proposed local/peer: <span class="number">15</span>/<span class="number">15</span> sec</span><br><span class="line">    Reachable via <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span></span><br><span class="line">    Password: not required, none, in use</span><br><span class="line">   Clients: IPv4</span><br><span class="line"><span class="title function_">R4</span><span class="params">(config-router)</span><span class="meta">#do sh mpls interface detail</span></span><br><span class="line">Interface FastEthernet0/0:</span><br><span class="line">  IP labeling <span class="title function_">enabled</span> <span class="params">(ldp)</span>:</span><br><span class="line">   IGP config</span><br><span class="line">  LSP Tunnel labeling not enabled</span><br><span class="line">  BGP labeling not enabled</span><br><span class="line">  MPLS operational</span><br><span class="line">  MTU = <span class="number">1500</span></span><br><span class="line"><span class="comment">//可以看到，接口F0/0现在已经启用了LDP，但现在是通过IGP自动配置的方式启用的；</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：MPLS LDP自动配置目前只支持OSPF；</p>
</blockquote>
<h2 id="实验3：修改MPLS-LDP-计时器；"><a href="#实验3：修改MPLS-LDP-计时器；" class="headerlink" title="实验3：修改MPLS LDP 计时器；"></a>实验3：修改MPLS LDP 计时器；</h2><p>可以使用命令<code>show mpls ldp parameters</code>查看 LDP 当前使用的计时器参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show mpls ldp parameters </span></span><br><span class="line">Protocol version: <span class="number">1</span></span><br><span class="line">Downstream label generic region: min label: <span class="number">16</span>; max label: <span class="number">100000</span></span><br><span class="line">Session hold time: <span class="number">180</span> sec; keep alive interval: <span class="number">60</span> sec   <span class="comment">//LDP TCP会话保持时间为180秒，LDP TCP会话Keep Alive消息发送间隔为60秒；</span></span><br><span class="line">Discovery hello: holdtime: <span class="number">15</span> sec; interval: <span class="number">5</span> sec  <span class="comment">//LDP Discovery hello保持时间为15秒，hello消息发送时间间隔为5秒；</span></span><br><span class="line">Discovery targeted hello: holdtime: <span class="number">90</span> sec; interval: <span class="number">10</span> sec  <span class="comment">//目标邻居Discovery hello保持时间为90秒，hello消息发送间隔为10秒；</span></span><br><span class="line">Downstream on Demand max hop count: <span class="number">255</span></span><br><span class="line">Downstream on Demand Path Vector Limit: <span class="number">255</span></span><br><span class="line">LDP <span class="keyword">for</span> targeted sessions</span><br><span class="line">LDP initial/maximum backoff: <span class="number">15</span>/<span class="number">120</span> sec</span><br><span class="line">LDP loop detection: off</span><br></pre></td></tr></table></figure>

<p>在R1上修改MPLS LDP邻居发现hello 发送间隔和保持时间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将R1的MPLS LDP邻居发现hello时间间隔设置为10秒；</span></span><br><span class="line">R1(config)<span class="meta">#mpls ldp discovery hello interval 10</span></span><br><span class="line"><span class="comment">//将R1的MPLS LDP邻居发现保持时间设置为30秒；</span></span><br><span class="line">R1(config)<span class="meta">#mpls ldp discovery hello holdtime 30</span></span><br></pre></td></tr></table></figure>

<p>在R1上验证MPLS LDP参数信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do sh mpls ldp parameter</span></span><br><span class="line">LDP Feature Set Manager: State Initialized</span><br><span class="line"> LDP features:</span><br><span class="line"> Basic</span><br><span class="line"> IP-over-MPLS</span><br><span class="line"> TDP</span><br><span class="line"> IGP-Sync</span><br><span class="line"> Auto-Configuration</span><br><span class="line"> TCP-MD5-Rollover</span><br><span class="line">Protocol version: <span class="number">1</span></span><br><span class="line">Session hold time: <span class="number">180</span> sec; keep alive interval: <span class="number">60</span> sec</span><br><span class="line">Discovery hello: holdtime: <span class="number">30</span> sec; interval: <span class="number">10</span> sec</span><br><span class="line">Discovery targeted hello: holdtime: <span class="number">90</span> sec; interval: <span class="number">10</span> sec</span><br><span class="line">Downstream on Demand max hop count: <span class="number">255</span></span><br><span class="line">LDP <span class="keyword">for</span> targeted sessions</span><br><span class="line">LDP initial/maximum backoff: <span class="number">15</span>/<span class="number">120</span> sec</span><br><span class="line">LDP loop detection: off</span><br><span class="line"><span class="comment">//可以看到R1的LDP Discovery计时器的hello interval被修改为30秒，holdtime被修改为10秒；</span></span><br></pre></td></tr></table></figure>

<p>验证LDP Discovery 计时器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show mpls ldp neighbor 2.2.2.2 detail</span></span><br><span class="line"> Peer LDP Ident: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>; Local LDP Ident <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">  TCP connection: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span><span class="number">.42221</span> - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span></span><br><span class="line">  Password: not required, none, in use</span><br><span class="line">  State: Oper; Msgs sent/rcvd: <span class="number">82</span>/<span class="number">81</span>; Downstream; Last TIB rev sent <span class="number">16</span></span><br><span class="line">  Up time: <span class="number">01</span>:<span class="number">02</span>:<span class="number">47</span>; UID: <span class="number">2</span>; Peer Id <span class="number">0</span>;</span><br><span class="line">  LDP discovery sources:</span><br><span class="line">   FastEthernet0/<span class="number">0</span>; Src IP addr: <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> </span><br><span class="line">   holdtime: <span class="number">15000</span> ms, hello interval: <span class="number">5000</span> ms</span><br><span class="line">  Addresses bound to peer LDP Ident:</span><br><span class="line">   <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>    <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span>    <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>         </span><br><span class="line">  Peer holdtime: <span class="number">180000</span> ms; KA interval: <span class="number">60000</span> ms; Peer state: estab</span><br><span class="line">  Capabilities Sent:</span><br><span class="line">   [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">   [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">   [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">  Capabilities Received:</span><br><span class="line">   [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">   [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">   [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line"></span><br><span class="line">R1<span class="meta">#show mpls ldp discovery detail</span></span><br><span class="line"> Local LDP Identifier:</span><br><span class="line"> 1.1.1.1:0</span><br><span class="line"> Discovery Sources:</span><br><span class="line"> Interfaces:</span><br><span class="line">  FastEthernet0/0 <span class="params">(ldp)</span>: xmit/recv</span><br><span class="line">   Enabled: Interface config</span><br><span class="line">   Hello interval: 5000 ms; Transport IP addr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> </span><br><span class="line">   LDP Id: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span></span><br><span class="line">    Src IP addr: <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>; Transport IP addr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">    Hold time: <span class="number">15</span> sec; Proposed local/peer: <span class="number">30</span>/<span class="number">15</span> sec</span><br><span class="line">    Reachable via <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span></span><br><span class="line">    Password: not required, none, in use</span><br><span class="line">   Clients: IPv4</span><br><span class="line"><span class="comment">//可以看到邻居LSR的LDP Discovery hello interval为5秒,holdtime为15秒；</span></span><br><span class="line"><span class="comment">//本地的Holdtime为30秒；</span></span><br></pre></td></tr></table></figure>

<p>在R1上修改LDP TCP会话保持时间设置为300秒：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#mpls ldp holdtime 300 </span></span><br><span class="line">%Previously established sessions may not use the new holdtime.</span><br><span class="line"><span class="comment">//要让新的保持时间立即生效，需要重置一下LDP邻居关系；</span></span><br><span class="line">R1(config)<span class="meta">#do clear mpls ldp neighbor *</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：LDP TCP会话保持时间被修改后，LDP会话的Keep Alive计时器值自动被修改为保持时间的1&#x2F;3；</p>
</blockquote>
<p>验证R1的MPLS LDP TCP会话保持时间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do sh mpls ldp parameters</span></span><br><span class="line">LDP Feature Set Manager: State Initialized</span><br><span class="line"> LDP features:</span><br><span class="line"> Basic</span><br><span class="line"> IP-over-MPLS</span><br><span class="line"> TDP</span><br><span class="line"> IGP-Sync</span><br><span class="line"> Auto-Configuration</span><br><span class="line"> TCP-MD5-Rollover</span><br><span class="line">Protocol version: <span class="number">1</span></span><br><span class="line">Session hold time: <span class="number">300</span> sec; keep alive interval: <span class="number">100</span> sec</span><br><span class="line">Discovery hello: holdtime: <span class="number">30</span> sec; interval: <span class="number">10</span> sec</span><br><span class="line">Discovery targeted hello: holdtime: <span class="number">90</span> sec; interval: <span class="number">10</span> sec</span><br><span class="line">Downstream on Demand max hop count: <span class="number">255</span></span><br><span class="line">LDP <span class="keyword">for</span> targeted sessions</span><br><span class="line">LDP initial/maximum backoff: <span class="number">15</span>/<span class="number">120</span> sec</span><br><span class="line">LDP loop detection: off</span><br><span class="line"><span class="comment">//可以看到R1本地的LDP会话保持时间已经为300秒，其Keep Alive Interval自动被设置为100秒；</span></span><br></pre></td></tr></table></figure>

<p>查看邻居LDP对等体的MPLS LDP TCP会话保持时间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do sh mpls ldp neighbor 2.2.2.2 detail                         </span></span><br><span class="line"> Peer LDP Ident: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>; Local LDP Ident <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">  TCP connection: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span><span class="number">.21743</span> - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span></span><br><span class="line">  Password: not required, none, in use</span><br><span class="line">  State: Oper; Msgs sent/rcvd: <span class="number">15</span>/<span class="number">14</span>; Downstream; Last TIB rev sent <span class="number">16</span></span><br><span class="line">  Up time: <span class="number">00</span>:<span class="number">04</span>:<span class="number">00</span>; UID: <span class="number">3</span>; Peer Id <span class="number">0</span>;</span><br><span class="line">  LDP discovery sources:</span><br><span class="line">   FastEthernet0/<span class="number">0</span>; Src IP addr: <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> </span><br><span class="line">   holdtime: <span class="number">15000</span> ms, hello interval: <span class="number">5000</span> ms</span><br><span class="line">  Addresses bound to peer LDP Ident:</span><br><span class="line">   <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>    <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span>    <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>         </span><br><span class="line">  Peer holdtime: <span class="number">180000</span> ms; KA interval: <span class="number">60000</span> ms; Peer state: estab</span><br><span class="line">  Capabilities Sent:</span><br><span class="line">   [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">   [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">   [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">  Capabilities Received:</span><br><span class="line">   [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">   [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">   [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>注意到邻居对等体的保持时间仍然为180秒，Keep Alive Interval仍然是60秒；其原因在于，和LDP Discovery计时器取较小值相同，LDP TCP会话计时器也取较小值；</li>
<li>由于刚刚修改LDP 会话保持时间为300秒，此值大于默认的180秒；</li>
</ul>
<p>修改R2的LDP TCP会话保持时间改为900秒：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R2(config)<span class="meta">#mpls ldp holdtime 900</span></span><br><span class="line">%Previously established sessions may not use the new holdtime.</span><br><span class="line"></span><br><span class="line">R2(config)<span class="meta">#do clear mpls ldp neighbor *</span></span><br></pre></td></tr></table></figure>

<p>可以看到R2本地的LDP TCP会话保持时间已经被设置为900秒，KA Interval自动被设置为300秒：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R2(config)<span class="meta">#do show mpls ldp parameters</span></span><br><span class="line">LDP Feature Set Manager: State Initialized</span><br><span class="line"> LDP features:</span><br><span class="line"> Basic</span><br><span class="line"> IP-over-MPLS</span><br><span class="line"> TDP</span><br><span class="line"> IGP-Sync</span><br><span class="line"> Auto-Configuration</span><br><span class="line"> TCP-MD5-Rollover</span><br><span class="line">Protocol version: <span class="number">1</span></span><br><span class="line">Session hold time: <span class="number">900</span> sec; keep alive interval: <span class="number">300</span> sec</span><br><span class="line">Discovery hello: holdtime: <span class="number">15</span> sec; interval: <span class="number">5</span> sec</span><br><span class="line">Discovery targeted hello: holdtime: <span class="number">90</span> sec; interval: <span class="number">10</span> sec</span><br><span class="line">Downstream on Demand max hop count: <span class="number">255</span></span><br><span class="line">LDP <span class="keyword">for</span> targeted sessions</span><br><span class="line">LDP initial/maximum backoff: <span class="number">15</span>/<span class="number">120</span> sec</span><br><span class="line">LDP loop detection: off</span><br></pre></td></tr></table></figure>
<p>回到R1上查看LDP 邻居对等体R2实际使用的LDP会话保持时间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do sh mpls ldp neighbor 2.2.2.2 detail</span></span><br><span class="line"> Peer LDP Ident: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>; Local LDP Ident <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">  TCP connection: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span><span class="number">.37641</span> - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span></span><br><span class="line">  Password: not required, none, in use</span><br><span class="line">  State: Oper; Msgs sent/rcvd: <span class="number">12</span>/<span class="number">12</span>; Downstream; Last TIB rev sent <span class="number">16</span></span><br><span class="line">  Up time: <span class="number">00</span>:<span class="number">02</span>:<span class="number">58</span>; UID: <span class="number">5</span>; Peer Id <span class="number">0</span>;</span><br><span class="line">  LDP discovery sources:</span><br><span class="line">   FastEthernet0/<span class="number">0</span>; Src IP addr: <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> </span><br><span class="line">   holdtime: <span class="number">15000</span> ms, hello interval: <span class="number">5000</span> ms</span><br><span class="line">  Addresses bound to peer LDP Ident:</span><br><span class="line">   <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>    <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span>    <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>         </span><br><span class="line">  Peer holdtime: <span class="number">300000</span> ms; KA interval: <span class="number">100000</span> ms; Peer state: estab</span><br><span class="line">  Capabilities Sent:</span><br><span class="line">   [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">   [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">   [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">  Capabilities Received:</span><br><span class="line">   [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">   [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">   [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到虽然R2本地的LDP 会话保持时间已经被设置为900秒，但是在与R1协商后，由于R1的LDP会话保持时间300秒小于R2的900秒，所以R2使用300秒作为LDP会话保持时间；<blockquote>
<p><strong>注意，LDP邻居计时器可以不一致，当两台LDP邻居对等体在交换参数的时候，取较小的计时器值，Discovery计时器如此，LDP TCP会话保持时间亦如此，基于目标的LDP邻居会话同样如此；</strong></p>
</blockquote>
</li>
</ul>
<h2 id="实验4：LDP认证：在R1和R2之间配置LDP身份认证"><a href="#实验4：LDP认证：在R1和R2之间配置LDP身份认证" class="headerlink" title="实验4：LDP认证：在R1和R2之间配置LDP身份认证"></a>实验4：LDP认证：在R1和R2之间配置LDP身份认证</h2><p>为避免等待验证实验现象时间较长，修改LDP 会话保持时间为15秒：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#mpls ldp holdtime 15</span></span><br></pre></td></tr></table></figure>

<p>在R1上针对邻居2.2.2.2启用LDP认证：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#mpls ldp neighbor 2.2.2.2 password cisco</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：实验中，发现如果不重置LDP邻居对等体关系，LDP身份认证配置无法生效；</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do clear mpls ldp nei 2.2.2.2  </span></span><br><span class="line">R1(config)#</span><br><span class="line">*Mar <span class="number">13</span> <span class="number">21</span>:<span class="number">36</span>:<span class="number">40.426</span>: %LDP<span class="number">-5</span>-CLEAR_NBRS: Clear LDP <span class="title function_">neighbors</span> <span class="params">(<span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>)</span> by console</span><br><span class="line">*Mar 13 21:36:40.466: %LDP-5-NBRCHG: LDP Neighbor 2.2.2.2:0 <span class="params">(<span class="number">1</span>)</span> is <span class="title function_">DOWN</span> <span class="params">(User cleared session manually)</span></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 13 21:36:42.822: %TCP-6-BADAUTH: No MD5 digest from 2.2.2.2<span class="params">(<span class="number">11164</span>)</span> to 1.1.1.1<span class="params">(<span class="number">646</span>)</span></span><br></pre></td></tr></table></figure>

<p>由于R2还未配置LDP认证，重置LDP邻居关系后，出现TCP认证报错日志，没有MD5摘要来自2.2.2.2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在R2上针对邻居1.1.1.1启用LDP认证；</span></span><br><span class="line">R2(config)<span class="meta">#mpls ldp neighbor 1.1.1.1 password cisco    </span></span><br><span class="line"><span class="comment">//注意：实验中，发现如果不重置LDP邻居对等体关系，LDP身份认证配置无法生效；</span></span><br><span class="line">R2(config)<span class="meta">#do clear mpls ldp nei 1.1.1.1</span></span><br></pre></td></tr></table></figure>

<h2 id="实验5：基于目标的LDP会话"><a href="#实验5：基于目标的LDP会话" class="headerlink" title="实验5：基于目标的LDP会话"></a>实验5：基于目标的LDP会话</h2><p>配置R1与R4建立基于目标的远程LDP会话</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在R1上指定远程LDP邻居；</span></span><br><span class="line"> R1(config)<span class="meta">#mpls ldp neighbor 4.4.4.4 targeted</span></span><br><span class="line"> <span class="comment">//注意，如果一台LSR只配置命令mpls ldp neighbor ip-address targeted，则这台LSR为远程LDP会话的主动发起方；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置的基于目标的LDP邻居会话Discovery Hello Interval和Holdtime；</span></span><br><span class="line"> R1(config)<span class="meta">#mpls ldp discovery targeted-hello interval 10</span></span><br><span class="line"> R1(config)<span class="meta">#mpls ldp discovery targeted-hello holdtime 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置R1只允许R4与自己建立远程LDP邻居，通过配置R1只接受R4发送给自己的Discovery Hello消息来实现；</span></span><br><span class="line"> R1(config)<span class="meta">#mpls ldp discovery targeted-hello accept from 1</span></span><br><span class="line"> R1(config)<span class="meta">#access-list 1 permit host 4.4.4.4</span></span><br><span class="line"> <span class="comment">//注意，如果一台LSR只配置命令mpls ldp discovery targeted-hello accept from，则这台LSR为远程LDP会话的被动接受方；</span></span><br><span class="line"> <span class="comment">//注意：当一台LSR只配置此命令，并不是说这台LSR只能接收主动发起方通告来的标签绑定信息，</span></span><br><span class="line"> <span class="comment">//即使，一台LSR只配置了此命令，当其与远程LDP会话主动发起方建立LDP远程会话之后，</span></span><br><span class="line"> <span class="comment">//被动接受方LSR也会向主动发起方LSR通告自己的入标签；</span></span><br></pre></td></tr></table></figure>

<p>在R4上指定远程LDP邻居；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#mpls ldp neighbor 1.1.1.1 targeted</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置R4只允许R1与自己建立远程LDP邻居，通过配置R4只接受R1发送给自己的Discovery Hello消息来实现；</span></span><br><span class="line">R4(config)<span class="meta">#mpls ldp discovery targeted-hello accept from 1</span></span><br><span class="line">R4(config)<span class="meta">#access-list 1 permit host 1.1.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：如果一台LSR同时配置了命令mpls ldp discovery targeted-hello accept from和命令mpls ldp neighbor ip-address targeted，</span></span><br><span class="line"><span class="comment">//则这台路由器既是远程基于目标LDP会话的主动发起方，同时也是被动接受方；</span></span><br></pre></td></tr></table></figure>

<p>验证R1基于目标LDP会话计时器配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do sh mpls ldp parameters               </span></span><br><span class="line">LDP Feature Set Manager: State Initialized</span><br><span class="line"> LDP features:</span><br><span class="line"> Basic</span><br><span class="line"> IP-over-MPLS</span><br><span class="line"> TDP</span><br><span class="line"> IGP-Sync</span><br><span class="line"> Auto-Configuration</span><br><span class="line"> TCP-MD5-Rollover</span><br><span class="line">Protocol version: <span class="number">1</span></span><br><span class="line">Session hold time: <span class="number">15</span> sec; keep alive interval: <span class="number">5</span> sec</span><br><span class="line">Discovery hello: holdtime: <span class="number">30</span> sec; interval: <span class="number">10</span> sec</span><br><span class="line">Discovery targeted hello: holdtime: <span class="number">30</span> sec; interval: <span class="number">10</span> sec</span><br><span class="line">Accepting targeted hellos; peer acl: <span class="number">1</span></span><br><span class="line">Downstream on Demand max hop count: <span class="number">255</span></span><br><span class="line">LDP <span class="keyword">for</span> targeted sessions</span><br><span class="line">LDP initial/maximum backoff: <span class="number">15</span>/<span class="number">120</span> sec</span><br><span class="line">LDP loop detection: off</span><br><span class="line"><span class="comment">//可以看到R1本地基于目标的LDP会话Discovery Hello Interval为10秒，Holdtime为30秒；</span></span><br><span class="line"><span class="comment">//R1接受基于目标的Hello消息，并且基于ACL1来进行远程邻居对等体过滤；</span></span><br></pre></td></tr></table></figure>

<p>在R1上查看MPLS LDP邻居R4的信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do show mpls ldp neighbor 4.4.4.4 detail</span></span><br><span class="line"> Peer LDP Ident: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>; Local LDP Ident <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">  TCP connection: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span><span class="number">.61631</span> - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span></span><br><span class="line">  Password: not required, none, in use</span><br><span class="line">  State: Oper; Msgs sent/rcvd: <span class="number">75</span>/<span class="number">75</span>; Downstream; Last TIB rev sent <span class="number">17</span></span><br><span class="line">  Up time: <span class="number">00</span>:<span class="number">04</span>:<span class="number">44</span>; UID: <span class="number">8</span>; Peer Id <span class="number">2</span>;</span><br><span class="line">  LDP discovery sources:</span><br><span class="line">   Targeted Hello <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> -&gt; <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>, active, passive;<span class="comment">//R1与R4已建立远程LDP会话；关键字active和passive表示R1是远程会话的主动发起方和被动接受方；</span></span><br><span class="line">   holdtime: infinite, hello interval: <span class="number">3333</span> ms</span><br><span class="line">  Addresses bound to peer LDP Ident:</span><br><span class="line">   <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span>    <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>    <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>         </span><br><span class="line">  Peer holdtime: <span class="number">15000</span> ms; KA interval: <span class="number">5000</span> ms; Peer state: estab</span><br><span class="line">  Clients: Dir Adj Client</span><br><span class="line">  Capabilities Sent:</span><br><span class="line">   [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">   [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">   [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">  Capabilities Received:</span><br><span class="line">   [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">   [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">   [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br></pre></td></tr></table></figure>

<p>在R4上查看MPLS LDP邻居R1的信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#do show mpls ldp neighbor 1.1.1.1 detail</span></span><br><span class="line"> Peer LDP Ident: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>; Local LDP Ident <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span></span><br><span class="line">  TCP connection: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span> - <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span><span class="number">.61631</span></span><br><span class="line">  Password: not required, none, in use</span><br><span class="line">  State: Oper; Msgs sent/rcvd: <span class="number">86</span>/<span class="number">85</span>; Downstream; Last TIB rev sent <span class="number">17</span></span><br><span class="line">  Up time: <span class="number">00</span>:<span class="number">05</span>:<span class="number">31</span>; UID: <span class="number">5</span>; Peer Id <span class="number">2</span>;</span><br><span class="line">  LDP discovery sources:</span><br><span class="line">   Targeted Hello <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> -&gt; <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>, active, passive;<span class="comment">//R1与R4已建立远程LDP会话；关键字active和passive表示R1是远程会话的主动发起方和被动接受方；</span></span><br><span class="line">   holdtime: infinite, hello interval: <span class="number">3333</span> ms</span><br><span class="line">  Addresses bound to peer LDP Ident:</span><br><span class="line">   <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span>    <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>    <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>         </span><br><span class="line">  Peer holdtime: <span class="number">15000</span> ms; KA interval: <span class="number">5000</span> ms; Peer state: estab</span><br><span class="line">  Clients: Dir Adj Client</span><br><span class="line">  Capabilities Sent:</span><br><span class="line">   [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">   [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">   [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">  Capabilities Received:</span><br><span class="line">   [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">   [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">   [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br></pre></td></tr></table></figure>


<h2 id="实验6：控制LDP标签通告；"><a href="#实验6：控制LDP标签通告；" class="headerlink" title="实验6：控制LDP标签通告；"></a>实验6：控制LDP标签通告；</h2><p>配置MPLS LDP来向特定的LDP对等体通告或者不通告特定的标签；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在R4上查看LIB;</span></span><br><span class="line">R4<span class="meta">#show mpls ldp bindings</span></span><br><span class="line"> lib entry: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>, rev <span class="number">14</span></span><br><span class="line">  local binding:  label: <span class="number">19</span></span><br><span class="line">  remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">18</span></span><br><span class="line">  remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line"> lib entry: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>, rev <span class="number">12</span></span><br><span class="line">  local binding:  label: <span class="number">18</span></span><br><span class="line">  remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">17</span></span><br><span class="line">  remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">16</span></span><br><span class="line"> lib entry: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>, rev <span class="number">8</span></span><br><span class="line">  local binding:  label: <span class="number">16</span></span><br><span class="line">  remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">  remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">19</span></span><br><span class="line"> lib entry: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>, rev <span class="number">2</span></span><br><span class="line">  local binding:  label: imp-null</span><br><span class="line">  remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">16</span></span><br><span class="line">  remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">18</span></span><br><span class="line"> lib entry: <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">16</span></span><br><span class="line">  local binding:  label: <span class="number">20</span></span><br><span class="line">  remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">19</span></span><br><span class="line">  remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line"> lib entry: <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">17</span></span><br><span class="line">  remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line"> lib entry: <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">10</span></span><br><span class="line">  local binding:  label: <span class="number">17</span></span><br><span class="line">  remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">  remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">17</span></span><br><span class="line"> lib entry: <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">6</span></span><br><span class="line">  local binding:  label: imp-null</span><br><span class="line">  remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">  remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">20</span></span><br><span class="line"> lib entry: <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">4</span></span><br><span class="line">  local binding:  label: imp-null</span><br><span class="line"></span><br><span class="line">R4<span class="meta">#show mpls ip binding</span></span><br><span class="line"> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span> </span><br><span class="line">  in label:     <span class="number">19</span>        </span><br><span class="line">  out label:    <span class="number">18</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">  out label:    imp-null  lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span> </span><br><span class="line">  in label:     <span class="number">18</span>        </span><br><span class="line">  out label:    <span class="number">17</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">  out label:    <span class="number">16</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span> </span><br><span class="line">  in label:     <span class="number">16</span>        </span><br><span class="line">  out label:    imp-null  lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">  out label:    <span class="number">19</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span> </span><br><span class="line">  in label:     imp-null  </span><br><span class="line">  out label:    <span class="number">16</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>       </span><br><span class="line">  out label:    <span class="number">18</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">  in label:     <span class="number">20</span>        </span><br><span class="line">  out label:    <span class="number">19</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">  out label:    imp-null  lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">  out label:    imp-null  lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">  in label:     <span class="number">17</span>        </span><br><span class="line">  out label:    imp-null  lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">  out label:    <span class="number">17</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">  in label:     imp-null  </span><br><span class="line">  out label:    imp-null  lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>       </span><br><span class="line">  out label:    <span class="number">20</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">  in label:     imp-null</span><br></pre></td></tr></table></figure>


<p><strong>在R3上进行配置，让R3只将与环回口的前缀相绑定的标签通告给R4；</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置ACL以确定准许通告的特定前缀；</span></span><br><span class="line">R3(config)<span class="meta">#ip access-list standard PERMIT_LOOPBACK </span></span><br><span class="line">R3(config-<span class="built_in">std</span>-nacl)<span class="meta">#permit</span></span><br><span class="line">R3(config-<span class="built_in">std</span>-nacl)<span class="meta">#permit host 1.1.1.1</span></span><br><span class="line">R3(config-<span class="built_in">std</span>-nacl)<span class="meta">#permit host 2.2.2.2</span></span><br><span class="line">R3(config-<span class="built_in">std</span>-nacl)<span class="meta">#permit host 3.3.3.3 </span></span><br><span class="line">R3(config-<span class="built_in">std</span>-nacl)<span class="meta">#exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置ACL以确定特定的LDP对等体可以接收标签绑定信息；</span></span><br><span class="line">R3(config)<span class="meta">#ip access-list standard PEER_R4</span></span><br><span class="line">R3(config-<span class="built_in">std</span>-nacl)<span class="meta">#permit host 4.4.4.4 </span></span><br><span class="line">R3(config-<span class="built_in">std</span>-nacl)<span class="meta">#exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置LDP不向外通告任何标签；</span></span><br><span class="line">R3(config)<span class="meta">#no mpls ldp advertise-labels</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置LDP向对等体PEER_R4通告前缀PERMIT_LOOPBACK的标签绑定信息；</span></span><br><span class="line">R3(config)<span class="meta">#mpls ldp advertise-labels for PERMIT_LOOPBACK to PEER_R4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看R3的标签通告信息；</span></span><br><span class="line">R3(config)<span class="meta">#do show mpls ldp bindings advertisement-acls</span></span><br><span class="line">Advertisement spec:</span><br><span class="line"> Prefix acl = PERMIT_LOOPBACK; Peer acl = PEER_R4</span><br><span class="line"></span><br><span class="line">lib entry: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>, rev <span class="number">22</span></span><br><span class="line"> Advert acl(s): Prefix acl PERMIT_LOOPBACK; Peer acl PEER_R4</span><br><span class="line">lib entry: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>, rev <span class="number">23</span></span><br><span class="line"> Advert <span class="title function_">acl</span><span class="params">(s)</span>: Prefix acl PERMIT_LOOPBACK; Peer acl PEER_R4</span><br><span class="line">lib entry: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>, rev <span class="number">24</span></span><br><span class="line"> Advert <span class="title function_">acl</span><span class="params">(s)</span>: Prefix acl PERMIT_LOOPBACK; Peer acl PEER_R4</span><br><span class="line">lib entry: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>, rev <span class="number">25</span></span><br><span class="line">lib entry: <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">26</span></span><br><span class="line">lib entry: <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">27</span></span><br><span class="line">lib entry: <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">28</span></span><br><span class="line">lib entry: <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">29</span></span><br><span class="line"><span class="comment">//可以看到R3基于ACL PERMIT_LOOPBACK来确定需要通告的与特定前缀相绑定的标签和可以接收标签绑定信息的LDP对等体PEER_R4；</span></span><br></pre></td></tr></table></figure>

<p>在R4上查看来自LDP对等体的标签绑定信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4<span class="meta">#show mpls ldp bindings neighbor 3.3.3.3 detail</span></span><br><span class="line"> lib entry: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>, rev <span class="number">14</span>, chkpt: none</span><br><span class="line">  remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">18</span></span><br><span class="line"> lib entry: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>, rev <span class="number">12</span>, chkpt: none</span><br><span class="line">  remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">17</span></span><br><span class="line"> lib entry: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>, rev <span class="number">8</span>, chkpt: none</span><br><span class="line">  remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line"> lib entry: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>, rev <span class="number">2</span></span><br><span class="line"> lib entry: <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">16</span></span><br><span class="line"> lib entry: <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">17</span></span><br><span class="line"> lib entry: <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">10</span></span><br><span class="line"> lib entry: <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">6</span></span><br><span class="line"> lib entry: <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">4</span></span><br><span class="line"><span class="comment">//可以看到R4确实只收到了与环回口前缀相绑定的标签；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看R4的LIB；</span></span><br><span class="line">R4<span class="meta">#show mpls ip binding</span></span><br><span class="line"> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span> </span><br><span class="line">  in label:     <span class="number">19</span>        </span><br><span class="line">  out label:    <span class="number">18</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse  <span class="comment">//inuse表示该标签已被放入LFIB表，并用来转发流量；</span></span><br><span class="line">  out label:    imp-null  lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span> </span><br><span class="line">  in label:     <span class="number">18</span>        </span><br><span class="line">  out label:    <span class="number">17</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">  out label:    <span class="number">16</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span> </span><br><span class="line">  in label:     <span class="number">16</span>        </span><br><span class="line">  out label:    imp-null  lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">  out label:    <span class="number">19</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span> </span><br><span class="line">  in label:     imp-null  </span><br><span class="line">  out label:    <span class="number">18</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">  in label:     <span class="number">20</span>        </span><br><span class="line">  out label:    imp-null  lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">  out label:    imp-null  lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">  in label:     <span class="number">17</span>        </span><br><span class="line">  out label:    <span class="number">17</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">  in label:     imp-null  </span><br><span class="line">  out label:    <span class="number">20</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line"> <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">  in label:     imp-null</span><br><span class="line"><span class="comment">//可以看到虽然R3只向R4通告了环回口前缀的标签绑定信息，</span></span><br><span class="line"><span class="comment">//但是由于R4和R1有远程目标对等体关系，所R4还是从R1哪里收到其他前缀的标签；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看R4的LFIB；</span></span><br><span class="line">R4<span class="meta">#show mpls forwarding-table</span></span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop    </span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface              </span><br><span class="line"><span class="number">16</span>         Pop Label  <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br><span class="line"><span class="number">17</span>         No Label   <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span>  <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br><span class="line"><span class="number">18</span>         <span class="number">17</span>         <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br><span class="line"><span class="number">19</span>         <span class="number">18</span>         <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br><span class="line"><span class="number">20</span>         No Label   <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span>  <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>
<p><strong>配置MPLS LDP，使其有选择地过滤接收到的特定前缀标签绑定信息</strong></p>
<ul>
<li>配置R4仅仅接收R1环回口1.1.1.1&#x2F;32的标签绑定信息；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置ACL以确定准许接受的特定前缀；</span></span><br><span class="line">R4(config)<span class="meta">#ip access-list standard PERMIT_R1_LOOPBACK</span></span><br><span class="line">R4(config-<span class="built_in">std</span>-nacl)<span class="meta">#permit host 1.1.1.1</span></span><br><span class="line">R4(config-<span class="built_in">std</span>-nacl)<span class="meta">#exit</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//针对LDP邻居R1和R3应用ACL以过滤接收到的特定前缀的绑定信息；</span></span><br><span class="line">R4(config)<span class="meta">#mpls ldp neighbor 3.3.3.3 labels accept PERMIT_R1_LOOPBACK</span></span><br><span class="line">R4(config)<span class="meta">#mpls ldp neighbor 1.1.1.1 labels accept PERMIT_R1_LOOPBACK</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//查看R4的LIB表，以验证实验配置；</span></span><br><span class="line">R4(config)<span class="meta">#do show mpls ldp bindings</span></span><br><span class="line"> lib entry: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>, rev <span class="number">14</span></span><br><span class="line">  local binding:  label: <span class="number">19</span></span><br><span class="line">  remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">18</span></span><br><span class="line">  remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line"> lib entry: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>, rev <span class="number">12</span></span><br><span class="line">  local binding:  label: <span class="number">18</span></span><br><span class="line"> lib entry: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>, rev <span class="number">8</span></span><br><span class="line">  local binding:  label: <span class="number">16</span></span><br><span class="line"> lib entry: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>, rev <span class="number">2</span></span><br><span class="line">  local binding:  label: imp-null</span><br><span class="line"> lib entry: <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">16</span></span><br><span class="line">  local binding:  label: <span class="number">20</span></span><br><span class="line"> lib entry: <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">10</span></span><br><span class="line">  local binding:  label: <span class="number">17</span></span><br><span class="line"> lib entry: <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">6</span></span><br><span class="line">  local binding:  label: imp-null</span><br><span class="line"> lib entry: <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">4</span></span><br><span class="line">  local binding:  label: imp-null</span><br><span class="line"></span><br><span class="line"><span class="title function_">R4</span><span class="params">(config)</span><span class="meta">#do show mpls ip binding</span></span><br><span class="line"> 1.1.1.1/32 </span><br><span class="line">  in label:     19        </span><br><span class="line">  out label:    18        lsr: 3.3.3.3:0        inuse</span><br><span class="line">  out label:    imp-null  lsr: 1.1.1.1:0       </span><br><span class="line"> 2.2.2.2/32 </span><br><span class="line">  in label:     18        </span><br><span class="line"> 3.3.3.3/32 </span><br><span class="line">  in label:     16        </span><br><span class="line"> 4.4.4.4/32 </span><br><span class="line">  in label:     imp-null  </span><br><span class="line"> 192.168.12.0/24 </span><br><span class="line">  in label:     20        </span><br><span class="line"> 192.168.23.0/24 </span><br><span class="line">  in label:     17        </span><br><span class="line"> 192.168.34.0/24 </span><br><span class="line">  in label:     imp-null  </span><br><span class="line"> 192.168.47.0/24 </span><br><span class="line">  in label:     imp-null</span><br><span class="line"><span class="comment">//可以看到R4的LIB表中确实只有R1前缀1.1.1.1/32的标签绑定信息；</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>MPLS</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLS 实验10：OSPF Loop Prevention in MPLS VPN</title>
    <url>/2014/MPLS_Lab_10/</url>
    <content><![CDATA[<h1 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h1><ul>
<li>模拟器：GNS3 0.8.6</li>
<li>Cisco IOS：c7200-adventerprisek9-mz.151-4.M2.image</li>
</ul>
<h1 id="GNS3实验拓扑文件："><a href="#GNS3实验拓扑文件：" class="headerlink" title="GNS3实验拓扑文件："></a>GNS3实验拓扑文件：</h1><p><a href="topology.net">拓扑文件</a></p>
<h1 id="实验拓扑："><a href="#实验拓扑：" class="headerlink" title="实验拓扑："></a>实验拓扑：</h1><p><img src="/2014/MPLS_Lab_10/topo.png"></p>
<span id="more"></span>

<h1 id="基本预配置："><a href="#基本预配置：" class="headerlink" title="基本预配置："></a>基本预配置：</h1><h2 id="R1："><a href="#R1：" class="headerlink" title="R1："></a>R1：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.13</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">ip vrf A-Site1</span><br><span class="line">        rd <span class="number">1</span>:<span class="number">1</span></span><br><span class="line"><span class="comment">//注意：连接到同一站点的同一ISP的多个不同PE可以使用相同的RD，也可以使用不同的RD；</span></span><br><span class="line">        route-target export <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        route-target import <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface Loopback1</span><br><span class="line">        ip vrf forwarding A-Site1</span><br><span class="line">        ip address <span class="number">22.22</span><span class="number">.22</span><span class="number">.22</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">2</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip vrf forwarding A-Site1</span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">2</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.24</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">2</span> vrf A-Site1</span><br><span class="line">        router-id <span class="number">22.22</span><span class="number">.22</span><span class="number">.22</span></span><br><span class="line">        redistribute bgp <span class="number">1</span> subnets</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">1</span></span><br><span class="line">        bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">        neighbor <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> remote-as <span class="number">1</span></span><br><span class="line">        neighbor <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> update-source Loopback0</span><br><span class="line">        neighbor <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> next-hop-self</span><br><span class="line">        !</span><br><span class="line">        address-family vpnv4</span><br><span class="line">        neighbor <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> activate</span><br><span class="line">        neighbor <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> send-community both</span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">        !</span><br><span class="line">        address-family ipv4 vrf A-Site1</span><br><span class="line">        redistribute connected</span><br><span class="line">        redistribute ospf <span class="number">2</span> match internal external <span class="number">1</span> external <span class="number">2</span></span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R3"><a href="#R3" class="headerlink" title="R3:"></a>R3:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R3</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">ip vrf A-Site1</span><br><span class="line">        rd <span class="number">1</span>:<span class="number">1</span></span><br><span class="line"><span class="comment">//注意：连接到同一站点的同一ISP的多个不同PE可以使用相同的RD，也可以使用不同的RD；</span></span><br><span class="line">        route-target export <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        route-target import <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface Loopback1</span><br><span class="line">        ip vrf forwarding A-Site1</span><br><span class="line">        ip address <span class="number">33.33</span><span class="number">.33</span><span class="number">.33</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">2</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip vrf forwarding A-Site1</span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.13</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">2</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">2</span> vrf A-Site1</span><br><span class="line">        router-id <span class="number">33.33</span><span class="number">.33</span><span class="number">.33</span></span><br><span class="line">        redistribute bgp <span class="number">1</span> subnets</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">1</span></span><br><span class="line">        bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">        neighbor <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> remote-as <span class="number">1</span></span><br><span class="line">        neighbor <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> update-source Loopback0</span><br><span class="line">        neighbor <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> next-hop-self</span><br><span class="line">        !</span><br><span class="line">        address-family vpnv4</span><br><span class="line">        neighbor <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> activate</span><br><span class="line">        neighbor <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> send-community both</span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">        !</span><br><span class="line">        address-family ipv4 vrf A-Site1</span><br><span class="line">        redistribute connected</span><br><span class="line">        redistribute ospf <span class="number">2</span> match internal external <span class="number">1</span> external <span class="number">2</span></span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R4"><a href="#R4" class="headerlink" title="R4:"></a>R4:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R4</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">ip vrf A-Site2</span><br><span class="line">        rd <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">        route-target export <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        route-target import <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface Loopback1</span><br><span class="line">        ip vrf forwarding A-Site2</span><br><span class="line">        ip address <span class="number">44.44</span><span class="number">.44</span><span class="number">.44</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">2</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.24</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet1/<span class="number">0</span></span><br><span class="line">        ip vrf forwarding A-Site2</span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.45</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">2</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">2</span> vrf A-Site2</span><br><span class="line">        router-id <span class="number">44.44</span><span class="number">.44</span><span class="number">.44</span></span><br><span class="line">        redistribute bgp <span class="number">1</span> subnets</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span></span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">1</span></span><br><span class="line">        bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">        neighbor ibgp peer-group</span><br><span class="line">        neighbor ibgp remote-as <span class="number">1</span></span><br><span class="line">        neighbor ibgp update-source Loopback0</span><br><span class="line">        neighbor ibgp next-hop-self</span><br><span class="line">        neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> peer-group ibgp</span><br><span class="line">        neighbor <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> peer-group ibgp</span><br><span class="line">        !</span><br><span class="line">        address-family vpnv4</span><br><span class="line">        neighbor ibgp send-community both</span><br><span class="line">        neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> activate</span><br><span class="line">        neighbor <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> activate</span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">        !</span><br><span class="line">        address-family ipv4 vrf A-Site2</span><br><span class="line">        redistribute connected</span><br><span class="line">        redistribute ospf <span class="number">2</span> match internal external <span class="number">1</span> external <span class="number">2</span></span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R5"><a href="#R5" class="headerlink" title="R5:"></a>R5:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R5</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address 5.5.5.5 255.255.255.255</span><br><span class="line">        ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">        ip address 192.168.45.5 255.255.255.0</span><br><span class="line">        ip ospf 1 area 0</span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">        router-id 5.5.5.5</span><br><span class="line">        redistribute connected subnets route-map CREATE_LSA5</span><br><span class="line">//为了创造出类型5的LSA；</span><br><span class="line">!</span><br><span class="line">route-map CREATE_LSA5 permit 10</span><br><span class="line">        match interface Loopback1</span><br><span class="line">//为了创造出类型5的LSA；</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">        exec-timeout 0 0</span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="实验与调试："><a href="#实验与调试：" class="headerlink" title="实验与调试："></a>实验与调试：</h1><h2 id="实验1：OSPF内部路由Down-bit"><a href="#实验1：OSPF内部路由Down-bit" class="headerlink" title="实验1：OSPF内部路由Down-bit"></a>实验1：OSPF内部路由Down-bit</h2>]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>MPLS</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLS 实验11：MPLS VPN running eBGP on the PE-CE link</title>
    <url>/2014/MPLS_Lab_11/</url>
    <content><![CDATA[<h1 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h1><ul>
<li>模拟器：GNS3 0.8.6</li>
<li>Cisco IOS：c7200-adventerprisek9-mz.151-4.M2.image</li>
</ul>
<h1 id="GNS3实验拓扑文件："><a href="#GNS3实验拓扑文件：" class="headerlink" title="GNS3实验拓扑文件："></a>GNS3实验拓扑文件：</h1><p><a href="topology.net">拓扑文件</a></p>
<h1 id="实验拓扑："><a href="#实验拓扑：" class="headerlink" title="实验拓扑："></a>实验拓扑：</h1><p><img src="/2014/MPLS_Lab_11/topo.png"></p>
<span id="more"></span>

<h1 id="基本预配置："><a href="#基本预配置：" class="headerlink" title="基本预配置："></a>基本预配置：</h1><h2 id="R1："><a href="#R1：" class="headerlink" title="R1："></a>R1：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shut</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shut</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">!         </span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R3"><a href="#R3" class="headerlink" title="R3:"></a>R3:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R3</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.23</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R4"><a href="#R4" class="headerlink" title="R4:"></a>R4:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R4</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span></span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R5"><a href="#R5" class="headerlink" title="R5:"></a>R5:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R5</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span></span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">65001</span></span><br><span class="line">        bgp router-id <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span></span><br><span class="line">        bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">        network <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> mask <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span> remote-as <span class="number">1</span></span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R7"><a href="#R7" class="headerlink" title="R7:"></a>R7:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R7</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.78</span><span class="number">.7</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span></span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">65002</span></span><br><span class="line">        bgp router-id <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span></span><br><span class="line">        bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">        network <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> mask <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span> remote-as <span class="number">1</span></span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<h1 id="MPLS-VPN配置步骤："><a href="#MPLS-VPN配置步骤：" class="headerlink" title="MPLS VPN配置步骤："></a>MPLS VPN配置步骤：</h1><ol>
<li>创建VRF（VRF名本地有效）：<ul>
<li>指定RD（提供全局唯一的私网单播地址）；</li>
<li>指定RT的导出（导出：把重分发进MP-BGP的VPNv4路由打上MP-BGP扩展团体属性RT）和导入（导入：把MP-BGP里的VPNv4路由进行RT的匹配，匹配成功的VPNv4路由将放进相应的VRF）；</li>
<li>将与CE相连的PE接口关联特定VRF；</li>
</ul>
</li>
<li>配置MP-BGP：<ul>
<li>配置建立PE之间的IBGP邻居关系；</li>
<li>启用VPNv4地址族（AF），并激活与其他PE设备的邻居关系；</li>
</ul>
</li>
<li>配置PE-CE路由；<ul>
<li>配置IGP，并启用IGP的地址族（AF）；</li>
<li>配置启用MP-BGP IPv4 VRF地址族，然后激活与其他PE路由器的MP-BGP IPv4 VRF邻居关系；</li>
</ul>
</li>
</ol>
<h1 id="实验与调试："><a href="#实验与调试：" class="headerlink" title="实验与调试："></a>实验与调试：</h1><h2 id="实验1：同一VPN的不同站点使用不同的AS号；"><a href="#实验1：同一VPN的不同站点使用不同的AS号；" class="headerlink" title="实验1：同一VPN的不同站点使用不同的AS号；"></a>实验1：同一VPN的不同站点使用不同的AS号；</h2><h3 id="在PE上创建VRF；"><a href="#在PE上创建VRF；" class="headerlink" title="在PE上创建VRF；"></a>在PE上创建VRF；</h3><p>在PE1（R1）上创建VRF，并命名为A-Site1，表示该VRF为VPN A的站点1服务；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#ip vrf A-Site1   </span></span><br></pre></td></tr></table></figure>

<p>指定RD，为1:1，如果按照AS：num命名法，以下RD表示AS1中的第2个VRF；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-vrf)<span class="meta">#rd 1:1</span></span><br><span class="line">```            </span><br><span class="line"></span><br><span class="line">指定RT的导入和导出，这里我将RT指定为导入和导出<span class="number">1</span>：<span class="number">1</span>；</span><br><span class="line">```c</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-vrf)</span><span class="meta">#route-target ?        </span></span><br><span class="line">        ASN:nn or IP-address:nn  Target VPN Extended Community</span><br><span class="line">        both                     Both import and export Target-VPN community</span><br><span class="line">        export                   Export Target-VPN community</span><br><span class="line">        import                   Import Target-VPN community</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-vrf)</span><span class="meta">#route-target both 1:1</span></span><br></pre></td></tr></table></figure>

<p>将PE1（R1）上与CE相连的PE接口F0&#x2F;1关联到VRF A-Site1；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#int f0/1</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#ip vrf forwarding A-Site1</span></span><br><span class="line">% Interface FastEthernet0/<span class="number">1</span> IPv4 disabled and <span class="title function_">address</span><span class="params">(es)</span> removed due to enabling VRF A-Site1</span><br><span class="line">        <span class="comment">//切记先将接口关联VRF，然后再配置IP地址；</span></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-<span class="keyword">if</span>)</span><span class="meta">#ip add 192.168.15.1 255.255.255.0</span></span><br></pre></td></tr></table></figure>
<p>在PE2（R4）上创建VRF，并命名为A-Site2，表示该VRF为VPN A的站点2服务；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#ip vrf A-Site2</span></span><br></pre></td></tr></table></figure>

<p>指定RD，为1:2，如果按照AS：num命名法，以下RD表示AS1中的第2个VRF；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-vrf)<span class="meta">#rd 1:2</span></span><br></pre></td></tr></table></figure>

<p>指定RT的导入和导出，这里我将RT指定为导入和导出1：1；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-vrf)<span class="meta">#route-target both 1:1</span></span><br></pre></td></tr></table></figure>
<p>因为PE1导出的RT为1:1，PE2导入的RT正是PE1的导出RT1:1；所以PE1（R1）的RT导出和PE2（R4）的RT导入能够匹配成功，R4能够学到R1导入到MP-BGP中的VPNv4路由；又因为PE2导出的RT为1:1，PE1导入的RT也正好是PE2的导出RT1:1；所以PE2（R4）的RT导出和PE1（R1）的RT导入能够匹配成对，R1能够学到R4导入到MP-BGP中的VPNv4路由</p>
<p>将PE2（R4）上与CE相连的PE接口F0&#x2F;1关联到VRF A-Site2；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#int f0/1</span></span><br><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#ip vrf forwarding A-Site2</span></span><br><span class="line">% Interface FastEthernet0/<span class="number">1</span> IPv4 disabled and <span class="title function_">address</span><span class="params">(es)</span> removed due to enabling VRF A-Site2</span><br><span class="line">        <span class="comment">//切记先将接口关联VRF，然后再配置IP地址；</span></span><br><span class="line"><span class="title function_">R4</span><span class="params">(config-<span class="keyword">if</span>)</span><span class="meta">#ip add 192.168.47.4 255.255.255.0</span></span><br></pre></td></tr></table></figure>
<h3 id="配置MP-BGP；"><a href="#配置MP-BGP；" class="headerlink" title="配置MP-BGP；"></a>配置MP-BGP；</h3><p>在PE1（R1）上配置MP-BGP，使之与其他PE建立IBGP关系，在此实验中只有PE1和PE2两台PE设备；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#no auto-summary</span></span><br><span class="line">R1(config-router)<span class="meta">#no syn</span></span><br><span class="line">R1(config-router)<span class="meta">#bgp router-id 1.1.1.1</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 remote-as 1</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 update-source l0</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 next-hop-self</span></span><br></pre></td></tr></table></figure>

<p>启用PE1（R1）的VPNv4地址族，并激活与IBGP邻居PE2（R4）的MP-BGP VPNv4邻居关系；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-router)<span class="meta">#address-family vpnv4</span></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 4.4.4.4 activate</span></span><br><span class="line"><span class="comment">//激活与IBGP邻居R4的VPNv4关系；</span></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 4.4.4.4 send-community ?</span></span><br><span class="line">        both      Send Standard and Extended Community attributes</span><br><span class="line">        extended  Send Extended Community attribute</span><br><span class="line">        standard  Send Standard Community attribute</span><br><span class="line">        &lt;cr&gt;</span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 4.4.4.4 send-community both</span></span><br><span class="line"><span class="comment">//由于BGP团体属性为可选传递属性，所以必须手动指定R1向IBGP邻居R4发送拓展团体属性和标准团体属性；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#exit-address-family</span></span><br><span class="line"><span class="comment">//退出AF配置模式；</span></span><br></pre></td></tr></table></figure>
<p>在PE2（R4）上配置MP-BGP，使之与其他PE建立IBGP关系，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#no auto-summary</span></span><br><span class="line">R4(config-router)<span class="meta">#no syn</span></span><br><span class="line">R4(config-router)<span class="meta">#bgp router-id 4.4.4.4</span></span><br><span class="line">R4(config-router)<span class="meta">#neighbor 1.1.1.1 remote-as 1</span></span><br><span class="line">R4(config-router)<span class="meta">#neighbor 1.1.1.1 update-source l0</span></span><br><span class="line">R4(config-router)<span class="meta">#neighbor 1.1.1.1 next-hop-self</span></span><br></pre></td></tr></table></figure>

<p>启用PE2（R4）的VPNv4地址族，并激活与IBGP邻居PE1（R1）的MP-BGP VPNv4邻居关系；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-router)<span class="meta">#address-family vpnv4</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 1.1.1.1 activate</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 1.1.1.1 send-community both</span></span><br></pre></td></tr></table></figure>
<h3 id="配置PE-CE路由；"><a href="#配置PE-CE路由；" class="headerlink" title="配置PE-CE路由；"></a>配置PE-CE路由；</h3><p>配置PE1（R1）的MP-BGP IPv4 VRF地址族（AF）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#address-family ipv4 vrf A-Site1</span></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 192.168.15.5 remote-as 65001</span></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 192.168.15.5 activate </span></span><br><span class="line"><span class="comment">//激活与IBGP邻居R4的VPNv4关系；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#redistribute connected</span></span><br><span class="line"><span class="comment">//如果用户在CE路由器上ping远程网络的另一个VPN站点中的CE或C路由器，</span></span><br><span class="line"><span class="comment">//为了使其在没有指定其源地址情况下（即默认使用CE路由器出站接口IP地址），Echo Reply包能够有路由并正常返回,</span></span><br><span class="line"><span class="comment">//将PE路由器的直连路由重分布进MP-BGP的IPv4 VRF AF中；</span></span><br></pre></td></tr></table></figure>

<p>配置PE2（R4）的MP-BGP IPv4 VRF地址族（AF）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#address-family ipv4 vrf A-Site2</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 192.168.47.7 remote-as 65002</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 192.168.47.7 activate</span></span><br><span class="line">R4(config-router-af)<span class="meta">#redistribute connected</span></span><br><span class="line">R4(config-router-af)<span class="meta">#exit-address-family</span></span><br></pre></td></tr></table></figure>


<h3 id="验证与调试"><a href="#验证与调试" class="headerlink" title="验证与调试:"></a>验证与调试:</h3><p>在VPN A站点1的CE路由器R5上ping远程VPN A站点2的CE路由器R7；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R5<span class="meta">#ping 7.7.7.7</span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Sending <span class="number">5</span>, <span class="number">100</span>-byte ICMP Echos to <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>, timeout is <span class="number">2</span> seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is <span class="number">100</span> percent (<span class="number">5</span>/<span class="number">5</span>), round-trip min/avg/max = <span class="number">100</span>/<span class="number">146</span>/<span class="number">208</span> ms</span><br><span class="line"><span class="comment">//成功！</span></span><br></pre></td></tr></table></figure>

<p>查看R1的IP BGP VPNv4路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do sh ip bgp vpnv4 all</span></span><br><span class="line">BGP table version is <span class="number">34</span>, local router ID is <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">                r RIB-failure, S Stale, m multipath, b backup-path, x best-external, f RT-Filter</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">        Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: <span class="number">1</span>:<span class="number">1</span> (<span class="keyword">default</span> <span class="keyword">for</span> vrf A-Site1)</span><br><span class="line">*&gt; <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>             <span class="number">0</span>             <span class="number">0</span> <span class="number">65001</span> i</span><br><span class="line">*&gt;i7<span class="number">.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> <span class="number">65002</span> i</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>                  <span class="number">0</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt;i192<span class="number">.168</span><span class="number">.47</span><span class="number">.0</span>     <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">Route Distinguisher: <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">*&gt;i7<span class="number">.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> <span class="number">65002</span> i</span><br><span class="line">*&gt;i192<span class="number">.168</span><span class="number">.47</span><span class="number">.0</span>     <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br></pre></td></tr></table></figure>

<p>查看R1的vrf路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do sh ip route vrf A-Site1</span></span><br><span class="line">Routing Table: A-Site1</span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">48</span>:<span class="number">25</span></span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> [<span class="number">200</span>/<span class="number">0</span>] via <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">41</span>:<span class="number">20</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">200</span>/<span class="number">0</span>] via <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">38</span>:<span class="number">35</span></span><br></pre></td></tr></table></figure>

<p>查看R5的IP路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R5(config)<span class="meta">#do sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">21</span>:<span class="number">34</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">22</span>:<span class="number">04</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>查看R5的BGP表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R5(config)<span class="meta">#do sh ip bgp</span></span><br><span class="line">BGP table version is <span class="number">18</span>, local router ID is <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span></span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">                r RIB-failure, S Stale, m multipath, b backup-path, x best-external, f RT-Filter</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">        Network          Next Hop            Metric LocPrf Weight  Path</span><br><span class="line">*&gt; <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>/<span class="number">32</span>       <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>                  <span class="number">0</span>         <span class="number">32768</span>                             i</span><br><span class="line">*&gt; <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>                           <span class="number">0</span>              <span class="number">1</span> <span class="number">65002</span> i</span><br><span class="line">r&gt; <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>             <span class="number">0</span>             <span class="number">0</span>           <span class="number">1</span> ?</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>                           <span class="number">0</span>            <span class="number">1</span> ?</span><br><span class="line"><span class="comment">//可以看到前缀7.7.7.7/32的AS_PATH属性中看到起源AS65002；</span></span><br></pre></td></tr></table></figure>
<h2 id="实验2：同一VPN的不同站点使用相同的AS号（使用as-override）；"><a href="#实验2：同一VPN的不同站点使用相同的AS号（使用as-override）；" class="headerlink" title="实验2：同一VPN的不同站点使用相同的AS号（使用as-override）；"></a>实验2：同一VPN的不同站点使用相同的AS号（使用as-override）；</h2><p>修改R7上BGP AS号为65001，使之与站点1的R5的BGP AS号相同；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7(config)<span class="meta">#no router bgp 65002</span></span><br><span class="line">R7(config)<span class="meta">#router bgp 65001</span></span><br><span class="line">R7(config-router)<span class="meta">#bgp router-id 7.7.7.7</span></span><br><span class="line">R7(config-router)<span class="meta">#bgp log-neighbor-changes</span></span><br><span class="line">R7(config-router)<span class="meta">#network 7.7.7.7 mask 255.255.255.255</span></span><br><span class="line">R7(config-router)<span class="meta">#neighbor 192.168.47.4 remote-as 1</span></span><br><span class="line">R7(config-router)<span class="meta">#exit</span></span><br></pre></td></tr></table></figure>

<p>修改PE2（R4）的PE-CE路由配置，将MP-BGP IPv4 VRF A-Site2的EBGP邻居配置进行修改；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#address-f ipv4 vrf A-Site2</span></span><br><span class="line">R4(config-router-af)<span class="meta">#no neighbor 192.168.47.7 remote-as 65002</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 192.168.47.7 remote-as 65001</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 192.168.47.7 activate</span></span><br></pre></td></tr></table></figure>

<p>验证：查看R5的IP路由表；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R5(config)#do sh ip route</span><br><span class="line">Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">        E1 - OSPF external type 1, E2 - OSPF external type 2</span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2</span><br><span class="line">        ia - IS-IS inter area, * - candidate default, U - per-user static route</span><br><span class="line">        o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not set</span><br><span class="line">        5.0.0.0/32 is subnetted, 1 subnets</span><br><span class="line">C        5.5.5.5 is directly connected, Loopback0</span><br><span class="line">        192.168.15.0/24 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        192.168.15.0/24 is directly connected, FastEthernet0/1</span><br><span class="line">L        192.168.15.5/32 is directly connected, FastEthernet0/1</span><br><span class="line">B     192.168.47.0/24 [20/0] via 192.168.15.1, 00:57:01</span><br><span class="line">        192.168.56.0/24 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        192.168.56.0/24 is directly connected, FastEthernet0/0</span><br><span class="line">L        192.168.56.5/32 is directly connected, FastEthernet0/0</span><br><span class="line">//没有发现关于前缀7.7.7.7/32的路由；</span><br></pre></td></tr></table></figure>

<p>验证：查看R5的BGP表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R5(config)<span class="meta">#do sh ip bgp    </span></span><br><span class="line">BGP table version is <span class="number">19</span>, local router ID is <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span></span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">                r RIB-failure, S Stale, m multipath, b backup-path, x best-external, f RT-Filter</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">*&gt; <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>/<span class="number">32</span>       <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>                  <span class="number">0</span>         <span class="number">32768</span> i</span><br><span class="line">r&gt; <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>             <span class="number">0</span>             <span class="number">0</span> <span class="number">1</span> ?</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>                           <span class="number">0</span> <span class="number">1</span> ?</span><br><span class="line"><span class="comment">//也没有发现关于前缀7.7.7.7/32的路由；</span></span><br><span class="line"><span class="comment">//因为EBGP防环机制，当R5收到来自PE1的BGP路由后，由于前缀7.7.7.7/32的BGP路由中AS_PATH属性有和自己AS相同的65001，</span></span><br><span class="line"><span class="comment">//所以将此路由丢弃了；</span></span><br></pre></td></tr></table></figure>

<p>在PE路由器上，针对各自直连到VRF接口的CE路由器EBGP邻居配置<code>as-override</code>；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#address-family ipv4 vrf A-Site1</span></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 192.168.15.5 as-override</span></span><br><span class="line"></span><br><span class="line">R4(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#address-family ipv4 vrf A-Site2</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 192.168.47.7 as-override</span></span><br></pre></td></tr></table></figure>

<p>查看R5的BGP表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R5(config)<span class="meta">#do sh ip bgp</span></span><br><span class="line">BGP table version is <span class="number">20</span>, local router ID is <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span></span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">                r RIB-failure, S Stale, m multipath, b backup-path, x best-external, f RT-Filter</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">*&gt; <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>/<span class="number">32</span>       <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>                  <span class="number">0</span>         <span class="number">32768</span> i</span><br><span class="line">*&gt; <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> i</span><br><span class="line">r&gt; <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>             <span class="number">0</span>             <span class="number">0</span> <span class="number">1</span> ?</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>                           <span class="number">0</span> <span class="number">1</span> ?</span><br></pre></td></tr></table></figure>

<p>查看R7的BGP表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7(config)<span class="meta">#do sh ip bgp</span></span><br><span class="line">BGP table version is <span class="number">5</span>, local router ID is <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span></span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">                r RIB-failure, S Stale, m multipath, b backup-path, x best-external, f RT-Filter</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">*&gt; <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>                           <span class="number">0</span>             <span class="number">1</span> <span class="number">1</span> i</span><br><span class="line">*&gt; <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>                  <span class="number">0</span>         <span class="number">32768</span>                   i</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>                                      <span class="number">0</span> <span class="number">1</span> ?</span><br><span class="line">r&gt; <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>             <span class="number">0</span>                       <span class="number">0</span> <span class="number">1</span> ?</span><br></pre></td></tr></table></figure>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>PE路由器简单地比较CE路由器ASN和as-path中的ASN，如果匹配的话，所有在as-path中的该ASN都会被服务提供商的ASN所代替。</p>
<p>这样一来，远程CE就会接受这些路由了，因为它们在这些BGP路由的as-path中看不到自己的ASN了！但这样一来，对于可能存在环路的保护机制，以及非最优路由的as-path检查机制就失效了。因此，在使用as-override功能进行ASN覆盖的时候，明智的做法是为BGP实施SOO特性。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>MPLS</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLS 实验12：SOO and EIGRP on Backdoor Link</title>
    <url>/2014/MPLS_Lab_12/</url>
    <content><![CDATA[<h1 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h1><ul>
<li>模拟器：GNS3 0.8.6</li>
<li>Cisco IOS：c7200-adventerprisek9-mz.151-4.M2.image</li>
</ul>
<h1 id="实验拓扑："><a href="#实验拓扑：" class="headerlink" title="实验拓扑："></a>实验拓扑：</h1><p><img src="/2014/MPLS_Lab_12/topo.png"></p>
<span id="more"></span>

<h1 id="基本预配置："><a href="#基本预配置：" class="headerlink" title="基本预配置："></a>基本预配置：</h1><h2 id="R1："><a href="#R1：" class="headerlink" title="R1："></a>R1：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">ip vrf A-Site1</span><br><span class="line">        rd <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        route-target export <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        route-target import <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip vrf forwarding A-Site1</span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.13</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">router eigrp <span class="number">1</span></span><br><span class="line">        !</span><br><span class="line">        address-family ipv4 vrf A-Site1 autonomous-system <span class="number">1</span></span><br><span class="line">        redistribute bgp <span class="number">1</span> metric <span class="number">10000</span> <span class="number">100</span> <span class="number">255</span> <span class="number">1</span> <span class="number">1500</span></span><br><span class="line">        network <span class="number">192.168</span><span class="number">.13</span><span class="number">.0</span></span><br><span class="line">        eigrp router-id <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">1</span></span><br><span class="line">        bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">        neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> remote-as <span class="number">1</span></span><br><span class="line">        neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> update-source Loopback0</span><br><span class="line">        neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> next-hop-self</span><br><span class="line">        !</span><br><span class="line">        address-family vpnv4</span><br><span class="line">        neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> activate</span><br><span class="line">        neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> send-community both</span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">        !</span><br><span class="line">        address-family ipv4 vrf A-Site1</span><br><span class="line">        network <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> mask <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        redistribute connected</span><br><span class="line">        redistribute eigrp <span class="number">1</span></span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">ip vrf A-Site2</span><br><span class="line">        rd <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">        route-target export <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        route-target import <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip vrf forwarding A-Site2</span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.24</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router eigrp <span class="number">1</span></span><br><span class="line">        !</span><br><span class="line">        address-family ipv4 vrf A-Site2 autonomous-system <span class="number">1</span></span><br><span class="line">        redistribute bgp <span class="number">1</span> metric <span class="number">10000</span> <span class="number">100</span> <span class="number">255</span> <span class="number">1</span> <span class="number">1500</span></span><br><span class="line">        network <span class="number">192.168</span><span class="number">.24</span><span class="number">.0</span></span><br><span class="line">        eigrp router-id <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">1</span></span><br><span class="line">        bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">        neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> remote-as <span class="number">1</span></span><br><span class="line">        neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> update-source Loopback0</span><br><span class="line">        neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> next-hop-self</span><br><span class="line">        !</span><br><span class="line">        address-family vpnv4</span><br><span class="line">        neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> activate</span><br><span class="line">        neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> send-community both</span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">        !</span><br><span class="line">        address-family ipv4 vrf A-Site2</span><br><span class="line">        network <span class="number">22.22</span><span class="number">.22</span><span class="number">.22</span> mask <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        redistribute connected</span><br><span class="line">        redistribute eigrp <span class="number">1</span></span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R3"><a href="#R3" class="headerlink" title="R3:"></a>R3:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R3</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.13</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">interface Serial1/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        serial restart-delay <span class="number">0</span></span><br><span class="line">        clock rate <span class="number">64000</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router eigrp <span class="number">1</span></span><br><span class="line">        network <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        network <span class="number">192.168</span><span class="number">.13</span><span class="number">.0</span></span><br><span class="line">        network <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span></span><br><span class="line">        eigrp router-id <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R4"><a href="#R4" class="headerlink" title="R4:"></a>R4:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R4</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.24</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">interface Serial1/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        serial restart-delay <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router eigrp <span class="number">1</span></span><br><span class="line">        network <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        network <span class="number">192.168</span><span class="number">.24</span><span class="number">.0</span></span><br><span class="line">        network <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span></span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="实验与调试："><a href="#实验与调试：" class="headerlink" title="实验与调试："></a>实验与调试：</h1><h2 id="实验1："><a href="#实验1：" class="headerlink" title="实验1："></a>实验1：</h2><p>查看R1的IP BGP VNPv4路由表关于路由4.4.4.4的明细；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#do sh ip bgp vpnv4 all 4.4.4.4</span></span><br><span class="line">BGP routing table entry <span class="keyword">for</span> <span class="number">1</span>:<span class="number">1</span>:<span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>, version <span class="number">79</span></span><br><span class="line">Paths: (<span class="number">1</span> available, best #<span class="number">1</span>, table A-Site1)</span><br><span class="line">Not advertised to any peer</span><br><span class="line">Local, imported path from <span class="number">1</span>:<span class="number">2</span>:<span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span></span><br><span class="line"><span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> (metric <span class="number">2</span>) from <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> (<span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>)</span><br><span class="line">        Origin incomplete, metric <span class="number">156160</span>, localpref <span class="number">100</span>, valid, internal, best</span><br><span class="line">        Extended Community: RT:<span class="number">1</span>:<span class="number">1</span> Cost:pre-bestpath:<span class="number">128</span>:<span class="number">156160</span> <span class="number">0x8800</span>:<span class="number">32768</span>:<span class="number">0</span> </span><br><span class="line">        <span class="number">0x8801</span>:<span class="number">1</span>:<span class="number">130560</span> <span class="number">0x8802</span>:<span class="number">65281</span>:<span class="number">25600</span> <span class="number">0x8803</span>:<span class="number">65281</span>:<span class="number">1500</span> <span class="number">0x8806</span>:<span class="number">0</span>:<span class="number">67372036</span></span><br><span class="line">        mpls labels in/out nolabel/<span class="number">22</span></span><br><span class="line">BGP routing table entry <span class="keyword">for</span> <span class="number">1</span>:<span class="number">2</span>:<span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>, version <span class="number">77</span></span><br><span class="line">Paths: (<span class="number">1</span> available, best #<span class="number">1</span>, no table)</span><br><span class="line">Not advertised to any peer</span><br><span class="line">Local</span><br><span class="line"><span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> (metric <span class="number">2</span>) from <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> (<span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>)</span><br><span class="line">        Origin incomplete, metric <span class="number">156160</span>, localpref <span class="number">100</span>, valid, internal, best</span><br><span class="line">        Extended Community: RT:<span class="number">1</span>:<span class="number">1</span> Cost:pre-bestpath:<span class="number">128</span>:<span class="number">156160</span> <span class="number">0x8800</span>:<span class="number">32768</span>:<span class="number">0</span> </span><br><span class="line">        <span class="number">0x8801</span>:<span class="number">1</span>:<span class="number">130560</span> <span class="number">0x8802</span>:<span class="number">65281</span>:<span class="number">25600</span> <span class="number">0x8803</span>:<span class="number">65281</span>:<span class="number">1500</span> <span class="number">0x8806</span>:<span class="number">0</span>:<span class="number">67372036</span></span><br><span class="line">        mpls labels in/out nolabel/<span class="number">22</span></span><br><span class="line"><span class="comment">//VPNv4路由默认不携带SOO；</span></span><br></pre></td></tr></table></figure>

<p>在PE上，创建路由映射表SOO_LAB，对所有VPNv4路由设置MP-BGP拓展团体属性；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#route-map SOO_LAB permit 10</span></span><br><span class="line">R1(config-route-<span class="built_in">map</span>)<span class="meta">#set extcommunity ?</span></span><br><span class="line">cost  Cost extended community</span><br><span class="line">rt    Route Target extended community</span><br><span class="line">soo   Site-of-Origin extended community</span><br><span class="line"></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-route-<span class="built_in">map</span>)</span><span class="meta">#set extcommunity soo ?</span></span><br><span class="line">ASN:nn or IP-address:nn  VPN extended community</span><br><span class="line"></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-route-<span class="built_in">map</span>)</span><span class="meta">#set extcommunity soo 1:1</span></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-route-<span class="built_in">map</span>)</span><span class="meta">#exit</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">R2</span><span class="params">(config)</span><span class="meta">#route-map SOO_LAB permit 10 </span></span><br><span class="line"><span class="title function_">R2</span><span class="params">(config-route-<span class="built_in">map</span>)</span><span class="meta">#set extcommunity soo 1:2</span></span><br><span class="line"><span class="title function_">R2</span><span class="params">(config-route-<span class="built_in">map</span>)</span><span class="meta">#exit</span></span><br></pre></td></tr></table></figure>
<p>在PE的vrf接口上应用设置SOO的<code>route-map</code>；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#int f0/1</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#ip vrf sitemap ?</span></span><br><span class="line">WORD  Name of the route-<span class="built_in">map</span></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-<span class="keyword">if</span>)</span><span class="meta">#ip vrf sitemap SOO_LAB</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">R2</span><span class="params">(config)</span><span class="meta">#int f0/1</span></span><br><span class="line"><span class="title function_">R2</span><span class="params">(config-<span class="keyword">if</span>)</span><span class="meta">#ip vrf sitemap SOO_LAB</span></span><br></pre></td></tr></table></figure>
<p>在连接到后门链路的CE或C路由器上为EIGRP配置SOO；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R3(config)<span class="meta">#route-map SOO_LAB permit 10 </span></span><br><span class="line">R3(config-route-<span class="built_in">map</span>)<span class="meta">#set extcommunity soo 1:1</span></span><br><span class="line"></span><br><span class="line">R3(config)<span class="meta">#int f0/1</span></span><br><span class="line">R3(config-<span class="keyword">if</span>)<span class="meta">#ip vrf sitemap SOO_LAB</span></span><br><span class="line"></span><br><span class="line">R4(config)<span class="meta">#route-map SOO_LAB permit 10 </span></span><br><span class="line">R4(config-route-<span class="built_in">map</span>)<span class="meta">#set extcommunity soo 1:2</span></span><br><span class="line"></span><br><span class="line">R4(config)<span class="meta">#int f0/1</span></span><br><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#ip vrf sitemap SOO_LAB</span></span><br></pre></td></tr></table></figure>
<p>查看R1的IP BGP VNPv4路由表关于路由4.4.4.4的明细；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#do sh ip bgp vpnv4 all 3.3.3.3</span></span><br><span class="line">BGP routing table entry <span class="keyword">for</span> <span class="number">1</span>:<span class="number">1</span>:<span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>, version <span class="number">96</span></span><br><span class="line">Paths: (<span class="number">1</span> available, best #<span class="number">1</span>, no table)</span><br><span class="line">Not advertised to any peer</span><br><span class="line">Local</span><br><span class="line"><span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> (metric <span class="number">2</span>) from <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> (<span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>)</span><br><span class="line">        Origin incomplete, metric <span class="number">156160</span>, localpref <span class="number">100</span>, valid, internal, best</span><br><span class="line">        Extended Community: SoO:<span class="number">1</span>:<span class="number">1</span> RT:<span class="number">1</span>:<span class="number">1</span> Cost:pre-bestpath:<span class="number">128</span>:<span class="number">156160</span> </span><br><span class="line">        <span class="number">0x8800</span>:<span class="number">32768</span>:<span class="number">0</span> <span class="number">0x8801</span>:<span class="number">1</span>:<span class="number">130560</span> <span class="number">0x8802</span>:<span class="number">65281</span>:<span class="number">25600</span> <span class="number">0x8803</span>:<span class="number">65281</span>:<span class="number">1500</span> </span><br><span class="line">        <span class="number">0x8806</span>:<span class="number">0</span>:<span class="number">50529027</span></span><br><span class="line">        mpls labels in/out nolabel/<span class="number">24</span></span><br><span class="line">BGP routing table entry <span class="keyword">for</span> <span class="number">1</span>:<span class="number">2</span>:<span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>, version <span class="number">99</span></span><br><span class="line">Paths: (<span class="number">1</span> available, best #<span class="number">1</span>, table A-Site2)</span><br><span class="line">Not advertised to any peer</span><br><span class="line">Local, imported path from <span class="number">1</span>:<span class="number">1</span>:<span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span></span><br><span class="line"><span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> (metric <span class="number">2</span>) from <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> (<span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>)</span><br><span class="line">        Origin incomplete, metric <span class="number">156160</span>, localpref <span class="number">100</span>, valid, internal, best</span><br><span class="line">        Extended Community: SoO:<span class="number">1</span>:<span class="number">1</span> RT:<span class="number">1</span>:<span class="number">1</span> Cost:pre-bestpath:<span class="number">128</span>:<span class="number">156160</span> </span><br><span class="line">        <span class="number">0x8800</span>:<span class="number">32768</span>:<span class="number">0</span> <span class="number">0x8801</span>:<span class="number">1</span>:<span class="number">130560</span> <span class="number">0x8802</span>:<span class="number">65281</span>:<span class="number">25600</span> <span class="number">0x8803</span>:<span class="number">65281</span>:<span class="number">1500</span> </span><br><span class="line">        <span class="number">0x8806</span>:<span class="number">0</span>:<span class="number">50529027</span></span><br><span class="line">        mpls labels in/out nolabel/<span class="number">24</span></span><br></pre></td></tr></table></figure>

<p>查看R3的EIGRP 拓扑表关于4.4.4.4&#x2F;32的明细；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R3<span class="meta">#sh ip ei topology 4.4.4.4/32</span></span><br><span class="line">EIGRP-IPv4 Topology Entry <span class="keyword">for</span> <span class="title function_">AS</span><span class="params">(<span class="number">1</span>)</span>/<span class="title function_">ID</span><span class="params">(<span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>)</span> <span class="keyword">for</span> 4.4.4.4/32</span><br><span class="line">State is Passive, Query origin flag is 1, 1 <span class="title function_">Successor</span><span class="params">(s)</span>, FD is 158720</span><br><span class="line">Descriptor Blocks:</span><br><span class="line">192.168.13.1 <span class="params">(FastEthernet0/<span class="number">1</span>)</span>, from 192.168.13.1, Send flag is 0x0</span><br><span class="line">        Composite metric <span class="title function_">is</span> <span class="params">(<span class="number">158720</span>/<span class="number">156160</span>)</span>, route is Internal</span><br><span class="line">        Vector metric:</span><br><span class="line">        Minimum bandwidth is 100000 Kbit</span><br><span class="line">        Total delay is 5200 microseconds</span><br><span class="line">        Reliability is 255/255</span><br><span class="line">        Load is 1/255</span><br><span class="line">        Minimum MTU is 1500</span><br><span class="line">        Hop count is 2</span><br><span class="line">        Originating router is 4.4.4.4</span><br><span class="line">        Extended Community: SoO:1:2</span><br><span class="line">192.168.34.4 <span class="params">(Serial1/<span class="number">0</span>)</span>, from 192.168.34.4, Send flag is 0x0</span><br><span class="line">        Composite metric <span class="title function_">is</span> <span class="params">(<span class="number">2297856</span>/<span class="number">128256</span>)</span>, route is Internal</span><br><span class="line">        Vector metric:</span><br><span class="line">        Minimum bandwidth is 1544 Kbit</span><br><span class="line">        Total delay is 25000 microseconds</span><br><span class="line">        Reliability is 255/255</span><br><span class="line">        Load is 1/255</span><br><span class="line">        Minimum MTU is 1500</span><br><span class="line">        Hop count is 1</span><br><span class="line">        Originating router is 4.4.4.4</span><br><span class="line"><span class="comment">//R3上来自于R4的关于4.4.4.4/32的路由携带了SOO1:2；</span></span><br></pre></td></tr></table></figure>

<p>查看R4的EIGRP 拓扑表关于3.3.3.3&#x2F;32的明细；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#do sh ip ei to 3.3.3.3/32</span></span><br><span class="line">EIGRP-IPv4 Topology Entry <span class="keyword">for</span> <span class="title function_">AS</span><span class="params">(<span class="number">1</span>)</span>/<span class="title function_">ID</span><span class="params">(<span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>)</span> <span class="keyword">for</span> 3.3.3.3/32</span><br><span class="line">State is Passive, Query origin flag is 1, 1 <span class="title function_">Successor</span><span class="params">(s)</span>, FD is 158720</span><br><span class="line">Descriptor Blocks:</span><br><span class="line">192.168.24.2 <span class="params">(FastEthernet0/<span class="number">1</span>)</span>, from 192.168.24.2, Send flag is 0x0</span><br><span class="line">        Composite metric <span class="title function_">is</span> <span class="params">(<span class="number">158720</span>/<span class="number">156160</span>)</span>, route is Internal</span><br><span class="line">        Vector metric:</span><br><span class="line">        Minimum bandwidth is 100000 Kbit</span><br><span class="line">        Total delay is 5200 microseconds</span><br><span class="line">        Reliability is 255/255</span><br><span class="line">        Load is 1/255</span><br><span class="line">        Minimum MTU is 1500</span><br><span class="line">        Hop count is 2</span><br><span class="line">        Originating router is 3.3.3.3</span><br><span class="line">        Extended Community: SoO:1:1</span><br><span class="line">192.168.34.3 <span class="params">(Serial1/<span class="number">0</span>)</span>, from 192.168.34.3, Send flag is 0x0</span><br><span class="line">        Composite metric <span class="title function_">is</span> <span class="params">(<span class="number">2297856</span>/<span class="number">128256</span>)</span>, route is Internal</span><br><span class="line">        Vector metric:</span><br><span class="line">        Minimum bandwidth is 1544 Kbit</span><br><span class="line">        Total delay is 25000 microseconds</span><br><span class="line">        Reliability is 255/255</span><br><span class="line">        Load is 1/255</span><br><span class="line">        Minimum MTU is 1500</span><br><span class="line">        Hop count is 1</span><br><span class="line">        Originating router is 3.3.3.3</span><br><span class="line">        <span class="comment">//R4上来自于R3的关于3.3.3.3/32的路由携带了SOO1:1；</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>MPLS</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLS 实验13：Hub-and-Spoke</title>
    <url>/2014/MPLS_Lab_13/</url>
    <content><![CDATA[<h1 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h1><ul>
<li>模拟器：GNS3 0.8.6</li>
<li>Cisco IOS：c7200-adventerprisek9-mz.151-4.M2.image</li>
</ul>
<h1 id="GNS3实验拓扑文件："><a href="#GNS3实验拓扑文件：" class="headerlink" title="GNS3实验拓扑文件："></a>GNS3实验拓扑文件：</h1><p><a href="topology.net">拓扑文件</a></p>
<h1 id="实验拓扑："><a href="#实验拓扑：" class="headerlink" title="实验拓扑："></a>实验拓扑：</h1><p><img src="/2014/MPLS_Lab_13/topo.png"></p>
<span id="more"></span>

<h1 id="实验场景："><a href="#实验场景：" class="headerlink" title="实验场景："></a>实验场景：</h1><ol>
<li>Spoke站点只能与Hub站点进行通信；</li>
<li>Spoke站点到Spoke站点的流量必须首先发送到Hub站点；</li>
</ol>
<p>要实现以上操作，就必须要使用两个不同的RT，分别负责导入和导出；还需要为不同站点分配不同的RD；</p>
<ol>
<li>使用RT控制VPNv4路由的导入导出；</li>
<li>使用在PE和CE使用BGP Allowas-in解决eBGP防环机制导致</li>
<li>使用SOO解决PE-CE路由协议eBGP的路由环路；</li>
</ol>
<h1 id="基本预配置："><a href="#基本预配置：" class="headerlink" title="基本预配置："></a>基本预配置：</h1><h2 id="R1："><a href="#R1：" class="headerlink" title="R1："></a>R1：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">ip vrf A-Site1</span><br><span class="line">        rd <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        route-target export <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        route-target import <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.13</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip vrf forwarding A-Site1</span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">1</span></span><br><span class="line">        bgp router-id <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">        bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">        neighbor ibgp peer-group</span><br><span class="line">        neighbor ibgp remote-as <span class="number">1</span></span><br><span class="line">        neighbor ibgp update-source Loopback0</span><br><span class="line">        neighbor ibgp next-hop-self</span><br><span class="line">        neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> peer-group ibgp</span><br><span class="line">        neighbor <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> peer-group ibgp</span><br><span class="line">        !</span><br><span class="line">        address-family vpnv4</span><br><span class="line">        neighbor ibgp send-community both</span><br><span class="line">        neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> activate</span><br><span class="line">        neighbor <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> activate</span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">        !</span><br><span class="line">        address-family ipv4 vrf A-Site1</span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span> remote-as <span class="number">65001</span></span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span> activate</span><br><span class="line">        redistribute connected</span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">ip vrf A-Site1</span><br><span class="line">        rd <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        route-target export <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        route-target import <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">!</span><br><span class="line">ip vrf A-Site2</span><br><span class="line">        rd <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">        route-target export <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        route-target import <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip vrf forwarding A-Site1</span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.25</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet1/<span class="number">0</span></span><br><span class="line">        ip vrf forwarding A-Site2</span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.26</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">1</span></span><br><span class="line">        bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">        neighbor ibgp peer-group</span><br><span class="line">        neighbor ibgp remote-as <span class="number">1</span></span><br><span class="line">        neighbor ibgp update-source Loopback0</span><br><span class="line">        neighbor ibgp next-hop-self</span><br><span class="line">        neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> peer-group ibgp</span><br><span class="line">        neighbor <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> peer-group ibgp</span><br><span class="line">        !</span><br><span class="line">        address-family vpnv4</span><br><span class="line">        neighbor ibgp send-community both</span><br><span class="line">        neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> activate</span><br><span class="line">        neighbor <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> activate</span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">        !</span><br><span class="line">        address-family ipv4 vrf A-Site1</span><br><span class="line">        redistribute connected</span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.25</span><span class="number">.5</span> remote-as <span class="number">65001</span></span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.25</span><span class="number">.5</span> activate</span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">        !</span><br><span class="line">        address-family ipv4 vrf A-Site2</span><br><span class="line">        redistribute connected</span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.26</span><span class="number">.6</span> remote-as <span class="number">65002</span></span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.26</span><span class="number">.6</span> activate</span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R3"><a href="#R3" class="headerlink" title="R3:"></a>R3:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R3</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.13</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.23</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet1/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!         </span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R4"><a href="#R4" class="headerlink" title="R4:"></a>R4:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R4</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">ip vrf A-Site3</span><br><span class="line">        rd <span class="number">1</span>:<span class="number">3</span></span><br><span class="line">        route-target export <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">        route-target import <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip vrf forwarding A-Site3</span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip vrf forwarding A-Site3</span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet1/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">        no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">        router-id <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span></span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">1</span></span><br><span class="line">        bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">        neighbor ibgp peer-group</span><br><span class="line">        neighbor ibgp remote-as <span class="number">1</span></span><br><span class="line">        neighbor ibgp update-source Loopback0</span><br><span class="line">        neighbor ibgp next-hop-self</span><br><span class="line">        neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> peer-group ibgp</span><br><span class="line">        neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> peer-group ibgp</span><br><span class="line">        !</span><br><span class="line">        address-family vpnv4</span><br><span class="line">        neighbor ibgp send-community both</span><br><span class="line">        neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> activate</span><br><span class="line">        neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> activate</span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">        !</span><br><span class="line">        address-family ipv4 vrf A-Site3</span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span> remote-as <span class="number">65003</span></span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span> activate</span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.48</span><span class="number">.8</span> remote-as <span class="number">65003</span></span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.48</span><span class="number">.8</span> activate</span><br><span class="line">        redistribute connected</span><br><span class="line">        <span class="built_in">exit</span>-address-family</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R5"><a href="#R5" class="headerlink" title="R5:"></a>R5:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R5</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.25</span><span class="number">.5</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">65001</span></span><br><span class="line">        bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">        network <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> mask <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span> remote-as <span class="number">1</span></span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.25</span><span class="number">.2</span> remote-as <span class="number">1</span></span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R6"><a href="#R6" class="headerlink" title="R6:"></a>R6:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R6</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.26</span><span class="number">.6</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">65002</span></span><br><span class="line">        bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">        network <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> mask <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.26</span><span class="number">.2</span> remote-as <span class="number">1</span></span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R7"><a href="#R7" class="headerlink" title="R7:"></a>R7:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R7</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">65003</span></span><br><span class="line">        bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">        network <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> mask <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        neighbor <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> remote-as <span class="number">65003</span></span><br><span class="line">        neighbor <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> update-source Loopback0</span><br><span class="line">        neighbor <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> next-hop-self</span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span> remote-as <span class="number">1</span></span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R8"><a href="#R8" class="headerlink" title="R8:"></a>R8:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R8</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">        ip address <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">        ip address <span class="number">192.168</span><span class="number">.48</span><span class="number">.8</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">        no shutdown</span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">65003</span></span><br><span class="line">        bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">        network <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> mask <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        neighbor <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> remote-as <span class="number">65003</span></span><br><span class="line">        neighbor <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> update-source Loopback0</span><br><span class="line">        neighbor <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> next-hop-self</span><br><span class="line">        neighbor <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span> remote-as <span class="number">1</span></span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">        exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<h1 id="实验与调试："><a href="#实验与调试：" class="headerlink" title="实验与调试："></a>实验与调试：</h1><h2 id="实验1：同一VPN的不同站点使用不同的AS号；"><a href="#实验1：同一VPN的不同站点使用不同的AS号；" class="headerlink" title="实验1：同一VPN的不同站点使用不同的AS号；"></a>实验1：同一VPN的不同站点使用不同的AS号；</h2><p>查看R7的BGP汇总表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7(config-router)<span class="meta">#do sh ip bgp summary</span></span><br><span class="line">BGP router identifier <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>, local AS number <span class="number">65003</span></span><br><span class="line">BGP table version is <span class="number">12</span>, main routing table version <span class="number">12</span></span><br><span class="line"><span class="number">5</span> network entries using <span class="number">680</span> bytes of memory</span><br><span class="line"><span class="number">5</span> path entries using <span class="number">280</span> bytes of memory</span><br><span class="line"><span class="number">4</span>/<span class="number">4</span> BGP path/bestpath attribute entries using <span class="number">512</span> bytes of memory</span><br><span class="line"><span class="number">3</span> BGP AS-PATH entries using <span class="number">72</span> bytes of memory</span><br><span class="line"><span class="number">0</span> BGP route-<span class="built_in">map</span> cache entries using <span class="number">0</span> bytes of memory</span><br><span class="line"><span class="number">0</span> BGP filter-<span class="built_in">list</span> cache entries using <span class="number">0</span> bytes of memory</span><br><span class="line">BGP using <span class="number">1544</span> total bytes of memory</span><br><span class="line">BGP activity <span class="number">6</span>/<span class="number">1</span> prefixes, <span class="number">16</span>/<span class="number">11</span> paths, scan interval <span class="number">60</span> secs</span><br><span class="line">Neighbor        V           AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd</span><br><span class="line"><span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>         <span class="number">4</span>        <span class="number">65003</span>       <span class="number">0</span>       <span class="number">0</span>        <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">00</span>:<span class="number">04</span>:<span class="number">50</span> Idle</span><br><span class="line"><span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>    <span class="number">4</span>            <span class="number">1</span>     <span class="number">107</span>      <span class="number">87</span>       <span class="number">12</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">01</span>:<span class="number">11</span>:<span class="number">52</span>        <span class="number">4</span></span><br><span class="line"><span class="comment">//注意到邻居R8处于Idle状态；</span></span><br></pre></td></tr></table></figure>

<p>查看R8的BGP汇总表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R8(config-router)<span class="meta">#do sh ip bgp summary</span></span><br><span class="line">BGP router identifier <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, local AS number <span class="number">65003</span></span><br><span class="line">BGP table version is <span class="number">12</span>, main routing table version <span class="number">12</span></span><br><span class="line"><span class="number">5</span> network entries using <span class="number">680</span> bytes of memory</span><br><span class="line"><span class="number">5</span> path entries using <span class="number">280</span> bytes of memory</span><br><span class="line"><span class="number">4</span>/<span class="number">4</span> BGP path/bestpath attribute entries using <span class="number">512</span> bytes of memory</span><br><span class="line"><span class="number">3</span> BGP AS-PATH entries using <span class="number">72</span> bytes of memory</span><br><span class="line"><span class="number">0</span> BGP route-<span class="built_in">map</span> cache entries using <span class="number">0</span> bytes of memory</span><br><span class="line"><span class="number">0</span> BGP filter-<span class="built_in">list</span> cache entries using <span class="number">0</span> bytes of memory</span><br><span class="line">BGP using <span class="number">1544</span> total bytes of memory</span><br><span class="line">BGP activity <span class="number">6</span>/<span class="number">1</span> prefixes, <span class="number">14</span>/<span class="number">9</span> paths, scan interval <span class="number">60</span> secs</span><br><span class="line">Neighbor        V           AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd</span><br><span class="line"><span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>         <span class="number">4</span>        <span class="number">65003</span>       <span class="number">0</span>       <span class="number">0</span>        <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">00</span>:<span class="number">07</span>:<span class="number">55</span> Idle</span><br><span class="line"><span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>    <span class="number">4</span>            <span class="number">1</span>     <span class="number">101</span>      <span class="number">92</span>       <span class="number">12</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">01</span>:<span class="number">14</span>:<span class="number">12</span>        <span class="number">4</span></span><br><span class="line"><span class="comment">//注意到邻居R7处于Idle状态；</span></span><br></pre></td></tr></table></figure>

<p>查看R7的路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7(config-router)<span class="meta">#do sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">54</span>:<span class="number">25</span></span><br><span class="line">        <span class="number">6.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">40</span>:<span class="number">41</span></span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> is directly connected, Loopback0</span><br><span class="line">B     <span class="number">192.168</span><span class="number">.25</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">41</span>:<span class="number">31</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.26</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">41</span>:<span class="number">06</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line"><span class="comment">//注意到R7的没有去往BGP邻居R8环回口的路由，所以它们无法建立邻居；</span></span><br></pre></td></tr></table></figure>

<p>查看R8的路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R8(config-router)<span class="meta">#do sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>, <span class="number">01</span>:<span class="number">06</span>:<span class="number">21</span></span><br><span class="line">        <span class="number">6.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">53</span>:<span class="number">21</span></span><br><span class="line">        <span class="number">8.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> is directly connected, Loopback0</span><br><span class="line">B     <span class="number">192.168</span><span class="number">.25</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">54</span>:<span class="number">12</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.26</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">53</span>:<span class="number">47</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.48</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.48</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.48</span><span class="number">.8</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line"><span class="comment">//注意到R8的没有去往BGP邻居R7环回口的路由，所以它们无法建立邻居；</span></span><br></pre></td></tr></table></figure>

<p>由于R7和R8同属于一个AS，但它们被PE3隔离开了，并且它们之间再没有其他链路可以到达对方，因此，PE3为R7和R8提供到达对方的连通性，但由于EBGP的AS_PATH环路防护机制，<br>导致R7和R8从PE3收到包含自己所在AS的EBGP路由之后，将直接丢弃这些路由，所以R7和R8不会有对方的路由；</p>
<p>配置 <code>allowas-in</code> ，使R7和R8放松对AS_PATH的环路防护检测；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7(config-router)<span class="meta">#nei 192.168.47.4 allowas-in 2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R8(config-router)<span class="meta">#nei 192.168.48.4 allowas-in 2</span></span><br></pre></td></tr></table></figure>

<p>查看R7的BGP汇总表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7(config-router)<span class="meta">#do sh ip bgp summary</span></span><br><span class="line">BGP router identifier <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>, local AS number <span class="number">65003</span></span><br><span class="line">BGP table version is <span class="number">22</span>, main routing table version <span class="number">22</span></span><br><span class="line"><span class="number">6</span> network entries using <span class="number">816</span> bytes of memory</span><br><span class="line"><span class="number">13</span> path entries using <span class="number">728</span> bytes of memory</span><br><span class="line"><span class="number">10</span>/<span class="number">5</span> BGP path/bestpath attribute entries using <span class="number">1280</span> bytes of memory</span><br><span class="line"><span class="number">4</span> BGP AS-PATH entries using <span class="number">96</span> bytes of memory</span><br><span class="line"><span class="number">0</span> BGP route-<span class="built_in">map</span> cache entries using <span class="number">0</span> bytes of memory</span><br><span class="line"><span class="number">0</span> BGP filter-<span class="built_in">list</span> cache entries using <span class="number">0</span> bytes of memory</span><br><span class="line">BGP using <span class="number">2920</span> total bytes of memory</span><br><span class="line">BGP activity <span class="number">7</span>/<span class="number">1</span> prefixes, <span class="number">31</span>/<span class="number">18</span> paths, scan interval <span class="number">60</span> secs</span><br><span class="line">Neighbor        V           AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd</span><br><span class="line"><span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>         <span class="number">4</span>        <span class="number">65003</span>       <span class="number">9</span>      <span class="number">13</span>       <span class="number">22</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">00</span>:<span class="number">01</span>:<span class="number">54</span>        <span class="number">6</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>    <span class="number">4</span>            <span class="number">1</span>     <span class="number">148</span>     <span class="number">125</span>       <span class="number">22</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">01</span>:<span class="number">44</span>:<span class="number">39</span>        <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>查看R8的BGP汇总表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R8(config-router)<span class="meta">#do sh ip bgp summary</span></span><br><span class="line">BGP router identifier <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, local AS number <span class="number">65003</span></span><br><span class="line">BGP table version is <span class="number">26</span>, main routing table version <span class="number">26</span></span><br><span class="line"><span class="number">6</span> network entries using <span class="number">816</span> bytes of memory</span><br><span class="line"><span class="number">13</span> path entries using <span class="number">728</span> bytes of memory</span><br><span class="line"><span class="number">10</span>/<span class="number">5</span> BGP path/bestpath attribute entries using <span class="number">1280</span> bytes of memory</span><br><span class="line"><span class="number">4</span> BGP AS-PATH entries using <span class="number">96</span> bytes of memory</span><br><span class="line"><span class="number">0</span> BGP route-<span class="built_in">map</span> cache entries using <span class="number">0</span> bytes of memory</span><br><span class="line"><span class="number">0</span> BGP filter-<span class="built_in">list</span> cache entries using <span class="number">0</span> bytes of memory</span><br><span class="line">BGP using <span class="number">2920</span> total bytes of memory</span><br><span class="line">BGP activity <span class="number">7</span>/<span class="number">1</span> prefixes, <span class="number">37</span>/<span class="number">24</span> paths, scan interval <span class="number">60</span> secs</span><br><span class="line">Neighbor        V           AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd</span><br><span class="line"><span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>         <span class="number">4</span>        <span class="number">65003</span>       <span class="number">9</span>      <span class="number">11</span>       <span class="number">26</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">00</span>:<span class="number">01</span>:<span class="number">47</span>        <span class="number">6</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>    <span class="number">4</span>            <span class="number">1</span>     <span class="number">142</span>     <span class="number">133</span>       <span class="number">26</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">01</span>:<span class="number">47</span>:<span class="number">10</span>        <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>从R7 ping R8；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7(config-router)<span class="meta">#do p 8.8.8.8</span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Sending <span class="number">5</span>, <span class="number">100</span>-byte ICMP Echos to <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, timeout is <span class="number">2</span> seconds:</span><br><span class="line">.....</span><br><span class="line">Success rate is <span class="number">0</span> percent (<span class="number">0</span>/<span class="number">5</span>)</span><br><span class="line">R7(config-router)<span class="meta">#do p 8.8.8.8 source 7.7.7.7</span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Sending <span class="number">5</span>, <span class="number">100</span>-byte ICMP Echos to <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, timeout is <span class="number">2</span> seconds:</span><br><span class="line">Packet sent with a source address of <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> </span><br><span class="line">.....</span><br><span class="line">Success rate is <span class="number">0</span> percent (<span class="number">0</span>/<span class="number">5</span>)</span><br><span class="line"><span class="comment">//R7无法ping通R8；</span></span><br></pre></td></tr></table></figure>

<p>查看R7的路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7(config-router)<span class="meta">#do sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">01</span>:<span class="number">44</span>:<span class="number">45</span></span><br><span class="line">        <span class="number">6.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">01</span>:<span class="number">31</span>:<span class="number">01</span></span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">8.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> [<span class="number">200</span>/<span class="number">0</span>] via <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, <span class="number">00</span>:<span class="number">01</span>:<span class="number">41</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.25</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">01</span>:<span class="number">31</span>:<span class="number">51</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.26</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">01</span>:<span class="number">31</span>:<span class="number">26</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>查看R8的路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R8(config-router)<span class="meta">#do sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>, <span class="number">01</span>:<span class="number">47</span>:<span class="number">33</span></span><br><span class="line">        <span class="number">6.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>, <span class="number">01</span>:<span class="number">34</span>:<span class="number">33</span></span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> [<span class="number">200</span>/<span class="number">0</span>] via <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>, <span class="number">00</span>:<span class="number">02</span>:<span class="number">03</span></span><br><span class="line">        <span class="number">8.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> is directly connected, Loopback0</span><br><span class="line">B     <span class="number">192.168</span><span class="number">.25</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>, <span class="number">01</span>:<span class="number">35</span>:<span class="number">24</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.26</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>, <span class="number">01</span>:<span class="number">34</span>:<span class="number">59</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.48</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.48</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.48</span><span class="number">.8</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>查看R7的BGP表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7(config-router)<span class="meta">#do sh ip bgp</span></span><br><span class="line">BGP table version is <span class="number">114</span>, local router ID is <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span></span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">                r RIB-failure, S Stale, m multipath, b backup-path, x best-external, f RT-Filter</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">* i5<span class="number">.5</span><span class="number">.5</span><span class="number">.5</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>             <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> <span class="number">1</span> <span class="number">65001</span> i</span><br><span class="line">*&gt;                  <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65001</span> i</span><br><span class="line">* i6<span class="number">.6</span><span class="number">.6</span><span class="number">.6</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>             <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> <span class="number">1</span> <span class="number">65002</span> i</span><br><span class="line">*&gt;                  <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65002</span> i</span><br><span class="line">* i7<span class="number">.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>             <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> <span class="number">1</span> <span class="number">65003</span> i<span class="comment">//可以看到R7的直连环回口却又通过PE被通告了回来，有环路存在；</span></span><br><span class="line">*                   <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65003</span> i<span class="comment">//可以看到R7的直连环回口却又通过PE被通告了回来，有环路存在；</span></span><br><span class="line">*&gt;                  <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>                  <span class="number">0</span>         <span class="number">32768</span> i</span><br><span class="line">*&gt;i8<span class="number">.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>       <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>                  <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> i</span><br><span class="line">*                   <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65003</span> i</span><br><span class="line">* i192<span class="number">.168</span><span class="number">.25</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>             <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> <span class="number">1</span> ?</span><br><span class="line">*&gt;                  <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> ?</span><br><span class="line">* i192<span class="number">.168</span><span class="number">.26</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>             <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> <span class="number">1</span> ?</span><br><span class="line">*&gt;                  <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> ?</span><br></pre></td></tr></table></figure>

<p>查看R8的BGP表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R8(config-router)<span class="meta">#do sh ip bgp</span></span><br><span class="line">BGP table version is <span class="number">116</span>, local router ID is <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">                r RIB-failure, S Stale, m multipath, b backup-path, x best-external, f RT-Filter</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">* i5<span class="number">.5</span><span class="number">.5</span><span class="number">.5</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>             <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> <span class="number">1</span> <span class="number">65001</span> i</span><br><span class="line">*&gt;                  <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65001</span> i</span><br><span class="line">* i6<span class="number">.6</span><span class="number">.6</span><span class="number">.6</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>             <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> <span class="number">1</span> <span class="number">65002</span> i</span><br><span class="line">*&gt;                  <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65002</span> i</span><br><span class="line">*&gt;i7<span class="number">.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>                  <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> i</span><br><span class="line">*                   <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65003</span> i</span><br><span class="line">* i8<span class="number">.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>             <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> <span class="number">1</span> <span class="number">65003</span> i<span class="comment">//可以看到R8的直连环回口却又通过PE被通告了回来，有环路存在；</span></span><br><span class="line">*                   <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65003</span> i<span class="comment">//可以看到R8的直连环回口却又通过PE被通告了回来，有环路存在；</span></span><br><span class="line">*&gt;                  <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>                  <span class="number">0</span>         <span class="number">32768</span> i</span><br><span class="line">* i192<span class="number">.168</span><span class="number">.25</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>             <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> <span class="number">1</span> ?</span><br><span class="line">*&gt;                  <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> ?</span><br><span class="line">* i192<span class="number">.168</span><span class="number">.26</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>             <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> <span class="number">1</span> ?</span><br><span class="line">*&gt;                  <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> ?</span><br></pre></td></tr></table></figure>
<p>可以看到，现在虽然将R7和R8配置为iBGP邻居，并且由于MPLS VPN的存在R7和R8通过MPLS VPN将iBGP路由发送给对方，而由PE通告的eBGP路由具有更长的AS_PATH，所以R7和R8会优选自己通告的BGP路由。</p>
<p>但是实际上它们之间的连通性是由同PE的eBGP邻居提供的，如果不走PE，就无法到达对方！</p>
<p><strong>解决方案是，不让R7和R8建立iBGP邻居；</strong></p>
<p>删除R7的iBGP邻居配置；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7(config-router)<span class="meta">#no nei 8.8.8.8 remote-as 65003</span></span><br></pre></td></tr></table></figure>

<p>删除R8的iBGP邻居配置；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R8(config-router)<span class="meta">#no nei 7.7.7.7 remote-as 65003</span></span><br></pre></td></tr></table></figure>

<p>查看R7的路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7(config-router)<span class="meta">#do sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">03</span>:<span class="number">22</span>:<span class="number">49</span></span><br><span class="line">        <span class="number">6.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">03</span>:<span class="number">09</span>:<span class="number">05</span></span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">8.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">11</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.25</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">03</span>:<span class="number">09</span>:<span class="number">55</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.26</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">03</span>:<span class="number">09</span>:<span class="number">30</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>查看R8的路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R8(config-router)<span class="meta">#do sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>, <span class="number">03</span>:<span class="number">24</span>:<span class="number">23</span></span><br><span class="line">        <span class="number">6.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>, <span class="number">03</span>:<span class="number">11</span>:<span class="number">23</span></span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">02</span>:<span class="number">34</span></span><br><span class="line">        <span class="number">8.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> is directly connected, Loopback0</span><br><span class="line">B     <span class="number">192.168</span><span class="number">.25</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>, <span class="number">03</span>:<span class="number">12</span>:<span class="number">14</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.26</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>, <span class="number">03</span>:<span class="number">11</span>:<span class="number">49</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.48</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.48</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.48</span><span class="number">.8</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>查看R7的BGP表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7(config)<span class="meta">#do sh ip bgp                                                   </span></span><br><span class="line">BGP table version is <span class="number">147</span>, local router ID is <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span></span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">                r RIB-failure, S Stale, m multipath, b backup-path, x best-external, f RT-Filter</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">*&gt; <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65001</span> i</span><br><span class="line">*&gt; <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65002</span> i</span><br><span class="line">*  <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65003</span> i</span><br><span class="line">*&gt;                  <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>                  <span class="number">0</span>         <span class="number">32768</span> i</span><br><span class="line">*&gt; <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65003</span> i</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.25</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> ?</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.26</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> ?</span><br><span class="line"><span class="comment">//虽然现在把下一跳解决了，但是环路依然存在；</span></span><br></pre></td></tr></table></figure>

<p>查看R8的BGP表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R8(config-router)<span class="meta">#do sh ip bgp </span></span><br><span class="line">BGP table version is <span class="number">147</span>, local router ID is <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">                r RIB-failure, S Stale, m multipath, b backup-path, x best-external, f RT-Filter</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">*&gt; <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65001</span> i</span><br><span class="line">*&gt; <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65002</span> i</span><br><span class="line">*&gt; <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65003</span> i</span><br><span class="line">*  <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> <span class="number">65003</span> i</span><br><span class="line">*&gt;                  <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>                  <span class="number">0</span>         <span class="number">32768</span> i</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.25</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> ?</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.26</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.48</span><span class="number">.4</span>                           <span class="number">0</span> <span class="number">1</span> ?</span><br><span class="line"><span class="comment">//虽然现在把下一跳解决了，但是环路依然存在；</span></span><br></pre></td></tr></table></figure>

<p>在R4上配置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#route-map SOO1:1 permit 10    </span></span><br><span class="line">R4(config-route-<span class="built_in">map</span>)<span class="meta">#set extcommunity soo 1:1      </span></span><br><span class="line">R4(config-route-<span class="built_in">map</span>)<span class="meta">#exit</span></span><br><span class="line">R4(config)<span class="meta">#route-map SOO1:2 permit 10</span></span><br><span class="line">R4(config-route-<span class="built_in">map</span>)<span class="meta">#set extcommunity soo 1:2  </span></span><br><span class="line">R4(config-route-<span class="built_in">map</span>)<span class="meta">#exit</span></span><br><span class="line"></span><br><span class="line">R4(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#add ipv4 vrf A-Site3</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 192.168.47.7 route-map SOO1:1 in</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 192.168.48.8 route-map SOO1:2 in</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7<span class="meta">#ping 8.8.8.8</span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Sending <span class="number">5</span>, <span class="number">100</span>-byte ICMP Echos to <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, timeout is <span class="number">2</span> seconds:</span><br><span class="line">.....</span><br><span class="line">Success rate is <span class="number">0</span> percent (<span class="number">0</span>/<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">R7<span class="meta">#ping 8.8.8.8 source l0</span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Sending <span class="number">5</span>, <span class="number">100</span>-byte ICMP Echos to <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, timeout is <span class="number">2</span> seconds:</span><br><span class="line">Packet sent with a source address of <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> </span><br><span class="line">!!!!!</span><br><span class="line">Success rate is <span class="number">100</span> percent (<span class="number">5</span>/<span class="number">5</span>), round-trip min/avg/max = <span class="number">44</span>/<span class="number">64</span>/<span class="number">88</span> ms</span><br><span class="line"><span class="comment">//指定源后，成功ping通！</span></span><br><span class="line"><span class="comment">//发现是之前疏忽大意了，忘了在预配中将R4的直连路由重分发进MP-BGP了；</span></span><br></pre></td></tr></table></figure>

<p>检查配置，R4和R1上将直连路由重分发进MP-BGP；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#add ipv4 vrf A-Site3</span></span><br><span class="line">R4(config-router-af)<span class="meta">#redistribute connected</span></span><br><span class="line"></span><br><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#address-family ipv4 vrf A-Site1</span></span><br><span class="line">R1(config-router-af)<span class="meta">#redistribute connected</span></span><br></pre></td></tr></table></figure>

<p>从R7上ping其他站点的路由器；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7<span class="meta">#ping 8.8.8.8</span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Sending <span class="number">5</span>, <span class="number">100</span>-byte ICMP Echos to <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, timeout is <span class="number">2</span> seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is <span class="number">100</span> percent (<span class="number">5</span>/<span class="number">5</span>), round-trip min/avg/max = <span class="number">36</span>/<span class="number">84</span>/<span class="number">120</span> ms</span><br><span class="line">R7<span class="meta">#ping 5.5.5.5</span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Sending <span class="number">5</span>, <span class="number">100</span>-byte ICMP Echos to <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>, timeout is <span class="number">2</span> seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is <span class="number">100</span> percent (<span class="number">5</span>/<span class="number">5</span>), round-trip min/avg/max = <span class="number">88</span>/<span class="number">121</span>/<span class="number">144</span> ms</span><br><span class="line">R7<span class="meta">#ping 6.6.6.6  </span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Sending <span class="number">5</span>, <span class="number">100</span>-byte ICMP Echos to <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span>, timeout is <span class="number">2</span> seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is <span class="number">100</span> percent (<span class="number">5</span>/<span class="number">5</span>), round-trip min/avg/max = <span class="number">80</span>/<span class="number">105</span>/<span class="number">140</span> ms</span><br></pre></td></tr></table></figure>

<p>查看R5的路由表，发现R5依然没有R6的路由；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R5<span class="meta">#sh ip route </span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>, <span class="number">04</span>:<span class="number">17</span>:<span class="number">22</span></span><br><span class="line">        <span class="number">8.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>, <span class="number">04</span>:<span class="number">16</span>:<span class="number">37</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.25</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.25</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.25</span><span class="number">.5</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">11</span>:<span class="number">01</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.48</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">11</span>:<span class="number">01</span></span><br></pre></td></tr></table></figure>

<p>查看R6的路由表，发现R6同样没有R5的路由；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R6<span class="meta">#sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">6.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.26</span><span class="number">.2</span>, <span class="number">04</span>:<span class="number">04</span>:<span class="number">46</span></span><br><span class="line">        <span class="number">8.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.26</span><span class="number">.2</span>, <span class="number">04</span>:<span class="number">04</span>:<span class="number">46</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.26</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.26</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.26</span><span class="number">.6</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.26</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">12</span>:<span class="number">07</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.48</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.26</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">12</span>:<span class="number">07</span></span><br></pre></td></tr></table></figure>

<p>由于需求要求Spoke和Spoke间的通信需要先绕经Hub站点，所以R5需要从站点3学到关于R6的路由，R6也需要从站点3学到关于R5的路由；但当路由从R4通告给站点3的时候，路由的AS_PATH携带了AS1，当被站点3通告回R4的时候，R4就会丢弃AS_PATH中携带了和自己所在AS号相同的的路由。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>PE路由器简单地比较CE路由器ASN和 <code>as-path</code> 中的ASN，如果匹配的话，所有在 <code>as-path</code> 中的该ASN都会被服务提供商的ASN所代替。<br>这样一来，远程CE就会接受这些路由了，因为它们在这些BGP路由的 <code>as-path</code> 中看不到自己的ASN了！但这样一来，对于可能存在环路的保护机制，以及非最优路由的 <code>as-path</code> 检查机制就失效了。因此，在使用 <code>as-override</code> 功能进行ASN覆盖的时候，明智的做法是为BGP实施SOO特性。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>MPLS</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLS 实验2：MPLS LDP会话保护</title>
    <url>/2014/MPLS_Lab_2/</url>
    <content><![CDATA[<h1 id="理论：MPLS-LDP会话保护"><a href="#理论：MPLS-LDP会话保护" class="headerlink" title="理论：MPLS LDP会话保护"></a>理论：MPLS LDP会话保护</h1><p>在对两台直接连接LSR之间的LDP会话实施保护后，将会在这两台LSR之间建立基于目标的LDP会话。当这两台LSR之间的直连链路断开以后，只要这两台LSR之间存在可替代路径，基于目标的LDP会话将会得到维持。</p>
<h1 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h1><ul>
<li>模拟器：GNS3 0.8.6</li>
<li>Cisco IOS：c7200-adventerprisek9-mz.151-4.M2.image</li>
</ul>
<h1 id="实验拓扑："><a href="#实验拓扑：" class="headerlink" title="实验拓扑："></a>实验拓扑：</h1><p><img src="/2014/MPLS_Lab_2/topo.png" alt="topology"></p>
<span id="more"></span>

<h1 id="基本预配置："><a href="#基本预配置：" class="headerlink" title="基本预配置："></a>基本预配置：</h1><h2 id="R1："><a href="#R1：" class="headerlink" title="R1："></a>R1：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">multilink bundle-name authenticated</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 1.1.1.1 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.12.1 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shut</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.14.1 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shut</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 1.1.1.1</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 2.2.2.2 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.12.2 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shut</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.23.2 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shut</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 2.2.2.2</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R3"><a href="#R3" class="headerlink" title="R3:"></a>R3:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R3</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 3.3.3.3 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.34.3 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shut</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.23.3 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shut</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 3.3.3.3</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R4"><a href="#R4" class="headerlink" title="R4:"></a>R4:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R4</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 4.4.4.4 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.34.4 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shut</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.14.4 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shut</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 4.4.4.4</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<h1 id="实验与调试："><a href="#实验与调试：" class="headerlink" title="实验与调试："></a>实验与调试：</h1><h2 id="实验1：两台LSR相互将对方配置为受MPLS-LDP会话保护的对等体；"><a href="#实验1：两台LSR相互将对方配置为受MPLS-LDP会话保护的对等体；" class="headerlink" title="实验1：两台LSR相互将对方配置为受MPLS LDP会话保护的对等体；"></a>实验1：两台LSR相互将对方配置为受MPLS LDP会话保护的对等体；</h2><p>配置ACL来指定需要被保护的LDP对等体；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#ip access-list standard PROTECT_R4</span></span><br><span class="line">R1(config-<span class="built_in">std</span>-nacl)<span class="meta">#permit host 4.4.4.4</span></span><br><span class="line">R1(config-<span class="built_in">std</span>-nacl)<span class="meta">#exit</span></span><br></pre></td></tr></table></figure>

<p>配置MPLS LDP会话保护，并将其与指定需要保护的LDP对等体ACL相关联；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#mpls ldp session protection for PROTECT_R4 duration ?</span></span><br><span class="line">    &lt;<span class="number">30</span><span class="number">-2147483</span>&gt;  Holdup time in seconds</span><br><span class="line">    infinite      Protect session forever after loss of link discovery</span><br><span class="line"><span class="comment">//选项duration指出持续时间，持续时间指的是在LDP链路的邻接关系断掉以后，需要得到保护（基于目标的LDP会话）的周期时间；</span></span><br><span class="line"></span><br><span class="line">R1(config)<span class="meta">#mpls ldp session protection for PROTECT_R4</span></span><br></pre></td></tr></table></figure>

<p>验证：查看R1的MPLS LDP邻居列表中邻居R4的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do sh mpls ldp nei 4.4.4.4 detail            </span></span><br><span class="line">    Peer LDP Ident: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>; Local LDP Ident <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span><span class="number">.40199</span> - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span></span><br><span class="line">        Password: not required, none, in use</span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">61</span>/<span class="number">59</span>; Downstream; Last TIB rev sent <span class="number">16</span></span><br><span class="line">        Up time: <span class="number">00</span>:<span class="number">42</span>:<span class="number">56</span>; UID: <span class="number">2</span>; Peer Id <span class="number">1</span>;</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">          FastEthernet0/<span class="number">1</span>; Src IP addr: <span class="number">192.168</span><span class="number">.14</span><span class="number">.4</span> </span><br><span class="line">            holdtime: <span class="number">15000</span> ms, hello interval: <span class="number">5000</span> ms</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">          <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>         <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span>    <span class="number">192.168</span><span class="number">.14</span><span class="number">.4</span>    </span><br><span class="line">        Peer holdtime: <span class="number">180000</span> ms; KA interval: <span class="number">60000</span> ms; Peer state: estab</span><br><span class="line">        Clients: Dir Adj Client</span><br><span class="line">        LDP Session Protection enabled, state: Incomplete <span class="comment">//可以看到针对邻居4.4.4.4,LDP会话保护已经启用；但因R1端还未配置，所以状态为Incomplete；</span></span><br><span class="line">            acl: PROTECT_R4, duration: <span class="number">86400</span> seconds <span class="comment">//持续保护时间为86400秒，即24小时；</span></span><br><span class="line">        Capabilities Sent:</span><br><span class="line">          [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">          [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">          [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">        Capabilities Received:</span><br><span class="line">          [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">          [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">          [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br></pre></td></tr></table></figure>
<p>注意：根据《MPLS Fundamental》86页所述，默认的持续时间（Duration）为无限期，即永远，<br>但是经过试验发现，如果不指明选项duration，则持续保护时间为86400秒，即24小时；</p>
<p>而明确指定 duration 为 infinite（无限期）之后，持续保护时间才真正变为了 infinite（无限期）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#mpls ldp session protection for PROTECT_R4 duration infinite </span></span><br></pre></td></tr></table></figure>

<p>验证：查看R1的MPLS LDP邻居列表中邻居R4的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do sh mpls ldp nei 4.4.4.4 detail                           </span></span><br><span class="line">    Peer LDP Ident: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>; Local LDP Ident <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span><span class="number">.40199</span> - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span></span><br><span class="line">        Password: not required, none, in use</span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">70</span>/<span class="number">69</span>; Downstream; Last TIB rev sent <span class="number">16</span></span><br><span class="line">        Up time: <span class="number">00</span>:<span class="number">51</span>:<span class="number">05</span>; UID: <span class="number">2</span>; Peer Id <span class="number">1</span>;</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">            FastEthernet0/<span class="number">1</span>; Src IP addr: <span class="number">192.168</span><span class="number">.14</span><span class="number">.4</span> </span><br><span class="line">            holdtime: <span class="number">15000</span> ms, hello interval: <span class="number">5000</span> ms</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">            <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>         <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span>    <span class="number">192.168</span><span class="number">.14</span><span class="number">.4</span>    </span><br><span class="line">        Peer holdtime: <span class="number">180000</span> ms; KA interval: <span class="number">60000</span> ms; Peer state: estab</span><br><span class="line">        Clients: Dir Adj Client</span><br><span class="line">        LDP Session Protection enabled, state: Incomplete  <span class="comment">//可以看到针对邻居4.4.4.4,LDP会话保护已经启用；但因R1端还未配置，所以状态为Incomplete；</span></span><br><span class="line">            acl: PROTECT_R4, duration: infinite<span class="comment">//持续保护时间为无限期，即永远保护；</span></span><br><span class="line">        Capabilities Sent:</span><br><span class="line">            [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">        Capabilities Received:</span><br><span class="line">            [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br></pre></td></tr></table></figure>
<p>而当指定了duration为无限期（infinite）之后，持续保护时间才真正变为了infinite（无限期）；</p>
<p>验证：查看R4的MPLS LDP邻居列表中邻居R1的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#do sh mpls ldp nei 1.1.1.1 detail</span></span><br><span class="line">    Peer LDP Ident: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>; Local LDP Ident <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span> - <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span><span class="number">.40199</span></span><br><span class="line">        Password: not required, none, in use</span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">85</span>/<span class="number">86</span>; Downstream; Last TIB rev sent <span class="number">16</span></span><br><span class="line">        Up time: <span class="number">01</span>:<span class="number">05</span>:<span class="number">13</span>; UID: <span class="number">2</span>; Peer Id <span class="number">1</span>;</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">            FastEthernet0/<span class="number">1</span>; Src IP addr: <span class="number">192.168</span><span class="number">.14</span><span class="number">.1</span> </span><br><span class="line">            holdtime: <span class="number">15000</span> ms, hello interval: <span class="number">5000</span> ms</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">            <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span>    <span class="number">192.168</span><span class="number">.14</span><span class="number">.1</span>    <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>         </span><br><span class="line">        Peer holdtime: <span class="number">180000</span> ms; KA interval: <span class="number">60000</span> ms; Peer state: estab</span><br><span class="line">        Capabilities Sent:</span><br><span class="line">            [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">        Capabilities Received:</span><br><span class="line">            [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br></pre></td></tr></table></figure>
<p>注意到，虽然此时R1上已经配置了针对邻居R4的LDP会话保护，但是由于R4上未做配置，所以在R4看来，仿佛这一切的一切并未发生过一般；</p>
<p>配置ACL来指定需要被保护的LDP对等体；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#ip access-list standard PROTECT_R1</span></span><br><span class="line">R4(config-<span class="built_in">std</span>-nacl)<span class="meta">#permit host 1.1.1.1</span></span><br><span class="line">R4(config-<span class="built_in">std</span>-nacl)<span class="meta">#exit</span></span><br></pre></td></tr></table></figure>

<p>配置MPLS LDP会话保护，并将其与指定需要保护的LDP对等体ACL相关联；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#mpls ldp session protection for PROTECT_R1 duration infinite</span></span><br></pre></td></tr></table></figure>
<p>验证：查看R4的MPLS LDP邻居列表中邻居R1的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#do sh mpls ldp nei 1.1.1.1 detail                           </span></span><br><span class="line">    Peer LDP Ident: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>; Local LDP Ident <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span> - <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span><span class="number">.40199</span></span><br><span class="line">        Password: not required, none, in use</span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">101</span>/<span class="number">103</span>; Downstream; Last TIB rev sent <span class="number">16</span></span><br><span class="line">        Up time: <span class="number">01</span>:<span class="number">19</span>:<span class="number">22</span>; UID: <span class="number">2</span>; Peer Id <span class="number">1</span>;</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">            FastEthernet0/<span class="number">1</span>; Src IP addr: <span class="number">192.168</span><span class="number">.14</span><span class="number">.1</span> </span><br><span class="line">            holdtime: <span class="number">15000</span> ms, hello interval: <span class="number">5000</span> ms</span><br><span class="line">            Targeted Hello <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> -&gt; <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>, active, passive;<span class="comment">//基于目标的远程LDP会话已经建立；</span></span><br><span class="line">            holdtime: infinite, hello interval: <span class="number">10000</span> ms</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">            <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span>    <span class="number">192.168</span><span class="number">.14</span><span class="number">.1</span>    <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>         </span><br><span class="line">        Peer holdtime: <span class="number">180000</span> ms; KA interval: <span class="number">60000</span> ms; Peer state: estab</span><br><span class="line">        Clients: Dir Adj Client</span><br><span class="line">        LDP Session Protection enabled, state: Ready <span class="comment">//可以看到R4针对邻居R1的LDP会话保护已经开启，并且状态为Ready，表示已经做好会话保护准备；</span></span><br><span class="line">            acl: PROTECT_R1, duration: infinite<span class="comment">//持续保护时间为无限期，即永远保护；</span></span><br><span class="line">        Capabilities Sent:</span><br><span class="line">            [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">        Capabilities Received:</span><br><span class="line">            [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br></pre></td></tr></table></figure>

<p>验证：查看R1的MPLS LDP邻居列表中邻居R4的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do sh mpls ldp nei 4.4.4.4 detail</span></span><br><span class="line">    Peer LDP Ident: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>; Local LDP Ident <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span><span class="number">.40199</span> - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span></span><br><span class="line">        Password: not required, none, in use</span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">108</span>/<span class="number">106</span>; Downstream; Last TIB rev sent <span class="number">16</span></span><br><span class="line">        Up time: <span class="number">01</span>:<span class="number">24</span>:<span class="number">16</span>; UID: <span class="number">2</span>; Peer Id <span class="number">1</span>;</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">            FastEthernet0/<span class="number">1</span>; Src IP addr: <span class="number">192.168</span><span class="number">.14</span><span class="number">.4</span> </span><br><span class="line">            holdtime: <span class="number">15000</span> ms, hello interval: <span class="number">5000</span> ms</span><br><span class="line">            Targeted Hello <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> -&gt; <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>, active, passive;<span class="comment">//基于目标的远程LDP会话已经建立；</span></span><br><span class="line">            holdtime: infinite, hello interval: <span class="number">10000</span> ms</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">            <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>         <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span>    <span class="number">192.168</span><span class="number">.14</span><span class="number">.4</span>    </span><br><span class="line">        Peer holdtime: <span class="number">180000</span> ms; KA interval: <span class="number">60000</span> ms; Peer state: estab</span><br><span class="line">        Clients: Dir Adj Client</span><br><span class="line">        LDP Session Protection enabled, state: Ready<span class="comment">//可以看到R4针对邻居R1的LDP会话保护已经开启，并且状态为Ready，表示已经做好会话保护准备；</span></span><br><span class="line">            acl: PROTECT_R4, duration: infinite<span class="comment">//持续保护时间为无限期，即永远保护；</span></span><br><span class="line">        Capabilities Sent:</span><br><span class="line">            [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">        Capabilities Received:</span><br><span class="line">            [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br></pre></td></tr></table></figure>

<p>调试：断开R1和R4之间的直连链路；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将R1上与R4相连的F0/1口shutdown；</span></span><br><span class="line">R1(config)<span class="meta">#int f0/1</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#shutdown</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)#</span><br><span class="line">*Mar <span class="number">15</span> <span class="number">11</span>:<span class="number">24</span>:<span class="number">27.663</span>: %LDP<span class="number">-5</span>-SP: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>: session hold up initiated  <span class="comment">//LDP会话保护机制已经开始初始化；</span></span><br><span class="line">*Mar <span class="number">15</span> <span class="number">11</span>:<span class="number">24</span>:<span class="number">27.675</span>: %OSPF<span class="number">-5</span>-ADJCHG: Process <span class="number">1</span>, Nbr <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> on FastEthernet0/<span class="number">1</span> from FULL to DOWN, Neighbor Down: Interface down or detached</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-<span class="keyword">if</span>)</span>#</span><br><span class="line">*Mar 15 11:24:29.619: %LINK-5-CHANGED: Interface FastEthernet0/1, changed state to administratively down</span><br><span class="line">*Mar 15 11:24:30.619: %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/1, changed state to down</span><br></pre></td></tr></table></figure>

<p>验证：查看R1的MPLS LDP邻居列表中邻居R4的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do sh mpls ldp nei 4.4.4.4 detail</span></span><br><span class="line">    Peer LDP Ident: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>; Local LDP Ident <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span><span class="number">.40199</span> - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span></span><br><span class="line">        Password: not required, none, in use</span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">120</span>/<span class="number">116</span>; Downstream; Last TIB rev sent <span class="number">18</span></span><br><span class="line">        Up time: <span class="number">01</span>:<span class="number">32</span>:<span class="number">26</span>; UID: <span class="number">2</span>; Peer Id <span class="number">1</span>;</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">            Targeted Hello <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> -&gt; <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>, active, passive;</span><br><span class="line">            holdtime: infinite, hello interval: <span class="number">10000</span> ms</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">            <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>         <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span>    <span class="number">192.168</span><span class="number">.14</span><span class="number">.4</span>    </span><br><span class="line">        Peer holdtime: <span class="number">180000</span> ms; KA interval: <span class="number">60000</span> ms; Peer state: estab</span><br><span class="line">        Clients: Dir Adj Client</span><br><span class="line">        LDP Session Protection enabled, state: Protecting <span class="comment">//LDP会话保护正在进行中，状态为Protecting；</span></span><br><span class="line">            acl: PROTECT_R4, duration: infinite</span><br><span class="line">        Capabilities Sent:</span><br><span class="line">            [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">        Capabilities Received:</span><br><span class="line">            [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br></pre></td></tr></table></figure>
<p>查看R1的LIB表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do show mpls ldp bindings</span></span><br><span class="line">    lib entry: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>, rev <span class="number">2</span></span><br><span class="line">        local binding:  label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: <span class="number">16</span></span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: <span class="number">16</span></span><br><span class="line">    lib entry: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>, rev <span class="number">8</span></span><br><span class="line">        local binding:  label: <span class="number">16</span></span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: <span class="number">17</span></span><br><span class="line">    lib entry: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>, rev <span class="number">13</span></span><br><span class="line">        local binding:  label: <span class="number">18</span></span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: <span class="number">18</span></span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: <span class="number">18</span></span><br><span class="line">    lib entry: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>, rev <span class="number">16</span></span><br><span class="line">        local binding:  label: <span class="number">20</span></span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: <span class="number">20</span></span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">4</span></span><br><span class="line">        local binding:  label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: <span class="number">19</span></span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.14</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">18</span></span><br><span class="line">        local binding:  label: <span class="number">21</span></span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: <span class="number">17</span></span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">10</span></span><br><span class="line">        local binding:  label: <span class="number">17</span></span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: <span class="number">20</span></span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">14</span></span><br><span class="line">        local binding:  label: <span class="number">19</span></span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: <span class="number">19</span></span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line"></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config)</span><span class="meta">#do show mpls ip binding</span></span><br><span class="line">    1.1.1.1/32 </span><br><span class="line">        in label:     imp-null  </span><br><span class="line">        out label:    16        lsr: 2.2.2.2:0       </span><br><span class="line">        out label:    16        lsr: 4.4.4.4:0       </span><br><span class="line">    2.2.2.2/32 </span><br><span class="line">        in label:     16        </span><br><span class="line">        out label:    imp-null  lsr: 2.2.2.2:0        inuse</span><br><span class="line">        out label:    17        lsr: 4.4.4.4:0       </span><br><span class="line">    3.3.3.3/32 </span><br><span class="line">        in label:     18        </span><br><span class="line">        out label:    18        lsr: 2.2.2.2:0        inuse</span><br><span class="line">        out label:    18        lsr: 4.4.4.4:0       </span><br><span class="line">    4.4.4.4/32 </span><br><span class="line">        in label:     20        </span><br><span class="line">        out label:    20        lsr: 2.2.2.2:0        inuse</span><br><span class="line">        out label:    imp-null  lsr: 4.4.4.4:0       </span><br><span class="line">    192.168.12.0/24 </span><br><span class="line">        in label:     imp-null  </span><br><span class="line">        out label:    imp-null  lsr: 2.2.2.2:0       </span><br><span class="line">        out label:    19        lsr: 4.4.4.4:0       </span><br><span class="line">    192.168.14.0/24 </span><br><span class="line">        in label:     21        </span><br><span class="line">        out label:    17        lsr: 2.2.2.2:0        inuse</span><br><span class="line">        out label:    imp-null  lsr: 4.4.4.4:0       </span><br><span class="line">    192.168.23.0/24 </span><br><span class="line">        in label:     17        </span><br><span class="line">        out label:    imp-null  lsr: 2.2.2.2:0        inuse</span><br><span class="line">        out label:    20        lsr: 4.4.4.4:0       </span><br><span class="line">    192.168.34.0/24 </span><br><span class="line">        in label:     19        </span><br><span class="line">        out label:    19        lsr: 2.2.2.2:0        inuse</span><br><span class="line">        out label:    imp-null  lsr: 4.4.4.4:0  </span><br><span class="line"><span class="comment">//可以看到，即便R1与R4的直连链路已经断开，但是R1的LIB表中仍然保留着通告自R4的标签绑定信息；</span></span><br></pre></td></tr></table></figure>
<p>验证：查看R4的MPLS LDP邻居列表中邻居R1的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#do sh mpls ldp nei 1.1.1.1 detail</span></span><br><span class="line">    Peer LDP Ident: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>; Local LDP Ident <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span> - <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span><span class="number">.40199</span></span><br><span class="line">        Password: not required, none, in use</span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">117</span>/<span class="number">121</span>; Downstream; Last TIB rev sent <span class="number">16</span></span><br><span class="line">        Up time: <span class="number">01</span>:<span class="number">33</span>:<span class="number">22</span>; UID: <span class="number">2</span>; Peer Id <span class="number">1</span>;</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">            Targeted Hello <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> -&gt; <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>, active, passive;</span><br><span class="line">            holdtime: infinite, hello interval: <span class="number">10000</span> ms</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">            <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span>    <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>         </span><br><span class="line">        Peer holdtime: <span class="number">180000</span> ms; KA interval: <span class="number">60000</span> ms; Peer state: estab</span><br><span class="line">        Clients: Dir Adj Client</span><br><span class="line">        LDP Session Protection enabled, state: Protecting <span class="comment">//LDP会话保护正在进行中，状态为Protecting；</span></span><br><span class="line">            acl: PROTECT_R1, duration: infinite</span><br><span class="line">        Capabilities Sent:</span><br><span class="line">            [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">        Capabilities Received:</span><br><span class="line">            [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br></pre></td></tr></table></figure>

<p>查看R4到LIB表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#do show mpls ldp bindings</span></span><br><span class="line">    lib entry: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>, rev <span class="number">2</span></span><br><span class="line">        local binding:  label: <span class="number">16</span></span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">17</span></span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">    lib entry: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>, rev <span class="number">4</span></span><br><span class="line">        local binding:  label: <span class="number">17</span></span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">16</span></span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">16</span></span><br><span class="line">    lib entry: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>, rev <span class="number">6</span></span><br><span class="line">        local binding:  label: <span class="number">18</span></span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">18</span></span><br><span class="line">    lib entry: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>, rev <span class="number">8</span></span><br><span class="line">        local binding:  label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">20</span></span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">20</span></span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">10</span></span><br><span class="line">        local binding:  label: <span class="number">19</span></span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">19</span></span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.14</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">12</span></span><br><span class="line">        local binding:  label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">18</span></span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">21</span></span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">14</span></span><br><span class="line">        local binding:  label: <span class="number">20</span></span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">17</span></span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">16</span></span><br><span class="line">        local binding:  label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">19</span></span><br><span class="line"></span><br><span class="line">R4(config)<span class="meta">#do show mpls ip binding</span></span><br><span class="line">    <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span> </span><br><span class="line">        in label:     <span class="number">16</span>        </span><br><span class="line">        out label:    <span class="number">17</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">        out label:    imp-null  lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span> </span><br><span class="line">        in label:     <span class="number">17</span>        </span><br><span class="line">        out label:    <span class="number">16</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">        out label:    <span class="number">16</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span> </span><br><span class="line">        in label:     <span class="number">18</span>        </span><br><span class="line">        out label:    imp-null  lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">        out label:    <span class="number">18</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span> </span><br><span class="line">        in label:     imp-null  </span><br><span class="line">        out label:    <span class="number">20</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>       </span><br><span class="line">        out label:    <span class="number">20</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">        in label:     <span class="number">19</span>        </span><br><span class="line">        out label:    <span class="number">19</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">        out label:    imp-null  lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">192.168</span><span class="number">.14</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">        in label:     imp-null  </span><br><span class="line">        out label:    <span class="number">18</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>       </span><br><span class="line">        out label:    <span class="number">21</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">        in label:     <span class="number">20</span>        </span><br><span class="line">        out label:    imp-null  lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">        out label:    <span class="number">17</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">        in label:     imp-null  </span><br><span class="line">        out label:    imp-null  lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>       </span><br><span class="line">        out label:    <span class="number">19</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span> </span><br><span class="line"><span class="comment">//可以看到，即便R1与R4的直连链路已经断开，但是R4的LIB表中仍然保留着通告自R1的标签绑定信息；</span></span><br></pre></td></tr></table></figure>

<p>调试：恢复R1和R4之间的链路连接；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#int f0/1</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#no shut</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)#</span><br><span class="line">*Mar <span class="number">15</span> <span class="number">11</span>:<span class="number">44</span>:<span class="number">21.407</span>: %LDP<span class="number">-5</span>-SP: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>: session recovery succeeded <span class="comment">//R1与R4的会话恢复成功；</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)#</span><br><span class="line">*Mar <span class="number">15</span> <span class="number">11</span>:<span class="number">44</span>:<span class="number">23.279</span>: %LINK<span class="number">-3</span>-UPDOWN: Interface FastEthernet0/<span class="number">1</span>, changed state to up</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-<span class="keyword">if</span>)</span>#</span><br><span class="line">*Mar 15 11:44:24.279: %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/1, changed state to up</span><br></pre></td></tr></table></figure>
<h2 id="实验2：两台LSR中只有一台支持LDP会话保护特性"><a href="#实验2：两台LSR中只有一台支持LDP会话保护特性" class="headerlink" title="实验2：两台LSR中只有一台支持LDP会话保护特性"></a>实验2：两台LSR中只有一台支持LDP会话保护特性</h2><p>要让 LDP 会话保护特性正常工作，你需要在两端的 LSR 上都启用该特性。如果其中一台 LSR 无法实现该特性的话，可以在另一台LSR上启用该特性，而无法启用 LDP 会话保护的 LSR 上需要通过配置命令 <code>mpls ldp discovery targeted-hello accept</code> 来接受基于目标的 LDP Discovery Hello报文。 </p>
<p>配置ACL指定接受其远程LDP会话LSR；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#ip access-list standard ACCEPT_R1_REMOTE</span></span><br><span class="line">R4(config-<span class="built_in">std</span>-nacl)<span class="meta">#permit host 1.1.1.1</span></span><br><span class="line">R4(config-<span class="built_in">std</span>-nacl)<span class="meta">#exit</span></span><br></pre></td></tr></table></figure>

<p>配置R4接受来自ACCEPT_R1_REMOTE的远程LDP会话；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#mpls ldp discovery targeted-hello accept from ACCEPT_R1_REMOTE    </span></span><br></pre></td></tr></table></figure>

<p>验证：查看R4的MPLS LDP邻居列表中邻居R1的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#do sh mpls ldp nei 1.1.1.1 detail                              </span></span><br><span class="line">    Peer LDP Ident: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>; Local LDP Ident <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span> - <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span><span class="number">.40199</span></span><br><span class="line">        Password: not required, none, in use</span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">141</span>/<span class="number">146</span>; Downstream; Last TIB rev sent <span class="number">16</span></span><br><span class="line">        Up time: <span class="number">01</span>:<span class="number">52</span>:<span class="number">47</span>; UID: <span class="number">2</span>; Peer Id <span class="number">1</span>;</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">            FastEthernet0/<span class="number">1</span>; Src IP addr: <span class="number">192.168</span><span class="number">.14</span><span class="number">.1</span> </span><br><span class="line">            holdtime: <span class="number">15000</span> ms, hello interval: <span class="number">5000</span> ms</span><br><span class="line">            Targeted Hello <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> -&gt; <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>, passive; <span class="comment">//R4被动接受来自R1的远程LDP会话；关键字passive表示R4是被动方，被动接受与R1的远程LDP会话关系：</span></span><br><span class="line">            holdtime: <span class="number">90000</span> ms, hello interval: <span class="number">10000</span> ms</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">            <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span>    <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>         <span class="number">192.168</span><span class="number">.14</span><span class="number">.1</span>    </span><br><span class="line">        Peer holdtime: <span class="number">180000</span> ms; KA interval: <span class="number">60000</span> ms; Peer state: estab</span><br><span class="line">        Capabilities Sent:</span><br><span class="line">            [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">        Capabilities Received:</span><br><span class="line">            [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br></pre></td></tr></table></figure>

<p>验证：查看R1的MPLS LDP邻居列表中邻居R4的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#do show mpls ldp neighbor 4.4.4.4 detail</span></span><br><span class="line">    Peer LDP Ident: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>; Local LDP Ident <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span><span class="number">.40199</span> - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span></span><br><span class="line">        Password: not required, none, in use</span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">146</span>/<span class="number">140</span>; Downstream; Last TIB rev sent <span class="number">20</span></span><br><span class="line">        Up time: <span class="number">01</span>:<span class="number">52</span>:<span class="number">35</span>; UID: <span class="number">2</span>; Peer Id <span class="number">1</span>;</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">            FastEthernet0/<span class="number">1</span>; Src IP addr: <span class="number">192.168</span><span class="number">.14</span><span class="number">.4</span> </span><br><span class="line">            holdtime: <span class="number">15000</span> ms, hello interval: <span class="number">5000</span> ms</span><br><span class="line">            Targeted Hello <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> -&gt; <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>, active, passive; <span class="comment">//R1与R4已建立远程LDP会话；关键字active和passive表示R1是远程会话的主动发起方和被动接受方；</span></span><br><span class="line">            holdtime: infinite, hello interval: <span class="number">10000</span> ms</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">            <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>         <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span>    <span class="number">192.168</span><span class="number">.14</span><span class="number">.4</span>    </span><br><span class="line">        Peer holdtime: <span class="number">180000</span> ms; KA interval: <span class="number">60000</span> ms; Peer state: estab</span><br><span class="line">        Clients: Dir Adj Client</span><br><span class="line">        LDP Session Protection enabled, state: Ready <span class="comment">//R1上针对邻居R4的LDP会话保护已经启用；并且状态为Ready，表示已经做了会话保护准备；</span></span><br><span class="line">            acl: PROTECT_R4, duration: infinite</span><br><span class="line">        Capabilities Sent:</span><br><span class="line">            [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">        Capabilities Received:</span><br><span class="line">            [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line"><span class="comment">//可以看到，即使R4没有启用LDP会话保护特性，但只要R4接受来自R1基于目标的远程LDP会话报文，R1的LDP会话保护特性就可以正常运作；</span></span><br></pre></td></tr></table></figure>

<p>调试：断开R1与R4之间的链路连接；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在R1上，将连接到R4的F0/1口shutdown；</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#int f0/1</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#shutdown</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)#</span><br><span class="line">*Mar <span class="number">15</span> <span class="number">12</span>:<span class="number">10</span>:<span class="number">34.939</span>: %LDP<span class="number">-5</span>-SP: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>: session hold up initiated <span class="comment">//R1上针对R4的LDP会话保护机制开始初始化；</span></span><br><span class="line">*Mar <span class="number">15</span> <span class="number">12</span>:<span class="number">10</span>:<span class="number">34.951</span>: %OSPF<span class="number">-5</span>-ADJCHG: Process <span class="number">1</span>, Nbr <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> on FastEthernet0/<span class="number">1</span> from FULL to DOWN, Neighbor Down: Interface down or detached</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-<span class="keyword">if</span>)</span>#</span><br><span class="line">*Mar 15 12:10:36.899: %LINK-5-CHANGED: Interface FastEthernet0/1, changed state to administratively down</span><br><span class="line">*Mar 15 12:10:37.899: %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/1, changed state to down</span><br></pre></td></tr></table></figure>

<p>验证：查看R1的MPLS LDP邻居列表中邻居R4的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#do sh mpls ldp nei 4.4.4.4 detail  </span></span><br><span class="line">    Peer LDP Ident: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>; Local LDP Ident <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span><span class="number">.40199</span> - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span></span><br><span class="line">        Password: not required, none, in use</span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">175</span>/<span class="number">168</span>; Downstream; Last TIB rev sent <span class="number">22</span></span><br><span class="line">        Up time: <span class="number">02</span>:<span class="number">15</span>:<span class="number">35</span>; UID: <span class="number">2</span>; Peer Id <span class="number">1</span>;</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">            Targeted Hello <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> -&gt; <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>, active, passive;</span><br><span class="line">            holdtime: infinite, hello interval: <span class="number">10000</span> ms</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">            <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>         <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span>    <span class="number">192.168</span><span class="number">.14</span><span class="number">.4</span>    </span><br><span class="line">        Peer holdtime: <span class="number">180000</span> ms; KA interval: <span class="number">60000</span> ms; Peer state: estab</span><br><span class="line">        Clients: Dir Adj Client</span><br><span class="line">        LDP Session Protection enabled, state: Protecting <span class="comment">//R1针对邻居R4的LDP会话保护状态变为Protecting；</span></span><br><span class="line">            acl: PROTECT_R4, duration: infinite</span><br><span class="line">        Capabilities Sent:</span><br><span class="line">            [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">        Capabilities Received:</span><br><span class="line">            [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br></pre></td></tr></table></figure>

<p>查看R1的LIB表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#do sh mpls ldp bindings</span></span><br><span class="line">    lib entry: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>, rev <span class="number">2</span></span><br><span class="line">        local binding:  label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: <span class="number">16</span></span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: <span class="number">16</span></span><br><span class="line">    lib entry: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>, rev <span class="number">8</span></span><br><span class="line">        local binding:  label: <span class="number">16</span></span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: <span class="number">17</span></span><br><span class="line">    lib entry: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>, rev <span class="number">13</span></span><br><span class="line">        local binding:  label: <span class="number">18</span></span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: <span class="number">18</span></span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: <span class="number">18</span></span><br><span class="line">    lib entry: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>, rev <span class="number">16</span></span><br><span class="line">        local binding:  label: <span class="number">20</span></span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: <span class="number">20</span></span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">4</span></span><br><span class="line">        local binding:  label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: <span class="number">19</span></span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.14</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">22</span></span><br><span class="line">        local binding:  label: <span class="number">21</span></span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: <span class="number">17</span></span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">10</span></span><br><span class="line">        local binding:  label: <span class="number">17</span></span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: <span class="number">20</span></span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">14</span></span><br><span class="line">        local binding:  label: <span class="number">19</span></span><br><span class="line">        remote binding: lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>, label: <span class="number">19</span></span><br><span class="line">        remote binding: lsr: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line"></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-<span class="keyword">if</span>)</span><span class="meta">#do sh mpls ip binding</span></span><br><span class="line">    1.1.1.1/32 </span><br><span class="line">        in label:     imp-null  </span><br><span class="line">        out label:    16        lsr: 2.2.2.2:0       </span><br><span class="line">        out label:    16        lsr: 4.4.4.4:0       </span><br><span class="line">    2.2.2.2/32 </span><br><span class="line">        in label:     16        </span><br><span class="line">        out label:    imp-null  lsr: 2.2.2.2:0        inuse</span><br><span class="line">        out label:    17        lsr: 4.4.4.4:0       </span><br><span class="line">    3.3.3.3/32 </span><br><span class="line">        in label:     18        </span><br><span class="line">        out label:    18        lsr: 2.2.2.2:0        inuse</span><br><span class="line">        out label:    18        lsr: 4.4.4.4:0       </span><br><span class="line">    4.4.4.4/32 </span><br><span class="line">        in label:     20        </span><br><span class="line">        out label:    20        lsr: 2.2.2.2:0        inuse</span><br><span class="line">        out label:    imp-null  lsr: 4.4.4.4:0       </span><br><span class="line">    192.168.12.0/24 </span><br><span class="line">        in label:     imp-null  </span><br><span class="line">        out label:    imp-null  lsr: 2.2.2.2:0       </span><br><span class="line">        out label:    19        lsr: 4.4.4.4:0       </span><br><span class="line">    192.168.14.0/24 </span><br><span class="line">        in label:     21        </span><br><span class="line">        out label:    17        lsr: 2.2.2.2:0        inuse</span><br><span class="line">        out label:    imp-null  lsr: 4.4.4.4:0       </span><br><span class="line">    192.168.23.0/24 </span><br><span class="line">        in label:     17        </span><br><span class="line">        out label:    imp-null  lsr: 2.2.2.2:0        inuse</span><br><span class="line">        out label:    20        lsr: 4.4.4.4:0       </span><br><span class="line">    192.168.34.0/24 </span><br><span class="line">        in label:     19        </span><br><span class="line">        out label:    19        lsr: 2.2.2.2:0        inuse</span><br><span class="line">        out label:    imp-null  lsr: 4.4.4.4:0   </span><br><span class="line"><span class="comment">//注意到，由于LDP会话保护机制，R1的LIB表中仍然保留着R4通告来的标签；</span></span><br></pre></td></tr></table></figure>

<p>验证：查看R4的MPLS LDP邻居列表中邻居R1的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#do show mpls ldp nei 1.1.1.1 detail</span></span><br><span class="line">    Peer LDP Ident: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>; Local LDP Ident <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span> - <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span><span class="number">.40199</span></span><br><span class="line">        Password: not required, none, in use</span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">201</span>/<span class="number">208</span>; Downstream; Last TIB rev sent <span class="number">16</span></span><br><span class="line">        Up time: <span class="number">02</span>:<span class="number">45</span>:<span class="number">13</span>; UID: <span class="number">2</span>; Peer Id <span class="number">1</span>;</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">            Targeted Hello <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> -&gt; <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>, passive;</span><br><span class="line">            holdtime: <span class="number">90000</span> ms, hello interval: <span class="number">10000</span> ms</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">            <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span>    <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>         </span><br><span class="line">        Peer holdtime: <span class="number">180000</span> ms; KA interval: <span class="number">60000</span> ms; Peer state: estab</span><br><span class="line">        Capabilities Sent:</span><br><span class="line">            [ICCP (type <span class="number">0x0405</span>) MajVer <span class="number">1</span> MinVer <span class="number">0</span>]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line">        Capabilities Received:</span><br><span class="line">            [<span class="title function_">ICCP</span> <span class="params">(type <span class="number">0x0405</span>)</span> MajVer 1 MinVer 0]</span><br><span class="line">            [Dynamic <span class="title function_">Announcement</span> <span class="params">(<span class="number">0x0506</span>)</span>]</span><br><span class="line">            [Typed <span class="title function_">Wildcard</span> <span class="params">(<span class="number">0x050B</span>)</span>]</span><br><span class="line"><span class="comment">//虽然R4没有启用LDP会话保护，但是R4仍然和R1保持着基于目标的LDP远程会话；</span></span><br></pre></td></tr></table></figure>

<p>查看R4的LIB表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#do show mpls ldp bindings</span></span><br><span class="line">    lib entry: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>, rev <span class="number">2</span></span><br><span class="line">        local binding:  label: <span class="number">16</span></span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">17</span></span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">    lib entry: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>, rev <span class="number">4</span></span><br><span class="line">        local binding:  label: <span class="number">17</span></span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">16</span></span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">16</span></span><br><span class="line">    lib entry: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>, rev <span class="number">6</span></span><br><span class="line">        local binding:  label: <span class="number">18</span></span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">18</span></span><br><span class="line">    lib entry: <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>, rev <span class="number">8</span></span><br><span class="line">        local binding:  label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">20</span></span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">20</span></span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">10</span></span><br><span class="line">        local binding:  label: <span class="number">19</span></span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">19</span></span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.14</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">12</span></span><br><span class="line">        local binding:  label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: <span class="number">18</span></span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">21</span></span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">14</span></span><br><span class="line">        local binding:  label: <span class="number">20</span></span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">17</span></span><br><span class="line">    lib entry: <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span>, rev <span class="number">16</span></span><br><span class="line">        local binding:  label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>, label: imp-null</span><br><span class="line">        remote binding: lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>, label: <span class="number">19</span></span><br><span class="line"></span><br><span class="line">R4(config)<span class="meta">#do show mpls ip binding</span></span><br><span class="line">    <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span> </span><br><span class="line">        in label:     <span class="number">16</span>        </span><br><span class="line">        out label:    <span class="number">17</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">        out label:    imp-null  lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span> </span><br><span class="line">        in label:     <span class="number">17</span>        </span><br><span class="line">        out label:    <span class="number">16</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">        out label:    <span class="number">16</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span> </span><br><span class="line">        in label:     <span class="number">18</span>        </span><br><span class="line">        out label:    imp-null  lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">        out label:    <span class="number">18</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span> </span><br><span class="line">        in label:     imp-null  </span><br><span class="line">        out label:    <span class="number">20</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>       </span><br><span class="line">        out label:    <span class="number">20</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">        in label:     <span class="number">19</span>        </span><br><span class="line">        out label:    <span class="number">19</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">        out label:    imp-null  lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">192.168</span><span class="number">.14</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">        in label:     imp-null  </span><br><span class="line">        out label:    <span class="number">18</span>        lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>       </span><br><span class="line">        out label:    <span class="number">21</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">        in label:     <span class="number">20</span>        </span><br><span class="line">        out label:    imp-null  lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>        inuse</span><br><span class="line">        out label:    <span class="number">17</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">        in label:     imp-null  </span><br><span class="line">        out label:    imp-null  lsr: <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>:<span class="number">0</span>       </span><br><span class="line">        out label:    <span class="number">19</span>        lsr: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span>      </span><br><span class="line"><span class="comment">//注意到，虽然R4没有启用LDP会话保护机制，但是R4的LIB表中同样保留着R1通告来的标签；</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>MPLS</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLS 实验3：MPLS LDP-IGP同步</title>
    <url>/2014/MPLS_Lab_3/</url>
    <content><![CDATA[<h1 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h1><ul>
<li>模拟器：GNS3 0.8.6</li>
<li>Cisco IOS：c7200-adventerprisek9-mz.151-4.M2.image</li>
</ul>
<h1 id="GNS3实验拓扑文件："><a href="#GNS3实验拓扑文件：" class="headerlink" title="GNS3实验拓扑文件："></a>GNS3实验拓扑文件：</h1><p><a href="topology.net">拓扑文件</a></p>
<h1 id="实验拓扑："><a href="#实验拓扑：" class="headerlink" title="实验拓扑："></a>实验拓扑：</h1><p><img src="/2014/MPLS_Lab_3/topo.png"></p>
<span id="more"></span>

<h1 id="基本预配置："><a href="#基本预配置：" class="headerlink" title="基本预配置："></a>基本预配置：</h1><h2 id="R1："><a href="#R1：" class="headerlink" title="R1："></a>R1：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 1.1.1.1 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.12.1 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">    mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.21.1 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 1.1.1.1</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 2.2.2.2 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.12.2 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.21.2 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 2.2.2.2</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<h1 id="实验与调试："><a href="#实验与调试：" class="headerlink" title="实验与调试："></a>实验与调试：</h1><h2 id="实验1：R1和R2之间仅有唯一一条链路时的LDP-IGP同步"><a href="#实验1：R1和R2之间仅有唯一一条链路时的LDP-IGP同步" class="headerlink" title="实验1：R1和R2之间仅有唯一一条链路时的LDP-IGP同步"></a>实验1：R1和R2之间仅有唯一一条链路时的LDP-IGP同步</h2><p>将R1和R2之间的由F0&#x2F;1相连的链路禁用，只留下F0&#x2F;0的链路；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#int f0/1</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#shutdown</span></span><br><span class="line"></span><br><span class="line">R2(config)<span class="meta">#int f0/1</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#shutdown</span></span><br></pre></td></tr></table></figure>

<p>查看R1的LDP邻居表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#do show mpls ldp nei</span></span><br><span class="line">    Peer LDP Ident: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>; Local LDP Ident <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span><span class="number">.52561</span> - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span></span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">7</span>/<span class="number">7</span>; Downstream</span><br><span class="line">        Up time: <span class="number">00</span>:<span class="number">00</span>:<span class="number">11</span></span><br><span class="line">        LDP discovery sources:</span><br><span class="line">            FastEthernet0/<span class="number">0</span>, Src IP addr: <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span></span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">            <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>         <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span></span><br><span class="line"><span class="comment">//可以看到，此时R1只有一个LDP邻居，即R2，并且他们之间只有一条链路，因为R1只在F0/0发现了LDP邻居；</span></span><br></pre></td></tr></table></figure>

<p>在R1和R2上启用LDP-IGP同步功能；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router ospf 1</span></span><br><span class="line">R1(config-router)<span class="meta">#mpls ldp sync</span></span><br><span class="line"></span><br><span class="line">R2(config)<span class="meta">#router ospf 1</span></span><br><span class="line">R2(config-router)<span class="meta">#mpls ldp sync</span></span><br></pre></td></tr></table></figure>

<p>查看R1上F0&#x2F;0的LDP和OSPF同步信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do show ip ospf mpls ldp interface f0/0</span></span><br><span class="line">FastEthernet0/<span class="number">0</span></span><br><span class="line">    Process ID <span class="number">1</span>, Area <span class="number">0</span></span><br><span class="line">    LDP is not configured through LDP autoconfig</span><br><span class="line">    LDP-IGP Synchronization : Required <span class="comment">//接口f0/0的LDP-IGP同步状态为Required，说明LDP-IGP已经开启；</span></span><br><span class="line">    Holddown timer is not configured <span class="comment">//LDP-IGP保持计时器没有配置；</span></span><br><span class="line">    Interface is up <span class="comment">//接口为UP状态；</span></span><br></pre></td></tr></table></figure>
<h2 id="调试1："><a href="#调试1：" class="headerlink" title="调试1："></a>调试1：</h2><p>清楚MPLS LDP的邻接关系；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do clear mpls ldp neighbor *</span></span><br><span class="line"><span class="comment">//注意：这两条命令切换要快，否则看不到现象；</span></span><br><span class="line">R1(config)<span class="meta">#do show ip ospf mpls ldp interface f0/0</span></span><br><span class="line">FastEthernet0/<span class="number">0</span></span><br><span class="line">    Process ID <span class="number">1</span>, Area <span class="number">0</span></span><br><span class="line">    LDP is not configured through LDP autoconfig</span><br><span class="line">    LDP-IGP Synchronization : Required</span><br><span class="line">    Holddown timer is not configured</span><br><span class="line">    Interface is up and sending maximum metric <span class="comment">//接口已经UP，但由于LDP邻居被重置，所以OSPF将度量值用最大值来发送给邻居；</span></span><br><span class="line">R1(config)#</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">09</span>:<span class="number">33</span>:<span class="number">16.371</span>: %LDP<span class="number">-5</span>-CLEAR_NBRS: Clear LDP <span class="title function_">neighbors</span> <span class="params">(*)</span> by console</span><br><span class="line">*Mar 16 09:33:16.387: %LDP-5-NBRCHG: LDP Neighbor 2.2.2.2:0 <span class="params">(<span class="number">1</span>)</span> is <span class="title function_">DOWN</span> <span class="params">(User cleared session manually)</span></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 16 09:33:20.507: %LDP-5-NBRCHG: LDP Neighbor 2.2.2.2:0 <span class="params">(<span class="number">1</span>)</span> is UP</span><br><span class="line"><span class="comment">//LDP邻居又再度建立；</span></span><br></pre></td></tr></table></figure>

<p>调试MPLS LDP-IGP同步过程；</p>
<p>配置ACL 100以捕获R1发往R2的OSPF LSA；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)#R1(config)<span class="meta">#access-list 100 permit ospf host 1.1.1.1 any</span></span><br></pre></td></tr></table></figure>
<p><strong>同时，开启抓包工具Wireshark，捕获F0&#x2F;0上的OSPF数据包；</strong></p>
<p>调试<code>debug mpls ldp igp sync</code> 和 <code>debug ip ospf lsa-generation 100</code>；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#debug ip ospf lsa-generation 100</span></span><br><span class="line">OSPF LSA generation debugging is on <span class="keyword">for</span> access <span class="built_in">list</span> <span class="number">100</span></span><br><span class="line">R1<span class="meta">#debug mpls ldp igp sync</span></span><br><span class="line">LDP-IGP Synchronization debugging is on</span><br><span class="line">R1<span class="meta">#clear mpls ldp neighbor *</span></span><br><span class="line"></span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">10</span>:<span class="number">51</span>:<span class="number">55.823</span>: %LDP<span class="number">-5</span>-CLEAR_NBRS: Clear LDP <span class="title function_">neighbors</span> <span class="params">(*)</span> by console</span><br><span class="line">*Mar 16 10:51:55.831: LDP-SYNC: Fa0/0, OSPF 1: notify <span class="title function_">status</span> <span class="params">(required, not achieved, delay, holddown infinite)</span> internal <span class="title function_">status</span> <span class="params">(not achieved, timer not running)</span></span><br><span class="line"><span class="comment">//LDP-IGP未同步；</span></span><br><span class="line">*Mar 16 10:51:55.835: OSPF-1 LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area 0</span><br><span class="line">*Mar 16 10:51:55.835: LDP-SYNC: Fa0/0, 2.2.2.2: Adj being deleted, sync_achieved goes down</span><br><span class="line"><span class="comment">//LDP邻接关系被删除，同步完成状态变为down；</span></span><br><span class="line">*Mar 16 10:51:55.843: %LDP-5-NBRCHG: LDP Neighbor 2.2.2.2:0 <span class="params">(<span class="number">1</span>)</span> is <span class="title function_">DOWN</span> <span class="params">(User cleared session manually)</span></span><br><span class="line"><span class="comment">//LDP邻居关系Down；用户手动清除了会话；</span></span><br><span class="line">*Mar 16 10:51:56.335: OSPF-1 LSGEN: Build router LSA <span class="keyword">for</span> area 0, router ID 1.1.1.1, seq 0x80000059</span><br></pre></td></tr></table></figure>

<p><strong>在调试输出过程中飞快按下此命令，得到LDP-IGP同步过程中的OSPF Database中的一类LSA信息；</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#sh ip ospf database router</span></span><br><span class="line"></span><br><span class="line">            OSPF Router with <span class="title function_">ID</span> <span class="params">(<span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>)</span> <span class="params">(Process ID <span class="number">1</span>)</span></span><br><span class="line"></span><br><span class="line">                Router Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line">    LS age: 2</span><br><span class="line">    Options: <span class="params">(No TOS-capability, DC)</span></span><br><span class="line">    LS Type: Router Links</span><br><span class="line">    Link State ID: 1.1.1.1</span><br><span class="line">    Advertising Router: 1.1.1.1</span><br><span class="line">    LS Seq Number: 80000059</span><br><span class="line">    Checksum: 0x814F</span><br><span class="line">    Length: 48</span><br><span class="line">    Number of Links: 2</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Network/subnet number: 1.1.1.1</span><br><span class="line">        <span class="params">(Link Data)</span> Network Mask: 255.255.255.255</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 1</span><br><span class="line"></span><br><span class="line">    Link connected to: a Transit <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Designated Router address: 192.168.12.2</span><br><span class="line">        <span class="params">(Link Data)</span> Router Interface address: 192.168.12.1</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 65535 <span class="comment">//注意LDP-IGP同步过程中，度量值变为了最大值65535；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LS age: 3</span><br><span class="line">    Options: <span class="params">(No TOS-capability, DC)</span></span><br><span class="line">    LS Type: Router Links</span><br><span class="line">    Link State ID: 2.2.2.2</span><br><span class="line">    Advertising Router: 2.2.2.2</span><br><span class="line">    LS Seq Number: 8000004C</span><br><span class="line">    Checksum: 0x8B45</span><br><span class="line">    Length: 48</span><br><span class="line">    Number of Links: 2</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Network/subnet number: 2.2.2.2</span><br><span class="line">        <span class="params">(Link Data)</span> Network Mask: 255.255.255.255</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 1</span><br><span class="line"></span><br><span class="line">    Link connected to: a Transit <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Designated Router address: 192.168.12.2</span><br><span class="line">        <span class="params">(Link Data)</span> Router Interface address: 192.168.12.2</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 65535<span class="comment">//注意LDP-IGP同步过程中，度量值变为了最大值65535；</span></span><br><span class="line">        </span><br><span class="line">R1#</span><br><span class="line">*Mar 16 10:51:59.543: LDP-SYNC: Fa0/0: No session or session has not send initial update, ignore adj joining event.</span><br><span class="line">*Mar 16 10:51:59.547: %LDP-5-NBRCHG: LDP Neighbor 2.2.2.2:0 <span class="params">(<span class="number">2</span>)</span> is UP</span><br><span class="line">R1#</span><br><span class="line">*Mar 16 10:51:59.551: LDP-SYNC: Fa0/0: session 2.2.2.2:0 came up, sync_achieved up</span><br><span class="line"><span class="comment">//LDP-IGP同步状态UP；</span></span><br><span class="line">*Mar 16 10:51:59.555: LDP-SYNC: Fa0/0, OSPF 1: notify <span class="title function_">status</span> <span class="params">(required, achieved, no delay, holddown infinite)</span> internal <span class="title function_">status</span> <span class="params">(achieved, timer not running)</span></span><br><span class="line"><span class="comment">//LDP-IGP同步完成；</span></span><br><span class="line">*Mar 16 10:51:59.555: OSPF-1 LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area 0</span><br><span class="line">*Mar 16 10:52:00.055: OSPF-1 LSGEN: Rate limit LSA generation <span class="keyword">for</span> 1.1.1.1 1.1.1.1 1</span><br><span class="line">R1#</span><br><span class="line">*Mar 16 10:52:01.335: OSPF-1 LSGEN: Build router LSA <span class="keyword">for</span> area 0, router ID 1.1.1.1, seq 0x8000005A</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#sh ip ospf database router</span></span><br><span class="line"></span><br><span class="line">            OSPF Router with <span class="title function_">ID</span> <span class="params">(<span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>)</span> <span class="params">(Process ID <span class="number">1</span>)</span></span><br><span class="line"></span><br><span class="line">                Router Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line">    LS age: 649</span><br><span class="line">    Options: <span class="params">(No TOS-capability, DC)</span></span><br><span class="line">    LS Type: Router Links</span><br><span class="line">    Link State ID: 1.1.1.1</span><br><span class="line">    Advertising Router: 1.1.1.1</span><br><span class="line">    LS Seq Number: 8000005A</span><br><span class="line">    Checksum: 0x9D31</span><br><span class="line">    Length: 48</span><br><span class="line">    Number of Links: 2</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Network/subnet number: 1.1.1.1</span><br><span class="line">        <span class="params">(Link Data)</span> Network Mask: 255.255.255.255</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 1</span><br><span class="line"></span><br><span class="line">    Link connected to: a Transit <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Designated Router address: 192.168.12.2</span><br><span class="line">        <span class="params">(Link Data)</span> Router Interface address: 192.168.12.1</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 1<span class="comment">//注意LDP-IGP同步完成后，度量值恢复到正常的1；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LS age: 650</span><br><span class="line">    Options: <span class="params">(No TOS-capability, DC)</span></span><br><span class="line">    LS Type: Router Links</span><br><span class="line">    Link State ID: 2.2.2.2</span><br><span class="line">    Advertising Router: 2.2.2.2</span><br><span class="line">    LS Seq Number: 8000004D</span><br><span class="line">    Checksum: 0xA727</span><br><span class="line">    Length: 48</span><br><span class="line">    Number of Links: 2</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Network/subnet number: 2.2.2.2</span><br><span class="line">        <span class="params">(Link Data)</span> Network Mask: 255.255.255.255</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 1</span><br><span class="line"></span><br><span class="line">    Link connected to: a Transit <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Designated Router address: 192.168.12.2</span><br><span class="line">        <span class="params">(Link Data)</span> Router Interface address: 192.168.12.2</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 1</span><br><span class="line"><span class="comment">//注意到，在OSPF邻居已经建立的情况下，OSPF并没有如预期的那样，因为LDP邻居关系的中断破裂（Down），而导致OSPF邻接关系的终端破裂（Down）；</span></span><br></pre></td></tr></table></figure>
<p>查看Wireshark在LDP-IGP收敛过程中捕获的数据包；<br>可以看到，LSA中的Metric和OSPF Database中一致；<br><img src="/2014/MPLS_Lab_3/pic1.png"><br><img src="/2014/MPLS_Lab_3/pic2.png"></p>
<p>继续调试<code>clear ip ospf process</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#clear ip ospf process </span></span><br><span class="line">Reset ALL OSPF processes? [no]: yes</span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">09.559</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">09.559</span>: %OSPF<span class="number">-5</span>-ADJCHG: Process <span class="number">1</span>, Nbr <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> on FastEthernet0/<span class="number">0</span> from FULL to DOWN, Neighbor Down: Interface down or detached</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">09.563</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">09.563</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling network LSA on FastEthernet0/<span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">09.567</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">09.567</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">09.571</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">09.575</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">09.575</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">09.603</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">09.907</span>: %OSPF<span class="number">-5</span>-ADJCHG: Process <span class="number">1</span>, Nbr <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> on FastEthernet0/<span class="number">0</span> from LOADING to FULL, Loading Done</span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">09.911</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">10.059</span>: OSPF<span class="number">-1</span> LSGEN: Build router LSA <span class="keyword">for</span> area <span class="number">0</span>, router ID <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>, seq <span class="number">0x80000001</span></span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">14.591</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">14.707</span>: OSPF<span class="number">-1</span> LSMAX: Rcv Maxage LSA, Type <span class="number">1</span>, LSID <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>, Adv rtr <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>, age <span class="number">3600</span>, seq <span class="number">0x8000005A</span>, from <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">14.707</span>: OSPF<span class="number">-1</span> LSGEN: Update router LSA <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> <span class="number">1</span> <span class="number">8000005</span>A</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">14.711</span>: OSPF<span class="number">-1</span> LSGEN: Rate limit LSA generation <span class="keyword">for</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> <span class="number">1</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">15.059</span>: OSPF<span class="number">-1</span> LSGEN: Build router LSA <span class="keyword">for</span> area <span class="number">0</span>, router ID <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>, seq <span class="number">0x8000005B</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">15.067</span>: OSPF<span class="number">-1</span> LSMAX: Rcv Maxage LSA, Type <span class="number">1</span>, LSID <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>, Adv rtr <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>, age <span class="number">3600</span>, seq <span class="number">0x8000005A</span>, from <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">15.087</span>: OSPF<span class="number">-1</span> LSGEN: Rate limit LSA generation <span class="keyword">for</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> <span class="number">1</span></span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">20.059</span>: OSPF<span class="number">-1</span> LSGEN: No change in router LSA, area <span class="number">0</span></span><br><span class="line"><span class="comment">//注意到，由于OSPF收敛迅速，所以LDP没有受到影响，甚至没有出现任何LDP日志信息；</span></span><br></pre></td></tr></table></figure>
<h2 id="调试2："><a href="#调试2：" class="headerlink" title="调试2："></a>调试2：</h2><p>禁用R2上F0&#x2F;0的MPLS，让R1和R2的LDP邻居关系断开，确保LDP会话晚于OSPF邻接关系建立；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#int f0/0  </span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#no mpls ip</span></span><br></pre></td></tr></table></figure>

<p>在R1上查看OSPF邻接关系；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show ip ospf neighbor</span></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Address         Interface</span><br><span class="line"><span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>           <span class="number">1</span>   FULL/DR         <span class="number">00</span>:<span class="number">00</span>:<span class="number">36</span>    <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>    FastEthernet0/<span class="number">0</span></span><br><span class="line"><span class="comment">//注意：可以看到，正如调试1中验证的一样，在OSPF邻接关系已经建立的情况下，终止LDP的邻接关系并不会影响OSPF的邻接关系；</span></span><br></pre></td></tr></table></figure>

<p>此时，在经过将R2的F0&#x2F;0禁用MPLS之后，R1和R2的LDP邻居已经关系；<br>接下来，重置OSPF进程；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#debug ip ospf adj</span></span><br><span class="line">OSPF adjacency debugging is on</span><br><span class="line">R1<span class="meta">#clear ip ospf process</span></span><br><span class="line">Reset ALL OSPF processes? [no]: yes</span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.419</span>: OSPF<span class="number">-1</span> ADJ   Lo0: Interface going Down</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.419</span>: OSPF<span class="number">-1</span> ADJ   Lo0: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> address <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> is dead, state DOWN</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.423</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.423</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Interface going Down</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.423</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> address <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> is dead, state DOWN</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.427</span>: %OSPF<span class="number">-5</span>-ADJCHG: Process <span class="number">1</span>, Nbr <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> on FastEthernet0/<span class="number">0</span> from FULL to DOWN, Neighbor Down: Interface down or detached</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.427</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.431</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Neighbor change event</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.431</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: DR/BDR election</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.431</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Elect BDR <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.435</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Elect DR <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.435</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Elect BDR <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.435</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Elect DR <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.439</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: DR: <span class="number">1.1</span><span class="number">.1</span>.</span><br><span class="line">R1#<span class="number">1</span> (Id)   BDR: none </span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.439</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling network LSA on FastEthernet0/<span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.443</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Remember old DR <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> (id)</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.443</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.443</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> address <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span> is dead, state DOWN</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.447</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Neighbor change event</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.447</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: DR/BDR election</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.447</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Elect BDR <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.451</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Elect DR <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.451</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Elect BDR <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.451</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Elect DR <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.455</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: DR: none    BDR: none </span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.455</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Flush network LSA immediately</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.459</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Remember old DR <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> (id)</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.459</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.459</span>: OS</span><br><span class="line">R1#PF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.467</span>: OSPF<span class="number">-1</span> ADJ   Lo0: Interface going Up</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.467</span>: OSPF<span class="number">-1</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.467</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">1</span>: Not sending Hellos until LDP session comes up, FastEthernet0/<span class="number">1</span> remains down</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.471</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Not sending Hellos until LDP session comes up, FastEthernet0/<span class="number">0</span> remains down</span><br><span class="line"><span class="comment">//直到LDP会话建立，否则OSPF不发送Hello消息，F0/0口保持DOWN；</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.927</span>: OSPF<span class="number">-1</span> LSGEN: Build router LSA <span class="keyword">for</span> area <span class="number">0</span>, router ID <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>, seq <span class="number">0x80000001</span></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">16.943</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: We are not DR to build Net LSA</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">17.611</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Interface held DOWN waiting <span class="keyword">for</span> LDP<span class="comment">//为了等待LDP会话建立，OSPF保持接口为DOWN；</span></span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">18.923</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Rcv pkt  src <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> dst <span class="number">224.0</span><span class="number">.0</span><span class="number">.5</span> id <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> type <span class="number">5</span> if_state <span class="number">0</span> : ignored due to unknown neighbor</span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">27.611</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Interface held DOWN waiting <span class="keyword">for</span> LDP</span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">37.611</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Interface held DOWN waiting <span class="keyword">for</span> LDP</span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">16</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">47.611</span>: OSPF<span class="number">-1</span> ADJ   Fa0/<span class="number">0</span>: Interface held DOWN waiting <span class="keyword">for</span> LDP<span class="comment">//为了等待LDP会话建立，OSPF保持接口为DOWN；</span></span><br><span class="line"><span class="comment">//可以看到LDP-IGP同步机制开始运作了！</span></span><br><span class="line"><span class="comment">//注意：由于LDP会话关系建立在OSPF提供可达性的基础上，而OSPF邻接关系却要等待LDP会话首先建立，</span></span><br><span class="line"><span class="comment">//所以此时OSPF和LDP会互相等待对方完成邻居关系的建立，而导致死循环，最终无论是OSPF还是LDP都无法建立邻居关系；</span></span><br></pre></td></tr></table></figure>

<p>查看OSPF接口F0&#x2F;0的信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show ip ospf interface f0/0</span></span><br><span class="line">FastEthernet0/<span class="number">0</span> is up, line protocol is up </span><br><span class="line">    Internet Address <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span>/<span class="number">24</span>, Area <span class="number">0</span>, Attached via Interface Enable</span><br><span class="line">    Process ID <span class="number">1</span>, Router ID <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>, Network Type BROADCAST, Cost: <span class="number">1</span></span><br><span class="line">    Topology-MTID    Cost    Disabled    Shutdown      Topology Name</span><br><span class="line">        <span class="number">0</span>           <span class="number">1</span>         no          no            Base</span><br><span class="line">    Enabled by interface config, including secondary ip addresses</span><br><span class="line">    Transmit Delay is <span class="number">1</span> sec, State <span class="title function_">DOWN</span> <span class="params">(waiting <span class="keyword">for</span> LDP)</span>, Priority 1</span><br><span class="line">    No designated router on this network</span><br><span class="line">    No backup designated router on this network</span><br><span class="line">    Timer intervals configured, Hello 10, Dead 40, Wait 40, Retransmit 5</span><br><span class="line">    oob-resync timeout 40</span><br></pre></td></tr></table></figure>

<p>配置命令<code>mpls ldp igp sync holddown msecs</code>，以告知 IGP 只等待配置命令中所规定的时间，一旦保持计时器超时，不管 LDP 会话是否建立，OSPF 都会建立邻接关系；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#mpls ldp igp sync holddown ?</span></span><br><span class="line">    &lt;<span class="number">1</span><span class="number">-2147483647</span>&gt;  Hold down time in milliseconds</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config)</span><span class="meta">#mpls ldp igp sync holddown 5000</span></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 16 12:11:01.743: LDP-SYNC: Fa0/0, OSPF 1: notify <span class="title function_">status</span> <span class="params">(required, not achieved, delay, holddown <span class="number">5000</span>)</span> internal <span class="title function_">status</span> <span class="params">(not achieved, timer not running)</span></span><br><span class="line">*Mar 16 12:11:01.743: OSPF-1 ADJ   Fa0/0: Rcv <span class="type">int</span> status from LDP: 1 0 1 5000</span><br><span class="line">*Mar 16 12:11:01.747: LDP-SYNC: Fa0/1, OSPF 1: notify <span class="title function_">status</span> <span class="params">(required, not achieved, delay, holddown <span class="number">5000</span>)</span> internal <span class="title function_">status</span> <span class="params">(not achieved, timer not running)</span></span><br><span class="line">*Mar 16 12:11:01.747: OSPF-1 ADJ   Fa0/1: Rcv <span class="type">int</span> status from LDP: 1 0 1 5000</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 16 12:11:06.743: OSPF-1 ADJ   Fa0/0: Interface going Up</span><br><span class="line">*Mar 16 12:11:06.743: OSPF-1 LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area 0</span><br><span class="line">*Mar 16 12:11:06.747: OSPF-1 ADJ   Fa0/1: Interface is down</span><br><span class="line">*Mar 16 12:11:06.831: OSPF-1 ADJ   Fa0/0: 2 Way Communication to 2.2.2.2, state 2WAY</span><br><span class="line">*Mar 16 12:11:06.831: OSPF-1 ADJ   Fa0/0: Backup seen event before WAIT timer</span><br><span class="line">*Mar 16 12:11:06.831: OSPF-1 ADJ   Fa0/0: DR/BDR election</span><br><span class="line">*Mar 16 12:11:06.835: OSPF-1 ADJ   Fa0/0: Elect BDR 1.1.1.1</span><br><span class="line">*Mar 16 12:11:06.835: OSPF-1 ADJ   Fa0/0: Elect DR 2.2.2.2</span><br><span class="line">*Mar 16 12:11:06.839: OSPF-1 ADJ   Fa0/0: Elect BDR 1.1.1.1</span><br><span class="line">*Mar 16 12:11:06.839: OSPF-1 ADJ   Fa0/0: Elect DR 2.2.2.2</span><br><span class="line">*Mar 16 12:11:06.839: OSPF-1 ADJ   Fa0/0: DR: 2.2.2.2 <span class="params">(Id)</span>   BDR: 1.1.1.1 <span class="params">(Id)</span></span><br><span class="line">*Mar 16 12:11:06.843: OSPF-1 ADJ   Fa0/0: Nbr 2.2.2.2: Prepare dbase exchange</span><br><span class="line">*Mar 16 12:11:06.847: OSPF-1 ADJ   Fa0/0: Send DBD to 2.2.2.2 seq 0x2542 opt 0x52 flag 0x7 len 32</span><br><span class="line">*Mar 16 12:11:06.847: OSPF-1 LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area 0</span><br><span class="line">*Mar 16 12:11:06</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config)</span>#.891: OSPF-1 ADJ   Fa0/0: Rcv DBD from 2.2.2.2 seq 0x1A5A opt 0x52 flag 0x7 len 32  mtu 1500 state EXSTART</span><br><span class="line">*Mar 16 12:11:06.891: OSPF-1 ADJ   Fa0/0: NBR Negotiation Done. We are the SLAVE</span><br><span class="line">*Mar 16 12:11:06.895: OSPF-1 ADJ   Fa0/0: Nbr 2.2.2.2: Summary <span class="built_in">list</span> built, size 1</span><br><span class="line">*Mar 16 12:11:06.895: OSPF-1 ADJ   Fa0/0: Send DBD to 2.2.2.2 seq 0x1A5A opt 0x52 flag 0x2 len 52</span><br><span class="line">*Mar 16 12:11:06.963: OSPF-1 ADJ   Fa0/0: Rcv DBD from 2.2.2.2 seq 0x1A5B opt 0x52 flag 0x1 len 52  mtu 1500 state EXCHANGE</span><br><span class="line">*Mar 16 12:11:06.967: OSPF-1 ADJ   Fa0/0: Exchange Done with 2.2.2.2</span><br><span class="line">*Mar 16 12:11:06.967: OSPF-1 ADJ   Fa0/0: Send LS REQ to 2.2.2.2 length 12 LSA count 1</span><br><span class="line">*Mar 16 12:11:06.967: OSPF-1 ADJ   Fa0/0: Send DBD to 2.2.2.2 seq 0x1A5B opt 0x52 flag 0x0 len 32</span><br><span class="line">*Mar 16 12:11:07.039: OSPF-1 ADJ   Fa0/0: Rcv LS UPD from 2.2.2.2 length 76 LSA count 1</span><br><span class="line">*Mar 16 12:11:07.039: OSPF-1 ADJ   Fa0/0: Synchronized with 2.2.2.2, state FULL</span><br><span class="line">*Mar 16 12:11:07.043: %OSPF-5-ADJCHG: Process 1, Nbr 2.2.2.2 on FastEtherne</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config)</span>#t0/0 from LOADING to FULL, Loading Done</span><br><span class="line">*Mar 16 12:11:07.043: OSPF-1 LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area 0</span><br><span class="line">*Mar 16 12:11:07.047: OSPF-1 ADJ   Fa0/0: Rcv LS REQ from 2.2.2.2 length 36 LSA count 1</span><br><span class="line">*Mar 16 12:11:07.243: OSPF-1 LSGEN: Build router LSA <span class="keyword">for</span> area 0, router ID 1.1.1.1, seq 0x80000002 <span class="comment">//注意此LSA的序列号；</span></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 16 12:11:09.979: OSPF-1 ADJ   Fa0/0: Neighbor change event</span><br><span class="line">*Mar 16 12:11:09.983: OSPF-1 ADJ   Fa0/0: DR/BDR election</span><br><span class="line">*Mar 16 12:11:09.983: OSPF-1 ADJ   Fa0/0: Elect BDR 1.1.1.1</span><br><span class="line">*Mar 16 12:11:09.987: OSPF-1 ADJ   Fa0/0: Elect DR 2.2.2.2</span><br><span class="line">*Mar 16 12:11:09.987: OSPF-1 ADJ   Fa0/0: DR: 2.2.2.2 <span class="params">(Id)</span>   BDR: 1.1.1.1 <span class="params">(Id)</span></span><br><span class="line">*Mar 16 12:11:09.991: OSPF-1 LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area 0</span><br><span class="line">*Mar 16 12:11:10.491: OSPF-1 LSGEN: Rate limit LSA generation <span class="keyword">for</span> 1.1.1.1 1.1.1.1 1</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 16 12:11:12.243: OSPF-1 LSGEN: No change in router LSA, area 0 </span><br><span class="line"><span class="comment">//当holdtime超时后，虽然LDP会话还没有建立，OSPF却主动建立了邻接关系；</span></span><br></pre></td></tr></table></figure>

<p>查看R1的OSPF Database中1类LSA；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show ip ospf database router</span></span><br><span class="line"></span><br><span class="line">            OSPF Router with <span class="title function_">ID</span> <span class="params">(<span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>)</span> <span class="params">(Process ID <span class="number">1</span>)</span></span><br><span class="line"></span><br><span class="line">                Router Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line">    LS age: 304</span><br><span class="line">    Options: <span class="params">(No TOS-capability, DC)</span></span><br><span class="line">    LS Type: Router Links</span><br><span class="line">    Link State ID: 1.1.1.1</span><br><span class="line">    Advertising Router: 1.1.1.1</span><br><span class="line">    LS Seq Number: 80000002</span><br><span class="line">    Checksum: 0x30F7</span><br><span class="line">    Length: 48</span><br><span class="line">    Number of Links: 2</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Network/subnet number: 1.1.1.1</span><br><span class="line">        <span class="params">(Link Data)</span> Network Mask: 255.255.255.255</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 1</span><br><span class="line"></span><br><span class="line">    Link connected to: a Transit <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Designated Router address: 192.168.12.2</span><br><span class="line">        <span class="params">(Link Data)</span> Router Interface address: 192.168.12.1</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 65535 <span class="comment">//接口为UP，OSPF正在发送最大度量值；</span></span><br><span class="line"></span><br><span class="line">    LS age: 304</span><br><span class="line">    Options: <span class="params">(No TOS-capability, DC)</span></span><br><span class="line">    LS Type: Router Links</span><br><span class="line">    Link State ID: 2.2.2.2</span><br><span class="line">    Advertising Router: 2.2.2.2</span><br><span class="line">    LS Seq Number: 80000059</span><br><span class="line">    Checksum: 0x8F33</span><br><span class="line">    Length: 48</span><br><span class="line">    Number of Links: 2</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Network/subnet number: 2.2.2.2</span><br><span class="line">        <span class="params">(Link Data)</span> Network Mask: 255.255.255.255</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 1</span><br><span class="line"></span><br><span class="line">    Link connected to: a Transit <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Designated Router address: 192.168.12.2</span><br><span class="line">        <span class="params">(Link Data)</span> Router Interface address: 192.168.12.2</span><br><span class="line">        Number of MTID metrics: 0</span><br></pre></td></tr></table></figure>

<p>查看R1上F0&#x2F;0的LDP和OSPF同步信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//备注：由于holdtime为5秒（5000毫秒），所以输入下一条命令，必须非常快！</span></span><br><span class="line">R1(config)<span class="meta">#do sh ip ospf mpls ldp interface</span></span><br><span class="line">Loopback0</span><br><span class="line">    Process ID <span class="number">1</span>, Area <span class="number">0</span></span><br><span class="line">    LDP is not configured through LDP autoconfig</span><br><span class="line">    LDP-IGP Synchronization : Not required</span><br><span class="line">    Holddown timer is disabled</span><br><span class="line">    Interface is up </span><br><span class="line">FastEthernet0/<span class="number">1</span></span><br><span class="line">    Process ID <span class="number">1</span>, Area <span class="number">0</span></span><br><span class="line">    LDP is not configured through LDP autoconfig</span><br><span class="line">    LDP-IGP Synchronization : Required</span><br><span class="line">    Holddown timer is configured : <span class="number">5000</span> msecs</span><br><span class="line">    Holddown timer is not running</span><br><span class="line">    Interface is down </span><br><span class="line">FastEthernet0/<span class="number">0</span></span><br><span class="line">    Process ID <span class="number">1</span>, Area <span class="number">0</span></span><br><span class="line">    LDP is not configured through LDP autoconfig</span><br><span class="line">    LDP-IGP Synchronization : Required</span><br><span class="line">    Holddown timer is configured : <span class="number">5000</span> msecs <span class="comment">//LDP-IGP同步保持计时器被配置为5000毫秒；</span></span><br><span class="line">    Holddown timer is running and is expiring in <span class="number">1848</span> msecs<span class="comment">//LDP-IGP保持计时器正在运行，并且将在1848毫秒后到期超时；</span></span><br><span class="line">    Interface is down and pending LDP <span class="comment">//接口为Down，等待LDP；</span></span><br></pre></td></tr></table></figure>

<p>查看R1上F0&#x2F;0的LDP和OSPF同步信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#do sh ip ospf mpls ldp interface f0/0</span></span><br><span class="line">FastEthernet0/<span class="number">0</span></span><br><span class="line">    Process ID <span class="number">1</span>, Area <span class="number">0</span></span><br><span class="line">    LDP is not configured through LDP autoconfig</span><br><span class="line">    LDP-IGP Synchronization : Required</span><br><span class="line">    Holddown timer is configured : <span class="number">5000</span> msecs</span><br><span class="line">    Holddown timer is not running<span class="comment">//LDP-IGP保持计时器未在运行，说明保持计时器已经超时；</span></span><br><span class="line">    Interface is up and sending maximum metric<span class="comment">//接口为UP，OSPF正在发送最大度量值；</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到虽然OSPF邻接关系已经建立，但是由于LDP会话还没有建立，所以OSPF向邻居通告的度量值为最大值65535，在具有多条链路同时能够达到目的地的情况下，这一OSPF的这一动作确保此链路不会被用来转发数据；从而防止了到达该此链路的数据包不会因不能被打上标签，而导致数据包被丢弃；</p>
</blockquote>
<p>在R2上，将F0&#x2F;0口的mpls开启：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#int f0/0 </span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#mpls ip</span></span><br><span class="line"></span><br><span class="line">*Mar <span class="number">16</span> <span class="number">12</span>:<span class="number">29</span>:<span class="number">53.575</span>: %LDP<span class="number">-5</span>-NBRCHG: LDP Neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span> (<span class="number">1</span>) is UP</span><br><span class="line"><span class="comment">//可以看到LDP邻居马上建立；</span></span><br></pre></td></tr></table></figure>

<p>查看R1的OSPF Database中1类LSA：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#sh ip ospf database router</span></span><br><span class="line"></span><br><span class="line">            OSPF Router with <span class="title function_">ID</span> <span class="params">(<span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>)</span> <span class="params">(Process ID <span class="number">1</span>)</span></span><br><span class="line"></span><br><span class="line">                Router Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line">    LS age: 122</span><br><span class="line">    Options: <span class="params">(No TOS-capability, DC)</span></span><br><span class="line">    LS Type: Router Links</span><br><span class="line">    Link State ID: 1.1.1.1</span><br><span class="line">    Advertising Router: 1.1.1.1</span><br><span class="line">    LS Seq Number: 80000003 <span class="comment">//R1的OSPF进程更新了之前的Seq：80000002的LSA；</span></span><br><span class="line">    Checksum: 0x4CD9</span><br><span class="line">    Length: 48</span><br><span class="line">    Number of Links: 2</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Network/subnet number: 1.1.1.1</span><br><span class="line">        <span class="params">(Link Data)</span> Network Mask: 255.255.255.255</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 1</span><br><span class="line"></span><br><span class="line">    Link connected to: a Transit <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Designated Router address: 192.168.12.2</span><br><span class="line">        <span class="params">(Link Data)</span> Router Interface address: 192.168.12.1</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 1 <span class="comment">//在更新后的Seq：80000003 LSA中，度量值被更改回正常的1；</span></span><br><span class="line"></span><br><span class="line">    LS age: 1250</span><br><span class="line">    Options: <span class="params">(No TOS-capability, DC)</span></span><br><span class="line">    LS Type: Router Links</span><br><span class="line">    Link State ID: 2.2.2.2</span><br><span class="line">    Advertising Router: 2.2.2.2</span><br><span class="line">    LS Seq Number: 80000059</span><br><span class="line">    Checksum: 0x8F33</span><br><span class="line">    Length: 48</span><br><span class="line">    Number of Links: 2</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Network/subnet number: 2.2.2.2</span><br><span class="line">        <span class="params">(Link Data)</span> Network Mask: 255.255.255.255</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 1</span><br><span class="line"></span><br><span class="line">    Link connected to: a Transit <span class="title function_">Network</span></span><br><span class="line">        <span class="params">(Link ID)</span> Designated Router address: 192.168.12.2</span><br><span class="line">        <span class="params">(Link Data)</span> Router Interface address: 192.168.12.2</span><br><span class="line">        Number of MTID metrics: 0</span><br><span class="line">        TOS 0 Metrics: 1</span><br></pre></td></tr></table></figure>

<p>查看R1上F0&#x2F;0的LDP和OSPF同步信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#sh ip ospf mpls ldp interface f0/0</span></span><br><span class="line">FastEthernet0/<span class="number">0</span></span><br><span class="line">    Process ID <span class="number">1</span>, Area <span class="number">0</span></span><br><span class="line">    LDP is not configured through LDP autoconfig</span><br><span class="line">    LDP-IGP Synchronization : Required</span><br><span class="line">    Holddown timer is configured : <span class="number">5000</span> msecs</span><br><span class="line">    Holddown timer is not running</span><br><span class="line">    Interface is up</span><br><span class="line"><span class="comment">//可以看到接口已经起来了，说明LDP和OSPF已经同步；</span></span><br></pre></td></tr></table></figure>


<h2 id="实验2：R1和R2之间仅有两条或多条链路时的LDP-IGP同步"><a href="#实验2：R1和R2之间仅有两条或多条链路时的LDP-IGP同步" class="headerlink" title="实验2：R1和R2之间仅有两条或多条链路时的LDP-IGP同步"></a>实验2：R1和R2之间仅有两条或多条链路时的LDP-IGP同步</h2><p>将R1和R2之间的由F0&#x2F;1相连的链路启用，让R1和R2之间形成双链路；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#int f0/1</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#no shutdown</span></span><br><span class="line"></span><br><span class="line">R2(config)<span class="meta">#int f0/1</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#no shutdown</span></span><br></pre></td></tr></table></figure>

<p>查看R1的LDP邻居表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show mpls ldp neighbor</span></span><br><span class="line">    Peer LDP Ident: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>; Local LDP Ident <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span><span class="number">.52561</span> - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span></span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">15</span>/<span class="number">15</span>; Downstream</span><br><span class="line">        Up time: <span class="number">00</span>:<span class="number">06</span>:<span class="number">36</span></span><br><span class="line">        LDP discovery sources:</span><br><span class="line">            FastEthernet0/<span class="number">0</span>, Src IP addr: <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span></span><br><span class="line">            FastEthernet0/<span class="number">1</span>, Src IP addr: <span class="number">192.168</span><span class="number">.21</span><span class="number">.2</span></span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">            <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>         <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>    <span class="number">192.168</span><span class="number">.21</span><span class="number">.2</span> </span><br><span class="line"><span class="comment">//可以看到，R1在F0/0和F0/1发现了LDP邻居；</span></span><br></pre></td></tr></table></figure>

<p>禁用R2上F0&#x2F;0的MPLS，让R1和R2的LDP邻居关系断开，确保LDP会话晚于OSPF邻接关系建立；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#int f0/0  </span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#no mpls ip</span></span><br></pre></td></tr></table></figure>

<p>此时，在经过将R2的F0&#x2F;0禁用MPLS之后，R1和R2的LDP邻居已经关系。接下来，重置OSPF进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#clear mpls ldp neighbor *</span></span><br><span class="line">R1# </span><br><span class="line">*Mar <span class="number">16</span> <span class="number">13</span>:<span class="number">53</span>:<span class="number">14.798</span>: %LDP<span class="number">-5</span>-CLEAR_NBRS: Clear LDP <span class="title function_">neighbors</span> <span class="params">(*)</span> by console</span><br><span class="line">*Mar 16 13:53:14.810: %LDP-5-NBRCHG: LDP Neighbor 2.2.2.2:0 <span class="params">(<span class="number">2</span>)</span> is <span class="title function_">DOWN</span> <span class="params">(User cleared session manually)</span></span><br><span class="line">*Mar 16 13:53:19.914: %LDP-5-NBRCHG: LDP Neighbor 2.2.2.2:0 <span class="params">(<span class="number">1</span>)</span> is UP</span><br><span class="line">R1<span class="meta">#clear ip ospf process</span></span><br><span class="line">Reset ALL OSPF processes? [no]: yes</span><br><span class="line">*Mar 16 13:53:27.098: %OSPF-5-ADJCHG: Process 1, Nbr 2.2.2.2 on FastEthernet0/1 from FULL to DOWN, Neighbor Down: Interface down or detached</span><br><span class="line">*Mar 16 13:53:27.102: %OSPF-5-ADJCHG: Process 1, Nbr 2.2.2.2 on FastEthernet0/0 from FULL to DOWN, Neighbor Down: Interface down or detached</span><br><span class="line">*Mar 16 13:53:27.442: %OSPF-5-ADJCHG: Process 1, Nbr 2.2.2.2 on FastEthernet0/1 from LOADING to FULL, Loading Done</span><br><span class="line"><span class="comment">//备注：快速输入命令查看R1接口F0/0的LDP与OSPF的同步信息；</span></span><br><span class="line">R1<span class="meta">#sh ip ospf mpls ldp interface f0/0</span></span><br><span class="line">FastEthernet0/0</span><br><span class="line">    Process ID 1, Area 0</span><br><span class="line">    LDP is not configured through LDP autoconfig</span><br><span class="line">    LDP-IGP Synchronization : Required</span><br><span class="line">    Holddown timer is configured : 5000 msecs<span class="comment">//LDP-IGP同步保持计时器被配置为5000毫秒；</span></span><br><span class="line">    Holddown timer is running and is expiring in 952 msecs<span class="comment">//LDP-IGP保持计时器正在运行，并且将在952毫秒后到期超时；</span></span><br><span class="line">    Interface is down and pending LDP</span><br><span class="line"><span class="comment">//备注：快速输入命令查看R1接口F0/0的LDP与OSPF的同步信息；</span></span><br><span class="line">R1<span class="meta">#sh ip ospf mpls ldp interface f0/0</span></span><br><span class="line">FastEthernet0/0</span><br><span class="line">    Process ID 1, Area 0</span><br><span class="line">    LDP is not configured through LDP autoconfig</span><br><span class="line">    LDP-IGP Synchronization : Required</span><br><span class="line">    Holddown timer is configured : 5000 msecs</span><br><span class="line">    Holddown timer is not running<span class="comment">//LDP-IGP保持计时器未在运行，说明保持计时器已经超时；</span></span><br><span class="line">    Interface is up and sending maximum metric<span class="comment">//OSPF已经让接口UP，但却在发送最大度量值；</span></span><br><span class="line"><span class="comment">//可以看到虽然OSPF邻接关系已经建立，但是由于LDP会话还没有建立，</span></span><br><span class="line"><span class="comment">//所以OSPF向邻居通告的度量值为最大值65535，在具有多条链路同时能够达到目的地的情况下，</span></span><br><span class="line"><span class="comment">//这一OSPF的这一动作确保此链路不会被用来转发数据；</span></span><br><span class="line"><span class="comment">//从而防止了到达该此链路的数据包不会因不能被打上标签，而导致数据包被丢弃；</span></span><br></pre></td></tr></table></figure>

<p>查看R1的OSPF邻居表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show ip ospf neighbor</span></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Address         Interface</span><br><span class="line"><span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>           <span class="number">1</span>   FULL/DR         <span class="number">00</span>:<span class="number">00</span>:<span class="number">31</span>    <span class="number">192.168</span><span class="number">.21</span><span class="number">.2</span>    FastEthernet0/<span class="number">1</span></span><br><span class="line"><span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>           <span class="number">1</span>   FULL/DR         <span class="number">00</span>:<span class="number">00</span>:<span class="number">32</span>    <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>    FastEthernet0/<span class="number">0</span></span><br><span class="line"><span class="comment">//可以看到R1仍然从两个接口发现了OSPF邻居R2；</span></span><br></pre></td></tr></table></figure>

<p>查看R1的MPLS LDP邻居表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show mpls ldp neighbor</span></span><br><span class="line">    Peer LDP Ident: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>; Local LDP Ident <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>:<span class="number">0</span></span><br><span class="line">        TCP connection: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span><span class="number">.64074</span> - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.646</span></span><br><span class="line">        State: Oper; Msgs sent/rcvd: <span class="number">19</span>/<span class="number">19</span>; Downstream</span><br><span class="line">        Up time: <span class="number">00</span>:<span class="number">11</span>:<span class="number">03</span></span><br><span class="line">        LDP discovery sources:</span><br><span class="line">            FastEthernet0/<span class="number">1</span>, Src IP addr: <span class="number">192.168</span><span class="number">.21</span><span class="number">.2</span></span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">            <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>         <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>    <span class="number">192.168</span><span class="number">.21</span><span class="number">.2</span> </span><br><span class="line"><span class="comment">//可以看到R1仅仅从F0/1发现了LDP邻居R2；</span></span><br></pre></td></tr></table></figure>

<p>查看R1的LFIB表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show mpls forwarding-table</span></span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop    </span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface              </span><br><span class="line"><span class="number">16</span>         Pop Label  <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.21</span><span class="number">.2</span></span><br><span class="line"><span class="comment">//可以看到仅有从F0/1学到标签；</span></span><br></pre></td></tr></table></figure>

<p>查看R1的IP路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">                                                            </span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">                                                            </span><br><span class="line">        <span class="number">1.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">2.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.21</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">24</span>:<span class="number">13</span>, FastEthernet0/<span class="number">1</span><span class="comment">//虽然从两条链路学到路由，但是OSPF与LDP保持了一致，只使用其中走F0/1的路径；</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.21</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.21</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.21</span><span class="number">.1</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line"><span class="comment">//注意：本来我以为虽然LFIB中只有走F0/1的一条出站路径，而路由表中会有两条OSPF路由，分别是从F0/0和F0/1学到的，但事实并非如此；</span></span><br><span class="line"><span class="comment">//正是因为开启了LDP-IGP同步，所以造成了这样的结果；</span></span><br></pre></td></tr></table></figure>

<p>启用R2 f0&#x2F;0的MPLS；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R2(config)<span class="meta">#int f0/0</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#mpls ip</span></span><br></pre></td></tr></table></figure>

<p>查看R1上接口F0&#x2F;0的LDP-OSPF同步信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-router)<span class="meta">#do sh ip ospf mpls ldp interface f0/0</span></span><br><span class="line">FastEthernet0/<span class="number">0</span></span><br><span class="line">    Process ID <span class="number">1</span>, Area <span class="number">0</span></span><br><span class="line">    LDP is not configured through LDP autoconfig</span><br><span class="line">    LDP-IGP Synchronization : Required</span><br><span class="line">    Holddown timer is configured : <span class="number">5000</span> msecs</span><br><span class="line">    Holddown timer is not running</span><br><span class="line">    Interface is up</span><br><span class="line"><span class="comment">//注意：当R2的F0/0启用了MPLS后，R1的OSPF将接口F0/0度量值还原为了正常值；</span></span><br></pre></td></tr></table></figure>

<p>查看R1的LFIB表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-router)<span class="meta">#do sh mpls forwarding-table</span></span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop    </span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface              </span><br><span class="line"><span class="number">16</span>         Pop Label  <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span></span><br><span class="line">            Pop Label  <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.21</span><span class="number">.2</span></span><br><span class="line"><span class="comment">//当R2的F0/0启用了MPLS后，R1具有了两条等价的去往2.2.2.2的路径；</span></span><br></pre></td></tr></table></figure>

<p>查看R1的IP路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-router)<span class="meta">#do sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">        <span class="number">1.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">2.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.21</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">47</span>:<span class="number">46</span>, FastEthernet0/<span class="number">1</span><span class="comment">//当LDP从F0/0和F0/1收到两条标签绑定信息后，路由表中同样有了两条路径；</span></span><br><span class="line">                        [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">20</span>:<span class="number">20</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.21</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.21</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.21</span><span class="number">.1</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">```  </span><br><span class="line">            </span><br><span class="line">验证关闭LDP-IGP同步后LFIB和IP路由表情况；</span><br><span class="line">```c</span><br><span class="line"><span class="comment">//关闭LDP-IGP同步；</span></span><br><span class="line">R1(config)<span class="meta">#router os 1</span></span><br><span class="line">R1(config-router)<span class="meta">#no mpls ldp sync</span></span><br><span class="line"></span><br><span class="line">R2(config)<span class="meta">#router os 1</span></span><br><span class="line">R2(config-router)<span class="meta">#no mpls ldp sync</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//禁用R2上F0/0的MPLS；</span></span><br><span class="line">R2(config-router)<span class="meta">#int f0/0</span></span><br><span class="line">R2(config-<span class="keyword">if</span>)<span class="meta">#no mpls ip</span></span><br></pre></td></tr></table></figure>

<p>查看R1的LIB表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show mpls ip binding</span></span><br><span class="line">    <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span> </span><br><span class="line">        in label:     imp-null  </span><br><span class="line">        out label:    <span class="number">16</span>        lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span> </span><br><span class="line">        in label:     <span class="number">16</span>        </span><br><span class="line">        out label:    imp-null  lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>        inuse</span><br><span class="line">    <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">        in label:     imp-null  </span><br><span class="line">        out label:    imp-null  lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span>       </span><br><span class="line">    <span class="number">192.168</span><span class="number">.21</span><span class="number">.0</span>/<span class="number">24</span> </span><br><span class="line">        in label:     imp-null  </span><br><span class="line">        out label:    imp-null  lsr: <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>查看R1的LFIB表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#sh mpls forwarding-table</span></span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop    </span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface              </span><br><span class="line"><span class="number">16</span>         Pop Label  <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.21</span><span class="number">.2</span></span><br><span class="line">                No Label   <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>

<p>查看R1的IP路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">        <span class="number">1.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">2.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.21</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">54</span>:<span class="number">25</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">                        [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">26</span>:<span class="number">59</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.21</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.21</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.21</span><span class="number">.1</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line"><span class="comment">//注意：关闭LDP-IGP同步后，即使没有从F0/0口收到R2通告的标签，R1的路由表中还是出现两条去往2.2.2.2/32的等价路径；</span></span><br><span class="line"><span class="comment">//如果这种情况出现是在MPLS VPN，AToM 或 VPLS环境中P路由器上，可以能会出现丢包现象；</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>MPLS</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLS 实验4：MPLS vs BGP同步</title>
    <url>/2014/MPLS_Lab_4/</url>
    <content><![CDATA[<h1 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h1><ul>
<li>模拟器：GNS3 0.8.6</li>
<li>Cisco IOS：c7200-adventerprisek9-mz.151-4.M2.image</li>
</ul>
<p>GNS3实验拓扑文件：<br><a href="topology.net">拓扑文件</a></p>
<h1 id="实验拓扑："><a href="#实验拓扑：" class="headerlink" title="实验拓扑："></a>实验拓扑：</h1><p><img src="/2014/MPLS_Lab_4/topo.png"></p>
<span id="more"></span>


<h1 id="基本预配置："><a href="#基本预配置：" class="headerlink" title="基本预配置："></a>基本预配置：</h1><h2 id="R1："><a href="#R1：" class="headerlink" title="R1："></a>R1：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 1.1.1.1 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.12.1 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shut</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.15.1 255.255.255.0</span><br><span class="line">    no shut</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 1.1.1.1</span><br><span class="line">!</span><br><span class="line">router bgp 1</span><br><span class="line">    bgp router-id 1.1.1.1</span><br><span class="line">    bgp log-neighbor-changes</span><br><span class="line">    network 1.1.1.1 mask 255.255.255.255</span><br><span class="line">    neighbor 4.4.4.4 remote-as 1</span><br><span class="line">    neighbor 4.4.4.4 update-source Loopback0</span><br><span class="line">    neighbor 4.4.4.4 next-hop-self</span><br><span class="line">    neighbor 192.168.15.5 remote-as 2</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 2.2.2.2 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.12.2 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.23.2 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 2.2.2.2</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R3"><a href="#R3" class="headerlink" title="R3:"></a>R3:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R3</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 3.3.3.3 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.34.3 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.23.3 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 3.3.3.3</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R4"><a href="#R4" class="headerlink" title="R4:"></a>R4:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R4</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 4.4.4.4 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.34.4 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.47.4 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 4.4.4.4</span><br><span class="line">!</span><br><span class="line">router bgp 1</span><br><span class="line">    bgp router-id 4.4.4.4</span><br><span class="line">    bgp log-neighbor-changes</span><br><span class="line">    network 4.4.4.4 mask 255.255.255.255</span><br><span class="line">    neighbor 1.1.1.1 remote-as 1</span><br><span class="line">    neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line">    neighbor 1.1.1.1 next-hop-self</span><br><span class="line">    neighbor 192.168.47.7 remote-as 3</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="R5"><a href="#R5" class="headerlink" title="R5:"></a>R5:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R5</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 5.5.5.5 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.56.5 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.15.5 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 5.5.5.5</span><br><span class="line">!</span><br><span class="line">router bgp 2</span><br><span class="line">    bgp router-id 5.5.5.5</span><br><span class="line">    bgp log-neighbor-changes</span><br><span class="line">    network 5.5.5.5 mask 255.255.255.255</span><br><span class="line">    neighbor 192.168.15.1 remote-as 1</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R6"><a href="#R6" class="headerlink" title="R6:"></a>R6:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R6</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 6.6.6.6 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.56.6 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 6.6.6.6</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R7"><a href="#R7" class="headerlink" title="R7:"></a>R7:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R7</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 7.7.7.7 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.78.7 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.47.7 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 7.7.7.7</span><br><span class="line">!</span><br><span class="line">router bgp 3</span><br><span class="line">    bgp router-id 7.7.7.7</span><br><span class="line">    bgp log-neighbor-changes</span><br><span class="line">    network 7.7.7.7 mask 255.255.255.255</span><br><span class="line">    neighbor 192.168.47.4 remote-as 1</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R8"><a href="#R8" class="headerlink" title="R8:"></a>R8:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R8</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 8.8.8.8 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.78.8 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 8.8.8.8</span><br><span class="line">!         </span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h1 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h1><ol>
<li>使用MPLS解决BGP关闭同步后IBGP非全互联造成的路由黑洞问题；</li>
<li>研究以递归方式为前缀分配标签是如何运作的；</li>
</ol>
<h1 id="实验与调试："><a href="#实验与调试：" class="headerlink" title="实验与调试："></a>实验与调试：</h1><h2 id="实验1："><a href="#实验1：" class="headerlink" title="实验1："></a>实验1：</h2><p>验证：从R5上，以R5的Loopback做源ping R7的Loopback0；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R5<span class="meta">#ping 7.7.7.7 source l0</span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Sending <span class="number">5</span>, <span class="number">100</span>-byte ICMP Echos to <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>, timeout is <span class="number">2</span> seconds:</span><br><span class="line">Packet sent with a source address of <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> </span><br><span class="line">!!!!!</span><br><span class="line">Success rate is <span class="number">100</span> percent (<span class="number">5</span>/<span class="number">5</span>), round-trip min/avg/max = <span class="number">112</span>/<span class="number">124</span>/<span class="number">140</span> ms</span><br><span class="line"><span class="comment">//成功了！</span></span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<ul>
<li>在该实验中，R2和R3作为P路由器，并没有运行BGP，为什么以R5的Loopback0做源可以ping通R7的Loopback0？</li>
<li>为什么数据包R2和R3在没有5.5.5.5&#x2F;32和7.7.7.7&#x2F;32的路由的情况下没有丢弃包？</li>
</ul>
<p>模拟ping包的交换过程，假设此时R1收到了来自R5的ping包：</p>
<blockquote>
<p>注意：当数据包进入R1时，数据包并未携带标签，此时R1作为LSP中的第一台LSR，也是入站LSR，R1需要查找CEF来为这个标准的IP数据包打上标签；</p>
</blockquote>
<p>查看R1的路由表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">        <span class="number">1.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">2.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>, <span class="number">01</span>:<span class="number">20</span>:<span class="number">09</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">3.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> [<span class="number">110</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>, <span class="number">01</span>:<span class="number">20</span>:<span class="number">09</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">4.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> [<span class="number">110</span>/<span class="number">4</span>] via <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>, <span class="number">01</span>:<span class="number">20</span>:<span class="number">09</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">17</span>:<span class="number">45</span></span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> [<span class="number">200</span>/<span class="number">0</span>] via <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">16</span>:<span class="number">46</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>, <span class="number">01</span>:<span class="number">20</span>:<span class="number">09</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>, <span class="number">01</span>:<span class="number">20</span>:<span class="number">09</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line"><span class="comment">//在R1上，路由表递归查找下一跳可以发现：要去往7.7.7.7/32必须先到达4.4.4.4；</span></span><br><span class="line"><span class="comment">//要到达4.4.4.4/32必须先到达192.168.12.2；</span></span><br></pre></td></tr></table></figure>

<p>查看R1的LFIB表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show mpls forwarding-table</span></span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop    </span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface              </span><br><span class="line"><span class="number">16</span>         <span class="number">16</span>         <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span></span><br><span class="line"><span class="number">17</span>         <span class="number">17</span>         <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span></span><br><span class="line"><span class="number">18</span>         Pop Label  <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span></span><br><span class="line"><span class="number">19</span>         <span class="number">18</span>         <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span>  <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span></span><br><span class="line"><span class="number">20</span>         Pop Label  <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span>  <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span></span><br><span class="line"><span class="comment">//由LFIB表可以得出，去往前缀4.4.4.4/32的出标签为16；</span></span><br></pre></td></tr></table></figure>

<p>沿路由递归查看CEF表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#sh ip cef 7.7.7.7 detail</span></span><br><span class="line"><span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>, epoch <span class="number">0</span>, flags rib only nolabel, rib defined all labels</span><br><span class="line">    recursive via <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span></span><br><span class="line">    nexthop <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> FastEthernet0/<span class="number">0</span> label <span class="number">16</span></span><br><span class="line"></span><br><span class="line">R1<span class="meta">#sh ip cef 4.4.4.4 detail</span></span><br><span class="line"><span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>, epoch <span class="number">0</span></span><br><span class="line">    local label info: global/<span class="number">16</span></span><br><span class="line">    <span class="number">1</span> RR source [no flags]</span><br><span class="line">    nexthop <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> FastEthernet0/<span class="number">0</span> label <span class="number">16</span></span><br><span class="line"><span class="comment">//由于路由递归查找的关系，去往前缀7.7.7.7/32的数据包在出站时被打上了和去往前缀4.4.4.4/32的数据包相同的出标签16（R1的出标签，R2的入标签）；</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#sh ip cef 192.168.12.2 detail</span><br><span class="line">192.168.12.2/32, epoch 0, flags attached</span><br><span class="line">    Adj source: IP adj out of FastEthernet0/0, addr 192.168.12.2 6819DAE0</span><br><span class="line">    Dependent covered prefix type adjfib cover 192.168.12.0/24</span><br><span class="line">    attached to FastEthernet0/0</span><br><span class="line">//由于R1与192.168.12.0/24直连，所以不再需要在进行标签转发，所以R1没有关于192.168.12.0/24的出标签；</span><br></pre></td></tr></table></figure>

<p><strong>此时数据达到了R2：</strong></p>
<p>查看R2的IP路由表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R2<span class="meta">#show ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">        <span class="number">1.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span>, <span class="number">03</span>:<span class="number">42</span>:<span class="number">35</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">2.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">3.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.23</span><span class="number">.3</span>, <span class="number">03</span>:<span class="number">42</span>:<span class="number">45</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">4.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> [<span class="number">110</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.23</span><span class="number">.3</span>, <span class="number">03</span>:<span class="number">42</span>:<span class="number">45</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.23</span><span class="number">.3</span>, <span class="number">03</span>:<span class="number">42</span>:<span class="number">45</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line"><span class="comment">//可以看到，由于R2没有运行BGP，所以R2的路由表中没有关于前缀7.7.7.7/32的路由条目；</span></span><br><span class="line"><span class="comment">//注意：递归查找路由表只会发生在运行BGP并与其他PE路由器建立IBGP关系的PE路由器，</span></span><br><span class="line"><span class="comment">//而在P路由器上，由于没有运行BGP，不可能有相关路由信息，所以只按照标签转发。</span></span><br></pre></td></tr></table></figure>

<p>查看R2的LFIB：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R2<span class="meta">#show mpls forwarding-table</span></span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop    </span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface              </span><br><span class="line"><span class="number">16</span>         <span class="number">16</span>         <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>       <span class="number">38689</span>         Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.23</span><span class="number">.3</span></span><br><span class="line"><span class="number">17</span>         Pop Label  <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.23</span><span class="number">.3</span></span><br><span class="line"><span class="number">18</span>         Pop Label  <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span>  <span class="number">686</span>           Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.23</span><span class="number">.3</span></span><br><span class="line"><span class="number">19</span>         Pop Label  <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>       <span class="number">41711</span>         Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span></span><br><span class="line"><span class="comment">//尽管R2没有关于前缀7.7.7.7/32的路由条目，但由于AS1是MPLS域，路由器都使用标签转发数据，</span></span><br><span class="line"><span class="comment">//加之因为路由的递归查找，使得前缀7.7.7.7/32“继承了”前缀4.4.4.4/32的标签；</span></span><br><span class="line"><span class="comment">//所以，当R2收到去往7.7.7.7/32的数据包时，此数据包携带了前缀4.4.4.4/32的入标签16（R2的入标签，R1的出标签）；</span></span><br><span class="line"><span class="comment">//于是，R2作出转发决定，并给数据包打上出标签16（R2的出标签，R3的入标签），然后转发给R3；</span></span><br></pre></td></tr></table></figure>

<p><strong>此时数据到达了R3：</strong></p>
<p>查看R3的IP路由表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R3<span class="meta">#show ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">        <span class="number">1.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> [<span class="number">110</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span>, <span class="number">03</span>:<span class="number">55</span>:<span class="number">45</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">2.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span>, <span class="number">03</span>:<span class="number">55</span>:<span class="number">55</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">3.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">4.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span>, <span class="number">03</span>:<span class="number">56</span>:<span class="number">35</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span>, <span class="number">03</span>:<span class="number">55</span>:<span class="number">55</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.23</span><span class="number">.3</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line"><span class="comment">//同样的，由于R2没有运行BGP，所以R3的路由表中没有关于前缀7.7.7.7/32的路由条目；</span></span><br></pre></td></tr></table></figure>

<p>查看R3的LFIB表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R3<span class="meta">#sh mpls forwarding-table</span></span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop    </span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface              </span><br><span class="line"><span class="number">16</span>         Pop Label  <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>       <span class="number">35742</span>         Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span></span><br><span class="line"><span class="number">17</span>         Pop Label  <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span></span><br><span class="line"><span class="number">18</span>         Pop Label  <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span>  <span class="number">1064</span>          Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span></span><br><span class="line"><span class="number">19</span>         <span class="number">19</span>         <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>       <span class="number">43006</span>         Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span></span><br><span class="line"><span class="comment">//尽管R2没有关于前缀7.7.7.7/32的路由条目，但由于AS1是MPLS域，路由器都使用标签转发数据，</span></span><br><span class="line"><span class="comment">//加之因为路由的递归查找，使得前缀7.7.7.7/32“继承了”前缀4.4.4.4/32的标签；</span></span><br><span class="line"><span class="comment">//所以，当R3收到去往7.7.7.7/32的数据包时，此数据包携带了前缀4.4.4.4/32的入标签16（R3的入标签，R2的出标签）；</span></span><br><span class="line"><span class="comment">//于是，R3作出转发决定，并将数据包的标签弹出（R3的出标签为隐式空标签，R4的通告给R3的入标签为隐式空标签），然后转发给R4；</span></span><br></pre></td></tr></table></figure>

<p><strong>此时数据到达了R4:</strong></p>
<p>由于R4是LSP中的最后一台LSR，即出站LSR，所以R4负责移除标签，然后查找CEF，按照IP数据包的标准流程进行处理；</p>
<p>查看R4的LFIB表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4<span class="meta">#sh mpls forwarding-table</span></span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop    </span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface              </span><br><span class="line"><span class="number">16</span>         Pop Label  <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br><span class="line"><span class="number">17</span>         Pop Label  <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span>  <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br><span class="line"><span class="number">18</span>         <span class="number">17</span>         <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br><span class="line"><span class="number">19</span>         <span class="number">19</span>         <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br><span class="line"><span class="number">20</span>         <span class="number">18</span>         <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span>  <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br><span class="line">```           </span><br><span class="line">                </span><br><span class="line">查看R4的IP路由表：</span><br><span class="line">```c</span><br><span class="line">R4<span class="meta">#show ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">        <span class="number">1.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> [<span class="number">110</span>/<span class="number">4</span>] via <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span>, <span class="number">04</span>:<span class="number">16</span>:<span class="number">48</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">2.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> [<span class="number">110</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span>, <span class="number">04</span>:<span class="number">16</span>:<span class="number">48</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">3.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span>, <span class="number">04</span>:<span class="number">17</span>:<span class="number">36</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">4.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">200</span>/<span class="number">0</span>] via <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>, <span class="number">03</span>:<span class="number">14</span>:<span class="number">32</span></span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> [<span class="number">20</span>/<span class="number">0</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span>, <span class="number">03</span>:<span class="number">13</span>:<span class="number">34</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span>, <span class="number">04</span>:<span class="number">16</span>:<span class="number">48</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span>, <span class="number">04</span>:<span class="number">17</span>:<span class="number">36</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>查看R4的CEF表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4<span class="meta">#show ip cef 7.7.7.7 detail</span></span><br><span class="line"><span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>, epoch <span class="number">0</span>, flags rib only nolabel, rib defined all labels</span><br><span class="line">    recursive via <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span></span><br><span class="line">    attached to FastEthernet0/<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//至此，ping包被按照普通IP数据包转发给了R7，echo reply包的转发交换方向相反，但过程相同；</span></span><br></pre></td></tr></table></figure>


<h1 id="实验结论："><a href="#实验结论：" class="headerlink" title="实验结论："></a>实验结论：</h1><ol>
<li>在分配标签时，标签可以以路由递归的方式被继承；</li>
<li>MPLS 不但可以解决BGP关闭同步后需要IBGP全互联的问题，更高效的是，MPLS可以让MPLS域内的P路由器不必运行BGP；</li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>MPLS</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLS 实验5：MPLS VPN using Static Routing on the PE-CE link</title>
    <url>/2014/MPLS_Lab_5/</url>
    <content><![CDATA[<h1 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h1><ul>
<li>模拟器：GNS3 0.8.6</li>
<li>Cisco IOS：c7200-adventerprisek9-mz.151-4.M2.image</li>
</ul>
<h1 id="GNS3实验拓扑文件："><a href="#GNS3实验拓扑文件：" class="headerlink" title="GNS3实验拓扑文件："></a>GNS3实验拓扑文件：</h1><p><a href="topology.net">拓扑文件</a></p>
<h1 id="实验拓扑："><a href="#实验拓扑：" class="headerlink" title="实验拓扑："></a>实验拓扑：</h1><p><img src="/2014/MPLS_Lab_5/topo.png"></p>
<span id="more"></span>

<h1 id="基本预配置："><a href="#基本预配置：" class="headerlink" title="基本预配置："></a>基本预配置：</h1><h2 id="R1："><a href="#R1：" class="headerlink" title="R1："></a>R1：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 1.1.1.1 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.12.1 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shut</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.15.1 255.255.255.0</span><br><span class="line">    no shut</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 1.1.1.1</span><br><span class="line">!         </span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 2.2.2.2 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.12.2 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.23.2 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 2.2.2.2</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R3"><a href="#R3" class="headerlink" title="R3:"></a>R3:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R3</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 3.3.3.3 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.34.3 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.23.3 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 3.3.3.3</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R4"><a href="#R4" class="headerlink" title="R4:"></a>R4:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R4</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 4.4.4.4 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.34.4 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.47.4 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 4.4.4.4</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R5"><a href="#R5" class="headerlink" title="R5:"></a>R5:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R5</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 5.5.5.5 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.56.5 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.15.5 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">ip route 6.6.6.6 255.255.255.255 192.168.56.6</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 192.168.15.1</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R6"><a href="#R6" class="headerlink" title="R6:"></a>R6:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R6</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 6.6.6.6 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.56.6 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 192.168.56.5</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R7"><a href="#R7" class="headerlink" title="R7:"></a>R7:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R7</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 7.7.7.7 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.78.7 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.47.7 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 192.168.47.4</span><br><span class="line">ip route 8.8.8.8 255.255.255.255 192.168.78.8</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R8"><a href="#R8" class="headerlink" title="R8:"></a>R8:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R8</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 8.8.8.8 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.78.8 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 192.168.78.7</span><br><span class="line">!         </span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="MPLS-VPN配置步骤："><a href="#MPLS-VPN配置步骤：" class="headerlink" title="MPLS VPN配置步骤："></a>MPLS VPN配置步骤：</h1><ol>
<li>创建VRF（VRF名本地有效）：<ul>
<li>指定RD（提供全局唯一的私网单播地址）；</li>
<li>指定RT的导出（导出：把重分发进MP-BGP的VPNv4路由打上MP-BGP扩展团体属性RT）和导入（导入：把MP-BGP里的VPNv4路由进行RT的匹配，匹配成功的VPNv4路由将放进相应的VRF）；</li>
<li>将与CE相连的PE接口关联特定VRF；</li>
</ul>
</li>
<li>配置MP-BGP：<ul>
<li>配置建立PE之间的IBGP邻居关系；</li>
<li>启用VPNv4地址族（AF），并激活与其他PE设备的邻居关系；</li>
</ul>
</li>
<li>配置PE-CE路由；<ul>
<li>配置IGP，并启用IGP的地址族（AF）；</li>
<li>配置启用MP-BGP IPv4 VRF地址族，然后激活与其他PE路由器的MP-BGP IPv4 VRF邻居关系；</li>
</ul>
</li>
</ol>
<h1 id="实验与调试："><a href="#实验与调试：" class="headerlink" title="实验与调试："></a>实验与调试：</h1><h2 id="实验1：配置MPLS-VPN"><a href="#实验1：配置MPLS-VPN" class="headerlink" title="实验1：配置MPLS VPN"></a>实验1：配置MPLS VPN</h2><h3 id="在PE上创建VRF"><a href="#在PE上创建VRF" class="headerlink" title="在PE上创建VRF"></a><strong>在PE上创建VRF</strong></h3><p>在PE1（R1）上创建VRF，并命名为A-Site1，表示该VRF为VPN A的站点1服务；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#ip vrf A-Site1   </span></span><br><span class="line">```            </span><br><span class="line"></span><br><span class="line">指定RD，为<span class="number">1</span>:<span class="number">1</span>，如果按照AS：num命名法，以下RD表示AS1中的第<span class="number">2</span>个VRF；</span><br><span class="line">```c</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-vrf)</span><span class="meta">#rd 1:1</span></span><br></pre></td></tr></table></figure>

<p>指定RT的导入和导出，这里我将RT指定为导入和导出1：1；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-vrf)<span class="meta">#route-target ?        </span></span><br><span class="line">    ASN:nn or IP-address:nn  Target VPN Extended Community</span><br><span class="line">    both                     Both import and export Target-VPN community</span><br><span class="line">    export                   Export Target-VPN community</span><br><span class="line">    import                   Import Target-VPN community</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-vrf)</span><span class="meta">#route-target both 1:1</span></span><br></pre></td></tr></table></figure>

<p>将PE1（R1）上与CE相连的PE接口F0&#x2F;1关联到VRF A-Site1；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#int f0/1</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#ip vrf forwarding A-Site1</span></span><br><span class="line">% Interface FastEthernet0/<span class="number">1</span> IPv4 disabled and <span class="title function_">address</span><span class="params">(es)</span> removed due to enabling VRF A-Site1</span><br><span class="line"><span class="comment">//切记先将接口关联VRF，然后再配置IP地址；</span></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-<span class="keyword">if</span>)</span><span class="meta">#ip add 192.168.15.1 255.255.255.0</span></span><br></pre></td></tr></table></figure>
<p>在PE2（R4）上创建VRF，并命名为A-Site2，表示该VRF为VPN A的站点2服务；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#ip vrf A-Site2</span></span><br></pre></td></tr></table></figure>

<p>指定RD，为1:2，如果按照AS：num命名法，以下RD表示AS1中的第2个VRF；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-vrf)<span class="meta">#rd 1:2</span></span><br></pre></td></tr></table></figure>

<p>指定RT的导入和导出，这里我将RT指定为导入和导出1：1；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-vrf)<span class="meta">#route-target both 1:1</span></span><br><span class="line"><span class="comment">//这里因为PE1（R1）的RT导出和PE2（R4）的RT导入能够匹配成功，所以R4能够学到R1导入到MP-BGP中的VPNv4路由；</span></span><br><span class="line"><span class="comment">//又因为PE2（R4）的RT导出和PE1（1）的RT导入能够匹配成对，所以R1能够学到R4导入到MP-BGP中的VPNv4路由；</span></span><br></pre></td></tr></table></figure>

<p>将PE2（R4）上与CE相连的PE接口F0&#x2F;1关联到VRF A-Site2；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#int f0/1</span></span><br><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#ip vrf forwarding A-Site2</span></span><br><span class="line">% Interface FastEthernet0/<span class="number">1</span> IPv4 disabled and <span class="title function_">address</span><span class="params">(es)</span> removed due to enabling VRF A-Site2</span><br><span class="line">    <span class="comment">//切记先将接口关联VRF，然后再配置IP地址；</span></span><br><span class="line"><span class="title function_">R4</span><span class="params">(config-<span class="keyword">if</span>)</span><span class="meta">#ip add 192.168.47.4 255.255.255.0</span></span><br></pre></td></tr></table></figure>
<h3 id="配置MP-BGP"><a href="#配置MP-BGP" class="headerlink" title="配置MP-BGP"></a><strong>配置MP-BGP</strong></h3><p>在PE1（R1）上配置MP-BGP，使之与其他PE建立IBGP关系，在此实验中只有PE1和PE2两台PE设备；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 remote-as 1</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 update-source l0</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 next-hop-self</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">启用PE1（R1）的VPNv4地址族，并激活与IBGP邻居PE2（R4）的MP-BGP VPNv4邻居关系；</span><br><span class="line">```c</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-router)</span><span class="meta">#address-family vpnv4</span></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-router-af)</span><span class="meta">#neighbor 4.4.4.4 activate</span></span><br><span class="line"><span class="comment">//激活与IBGP邻居R4的VPNv4关系；</span></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-router-af)</span><span class="meta">#neighbor 4.4.4.4 send-community ?</span></span><br><span class="line">    both      Send Standard and Extended Community attributes</span><br><span class="line">    extended  Send Extended Community attribute</span><br><span class="line">    standard  Send Standard Community attribute</span><br><span class="line">    &lt;cr&gt;</span><br><span class="line"></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-router-af)</span><span class="meta">#neighbor 4.4.4.4 send-community both</span></span><br><span class="line"><span class="comment">//由于BGP团体属性为可选传递属性，所以必须手动指定R1向IBGP邻居R4发送拓展团体属性和标准团体属性；</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-router-af)</span><span class="meta">#exit-address-family</span></span><br><span class="line"><span class="comment">//退出AF配置模式；</span></span><br></pre></td></tr></table></figure>
<p>在PE2（R4）上配置MP-BGP，使之与其他PE建立IBGP关系，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#nei 1.1.1.1 remote-as 1</span></span><br><span class="line">R4(config-router)<span class="meta">#neighbor 1.1.1.1 update-source l0</span></span><br><span class="line">R4(config-router)<span class="meta">#neighbor 1.1.1.1 next-hop-self</span></span><br></pre></td></tr></table></figure>

<p>启用PE2（R4）的VPNv4地址族，并激活与IBGP邻居PE1（R1）的MP-BGP VPNv4邻居关系；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-router)<span class="meta">#address-family vpnv4</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 1.1.1.1 activate</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 1.1.1.1 send-community both</span></span><br></pre></td></tr></table></figure>
<h3 id="配置PE-CE路由"><a href="#配置PE-CE路由" class="headerlink" title="配置PE-CE路由"></a><strong>配置PE-CE路由</strong></h3><p>配置PE1（R1）的静态路由；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#ip route vrf A-Site1 6.6.6.6 255.255.255.255 192.168.15.5</span></span><br></pre></td></tr></table></figure>

<p>配置PE1（R1）的MP-BGP IPv4 VRF地址族（AF）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#address-family ipv4 vrf A-Site1</span></span><br><span class="line"><span class="comment">//进入MP-BGP的IPv4 VRF地址族（AF）；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#redistribute static </span></span><br><span class="line"><span class="comment">//将静态路由中VRF名字与MP-BGP中IPv4 VRF名字相同的静态路由重分布进MP-BGP的IPv4 VRF AF；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#redistribute connected </span></span><br><span class="line"><span class="comment">//如果用户在CE路由器上ping远程网络的另一个VPN站点中的CE或C路由器，</span></span><br><span class="line"><span class="comment">//为了使其在没有指定其源地址情况下（即默认使用CE路由器出站接口IP地址），Echo Reply包能够有路由并正常返回,</span></span><br><span class="line"><span class="comment">//将PE路由器的直连路由重分布进MP-BGP的IPv4 VRF AF中；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#exit-address-family </span></span><br><span class="line"><span class="comment">//退出MP-BGP的IPv4 VRF地址族（AF）模式；</span></span><br></pre></td></tr></table></figure>
<p>配置PE2（R4）的静态路由；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#ip route vrf A-Site1 6.6.6.6 255.255.255.255 192.168.15.5</span></span><br></pre></td></tr></table></figure>

<p>配置PE2（R4）的MP-BGP IPv4 VRF地址族（AF）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#address-family ipv4 vrf A-Site2</span></span><br><span class="line">R4(config-router-af)<span class="meta">#redistribute connected</span></span><br><span class="line">R4(config-router-af)<span class="meta">#redistribute static</span></span><br><span class="line">R4(config-router-af)<span class="meta">#exit-address-family</span></span><br></pre></td></tr></table></figure>

<h1 id="实验与调试"><a href="#实验与调试" class="headerlink" title="实验与调试"></a>实验与调试</h1><p>在VPN A站点1的C路由器R6上ping远程VPN A站点2的C路由器R8，并且指定源为R6的接口Loopback0；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R6(config)<span class="meta">#do p 8.8.8.8 source 6.6.6.6</span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Sending <span class="number">5</span>, <span class="number">100</span>-byte ICMP Echos to <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, timeout is <span class="number">2</span> seconds:</span><br><span class="line">Packet sent with a source address of <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> </span><br><span class="line">!!!!!</span><br><span class="line">Success rate is <span class="number">100</span> percent (<span class="number">5</span>/<span class="number">5</span>), round-trip min/avg/max = <span class="number">128</span>/<span class="number">159</span>/<span class="number">200</span> ms</span><br></pre></td></tr></table></figure>
<p>成功！</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>MPLS</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLS 实验6：MPLS VPN running RIPv2 on the PE-CE link</title>
    <url>/2014/MPLS_Lab_6/</url>
    <content><![CDATA[<h1 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h1><ul>
<li>模拟器：GNS3 0.8.6</li>
<li>Cisco IOS：c7200-adventerprisek9-mz.151-4.M2.image</li>
</ul>
<h1 id="GNS3实验拓扑文件："><a href="#GNS3实验拓扑文件：" class="headerlink" title="GNS3实验拓扑文件："></a>GNS3实验拓扑文件：</h1><p><a href="topology.net">拓扑文件</a></p>
<h1 id="实验拓扑："><a href="#实验拓扑：" class="headerlink" title="实验拓扑："></a>实验拓扑：</h1><p><img src="/2014/MPLS_Lab_6/topo.png"></p>
<span id="more"></span>

<h1 id="基本预配置："><a href="#基本预配置：" class="headerlink" title="基本预配置："></a>基本预配置：</h1><h2 id="R1："><a href="#R1：" class="headerlink" title="R1："></a>R1：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 1.1.1.1 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.12.1 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shut</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.15.1 255.255.255.0</span><br><span class="line">    no shut</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 1.1.1.1</span><br><span class="line">!         </span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 2.2.2.2 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.12.2 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.23.2 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 2.2.2.2</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R3"><a href="#R3" class="headerlink" title="R3:"></a>R3:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R3</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 3.3.3.3 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.34.3 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.23.3 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 3.3.3.3</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R4"><a href="#R4" class="headerlink" title="R4:"></a>R4:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R4</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 4.4.4.4 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.34.4 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.47.4 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 4.4.4.4</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R5"><a href="#R5" class="headerlink" title="R5:"></a>R5:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R5</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 5.5.5.5 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.56.5 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.15.5 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router rip</span><br><span class="line">    version 2</span><br><span class="line">    network 5.0.0.0</span><br><span class="line">    network 192.168.15.0</span><br><span class="line">    network 192.168.56.0</span><br><span class="line">    no auto-summary</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R6"><a href="#R6" class="headerlink" title="R6:"></a>R6:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R6</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 6.6.6.6 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.56.6 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router rip</span><br><span class="line">    version 2</span><br><span class="line">    network 6.0.0.0</span><br><span class="line">    network 192.168.56.0</span><br><span class="line">    no auto-summary</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R7"><a href="#R7" class="headerlink" title="R7:"></a>R7:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R7</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 7.7.7.7 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.78.7 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.47.7 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router rip</span><br><span class="line">    version 2</span><br><span class="line">    network 7.0.0.0</span><br><span class="line">    network 192.168.47.0</span><br><span class="line">    network 192.168.78.0</span><br><span class="line">    no auto-summary</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R8"><a href="#R8" class="headerlink" title="R8:"></a>R8:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R8</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 8.8.8.8 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.78.8 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router rip</span><br><span class="line">    version 2</span><br><span class="line">    network 8.0.0.0</span><br><span class="line">    network 192.168.78.0</span><br><span class="line">    no auto-summary</span><br><span class="line">!         </span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="MPLS-VPN配置步骤："><a href="#MPLS-VPN配置步骤：" class="headerlink" title="MPLS VPN配置步骤："></a>MPLS VPN配置步骤：</h1><ol>
<li>创建VRF（VRF名本地有效）：<ul>
<li>指定RD（提供全局唯一的私网单播地址）；</li>
<li>指定RT的导出（导出：把重分发进MP-BGP的VPNv4路由打上MP-BGP扩展团体属性RT）和导入（导入：把MP-BGP里的VPNv4路由进行RT的匹配，匹配成功的VPNv4路由将放进相应的VRF）；</li>
<li>将与CE相连的PE接口关联特定VRF；</li>
</ul>
</li>
<li>配置MP-BGP：<ul>
<li>配置建立PE之间的IBGP邻居关系；</li>
<li>启用VPNv4地址族（AF），并激活与其他PE设备的邻居关系；</li>
</ul>
</li>
<li>配置PE-CE路由；<ul>
<li>配置IGP，并启用IGP的地址族（AF）；</li>
<li>配置启用MP-BGP IPv4 VRF地址族，然后激活与其他PE路由器的MP-BGP IPv4 VRF邻居关系；</li>
</ul>
</li>
</ol>
<h1 id="实验与调试："><a href="#实验与调试：" class="headerlink" title="实验与调试："></a>实验与调试：</h1><h2 id="实验1：配置MPLS-VPN"><a href="#实验1：配置MPLS-VPN" class="headerlink" title="实验1：配置MPLS VPN"></a>实验1：配置MPLS VPN</h2><h3 id="在PE上创建VRF"><a href="#在PE上创建VRF" class="headerlink" title="在PE上创建VRF"></a><strong>在PE上创建VRF</strong></h3><p>在PE1（R1）上创建VRF，并命名为A-Site1，表示该VRF为VPN A的站点1服务；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#ip vrf A-Site1   </span></span><br></pre></td></tr></table></figure>

<p>指定RD，为1:1，如果按照AS：num命名法，以下RD表示AS1中的第2个VRF；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-vrf)<span class="meta">#rd 1:1</span></span><br></pre></td></tr></table></figure>

<p>指定RT的导入和导出，这里我将RT指定为导入和导出1：1；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-vrf)<span class="meta">#route-target ?        </span></span><br><span class="line">    ASN:nn or IP-address:nn  Target VPN Extended Community</span><br><span class="line">    both                     Both import and export Target-VPN community</span><br><span class="line">    export                   Export Target-VPN community</span><br><span class="line">    import                   Import Target-VPN community</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-vrf)</span><span class="meta">#route-target both 1:1</span></span><br></pre></td></tr></table></figure>

<p>将PE1（R1）上与CE相连的PE接口F0&#x2F;1关联到VRF A-Site1；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#int f0/1</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#ip vrf forwarding A-Site1</span></span><br><span class="line">% Interface FastEthernet0/<span class="number">1</span> IPv4 disabled and <span class="title function_">address</span><span class="params">(es)</span> removed due to enabling VRF A-Site1</span><br><span class="line"><span class="comment">//切记先将接口关联VRF，然后再配置IP地址；</span></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-<span class="keyword">if</span>)</span><span class="meta">#ip add 192.168.15.1 255.255.255.0</span></span><br></pre></td></tr></table></figure>
<p>在PE2（R4）上创建VRF，并命名为A-Site2，表示该VRF为VPN A的站点2服务：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#ip vrf A-Site2</span></span><br></pre></td></tr></table></figure>

<p>指定RD，为1:2，如果按照AS：num命名法，以下RD表示AS1中的第2个VRF；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-vrf)<span class="meta">#rd 1:2</span></span><br></pre></td></tr></table></figure>

<p>指定RT的导入和导出，这里我将RT指定为导入和导出1：1；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-vrf)<span class="meta">#route-target both 1:1</span></span><br></pre></td></tr></table></figure>
<p>因为PE1导出的RT为1:1，PE2导入的RT正是PE1的导出RT1:1， 所以PE1（R1）的RT导出和PE2（R4）的RT导入能够匹配成功，R4能够学到R1导入到MP-BGP中的VPNv4路由；又因为PE2导出的RT为1:1，PE1导入的RT也正好是PE2的导出RT1:1；所以PE2（R4）的RT导出和PE1（R1）的RT导入能够匹配成对，R1能够学到R4导入到MP-BGP中的VPNv4路由。</p>
<p>将PE2（R4）上与CE相连的PE接口F0&#x2F;1关联到VRF A-Site2；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#int f0/1</span></span><br><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#ip vrf forwarding A-Site2</span></span><br><span class="line">% Interface FastEthernet0/<span class="number">1</span> IPv4 disabled and <span class="title function_">address</span><span class="params">(es)</span> removed due to enabling VRF A-Site2</span><br><span class="line"><span class="comment">//切记先将接口关联VRF，然后再配置IP地址；</span></span><br><span class="line"><span class="title function_">R4</span><span class="params">(config-<span class="keyword">if</span>)</span><span class="meta">#ip add 192.168.47.4 255.255.255.0</span></span><br></pre></td></tr></table></figure>
<h3 id="配置MP-BGP；"><a href="#配置MP-BGP；" class="headerlink" title="配置MP-BGP；"></a><strong>配置MP-BGP；</strong></h3><p>在PE1（R1）上配置MP-BGP，使之与其他PE建立IBGP关系，在此实验中只有PE1和PE2两台PE设备；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#no auto-summary</span></span><br><span class="line">R1(config-router)<span class="meta">#no syn</span></span><br><span class="line">R1(config-router)<span class="meta">#bgp router-id 1.1.1.1</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 remote-as 1</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 update-source l0</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 next-hop-self</span></span><br></pre></td></tr></table></figure>

<p>启用PE1（R1）的VPNv4地址族，并激活与IBGP邻居PE2（R4）的MP-BGP VPNv4邻居关系；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-router)<span class="meta">#address-family vpnv4</span></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 4.4.4.4 activate</span></span><br><span class="line"><span class="comment">//激活与IBGP邻居R4的VPNv4关系；</span></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 4.4.4.4 send-community ?</span></span><br><span class="line">    both      Send Standard and Extended Community attributes</span><br><span class="line">    extended  Send Extended Community attribute</span><br><span class="line">    standard  Send Standard Community attribute</span><br><span class="line">    &lt;cr&gt;</span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 4.4.4.4 send-community both</span></span><br><span class="line"><span class="comment">//由于BGP团体属性为可选传递属性，所以必须手动指定R1向IBGP邻居R4发送拓展团体属性和标准团体属性；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#exit-address-family</span></span><br><span class="line"><span class="comment">//退出AF配置模式；</span></span><br></pre></td></tr></table></figure>
<p>在PE2（R4）上配置MP-BGP，使之与其他PE建立IBGP关系，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#no auto-summary</span></span><br><span class="line">R4(config-router)<span class="meta">#no syn</span></span><br><span class="line">R4(config-router)<span class="meta">#bgp router-id 4.4.4.4</span></span><br><span class="line">R4(config-router)<span class="meta">#neighbor 1.1.1.1 remote-as 1</span></span><br><span class="line">R4(config-router)<span class="meta">#neighbor 1.1.1.1 update-source l0</span></span><br><span class="line">R4(config-router)<span class="meta">#neighbor 1.1.1.1 next-hop-self</span></span><br></pre></td></tr></table></figure>

<p>启用PE2（R4）的VPNv4地址族，并激活与IBGP邻居PE1（R1）的MP-BGP VPNv4邻居关系；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-router)<span class="meta">#address-family vpnv4</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 1.1.1.1 activate</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 1.1.1.1 send-community both</span></span><br></pre></td></tr></table></figure>
<h3 id="配置PE-CE路由；"><a href="#配置PE-CE路由；" class="headerlink" title="配置PE-CE路由；"></a><strong>配置PE-CE路由；</strong></h3><p>配置PE1（R1）的IGP；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router rip   </span></span><br><span class="line">R1(config-router)<span class="meta">#version 2</span></span><br><span class="line">R1(config-router)<span class="meta">#no auto-summary </span></span><br></pre></td></tr></table></figure>
<p>配置PE1（R1）的IGP地址族（AF）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入IGP RIP的AF模式；</span></span><br><span class="line">R1(config-router)<span class="meta">#address-family ipv4 ?</span></span><br><span class="line">    unicast  Address Family Modifier</span><br><span class="line">    vrf      Specify parameters <span class="keyword">for</span> a VPN Routing/Forwarding instance</span><br><span class="line">    &lt;cr&gt;</span><br><span class="line">R1(config-router)<span class="meta">#address-family ipv4 vrf A-Site1</span></span><br><span class="line">R4(config-router-af)<span class="meta">#version 2</span></span><br><span class="line">R4(config-router-af)<span class="meta">#no auto-summary</span></span><br><span class="line"><span class="comment">//将IGP RIP的IPv4 VRF地址族（AF）配置为RIPv2,并关闭自动汇总；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#redistribute bgp 1 metric ?</span></span><br><span class="line">    &lt;<span class="number">0</span><span class="number">-16</span>&gt;       Default metric</span><br><span class="line">    transparent  Transparently redistribute metric</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-router-af)</span><span class="meta">#redistribute bgp 1 metric transparent </span></span><br><span class="line"><span class="comment">// 关键字transparent表示透传，RIP将不会察觉到MPLS VPN的存在；</span></span><br><span class="line"><span class="comment">//必须指定Metric否则没有BGP能被重分布进RIP;</span></span><br><span class="line"><span class="comment">//将MP-BGP中IPv4 VRF名字与IGP中IPv4 VRF名字相同的地址族（AF）重分布进IGP的IPv4 VRF AF；</span></span><br><span class="line"><span class="comment">//IGP和MP-BGP中IPv4 VRF地址族（AF）实际上是执行相互重分发的操作；</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-router-af)</span><span class="meta">#network 192.168.15.0 </span></span><br><span class="line"><span class="comment">//将PE连接到CE的VRF接口宣告进IGP进程的IPv4 VRF地址族中；</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-router-af)</span><span class="meta">#exit-address-family</span></span><br><span class="line"><span class="comment">//退出IGP RIP的AF模式；</span></span><br></pre></td></tr></table></figure>
<p>配置PE1（R1）的MP-BGP IPv4 VRF地址族（AF）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line"><span class="comment">//进入MP-BGP的IPv4 VRF地址族（AF）；</span></span><br><span class="line">R1(config-router)<span class="meta">#address-family ipv4 vrf A-Site1</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#redistribute rip </span></span><br><span class="line"><span class="comment">//将IGP中IPv4 VRF名字与MP-BGP中IPv4 VRF名字相同的地址族（AF）重分布进MP-BGP的IPv4 VRF AF；</span></span><br><span class="line"><span class="comment">//IGP和MP-BGP中IPv4 VRF地址族（AF）实际上是执行相互重分发的操作；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#redistribute connected </span></span><br><span class="line"><span class="comment">//如果用户在CE路由器上ping远程网络的另一个VPN站点中的CE或C路由器，</span></span><br><span class="line"><span class="comment">//为了使其在没有指定其源地址情况下（即默认使用CE路由器出站接口IP地址），Echo Reply包能够有路由并正常返回,</span></span><br><span class="line"><span class="comment">//将PE路由器的直连路由重分布进MP-BGP的IPv4 VRF AF中；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#exit-address-family </span></span><br><span class="line"><span class="comment">//退出MP-BGP的IPv4 VRF地址族（AF）模式；</span></span><br></pre></td></tr></table></figure>
<p>配置PE2（R4）的IGP；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#router rip</span></span><br><span class="line">R4(config-router)<span class="meta">#version 2</span></span><br><span class="line">R4(config-router)<span class="meta">#no auto-summary</span></span><br></pre></td></tr></table></figure>

<p>配置PE2（R4）的IGP地址族（AF）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-router)<span class="meta">#address-family ipv4 vrf A-Site2</span></span><br><span class="line">R4(config-router-af)<span class="meta">#version 2</span></span><br><span class="line">R4(config-router-af)<span class="meta">#no auto-summary</span></span><br><span class="line">R4(config-router-af)<span class="meta">#redistribute bgp 1 metric transparent</span></span><br><span class="line">R4(config-router-af)<span class="meta">#network 192.168.47.0</span></span><br><span class="line">R4(config-router-af)<span class="meta">#exit-address-family</span></span><br></pre></td></tr></table></figure>
<p>配置PE2（R4）的MP-BGP IPv4 VRF地址族（AF）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#address-family ipv4 vrf A-Site2</span></span><br><span class="line">R4(config-router-af)<span class="meta">#redistribute connected</span></span><br><span class="line">R4(config-router-af)<span class="meta">#redistribute rip</span></span><br><span class="line">R4(config-router-af)<span class="meta">#exit-address-family</span></span><br></pre></td></tr></table></figure>
<h3 id="验证与调试："><a href="#验证与调试：" class="headerlink" title="验证与调试："></a>验证与调试：</h3><p>以ping 8.8.8.8的ICMP包转发交换过程为例，验证并解释MPLS VPN中数据包交换过程；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在VPN A站点1的C路由器R6上ping远程VPN A站点2的C路由器R8；</span></span><br><span class="line">R6<span class="meta">#ping 8.8.8.8</span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Sending <span class="number">5</span>, <span class="number">100</span>-byte ICMP Echos to <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, timeout is <span class="number">2</span> seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is <span class="number">100</span> percent (<span class="number">5</span>/<span class="number">5</span>), round-trip min/avg/max = <span class="number">132</span>/<span class="number">160</span>/<span class="number">196</span> ms</span><br><span class="line"><span class="comment">//成功！</span></span><br></pre></td></tr></table></figure>


<p>VPN A站点1的C路由器R6在发送ICMP echo Request数据包之前查看IP路由表，准确的说不是查看路由表，而是CEF表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R6<span class="meta">#sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">                                                            </span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">                                                            </span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">R        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">120</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">08</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">6.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">R        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> [<span class="number">120</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">08</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">8.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">R        <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> [<span class="number">120</span>/<span class="number">4</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">08</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">R     <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">120</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">08</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">R     <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">120</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">08</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.56</span><span class="number">.6</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">R     <span class="number">192.168</span><span class="number">.78</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">120</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">08</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line"><span class="comment">//R6有关于8.8.8.8/32的路由条目，并且是通过RIP从R5学到的；</span></span><br><span class="line"><span class="comment">//R6将数据包转发给R5；</span></span><br></pre></td></tr></table></figure>

<p>此时Echo Request包达到R5，查看R5的IP路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R5<span class="meta">#sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">                                                            </span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">                                                            </span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">6.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">R        <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> [<span class="number">120</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.6</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">05</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">R        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> [<span class="number">120</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">23</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">8.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">R        <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> [<span class="number">120</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">23</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">R     <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">120</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">23</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">R     <span class="number">192.168</span><span class="number">.78</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">120</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">23</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line"><span class="comment">//R5发现自己拥有关于8.8.8.8/32的路由条目，并且此路由条目是通过RIP从PE1（R1）学到的；</span></span><br><span class="line"><span class="comment">//R5将数据包转发给PE1（R1）；</span></span><br></pre></td></tr></table></figure>

<p><strong>此时Echo Request包抵达PE1（R1）；</strong></p>
<p>由于从R5转发来的ping包是在接口F0&#x2F;1上收到的，而此接口又与VRF A-Site1相关联，所以PE1需要查看IP vrf A-Site1路由表；准确的说也不是查看IP vrf A-Site1路由表，而是查看IP CEF vrf A-Site1表，但毕竟CEF表来自于路由表，这里只是为了说明选路的依据；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show ip route vrf A-Site1</span></span><br><span class="line"></span><br><span class="line">Routing Table: A-Site1</span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">R        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">120</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">04</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">6.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">R        <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> [<span class="number">120</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">04</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> [<span class="number">200</span>/<span class="number">1</span>] via <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>, <span class="number">01</span>:<span class="number">40</span>:<span class="number">04</span></span><br><span class="line">        <span class="number">8.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">B        <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> [<span class="number">200</span>/<span class="number">2</span>] via <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>, <span class="number">01</span>:<span class="number">40</span>:<span class="number">04</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">200</span>/<span class="number">0</span>] via <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>, <span class="number">01</span>:<span class="number">40</span>:<span class="number">04</span></span><br><span class="line">R     <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">120</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">04</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">B     <span class="number">192.168</span><span class="number">.78</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">200</span>/<span class="number">1</span>] via <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>, <span class="number">01</span>:<span class="number">40</span>:<span class="number">04</span></span><br></pre></td></tr></table></figure>

<p>PE1（R1）发现自己拥有关于8.8.8.8&#x2F;32的路由条目，并且此路由条目是通过IBGP从R4（PE2）学到的；与纯MPLS网络中一样，去往8.8.8.8&#x2F;32的路由需要递归查找明确的下一跳；要达到8.8.8.8&#x2F;32必须先到达4.4.4.4&#x2F;32，因为4.4.4.4&#x2F;32不是VPNv4路由，所以4.4.4.4&#x2F;32的路由存在于普通IP路由表中；</p>
<p>因而要达到4.4.4.4&#x2F;32就必须查看普通IP路由表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">                                                            </span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">                                                            </span><br><span class="line">        <span class="number">1.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">2.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>, <span class="number">02</span>:<span class="number">08</span>:<span class="number">31</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">3.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> [<span class="number">110</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>, <span class="number">02</span>:<span class="number">08</span>:<span class="number">21</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">4.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> [<span class="number">110</span>/<span class="number">4</span>] via <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>, <span class="number">02</span>:<span class="number">08</span>:<span class="number">21</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>, <span class="number">02</span>:<span class="number">08</span>:<span class="number">21</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>, <span class="number">02</span>:<span class="number">08</span>:<span class="number">21</span>, FastEthernet0/<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>要去往4.4.4.4&#x2F;32就必须到达192.168.12.2，至此PE1发现了关于8.8.8.8&#x2F;32明确的下一跳；</p>
<p>由于关于8.8.8.8&#x2F;32的BGP路由器条目是一条VPNv4路由，所以查看PE1的IP BGP VPNv4表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show ip bgp vpnv4 all</span></span><br><span class="line">BGP table version is <span class="number">13</span>, local router ID is <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">                r RIB-failure, S Stale, m multipath, b backup-path, x best-external, f RT-Filter</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line"></span><br><span class="line">    Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: <span class="number">1</span>:<span class="number">1</span> (<span class="keyword">default</span> <span class="keyword">for</span> vrf A-Site1)</span><br><span class="line">*&gt; <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>             <span class="number">1</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt; <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>             <span class="number">2</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt;i7<span class="number">.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">1</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt;i8<span class="number">.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>       <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">2</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>                  <span class="number">0</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt;i192<span class="number">.168</span><span class="number">.47</span><span class="number">.0</span>     <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>             <span class="number">1</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt;i192<span class="number">.168</span><span class="number">.78</span><span class="number">.0</span>     <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">1</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">Route Distinguisher: <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">*&gt;i7<span class="number">.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">1</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt;i8<span class="number">.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>       <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">2</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt;i192<span class="number">.168</span><span class="number">.47</span><span class="number">.0</span>     <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt;i192<span class="number">.168</span><span class="number">.78</span><span class="number">.0</span>     <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">1</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br></pre></td></tr></table></figure>

<p>查看PE1的IP BGP VPNv4表明细路由；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show ip bgp vpnv4 rd 1:1 8.8.8.8</span></span><br><span class="line">BGP routing table entry <span class="keyword">for</span> <span class="number">1</span>:<span class="number">1</span>:<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>, version <span class="number">11</span></span><br><span class="line">Paths: (<span class="number">1</span> available, best #<span class="number">1</span>, table A-Site1)</span><br><span class="line">    Not advertised to any peer</span><br><span class="line">    Local, imported path from <span class="number">1</span>:<span class="number">2</span>:<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span></span><br><span class="line">    <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> (metric <span class="number">4</span>) from <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> (<span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>)</span><br><span class="line">        Origin incomplete, metric <span class="number">2</span>, localpref <span class="number">100</span>, valid, internal, best</span><br><span class="line">        Extended Community: RT:<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        mpls labels in/out nolabel/<span class="number">22</span><span class="comment">//标签22是远程PE2（R4）MP-BGP通告的VPNv4路由中包含的VPNv4标签，此标签被用作MPLS VPN的栈底标签；</span></span><br><span class="line"></span><br><span class="line">R1<span class="meta">#show ip bgp vpnv4 rd 1:2 8.8.8.8</span></span><br><span class="line">BGP routing table entry <span class="keyword">for</span> <span class="number">1</span>:<span class="number">2</span>:<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>, version <span class="number">7</span></span><br><span class="line">Paths: (<span class="number">1</span> available, best #<span class="number">1</span>, no table)</span><br><span class="line">    Not advertised to any peer</span><br><span class="line">    Local</span><br><span class="line">    <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> (metric <span class="number">4</span>) from <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> (<span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>)</span><br><span class="line">        Origin incomplete, metric <span class="number">2</span>, localpref <span class="number">100</span>, valid, internal, best</span><br><span class="line">        Extended Community: RT:<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        mpls labels in/out nolabel/<span class="number">22</span><span class="comment">//标签22是远程PE2（R4）MP-BGP通告的VPNv4路由中包含的VPNv4标签，此标签被用作MPLS VPN的栈底标签；</span></span><br></pre></td></tr></table></figure>

<p>查看LFIB表中关于8.8.8.8&#x2F;32的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show mpls forwarding-table vrf A-Site1 8.8.8.8 detail</span></span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop    </span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface              </span><br><span class="line">None       <span class="number">22</span>         <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>[V]    <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span></span><br><span class="line">        MAC/Encaps=<span class="number">14</span>/<span class="number">22</span>, MRU=<span class="number">1496</span>, Label Stack&#123;<span class="number">17</span> <span class="number">22</span>&#125; <span class="comment">//标签栈中有两个标签，标签17用于在AS1中转发数据，栈底标签22为VPNv4标签；</span></span><br><span class="line">        CA0518300008CA04183000088847 <span class="number">0001100000016000</span></span><br><span class="line">        VPN route: A-Site1</span><br><span class="line">        No output feature configured</span><br></pre></td></tr></table></figure>

<p>知道了前缀8.8.8.8&#x2F;32的递归下一跳之后，沿递归路径查看每一跳的标签信息；查看PE1的IP CEF VRF A-Site1表中8.8.8.8的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#sh ip cef vrf A-Site1 8.8.8.8 detail</span></span><br><span class="line"><span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>, epoch <span class="number">0</span>, flags rib defined all labels</span><br><span class="line">    recursive via <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> label <span class="number">22</span><span class="comment">//标签22为栈底的VPNv4标签；</span></span><br><span class="line">    nexthop <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> FastEthernet0/<span class="number">0</span> label <span class="number">17</span><span class="comment">//8.8.8.8/32递归&quot;继承了&quot;4.4.4.4的标签17；</span></span><br></pre></td></tr></table></figure>

<p>查看PE1（R1）的IP CEF表中4.4.4.4的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#sh ip cef 4.4.4.4 detail</span></span><br><span class="line"><span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>, epoch <span class="number">0</span></span><br><span class="line">    local label info: global/<span class="number">18</span></span><br><span class="line">    <span class="number">1</span> RR source [no flags]</span><br><span class="line">    nexthop <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> FastEthernet0/<span class="number">0</span> label <span class="number">17</span></span><br><span class="line"><span class="comment">//标签17为PE1（R1）关于前缀4.4.4.4/32的出站标签，也就是R2通告给R1的入站标签；</span></span><br></pre></td></tr></table></figure>

<p>查看PE1（R1）的IP CEF表中192.168.12.2的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show ip cef 192.168.12.2 detail</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>/<span class="number">32</span>, epoch <span class="number">0</span>, flags attached</span><br><span class="line">    Adj source: IP adj out of FastEthernet0/<span class="number">0</span>, addr <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> <span class="number">6819</span>D980</span><br><span class="line">    Dependent covered prefix type adjfib cover <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line">    attached to FastEthernet0/<span class="number">0</span></span><br><span class="line"><span class="comment">//由于R1与192.168.12.0/24直连，所以不再需要在进行标签转发，所以R1没有关于192.168.12.0/24的出标签；</span></span><br></pre></td></tr></table></figure>

<p>至此，PE1（R1）为数据包打上出标签17，并将数据转发给R2；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此时ping包抵达R2；</span></span><br><span class="line"><span class="comment">//查看R2的LFIB表；</span></span><br><span class="line">R2<span class="meta">#show mpls forwarding-table</span></span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop    </span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface              </span><br><span class="line"><span class="number">16</span>         Pop Label  <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>       <span class="number">20757</span>         Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span></span><br><span class="line"><span class="number">17</span>         <span class="number">16</span>         <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>       <span class="number">22341</span>         Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.23</span><span class="number">.3</span></span><br><span class="line"><span class="number">18</span>         Pop Label  <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.23</span><span class="number">.3</span></span><br><span class="line"><span class="number">19</span>         Pop Label  <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span>  <span class="number">0</span>             Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.23</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>
<p>在收到R1转发来的带有R2本地标签17的数据包后，R2使用为数据包打上出标签16，并将其转发给R3；</p>
<p><strong>注意：递归查找路由表只会发生在运行BGP并与其他PE路由器建立IBGP关系的PE路由器，而在P路由器上，由于没有运行BGP，不可能有相关路由信息，所以只按照标签转发。</strong></p>
<p>此时ping包抵达R3；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看R3的LFIB表；</span></span><br><span class="line">R3<span class="meta">#show mpls forwarding-table</span></span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop    </span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface              </span><br><span class="line"><span class="number">16</span>         Pop Label  <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>/<span class="number">32</span>       <span class="number">27288</span>         Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span></span><br><span class="line"><span class="number">17</span>         Pop Label  <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span></span><br><span class="line"><span class="number">18</span>         <span class="number">16</span>         <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>       <span class="number">29345</span>         Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span></span><br><span class="line"><span class="number">19</span>         Pop Label  <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span>  <span class="number">0</span>             Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span></span><br><span class="line"><span class="comment">//R3弹出栈顶标签，并将数据转发给PE2（R4）；</span></span><br></pre></td></tr></table></figure>

<p>此时ping包抵达PE2（R4），由于数据中栈顶的标签被弹出，所以原本栈底的VPNv4标签就变成了栈顶标签；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看PE2（R4）的LFIB表；</span></span><br><span class="line">R4<span class="meta">#show mpls forwarding-table</span></span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop    </span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface              </span><br><span class="line"><span class="number">16</span>         Pop Label  <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br><span class="line"><span class="number">17</span>         Pop Label  <span class="number">192.168</span><span class="number">.23</span><span class="number">.0</span>/<span class="number">24</span>  <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br><span class="line"><span class="number">18</span>         <span class="number">17</span>         <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br><span class="line"><span class="number">19</span>         <span class="number">18</span>         <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span>       <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br><span class="line"><span class="number">20</span>         <span class="number">19</span>         <span class="number">192.168</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span>  <span class="number">0</span>             Fa0/<span class="number">0</span>      <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span></span><br><span class="line"><span class="number">21</span>         No Label   <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>[V]    <span class="number">0</span>             Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span></span><br><span class="line"><span class="number">22</span>         No Label   <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>[V]    <span class="number">570</span>           Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span></span><br><span class="line"><span class="number">23</span>         No Label   <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span>[V]   \</span><br><span class="line">                                        <span class="number">0</span>             aggregate/A-Site2 </span><br><span class="line"><span class="number">24</span>         No Label   <span class="number">192.168</span><span class="number">.78</span><span class="number">.0</span>/<span class="number">24</span>[V]   \</span><br><span class="line">                                        <span class="number">0</span>             Fa0/<span class="number">1</span>      <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span></span><br></pre></td></tr></table></figure>
<p>R4收到携带VPNv4标签22的Echo Request数据后，移除Echo Request数据的标签栈，将其转发给R7。</p>
<p>数据到达R7后，按照正常的转发方式被转发到R8。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7<span class="meta">#show ip route 8.8.8.8</span></span><br><span class="line">Routing entry <span class="keyword">for</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span></span><br><span class="line">    Known via <span class="string">&quot;rip&quot;</span>, distance <span class="number">120</span>, metric <span class="number">1</span></span><br><span class="line">    Redistributing via rip</span><br><span class="line">    Last update from <span class="number">192.168</span><span class="number">.78</span><span class="number">.8</span> on FastEthernet0/<span class="number">0</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">07</span> ago</span><br><span class="line">    Routing Descriptor Blocks:</span><br><span class="line">    * <span class="number">192.168</span><span class="number">.78</span><span class="number">.8</span>, from <span class="number">192.168</span><span class="number">.78</span><span class="number">.8</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">07</span> ago, via FastEthernet0/<span class="number">0</span></span><br><span class="line">        Route metric is <span class="number">1</span>, traffic share count is <span class="number">1</span></span><br><span class="line">R7<span class="meta">#show ip cef 8.8.8.8 detail </span></span><br><span class="line"><span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>, epoch <span class="number">0</span></span><br><span class="line">    nexthop <span class="number">192.168</span><span class="number">.78</span><span class="number">.8</span> FastEthernet0/<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>最终，ICMP Echo Request达到了R8，返回R6的ICMP Echo Reply的方向相反，但是过程和操作是一样的。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>MPLS</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLS 实验7：MPLS VPN running EIGRP on the PE-CE link</title>
    <url>/2014/MPLS_Lab_7/</url>
    <content><![CDATA[<h1 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h1><ul>
<li>模拟器：GNS3 0.8.6</li>
<li>Cisco IOS：c7200-adventerprisek9-mz.151-4.M2.image</li>
</ul>
<h1 id="GNS3实验拓扑文件："><a href="#GNS3实验拓扑文件：" class="headerlink" title="GNS3实验拓扑文件："></a>GNS3实验拓扑文件：</h1><p><a href="topology.net">拓扑文件</a></p>
<span id="more"></span>

<h1 id="基本预配置："><a href="#基本预配置：" class="headerlink" title="基本预配置："></a>基本预配置：</h1><h2 id="R1："><a href="#R1：" class="headerlink" title="R1："></a>R1：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 1.1.1.1 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.12.1 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shut</span><br><span class="line">    mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.15.1 255.255.255.0</span><br><span class="line">    no shut</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 1.1.1.1</span><br><span class="line">!         </span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 2.2.2.2 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.12.2 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">    mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.23.2 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">    mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 2.2.2.2</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R3"><a href="#R3" class="headerlink" title="R3:"></a>R3:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R3</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 3.3.3.3 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.34.3 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">    mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.23.3 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">    mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 3.3.3.3</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R4"><a href="#R4" class="headerlink" title="R4:"></a>R4:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R4</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 4.4.4.4 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.34.4 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.47.4 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 4.4.4.4</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R5"><a href="#R5" class="headerlink" title="R5:"></a>R5:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R5</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 5.5.5.5 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.56.5 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.15.5 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router eigrp 1</span><br><span class="line">    network 5.5.5.5 0.0.0.0</span><br><span class="line">    network 192.168.15.5 0.0.0.0</span><br><span class="line">    network 192.168.56.0</span><br><span class="line">    eigrp router-id 5.5.5.5</span><br><span class="line">    no auto-summary</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R6"><a href="#R6" class="headerlink" title="R6:"></a>R6:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R6</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 6.6.6.6 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.56.6 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router eigrp 1</span><br><span class="line">    network 6.6.6.6 0.0.0.0</span><br><span class="line">    network 192.168.56.0</span><br><span class="line">    eigrp router-id 6.6.6.6</span><br><span class="line">    no auto-summary</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R7"><a href="#R7" class="headerlink" title="R7:"></a>R7:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R7</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 7.7.7.7 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.78.7 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.47.7 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router eigrp 1</span><br><span class="line">    network 7.7.7.7 0.0.0.0</span><br><span class="line">    network 192.168.47.0</span><br><span class="line">    network 192.168.78.0</span><br><span class="line">    eigrp router-id 7.7.7.7</span><br><span class="line">    no auto-summary</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R8"><a href="#R8" class="headerlink" title="R8:"></a>R8:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R8</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 8.8.8.8 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.78.8 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router eigrp 1</span><br><span class="line">    network 8.8.8.8 0.0.0.0</span><br><span class="line">    network 192.168.78.0</span><br><span class="line">    eigrp router-id 8.8.8.8</span><br><span class="line">    no auto-summary</span><br><span class="line">!         </span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h1 id="MPLS-VPN配置步骤："><a href="#MPLS-VPN配置步骤：" class="headerlink" title="MPLS VPN配置步骤："></a>MPLS VPN配置步骤：</h1><ol>
<li>创建VRF（VRF名本地有效）：<ul>
<li>指定RD（提供全局唯一的私网单播地址）；</li>
<li>指定RT的导出（导出：把重分发进MP-BGP的VPNv4路由打上MP-BGP扩展团体属性RT）和导入（导入：把MP-BGP里的VPNv4路由进行RT的匹配，匹配成功的VPNv4路由将放进相应的VRF）；</li>
<li>将与CE相连的PE接口关联特定VRF；</li>
</ul>
</li>
<li>配置MP-BGP：<ul>
<li>配置建立PE之间的IBGP邻居关系；</li>
<li>启用VPNv4地址族（AF），并激活与其他PE设备的邻居关系；</li>
</ul>
</li>
<li>配置PE-CE路由；<ul>
<li>配置IGP，并启用IGP的地址族（AF）；</li>
<li>配置启用MP-BGP IPv4 VRF地址族，然后激活与其他PE路由器的MP-BGP IPv4 VRF邻居关系；</li>
</ul>
</li>
</ol>
<h1 id="实验与调试："><a href="#实验与调试：" class="headerlink" title="实验与调试："></a>实验与调试：</h1><h2 id="实验1：不同的VPN站点之间使用的EIGRP-AS号相同；"><a href="#实验1：不同的VPN站点之间使用的EIGRP-AS号相同；" class="headerlink" title="实验1：不同的VPN站点之间使用的EIGRP AS号相同；"></a>实验1：不同的VPN站点之间使用的EIGRP AS号相同；</h2><h3 id="实验1拓扑"><a href="#实验1拓扑" class="headerlink" title="实验1拓扑:"></a>实验1拓扑:</h3><p><img src="/2014/MPLS_Lab_7/topo1.png"></p>
<h3 id="在PE上创建VRF"><a href="#在PE上创建VRF" class="headerlink" title="在PE上创建VRF"></a><strong>在PE上创建VRF</strong></h3><p>在PE1（R1）上创建VRF，并命名为A-Site1，表示该VRF为VPN A的站点1服务；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#ip vrf A-Site1   </span></span><br></pre></td></tr></table></figure>

<p>指定RD，为1:1，如果按照AS：num命名法，以下RD表示AS1中的第2个VRF；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-vrf)<span class="meta">#rd 1:1</span></span><br></pre></td></tr></table></figure>

<p>指定RT的导入和导出，这里我将RT指定为导入和导出1：1；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-vrf)<span class="meta">#route-target ?        </span></span><br><span class="line">    ASN:nn or IP-address:nn  Target VPN Extended Community</span><br><span class="line">    both                     Both import and export Target-VPN community</span><br><span class="line">    export                   Export Target-VPN community</span><br><span class="line">    import                   Import Target-VPN community</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-vrf)</span><span class="meta">#route-target export 1:1</span></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-vrf)</span><span class="meta">#route-target import 1:2</span></span><br></pre></td></tr></table></figure>

<p>将PE1（R1）上与CE相连的PE接口F0&#x2F;1关联到VRF A-Site1；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#int f0/1</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#ip vrf forwarding A-Site1</span></span><br><span class="line">% Interface FastEthernet0/<span class="number">1</span> IPv4 disabled and <span class="title function_">address</span><span class="params">(es)</span> removed due to enabling VRF A-Site1</span><br><span class="line">    <span class="comment">//切记先将接口关联VRF，然后再配置IP地址；</span></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-<span class="keyword">if</span>)</span><span class="meta">#ip add 192.168.15.1 255.255.255.0</span></span><br></pre></td></tr></table></figure>
<p>在PE2（R4）上创建VRF，并命名为A-Site2，表示该VRF为VPN A的站点2服务；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#ip vrf A-Site2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定RD，为1:2，如果按照AS：num命名法，以下RD表示AS1中的第2个VRF；</span></span><br><span class="line">R4(config-vrf)<span class="meta">#rd 1:2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定RT的导入和导出，这里我将RT指定为导入和导出1：1；</span></span><br><span class="line">R4(config-vrf)<span class="meta">#route-target export 1:2</span></span><br><span class="line">R4(config-vrf)<span class="meta">#route-target import 1:1</span></span><br></pre></td></tr></table></figure>
<p>因为PE1导出的RT为1:1，PE2导入的RT正是PE1的导出RT1:1；所以PE1（R1）的RT导出和PE2（R4）的RT导入能够匹配成功，R4能够学到R1导入到MP-BGP中的VPNv4路由；又因为PE2导出的RT为1:2，PE1导入的RT正是PE2的导出RT1:2；所以PE2（R4）的RT导出和PE1（R1）的RT导入能够匹配成对，R1能够学到R4导入到MP-BGP中的VPNv4路由；</p>
<p>将PE2（R4）上与CE相连的PE接口F0&#x2F;1关联到VRF A-Site2；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#int f0/1</span></span><br><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#ip vrf forwarding A-Site2</span></span><br><span class="line">% Interface FastEthernet0/<span class="number">1</span> IPv4 disabled and <span class="title function_">address</span><span class="params">(es)</span> removed due to enabling VRF A-Site2</span><br><span class="line">    <span class="comment">//切记先将接口关联VRF，然后再配置IP地址；</span></span><br><span class="line"><span class="title function_">R4</span><span class="params">(config-<span class="keyword">if</span>)</span><span class="meta">#ip add 192.168.47.4 255.255.255.0</span></span><br></pre></td></tr></table></figure>
<h3 id="配置MP-BGP"><a href="#配置MP-BGP" class="headerlink" title="配置MP-BGP"></a><strong>配置MP-BGP</strong></h3><p>在PE1（R1）上配置MP-BGP，使之与其他PE建立IBGP关系，在此实验中只有PE1和PE2两台PE设备；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#no auto-summary</span></span><br><span class="line">R1(config-router)<span class="meta">#no syn</span></span><br><span class="line">R1(config-router)<span class="meta">#bgp router-id 1.1.1.1</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 remote-as 1</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 update-source l0</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 next-hop-self</span></span><br></pre></td></tr></table></figure>

<p>启用PE1（R1）的VPNv4地址族，并激活与IBGP邻居PE2（R4）的MP-BGP VPNv4邻居关系；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-router)<span class="meta">#address-family vpnv4</span></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 4.4.4.4 activate</span></span><br><span class="line"><span class="comment">//激活与IBGP邻居R4的VPNv4关系；</span></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 4.4.4.4 send-community ?</span></span><br><span class="line">    both      Send Standard and Extended Community attributes</span><br><span class="line">    extended  Send Extended Community attribute</span><br><span class="line">    standard  Send Standard Community attribute</span><br><span class="line">    &lt;cr&gt;</span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 4.4.4.4 send-community both</span></span><br><span class="line"><span class="comment">//由于BGP团体属性为可选传递属性，所以必须手动指定R1向IBGP邻居R4发送拓展团体属性和标准团体属性；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#exit-address-family</span></span><br><span class="line"><span class="comment">//退出AF配置模式；</span></span><br></pre></td></tr></table></figure>
<p>在PE2（R4）上配置MP-BGP，使之与其他PE建立IBGP关系，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#no auto-summary</span></span><br><span class="line">R4(config-router)<span class="meta">#no syn</span></span><br><span class="line">R4(config-router)<span class="meta">#bgp router-id 4.4.4.4</span></span><br><span class="line">R4(config-router)<span class="meta">#neighbor 1.1.1.1 remote-as 1</span></span><br><span class="line">R4(config-router)<span class="meta">#neighbor 1.1.1.1 update-source l0</span></span><br><span class="line">R4(config-router)<span class="meta">#neighbor 1.1.1.1 next-hop-self</span></span><br></pre></td></tr></table></figure>

<p>启用PE2（R4）的VPNv4地址族，并激活与IBGP邻居PE1（R1）的MP-BGP VPNv4邻居关系；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-router)<span class="meta">#address-family vpnv4</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 1.1.1.1 activate</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 1.1.1.1 send-community both</span></span><br></pre></td></tr></table></figure>
<h3 id="配置PE-CE路由"><a href="#配置PE-CE路由" class="headerlink" title="配置PE-CE路由"></a><strong>配置PE-CE路由</strong></h3><p>配置PE1（R1）的IGP；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router eigrp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#no auto-summary</span></span><br></pre></td></tr></table></figure>

<p>配置PE1（R1）的IGP地址族（AF）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-router)<span class="meta">#address-family ipv4 vrf A-Site1 ?                   </span></span><br><span class="line">    autonomous-system  Specify Address-Family Autonomous System Number</span><br><span class="line">    &lt;cr&gt;</span><br><span class="line"></span><br><span class="line">R1(config-router)<span class="meta">#address-family ipv4 vrf A-Site1 autonomous-system 1</span></span><br><span class="line"><span class="comment">//进入IGP EIGRP的AF模式，切记为EIGRP ipv4 vrf地址族（AF）指定一个EIGRP自治系统号；</span></span><br><span class="line"><span class="comment">//由于在实施MPLS VPN，ISP和VPN客服站点本地可能就已经部署了EIGRP，并为EIGRP指定了不同的AS号,</span></span><br><span class="line"><span class="comment">//而在实施MPLS VPN将PE和站点的CE连接起来的时候，由于PE和CE部署EIGRP时没有使用相同的AS号，</span></span><br><span class="line"><span class="comment">//所以PE和CE无法建立EIGRP邻居关系；</span></span><br><span class="line"><span class="comment">//为避免修改原始EIGRP的AS号，因此，在EIGRP的ipv4 vrf地址族（AF）里为PE和CE指定相同的EIGRP AS号；</span></span><br><span class="line"></span><br><span class="line">R4(config-router-af)<span class="meta">#no auto-summary</span></span><br><span class="line"><span class="comment">//将IGP EIGRP的IPv4 VRF地址族（AF）关闭自动汇总；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#redistribute bgp 1 metric 10000 100 255 1 1500</span></span><br><span class="line"><span class="comment">//必须指定Metric;</span></span><br><span class="line"><span class="comment">//将MP-BGP中IPv4 VRF名字与IGP中IPv4 VRF名字相同的地址族（AF）重分布进IGP的IPv4 VRF AF；</span></span><br><span class="line"><span class="comment">//IGP和MP-BGP中IPv4 VRF地址族（AF）实际上是执行相互重分发的操作；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#network 192.168.15.0 0.0.0.255 </span></span><br><span class="line"><span class="comment">//将PE连接到CE的VRF接口宣告进IGP EIGRP进程的IPv4 VRF地址族中；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#exit-address-family</span></span><br><span class="line"><span class="comment">//退出IGP EIGRP的AF模式；</span></span><br></pre></td></tr></table></figure>
<p>配置PE1（R1）的MP-BGP IPv4 VRF地址族（AF）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#address-family ipv4 vrf A-Site1</span></span><br><span class="line"><span class="comment">//进入MP-BGP的IPv4 VRF地址族（AF）；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#redistribute eigrp 1 </span></span><br><span class="line"><span class="comment">//将IGP中IPv4 VRF名字与MP-BGP中IPv4 VRF名字相同的地址族（AF）重分布进MP-BGP的IPv4 VRF AF；</span></span><br><span class="line"><span class="comment">//IGP和MP-BGP中IPv4 VRF地址族（AF）实际上是执行相互重分发的操作；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#redistribute connected </span></span><br><span class="line"><span class="comment">//如果用户在CE路由器上ping远程网络的另一个VPN站点中的CE或C路由器，</span></span><br><span class="line"><span class="comment">//为了使其在没有指定其源地址情况下（即默认使用CE路由器出站接口IP地址），Echo Reply包能够有路由并正常返回,</span></span><br><span class="line"><span class="comment">//将PE路由器的直连路由重分布进MP-BGP的IPv4 VRF AF中；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#exit-address-family </span></span><br><span class="line"><span class="comment">//退出MP-BGP的IPv4 VRF地址族（AF）模式；</span></span><br></pre></td></tr></table></figure>
<p>配置PE2（R4）的IGP；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#router eigrp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#no auto-summary</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置PE2（R4）的IGP地址族（AF）；</span></span><br><span class="line">R4(config-router)<span class="meta">#address-family ipv4 vrf A-Site2 autonomous-system 1</span></span><br><span class="line">R4(config-router-af)<span class="meta">#no auto-summary</span></span><br><span class="line">R4(config-router-af)<span class="meta">#redistribute bgp 1 metric 10000 100 255 1 1500</span></span><br><span class="line">R4(config-router-af)<span class="meta">#network 192.168.47.0 0.0.0.255</span></span><br><span class="line">R4(config-router-af)<span class="meta">#exit-address-family</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置PE2（R4）的MP-BGP IPv4 VRF地址族（AF）；</span></span><br><span class="line">R4(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#address-family ipv4 vrf A-Site2</span></span><br><span class="line">R4(config-router-af)<span class="meta">#redistribute connected</span></span><br><span class="line">R4(config-router-af)<span class="meta">#redistribute eigrp 1</span></span><br><span class="line">R4(config-router-af)<span class="meta">#exit-address-family</span></span><br></pre></td></tr></table></figure>
<h3 id="验证与调试："><a href="#验证与调试：" class="headerlink" title="验证与调试："></a>验证与调试：</h3><p>在VPN A站点1的C路由器R6上ping远程VPN A站点2的C路由器R8；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R6(config-router)<span class="meta">#do p 8.8.8.8</span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Sending <span class="number">5</span>, <span class="number">100</span>-byte ICMP Echos to <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, timeout is <span class="number">2</span> seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is <span class="number">100</span> percent (<span class="number">5</span>/<span class="number">5</span>), round-trip min/avg/max = <span class="number">132</span>/<span class="number">162</span>/<span class="number">232</span> ms</span><br><span class="line"><span class="comment">//成功！</span></span><br></pre></td></tr></table></figure>

<p>查看R1的IP BGP VPNv4路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-vrf)<span class="meta">#do sh ip bgp vpnv4 all</span></span><br><span class="line">BGP table version is <span class="number">86</span>, local router ID is <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">                r RIB-failure, S Stale, m multipath, b backup-path, x best-external, f RT-Filter</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">                                                                                </span><br><span class="line">    Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: <span class="number">1</span>:<span class="number">1</span> (<span class="keyword">default</span> <span class="keyword">for</span> vrf A-Site1)</span><br><span class="line">*&gt; <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>        <span class="number">156160</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt; <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>        <span class="number">158720</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt;i7<span class="number">.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>             <span class="number">156160</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt;i8<span class="number">.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>       <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>             <span class="number">158720</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>                  <span class="number">0</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt;i192<span class="number">.168</span><span class="number">.47</span><span class="number">.0</span>     <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>         <span class="number">30720</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt;i192<span class="number">.168</span><span class="number">.78</span><span class="number">.0</span>     <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>         <span class="number">4278221055</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">Route Distinguisher: <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">*&gt;i7<span class="number">.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>             <span class="number">156160</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt;i8<span class="number">.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>       <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>             <span class="number">158720</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt;i192<span class="number">.168</span><span class="number">.47</span><span class="number">.0</span>     <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt;i192<span class="number">.168</span><span class="number">.78</span><span class="number">.0</span>     <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>         <span class="number">4278221055</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br></pre></td></tr></table></figure>

<p>删除R1上ip vrf A-Site1的RT导入1：2；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#ip vrf A-Site1</span></span><br><span class="line">R1(config-vrf)<span class="meta">#no route-target import 1:2</span></span><br></pre></td></tr></table></figure>

<p>查看R1的IP BGP VPNv4路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-vrf)<span class="meta">#do sh ip bgp vpnv4 all</span></span><br><span class="line">BGP table version is <span class="number">78</span>, local router ID is <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">                r RIB-failure, S Stale, m multipath, b backup-path, x best-external, f RT-Filter</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">                                                                                </span><br><span class="line">    Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: <span class="number">1</span>:<span class="number">1</span> (<span class="keyword">default</span> <span class="keyword">for</span> vrf A-Site1)</span><br><span class="line">*&gt; <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>        <span class="number">156160</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt; <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>        <span class="number">158720</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>                  <span class="number">0</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>         <span class="number">30720</span>         <span class="number">32768</span> ?</span><br><span class="line"><span class="comment">//关于RT1:2的VPNv4路由消失了！</span></span><br></pre></td></tr></table></figure>

<p>让R1再度导入RT1:2的VPNv4路由；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-vrf)<span class="meta">#route-target import 1:2</span></span><br></pre></td></tr></table></figure>

<p>查看R1的IP BGP VPNv4路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-vrf)<span class="meta">#do sh ip bgp vpnv4 all</span></span><br><span class="line">BGP table version is <span class="number">86</span>, local router ID is <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">                r RIB-failure, S Stale, m multipath, b backup-path, x best-external, f RT-Filter</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">                                                                                </span><br><span class="line">    Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: <span class="number">1</span>:<span class="number">1</span> (<span class="keyword">default</span> <span class="keyword">for</span> vrf A-Site1)</span><br><span class="line">*&gt; <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>        <span class="number">156160</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt; <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span>/<span class="number">32</span>       <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>        <span class="number">158720</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt;i7<span class="number">.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>             <span class="number">156160</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt;i8<span class="number">.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>       <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>             <span class="number">158720</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>                  <span class="number">0</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt;i192<span class="number">.168</span><span class="number">.47</span><span class="number">.0</span>     <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt; <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>     <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span>         <span class="number">30720</span>         <span class="number">32768</span> ?</span><br><span class="line">*&gt;i192<span class="number">.168</span><span class="number">.78</span><span class="number">.0</span>     <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>         <span class="number">4278221055</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">Route Distinguisher: <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">*&gt;i7<span class="number">.7</span><span class="number">.7</span><span class="number">.7</span>/<span class="number">32</span>       <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>             <span class="number">156160</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt;i8<span class="number">.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>       <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>             <span class="number">158720</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt;i192<span class="number">.168</span><span class="number">.47</span><span class="number">.0</span>     <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>                  <span class="number">0</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line">*&gt;i192<span class="number">.168</span><span class="number">.78</span><span class="number">.0</span>     <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>         <span class="number">4278221055</span>    <span class="number">100</span>      <span class="number">0</span> ?</span><br><span class="line"><span class="comment">//关于RT1:2的VPNv4路由又回来了！</span></span><br></pre></td></tr></table></figure>
<p>将R1的EIGRP ip vrf A-Site1的AS号1改为2；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-router)<span class="meta">#no address-family ipv4 vrf A-Site1 autonomous-system 1</span></span><br><span class="line">R1(config-router)<span class="meta">#address-family ipv4 vrf A-Site1 autonomous-system 2</span></span><br><span class="line">R1(config-router-af)<span class="meta">#  redistribute bgp 1 metric 10000 100 255 1 1500</span></span><br><span class="line">R1(config-router-af)<span class="meta">#  network 192.168.15.0</span></span><br><span class="line">R1(config-router-af)<span class="meta"># exit-address-family</span></span><br><span class="line"><span class="comment">//仅仅修改AS号，其他配置都不变；</span></span><br></pre></td></tr></table></figure>


<p>查看EIGRP vrf A-Site1的邻居表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#sh ip eigrp vrf A-Site1 neighbors </span></span><br><span class="line">EIGRP-IPv4 Neighbors <span class="keyword">for</span> <span class="title function_">AS</span><span class="params">(<span class="number">2</span>)</span> <span class="title function_">VRF</span><span class="params">(A-Site1)</span></span><br><span class="line"><span class="comment">//由于现在PE1的EIGRP ip vrf A-Site1的AS号为2，而CE1的EIGRP AS号为1，所以PE1和CE1无法建立EIGRP邻居；</span></span><br></pre></td></tr></table></figure>

<p>将配置修改回来；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router eigrp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#no auto-summary</span></span><br><span class="line">R1(config-router)<span class="meta">#no address-family ipv4 vrf A-Site1 auto 2</span></span><br><span class="line">R1(config-router)<span class="meta">#address-family ipv4 vrf A-Site1 auto 1</span></span><br><span class="line">R1(config-router-af)<span class="meta">#no auto-summary</span></span><br><span class="line">R1(config-router-af)<span class="meta">#redistribute bgp 1 metric 10000 100 255 1 1500</span></span><br><span class="line">R1(config-router-af)<span class="meta">#network 192.168.15.0 0.0.0.255</span></span><br><span class="line">R1(config-router-af)<span class="meta">#exit</span></span><br><span class="line">R1(config-router)<span class="meta">#exit</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">11</span>:<span class="number">30</span>:<span class="number">00.263</span>: %DUAL<span class="number">-5</span>-NBRCHANGE: EIGRP-IPv4 <span class="number">1</span>: Neighbor <span class="number">192.168</span><span class="number">.15</span><span class="number">.5</span> (FastEthernet0/<span class="number">1</span>) is up: new adjacency</span><br><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R1(config-router)<span class="meta"># address-family ipv4 vrf A-Site1</span></span><br><span class="line">R1(config-router-af)<span class="meta">#redistribute connected</span></span><br><span class="line">R1(config-router-af)<span class="meta"># redistribute eigrp 1</span></span><br><span class="line">R1(config-router-af)<span class="meta">#exit-address-family</span></span><br><span class="line">R1(config-router)<span class="meta">#exit</span></span><br></pre></td></tr></table></figure>
<p>可以看到，PE1和CE1的EIGRP邻居关系又建立了！</p>
<h2 id="实验2：将R8配置为"><a href="#实验2：将R8配置为" class="headerlink" title="实验2：将R8配置为"></a>实验2：将R8配置为</h2><p>查看R1的IP BGP VPNv4路由表中关于前缀8.8.8.8&#x2F;32的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#sh ip bgp vpnv4 vrf A-Site1 8.8.8.8</span></span><br><span class="line">BGP routing table entry <span class="keyword">for</span> <span class="number">1</span>:<span class="number">1</span>:<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>, version <span class="number">114</span></span><br><span class="line">Paths: (<span class="number">1</span> available, best #<span class="number">1</span>, table A-Site1)</span><br><span class="line">    Not advertised to any peer</span><br><span class="line">    Local, imported path from <span class="number">1</span>:<span class="number">2</span>:<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span></span><br><span class="line">    <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> (metric <span class="number">4</span>) from <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> (<span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>)</span><br><span class="line">        Origin incomplete, metric <span class="number">158720</span>, localpref <span class="number">100</span>, valid, internal, best</span><br><span class="line">        Extended Community: RT:<span class="number">1</span>:<span class="number">2</span> Cost:pre-bestpath:<span class="number">128</span>:<span class="number">158720</span> <span class="number">0x8800</span>:<span class="number">32768</span>:<span class="number">0</span> </span><br><span class="line">        <span class="number">0x8801</span>:<span class="number">1</span>:<span class="number">133120</span> <span class="number">0x8802</span>:<span class="number">65282</span>:<span class="number">25600</span> <span class="number">0x8803</span>:<span class="number">65281</span>:<span class="number">1500</span> </span><br><span class="line">        <span class="number">0x8806</span>:<span class="number">0</span>:<span class="number">134744072</span></span><br><span class="line">        mpls labels in/out nolabel/<span class="number">21</span></span><br></pre></td></tr></table></figure>

<p>为了在VPN A站点2 C2路由器R8上创造一条EIGRP外部路由，不使用network命令宣告Loopback0口，而通过将直连接口Loopback0重分发进EIGRP中；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R8(config)<span class="meta">#route-map LOOPBACK permit 10</span></span><br><span class="line">R8(config-route-<span class="built_in">map</span>)<span class="meta">#match interface loopback 0</span></span><br><span class="line"></span><br><span class="line">R8(config)<span class="meta">#router eigrp 1</span></span><br><span class="line">R8(config-router)<span class="meta">#no network 8.8.8.8 0.0.0.0</span></span><br><span class="line">R8(config-router)<span class="meta">#redistribute connected route-map LOOPBACK</span></span><br></pre></td></tr></table></figure>
<p>查看CE2（R7）的IP路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7(config-router)<span class="meta">#do sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">                                                            </span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">                                                            </span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">D        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">90</span>/<span class="number">158720</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">11</span>:<span class="number">01</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">6.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">D        <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> [<span class="number">90</span>/<span class="number">161280</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">11</span>:<span class="number">01</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">8.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">D EX     <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> [<span class="number">170</span>/<span class="number">156160</span>] via <span class="number">192.168</span><span class="number">.78</span><span class="number">.8</span>, <span class="number">00</span>:<span class="number">01</span>:<span class="number">46</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">D     <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">90</span>/<span class="number">30720</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">11</span>:<span class="number">01</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">D     <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">90</span>/<span class="number">33280</span>] via <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">11</span>:<span class="number">01</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.78</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.78</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.78</span><span class="number">.7</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line"><span class="comment">//可以看到前缀8.8.8.8/32现在以EIGRP外部路由出现在了R7的路由表中；</span></span><br></pre></td></tr></table></figure>
<p>此时再来查看R1的IP BGP VPNv4路由表中关于前缀8.8.8.8&#x2F;32的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#sh ip bgp vpnv4 vrf A-Site1 8.8.8.8</span></span><br><span class="line">BGP routing table entry <span class="keyword">for</span> <span class="number">1</span>:<span class="number">1</span>:<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>, version <span class="number">150</span></span><br><span class="line">Paths: (<span class="number">1</span> available, best #<span class="number">1</span>, table A-Site1)</span><br><span class="line">    Not advertised to any peer</span><br><span class="line">    Local, imported path from <span class="number">1</span>:<span class="number">2</span>:<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span></span><br><span class="line">    <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> (metric <span class="number">4</span>) from <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> (<span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>)</span><br><span class="line">        Origin incomplete, metric <span class="number">158720</span>, localpref <span class="number">100</span>, valid, internal, best</span><br><span class="line">        Extended Community: RT:<span class="number">1</span>:<span class="number">2</span> Cost:pre-bestpath:<span class="number">129</span>:<span class="number">158720</span> <span class="number">0x8800</span>:<span class="number">0</span>:<span class="number">0</span> </span><br><span class="line">        <span class="number">0x8801</span>:<span class="number">1</span>:<span class="number">133120</span> <span class="number">0x8802</span>:<span class="number">65282</span>:<span class="number">25600</span> <span class="number">0x8803</span>:<span class="number">65281</span>:<span class="number">1500</span> </span><br><span class="line">        <span class="number">0x8804</span>:<span class="number">0</span>:<span class="number">134744072</span> <span class="number">0x8805</span>:<span class="number">11</span>:<span class="number">0</span> <span class="number">0x8806</span>:<span class="number">0</span>:<span class="number">134744072</span></span><br><span class="line">        mpls labels in/out nolabel/<span class="number">26</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>此时R1的IP BGP VPNv4路由表中关于前缀8.8.8.8&#x2F;32的详细信息中拓展团体属性中多了消息类型0x8804和0x8805；</li>
<li>拓展团体属性中类型0x8804和0x8805的字段是VPNv4路由用来描述远程VPN站点EIGRP外部路由的；</li>
<li>仅当在远程站点的网络中该路由条目就已经是EIGRP外部路由时，</li>
<li>才会在VPNv4的扩展团体属性中携带类型0x8804和0x8805字段，来为此EIGRP外部路由进- 下面实验3中的场景则不会出现类型0x8804和0x8805字段；</li>
</ul>
<h2 id="实验3："><a href="#实验3：" class="headerlink" title="实验3："></a>实验3：</h2><h3 id="实验3拓扑："><a href="#实验3拓扑：" class="headerlink" title="实验3拓扑："></a>实验3拓扑：</h3><p><img src="/2014/MPLS_Lab_7/topo2.png"></p>
<p>修改VPN A站点2的EIGRP配置，将EIGRP的AS号从1改为2；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R7(config)<span class="meta">#no router ei 1</span></span><br><span class="line">R7(config)<span class="meta">#router eigrp 2</span></span><br><span class="line">R7(config-router)<span class="meta">#network 7.7.7.7 0.0.0.0</span></span><br><span class="line">R7(config-router)<span class="meta">#network 192.168.47.0</span></span><br><span class="line">R7(config-router)<span class="meta">#network 192.168.78.0</span></span><br><span class="line">R7(config-router)<span class="meta">#eigrp router-id 7.7.7.7</span></span><br><span class="line">R7(config-router)<span class="meta">#no au</span></span><br><span class="line"></span><br><span class="line">R8(config)<span class="meta">#no router ei 1</span></span><br><span class="line">R8(config)<span class="meta">#router eigrp 2</span></span><br><span class="line">R8(config-router)<span class="meta">#no redistribute connected route-map LOOPBACK</span></span><br><span class="line">R8(config-router)<span class="meta">#network 8.8.8.8 0.0.0.0</span></span><br><span class="line">R8(config-router)<span class="meta">#network 192.168.78.0</span></span><br><span class="line">R8(config-router)<span class="meta">#eigrp router-id 8.8.8.8</span></span><br><span class="line">R8(config-router)<span class="meta">#no auto</span></span><br></pre></td></tr></table></figure>
<p>修改PE2（R4）上EIGRP 1中的ipv4 vrf A-Site1地址族的AS号2；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#router eigrp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#no address-family ip vrf A-Site2 autonomous-system 1</span></span><br><span class="line">R4(config-router)<span class="meta">#address-family ip vrf A-Site2 autonomous-system 2</span></span><br><span class="line">R4(config-router-af)<span class="meta">#no auto-summary</span></span><br><span class="line">R4(config-router-af)<span class="meta">#redistribute bgp 1 metric 10000 100 255 1 1500</span></span><br><span class="line">R4(config-router-af)<span class="meta">#network 192.168.47.0 0.0.0.255</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">58.047</span>: %DUAL<span class="number">-5</span>-NBRCHANGE: EIGRP-IPv4 <span class="number">2</span>: Neighbor <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span> (FastEthernet0/<span class="number">1</span>) is up: new adjacency</span><br><span class="line"><span class="comment">//可以看到PE2和CE2的EIGRP邻居关系马上就恢复了；</span></span><br></pre></td></tr></table></figure>

<p>并将EIGRP 1 的<code>ipv4 vrf A-Site2 autonomous-system 2</code>地址族重分发进MP-BGP的ipv4 vrf A-Site2地址族中；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#address-family ipv4 vrf A-Site2</span></span><br><span class="line">R4(config-router-af)<span class="meta">#redistribute eigrp 2</span></span><br></pre></td></tr></table></figure>

<h3 id="验证与调试：-1"><a href="#验证与调试：-1" class="headerlink" title="验证与调试："></a>验证与调试：</h3><p>在VPN A站点1的C路由器R6上ping远程VPN A站点2的C路由器R8；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R6(config-router)<span class="meta">#do p 8.8.8.8</span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Sending <span class="number">5</span>, <span class="number">100</span>-byte ICMP Echos to <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, timeout is <span class="number">2</span> seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is <span class="number">100</span> percent (<span class="number">5</span>/<span class="number">5</span>), round-trip min/avg/max = <span class="number">132</span>/<span class="number">162</span>/<span class="number">232</span> ms</span><br><span class="line"><span class="comment">//成功！</span></span><br></pre></td></tr></table></figure>

<p>查看C路由器R8的IP路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R8(config-router)<span class="meta">#do sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">D EX     <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">170</span>/<span class="number">286720</span>] via <span class="number">192.168</span><span class="number">.78</span><span class="number">.7</span>, <span class="number">00</span>:<span class="number">10</span>:<span class="number">06</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">6.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">D EX     <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> [<span class="number">170</span>/<span class="number">286720</span>] via <span class="number">192.168</span><span class="number">.78</span><span class="number">.7</span>, <span class="number">00</span>:<span class="number">10</span>:<span class="number">06</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">D        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> [<span class="number">90</span>/<span class="number">156160</span>] via <span class="number">192.168</span><span class="number">.78</span><span class="number">.7</span>, <span class="number">00</span>:<span class="number">14</span>:<span class="number">15</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">8.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> is directly connected, Loopback0</span><br><span class="line">D EX  <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">170</span>/<span class="number">286720</span>] via <span class="number">192.168</span><span class="number">.78</span><span class="number">.7</span>, <span class="number">00</span>:<span class="number">10</span>:<span class="number">06</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">D     <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">90</span>/<span class="number">30720</span>] via <span class="number">192.168</span><span class="number">.78</span><span class="number">.7</span>, <span class="number">00</span>:<span class="number">14</span>:<span class="number">15</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">D EX  <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">170</span>/<span class="number">286720</span>] via <span class="number">192.168</span><span class="number">.78</span><span class="number">.7</span>, <span class="number">00</span>:<span class="number">10</span>:<span class="number">06</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.78</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.78</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.78</span><span class="number">.8</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line"><span class="comment">//来自VPN A站点1的EIGRP路由变为EIGRP外部路由；</span></span><br></pre></td></tr></table></figure>

<p>此时再来查看R1的IP BGP VPNv4路由表中关于前缀8.8.8.8&#x2F;32的详细信息；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#sh ip bgp vpnv4 vrf A-Site1 8.8.8.8</span></span><br><span class="line">BGP routing table entry <span class="keyword">for</span> <span class="number">1</span>:<span class="number">1</span>:<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span>, version <span class="number">164</span></span><br><span class="line">Paths: (<span class="number">1</span> available, best #<span class="number">1</span>, table A-Site1)</span><br><span class="line">    Not advertised to any peer</span><br><span class="line">    Local, imported path from <span class="number">1</span>:<span class="number">2</span>:<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>/<span class="number">32</span></span><br><span class="line">    <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> (metric <span class="number">4</span>) from <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> (<span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>)</span><br><span class="line">        Origin incomplete, metric <span class="number">158720</span>, localpref <span class="number">100</span>, valid, internal, best</span><br><span class="line">        Extended Community: RT:<span class="number">1</span>:<span class="number">2</span> Cost:pre-bestpath:<span class="number">128</span>:<span class="number">158720</span> <span class="number">0x8800</span>:<span class="number">32768</span>:<span class="number">0</span> </span><br><span class="line">        <span class="number">0x8801</span>:<span class="number">2</span>:<span class="number">133120</span> <span class="number">0x8802</span>:<span class="number">65282</span>:<span class="number">25600</span> <span class="number">0x8803</span>:<span class="number">65281</span>:<span class="number">1500</span></span><br><span class="line">        <span class="number">0x8806</span>:<span class="number">0</span>:<span class="number">134744072</span></span><br><span class="line">        mpls labels in/out nolabel/<span class="number">27</span></span><br></pre></td></tr></table></figure>
<p>即便现在R6上所有来自VPN A站点2的EIGRP路由都变为了EIGRP外部路由，但PE1（R1）收到的VPNv4路由则不会携带拓展团体属性类型0x8804和0x8805字段；因为R6上的这些EIGRP外部路由是由于EIGRP AS号不同而造成的，而这些路由在远程VPN A站点2中并不是EIGRP外部路由。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>MPLS</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLS 实验8：MPLS VPN running OSPF on the PE-CE link</title>
    <url>/2014/MPLS_Lab_8/</url>
    <content><![CDATA[<h1 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h1><ul>
<li>模拟器：GNS3 0.8.6</li>
<li>Cisco IOS：c7200-adventerprisek9-mz.151-4.M2.image</li>
</ul>
<h1 id="GNS3实验拓扑文件："><a href="#GNS3实验拓扑文件：" class="headerlink" title="GNS3实验拓扑文件："></a>GNS3实验拓扑文件：</h1><p><a href="topology.net">拓扑文件</a></p>
<h1 id="实验拓扑："><a href="#实验拓扑：" class="headerlink" title="实验拓扑："></a>实验拓扑：</h1><p><img src="/2014/MPLS_Lab_8/topo.png"></p>
<span id="more"></span>

<h1 id="基本预配置："><a href="#基本预配置：" class="headerlink" title="基本预配置："></a>基本预配置：</h1><h2 id="R1："><a href="#R1：" class="headerlink" title="R1："></a>R1：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shut</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.15</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    no shut</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">    router-id <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">!         </span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">    exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.23</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">    router-id <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">    exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R3"><a href="#R3" class="headerlink" title="R3:"></a>R3:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R3</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.23</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">    router-id <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">    exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R4"><a href="#R4" class="headerlink" title="R4:"></a>R4:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R4</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.47</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">    router-id <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span></span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">    exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R5"><a href="#R5" class="headerlink" title="R5:"></a>R5:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname R5</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address 5.5.5.5 255.255.255.255</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/0</span><br><span class="line">    ip address 192.168.56.5 255.255.255.0</span><br><span class="line">    ip ospf 1 area 0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/1</span><br><span class="line">    ip address 192.168.15.5 255.255.255.0</span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line">    router-id 5.5.5.5</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R6"><a href="#R6" class="headerlink" title="R6:"></a>R6:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R6</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.56</span><span class="number">.6</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">    router-id <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span></span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">    exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R7"><a href="#R7" class="headerlink" title="R7:"></a>R7:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R7</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.78</span><span class="number">.7</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.47</span><span class="number">.7</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">    router-id <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span></span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">    exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R8"><a href="#R8" class="headerlink" title="R8:"></a>R8:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R8</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.78</span><span class="number">.8</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">    router-id <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">!         </span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">    exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<h1 id="MPLS-VPN配置步骤："><a href="#MPLS-VPN配置步骤：" class="headerlink" title="MPLS VPN配置步骤："></a>MPLS VPN配置步骤：</h1><ol>
<li>创建VRF（VRF名本地有效）：<ul>
<li>指定RD（提供全局唯一的私网单播地址）；</li>
<li>指定RT的导出（导出：把重分发进MP-BGP的VPNv4路由打上MP-BGP扩展团体属性RT）和导入（导入：把MP-BGP里的VPNv4路由进行RT的匹配，匹配成功的VPNv4路由将放进相应的VRF）；</li>
<li>将与CE相连的PE接口关联特定VRF；</li>
</ul>
</li>
<li>配置MP-BGP：<ul>
<li>配置建立PE之间的IBGP邻居关系；</li>
<li>启用VPNv4地址族（AF），并激活与其他PE设备的邻居关系；</li>
</ul>
</li>
<li>配置PE-CE路由；<ul>
<li>配置IGP，并启用IGP的地址族（AF）；</li>
<li>配置启用MP-BGP IPv4 VRF地址族，然后激活与其他PE路由器的MP-BGP IPv4 VRF邻居关系；</li>
</ul>
</li>
</ol>
<h1 id="实验与调试："><a href="#实验与调试：" class="headerlink" title="实验与调试："></a>实验与调试：</h1><h2 id="实验1：配置MPLS-VPN"><a href="#实验1：配置MPLS-VPN" class="headerlink" title="实验1：配置MPLS VPN"></a>实验1：配置MPLS VPN</h2><h3 id="在PE上创建VRF；"><a href="#在PE上创建VRF；" class="headerlink" title="在PE上创建VRF；"></a>在PE上创建VRF；</h3><p>在PE1（R1）上创建VRF，并命名为A-Site1，表示该VRF为VPN A的站点1服务；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#ip vrf A-Site1   </span></span><br></pre></td></tr></table></figure>

<p>指定RD，为1:1，如果按照AS：num命名法，以下RD表示AS1中的第2个VRF；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-vrf)<span class="meta">#rd 1:1</span></span><br></pre></td></tr></table></figure>

<p>指定RT的导入和导出，这里我将RT指定为导入和导出1：1；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-vrf)<span class="meta">#route-target ?        </span></span><br><span class="line">    ASN:nn or IP-address:nn  Target VPN Extended Community</span><br><span class="line">    both                     Both import and export Target-VPN community</span><br><span class="line">    export                   Export Target-VPN community</span><br><span class="line">    import                   Import Target-VPN community</span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-vrf)</span><span class="meta">#route-target both 1:1</span></span><br></pre></td></tr></table></figure>

<p>将PE1（R1）上与CE相连的PE接口F0&#x2F;1关联到VRF A-Site1；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#int f0/1</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#ip vrf forwarding A-Site1</span></span><br><span class="line">% Interface FastEthernet0/<span class="number">1</span> IPv4 disabled and <span class="title function_">address</span><span class="params">(es)</span> removed due to enabling VRF A-Site1</span><br><span class="line">    <span class="comment">//切记先将接口关联VRF，然后再配置IP地址；</span></span><br><span class="line"><span class="title function_">R1</span><span class="params">(config-<span class="keyword">if</span>)</span><span class="meta">#ip add 192.168.15.1 255.255.255.0</span></span><br></pre></td></tr></table></figure>
<p>在PE2（R4）上创建VRF，并命名为A-Site2，表示该VRF为VPN A的站点2服务；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#ip vrf A-Site2</span></span><br></pre></td></tr></table></figure>

<p>指定RD，为1:2，如果按照AS：num命名法，以下RD表示AS1中的第2个VRF；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-vrf)<span class="meta">#rd 1:2</span></span><br></pre></td></tr></table></figure>

<p>指定RT的导入和导出，这里我将RT指定为导入和导出1：1；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-vrf)<span class="meta">#route-target both 1:1</span></span><br></pre></td></tr></table></figure>
<p>因为PE1导出的RT为1:1，PE2导入的RT正是PE1的导出RT1:1，所以PE1（R1）的RT导出和PE2（R4）的RT导入能够匹配成功，R4能够学到R1导入到MP-BGP中的VPNv4路由；又因为PE2导出的RT为1:1，PE1导入的RT也正好是PE2的导出RT1:1；所以PE2（R4）的RT导出和PE1（R1）的RT导入能够匹配成对，R1能够学到R4导入到MP-BGP中的VPNv4路由</p>
<p>将PE2（R4）上与CE相连的PE接口F0&#x2F;1关联到VRF A-Site2；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#int f0/1</span></span><br><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#ip vrf forwarding A-Site2</span></span><br><span class="line">% Interface FastEthernet0/<span class="number">1</span> IPv4 disabled and <span class="title function_">address</span><span class="params">(es)</span> removed due to enabling VRF A-Site2</span><br><span class="line">    <span class="comment">//切记先将接口关联VRF，然后再配置IP地址；</span></span><br><span class="line"><span class="title function_">R4</span><span class="params">(config-<span class="keyword">if</span>)</span><span class="meta">#ip add 192.168.47.4 255.255.255.0</span></span><br></pre></td></tr></table></figure>
<h3 id="配置MP-BGP；"><a href="#配置MP-BGP；" class="headerlink" title="配置MP-BGP；"></a>配置MP-BGP；</h3><p>在PE1（R1）上配置MP-BGP，使之与其他PE建立IBGP关系，在此实验中只有PE1和PE2两台PE设备；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#no auto-summary</span></span><br><span class="line">R1(config-router)<span class="meta">#no syn</span></span><br><span class="line">R1(config-router)<span class="meta">#bgp router-id 1.1.1.1</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 remote-as 1</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 update-source l0</span></span><br><span class="line">R1(config-router)<span class="meta">#neighbor 4.4.4.4 next-hop-self</span></span><br></pre></td></tr></table></figure>

<p>启用PE1（R1）的VPNv4地址族，并激活与IBGP邻居PE2（R4）的MP-BGP VPNv4邻居关系；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-router)<span class="meta">#address-family vpnv4</span></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 4.4.4.4 activate</span></span><br><span class="line"><span class="comment">//激活与IBGP邻居R4的VPNv4关系；</span></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 4.4.4.4 send-community ?</span></span><br><span class="line">    both      Send Standard and Extended Community attributes</span><br><span class="line">    extended  Send Extended Community attribute</span><br><span class="line">    standard  Send Standard Community attribute</span><br><span class="line">    &lt;cr&gt;</span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#neighbor 4.4.4.4 send-community both</span></span><br><span class="line"><span class="comment">//由于BGP团体属性为可选传递属性，所以必须手动指定R1向IBGP邻居R4发送拓展团体属性和标准团体属性；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#exit-address-family</span></span><br><span class="line"><span class="comment">//退出AF配置模式；</span></span><br></pre></td></tr></table></figure>
<p>在PE2（R4）上配置MP-BGP，使之与其他PE建立IBGP关系，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#no auto-summary</span></span><br><span class="line">R4(config-router)<span class="meta">#no syn</span></span><br><span class="line">R4(config-router)<span class="meta">#bgp router-id 4.4.4.4</span></span><br><span class="line">R4(config-router)<span class="meta">#neighbor 1.1.1.1 remote-as 1</span></span><br><span class="line">R4(config-router)<span class="meta">#neighbor 1.1.1.1 update-source l0</span></span><br><span class="line">R4(config-router)<span class="meta">#neighbor 1.1.1.1 next-hop-self</span></span><br></pre></td></tr></table></figure>

<p>启用PE2（R4）的VPNv4地址族，并激活与IBGP邻居PE1（R1）的MP-BGP VPNv4邻居关系；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-router)<span class="meta">#address-family vpnv4</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 1.1.1.1 activate</span></span><br><span class="line">R4(config-router-af)<span class="meta">#neighbor 1.1.1.1 send-community both</span></span><br></pre></td></tr></table></figure>
<h3 id="配置PE-CE路由；"><a href="#配置PE-CE路由；" class="headerlink" title="配置PE-CE路由；"></a>配置PE-CE路由；</h3><p>配置PE1（R1）的IGP OSPF VRF进程；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#interface loopback1</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#ip vrf forwarding A-Site1</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#ip add 11.11.11.11 255.255.255.255</span></span><br><span class="line"><span class="comment">//创建接口Loopback1，以使用此环回口作为OSPF 2 VRF A-Site1进程的Router-id；</span></span><br><span class="line"></span><br><span class="line">R1(config)<span class="meta">#router ospf 2 vrf A-Site1</span></span><br><span class="line">R1(config-router)<span class="meta">#router-id 11.11.11.11</span></span><br><span class="line">R1(config-router)<span class="meta">#network 11.11.11.11 0.0.0.0 area 0</span></span><br><span class="line"><span class="comment">//OSPF VRF进程中的命令和常规OSPF进程中的相同，使用network命令将接口Loopback1宣告进OSPF VRF进程；</span></span><br><span class="line"></span><br><span class="line">R1(config-router)<span class="meta">#redistribute bgp 1 subnets </span></span><br><span class="line"><span class="comment">//将MP-BGP中IPv4 VRF地址族的命名与OSPF VRF进程的VRF命名相同的MP-BGP路由重分布进此OSPF VRF进程；</span></span><br><span class="line"><span class="comment">//OSPF VRF进程和MP-BGP中IPv4 VRF地址族（AF）实际上是执行相互重分发的操作；</span></span><br><span class="line"></span><br><span class="line">R1(config)<span class="meta">#int f0/1</span></span><br><span class="line">R1(config-<span class="keyword">if</span>)<span class="meta">#ip ospf 2 area 0</span></span><br><span class="line"><span class="comment">//同时，与常规OSPF进程相同，也可以在接口下将接口宣告进OSPF VRF进程；</span></span><br></pre></td></tr></table></figure>

<p>配置PE1（R1）的MP-BGP IPv4 VRF地址族（AF）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#address-family ipv4 vrf A-Site1</span></span><br><span class="line"><span class="comment">//进入MP-BGP的IPv4 VRF地址族（AF）；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#redistribute ospf 2 vrf A-Site1 match internal external </span></span><br><span class="line"><span class="comment">//默认情况下，把OSPF重分发进BGP，只会将OSPF内部路由重分发进BGP，</span></span><br><span class="line"><span class="comment">//如果需要将所有OSPF路由（内部和外部路由）重分发进去BGP，需要使用选项match；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#redistribute connected </span></span><br><span class="line"><span class="comment">//如果用户在CE路由器上ping远程网络的另一个VPN站点中的CE或C路由器，</span></span><br><span class="line"><span class="comment">//为了使其在没有指定其源地址情况下（即默认使用CE路由器出站接口IP地址），Echo Reply包能够有路由并正常返回,</span></span><br><span class="line"><span class="comment">//将PE路由器的直连路由重分布进MP-BGP的IPv4 VRF AF中；</span></span><br><span class="line"></span><br><span class="line">R1(config-router-af)<span class="meta">#exit-address-family </span></span><br><span class="line"><span class="comment">//退出MP-BGP的IPv4 VRF地址族（AF）模式；</span></span><br></pre></td></tr></table></figure>
<p>配置PE2（R4）的IGP OSPF VRF进程；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#interface loopback1</span></span><br><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#ip vrf forwarding A-Site2</span></span><br><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#ip add 11.11.11.11 255.255.255.255</span></span><br><span class="line"></span><br><span class="line">R4(config)<span class="meta">#router ospf 2 vrf A-Site2</span></span><br><span class="line">R4(config-router)<span class="meta">#router-id 11.11.11.11</span></span><br><span class="line">R4(config-router)<span class="meta">#network 11.11.11.11 0.0.0.0 area 0</span></span><br><span class="line"></span><br><span class="line">R4(config-router)<span class="meta">#redistribute bgp 1 subnets </span></span><br><span class="line"></span><br><span class="line">R4(config)<span class="meta">#int f0/1</span></span><br><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#ip ospf 2 area 0</span></span><br></pre></td></tr></table></figure>

<p>配置PE2（R4）的MP-BGP IPv4 VRF地址族（AF）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#address-family ipv4 vrf A-Site2</span></span><br><span class="line">R4(config-router-af)<span class="meta">#redistribute ospf 2 vrf A-Site2 match internal external </span></span><br><span class="line">R4(config-router-af)<span class="meta">#redistribute connected </span></span><br><span class="line">R4(config-router-af)<span class="meta">#exit-address-family </span></span><br></pre></td></tr></table></figure>
<h3 id="验证与调试；"><a href="#验证与调试；" class="headerlink" title="验证与调试；"></a>验证与调试；</h3><p>在VPN A站点1的C路由器R6上ping远程VPN A站点2的C路由器R8；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R6<span class="meta">#ping 8.8.8.8</span></span><br><span class="line">Type escape sequence to <span class="built_in">abort</span>.</span><br><span class="line">Sending <span class="number">5</span>, <span class="number">100</span>-byte ICMP Echos to <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, timeout is <span class="number">2</span> seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is <span class="number">100</span> percent (<span class="number">5</span>/<span class="number">5</span>), round-trip min/avg/max = <span class="number">140</span>/<span class="number">173</span>/<span class="number">212</span> ms</span><br><span class="line"><span class="comment">//成功！</span></span><br></pre></td></tr></table></figure>

<p>查看PE2（R4）的OSPF链路状态数据库；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4<span class="meta">#show ip ospf database</span></span><br><span class="line">            OSPF Router with <span class="title function_">ID</span> <span class="params">(<span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span>)</span> <span class="params">(Process ID <span class="number">1</span>)</span></span><br><span class="line">                Router Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">1.1.1.1         1.1.1.1         1920        0x80000005 0x0048DB 2</span><br><span class="line">2.2.2.2         2.2.2.2         1933        0x80000006 0x0039C6 3</span><br><span class="line">3.3.3.3         3.3.3.3         1978        0x80000006 0x009D26 3</span><br><span class="line">4.4.4.4         4.4.4.4         45          0x80000006 0x003A93 2</span><br><span class="line">                Net Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum</span><br><span class="line">192.168.12.2    2.2.2.2         1933        0x80000004 0x008922</span><br><span class="line">192.168.23.3    3.3.3.3         1978        0x80000004 0x003C57</span><br><span class="line">192.168.34.4    4.4.4.4         45          0x80000005 0x00EC8D</span><br><span class="line">            OSPF Router with <span class="title function_">ID</span> <span class="params">(<span class="number">44.44</span><span class="number">.44</span><span class="number">.44</span>)</span> <span class="params">(Process ID <span class="number">2</span>)</span></span><br><span class="line">                Router Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">7.7.7.7         7.7.7.7         1944        0x80000007 0x0030CA 3</span><br><span class="line">8.8.8.8         8.8.8.8         1146        0x80000005 0x002E11 2</span><br><span class="line">44.44.44.44     44.44.44.44     1858        0x80000003 0x004D81 2</span><br><span class="line">                Net Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum</span><br><span class="line">192.168.47.7    7.7.7.7         1944        0x80000002 0x005B55</span><br><span class="line">192.168.78.7    7.7.7.7         1167        0x80000004 0x00F12E</span><br><span class="line">                Summary Net Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum</span><br><span class="line">5.5.5.5         44.44.44.44     1858        0x80000002 0x00FFF4</span><br><span class="line">6.6.6.6         44.44.44.44     1858        0x80000002 0x00DB14</span><br><span class="line">11.11.11.11     44.44.44.44     1858        0x80000002 0x00E0FC</span><br><span class="line">192.168.15.0    44.44.44.44     1858        0x80000002 0x00850C</span><br><span class="line">192.168.56.0    44.44.44.44     1858        0x80000002 0x00CA9C</span><br><span class="line"><span class="comment">//可以看到，当关于VPN A站点2的前缀在PE2（R4）上的时候，它们都还是类型1或者类型2的LSA；</span></span><br><span class="line"><span class="comment">//而关于这些前缀的LSA在PE1（R1）的时候，它们</span></span><br></pre></td></tr></table></figure>

<p>查看PE1（R1）的OSPF链路状态数据库；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#show ip ospf database</span></span><br><span class="line">            OSPF Router with <span class="title function_">ID</span> <span class="params">(<span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>)</span> <span class="params">(Process ID <span class="number">1</span>)</span></span><br><span class="line">                Router Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">1.1.1.1         1.1.1.1         1406        0x80000005 0x0048DB 2</span><br><span class="line">2.2.2.2         2.2.2.2         1422        0x80000006 0x0039C6 3</span><br><span class="line">3.3.3.3         3.3.3.3         1468        0x80000006 0x009D26 3</span><br><span class="line">4.4.4.4         4.4.4.4         1559        0x80000005 0x003C92 2</span><br><span class="line">                Net Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum</span><br><span class="line">192.168.12.2    2.2.2.2         1422        0x80000004 0x008922</span><br><span class="line">192.168.23.3    3.3.3.3         1468        0x80000004 0x003C57</span><br><span class="line">192.168.34.4    4.4.4.4         1559        0x80000004 0x00EE8C</span><br><span class="line">            OSPF Router with <span class="title function_">ID</span> <span class="params">(<span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>)</span> <span class="params">(Process ID <span class="number">2</span>)</span></span><br><span class="line">                Router Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">5.5.5.5         5.5.5.5         1495        0x80000008 0x00ACD9 3</span><br><span class="line">6.6.6.6         6.6.6.6         812         0x80000006 0x00285E 2</span><br><span class="line">11.11.11.11     11.11.11.11     593         0x80000006 0x007628 2</span><br><span class="line">                Net Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum</span><br><span class="line">192.168.15.5    5.5.5.5         1495        0x80000003 0x004E18</span><br><span class="line">192.168.56.5    5.5.5.5         732         0x80000004 0x008CC3</span><br><span class="line">                Summary Net Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum</span><br><span class="line">7.7.7.7         11.11.11.11     1362        0x80000002 0x0085EB</span><br><span class="line">8.8.8.8         11.11.11.11     1362        0x80000002 0x00610B</span><br><span class="line">44.44.44.44     11.11.11.11     1362        0x80000002 0x00CE0F</span><br><span class="line">192.168.47.0    11.11.11.11     1362        0x80000002 0x0006EF</span><br><span class="line">192.168.78.0    11.11.11.11     1362        0x80000002 0x00B91C</span><br><span class="line"><span class="comment">//可以看到，当关于VPN A站点2的前缀在PE2（R4）上的时候，它们都还是类型1或者类型2的LSA；</span></span><br><span class="line"><span class="comment">//而关于这些前缀的LSA在PE1（R1）的时候，它们都已经变为了类型3的LSA；</span></span><br><span class="line"><span class="comment">//这说明，PE2（R4）将类型为1和2的LSA转换为类型3的LSA；</span></span><br><span class="line"><span class="comment">//PE1（R1）收到了远程PE2（R4）发来的类型3的LSA，将其装换为OSPF区域间路由（O IA）；</span></span><br></pre></td></tr></table></figure>

<p>查看R6的IP路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R6<span class="meta">#show ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">                                                            </span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">                                                            </span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">01</span>:<span class="number">25</span>:<span class="number">07</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">6.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O IA     <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> [<span class="number">110</span>/<span class="number">4</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">27</span>:<span class="number">55</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">8.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O IA     <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> [<span class="number">110</span>/<span class="number">5</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">27</span>:<span class="number">55</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">11.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> [<span class="number">110</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">45</span>:<span class="number">36</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">44.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O IA     <span class="number">44.44</span><span class="number">.44</span><span class="number">.44</span> [<span class="number">110</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">27</span>:<span class="number">55</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">01</span>:<span class="number">25</span>:<span class="number">07</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">O IA  <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">27</span>:<span class="number">55</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.56</span><span class="number">.6</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">O IA  <span class="number">192.168</span><span class="number">.78</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">4</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">27</span>:<span class="number">55</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line"><span class="comment">//注意：在OSPF看来，MPLS VPN超骨干网络超越了OSPF骨干区域Area0，MPLS VPN超骨干网络神似OSPF骨干区域Area0，</span></span><br><span class="line"><span class="comment">//但它又和OSPF骨干区域Area0不同，所以PE路由器会执行ABR的功能，会将类型为1和2的LSA转换为类型3的LSA；</span></span><br><span class="line"><span class="comment">//所以当PE在收到来自对端远程PE发来的OSPF区域内路由（O）时，会将OSPF区域内路由转换为OSPF区域间路由（O IA）；</span></span><br></pre></td></tr></table></figure>

<p>调试OSPF 2的LSA生成；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1<span class="meta">#debug ip ospf 2 lsa-generation</span></span><br><span class="line">OSPF LSA generation debugging is on <span class="keyword">for</span> process <span class="number">2</span></span><br><span class="line">R1<span class="meta">#clear ip ospf 2 process</span></span><br><span class="line">Reset OSPF process <span class="number">2</span>? [no]: yes</span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">26.607</span>: OSPF<span class="number">-2</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">26.611</span>: %OSPF<span class="number">-5</span>-ADJCHG: Process <span class="number">2</span>, Nbr <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> on FastEthernet0/<span class="number">1</span> from FULL to DOWN, Neighbor Down: Interface down or detached</span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">26.619</span>: OSPF<span class="number">-2</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">26.619</span>: OSPF<span class="number">-2</span> LSGEN: Scheduling network LSA on FastEthernet0/<span class="number">1</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">26.623</span>: OSPF<span class="number">-2</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">26.627</span>: OSPF<span class="number">-2</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">26.631</span>: OSPF<span class="number">-2</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">26.647</span>: OSPF<span class="number">-2</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">26.651</span>: OSPF<span class="number">-2</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">26.655</span>: OSPF<span class="number">-2</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">26.731</span>: OSPF<span class="number">-2</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">26.743</span>: OSPF<span class="number">-2</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.107</span>: OSPF<span class="number">-2</span> LSGEN: Build router LSA <span class="keyword">for</span> area <span class="number">0</span>, router ID <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, seq <span class="number">0x80000001</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.143</span>: %OSPF<span class="number">-5</span>-ADJCHG: Process <span class="number">2</span>, Nbr <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> on FastEthernet0/<span class="number">1</span> from LOADING to FULL, Loading Done</span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.147</span>: OSPF<span class="number">-2</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.647</span>: OSPF<span class="number">-2</span> LSGEN: Rate limit LSA generation <span class="keyword">for</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">1</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.747</span>: OSPF<span class="number">-2</span> LSMAX: Rcv Maxage LSA, Type <span class="number">3</span>, LSID <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>, Adv rtr <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, age <span class="number">3600</span>, seq <span class="number">0x80000001</span>, from <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.751</span>: OSPF<span class="number">-2</span> LSGEN: Update summary LSA <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">3</span> <span class="number">80000001</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.755</span>: OSPF<span class="number">-2</span> LSGEN: Rate limit LSA generation <span class="keyword">for</span> <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">3</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.759</span>: OSPF<span class="number">-2</span> LSMAX: Rcv Maxage LSA, Type <span class="number">3</span>, LSID <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, Adv rtr <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, age <span class="number">3600</span>, seq <span class="number">0x80000001</span>, from <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.763</span>: OSPF<span class="number">-2</span> LSGEN: Update summary LSA <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">3</span> <span class="number">80000001</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.767</span>: OSPF<span class="number">-2</span> LSGEN: Rate limit LSA generation <span class="keyword">for</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">3</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.771</span>: OSPF<span class="number">-2</span> LSMAX: Rcv Maxage LSA, Type <span class="number">3</span>, LSID <span class="number">44.4</span></span><br><span class="line">R1#<span class="number">4.44</span><span class="number">.44</span>, Adv rtr <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, age <span class="number">3600</span>, seq <span class="number">0x80000005</span>, from <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.775</span>: OSPF<span class="number">-2</span> LSGEN: Update summary LSA <span class="number">44.44</span><span class="number">.44</span><span class="number">.44</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">3</span> <span class="number">80000005</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.779</span>: OSPF<span class="number">-2</span> LSGEN: Rate limit LSA generation <span class="keyword">for</span> <span class="number">44.44</span><span class="number">.44</span><span class="number">.44</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">3</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.783</span>: OSPF<span class="number">-2</span> LSMAX: Rcv Maxage LSA, Type <span class="number">3</span>, LSID <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>, Adv rtr <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, age <span class="number">3600</span>, seq <span class="number">0x80000005</span>, from <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.787</span>: OSPF<span class="number">-2</span> LSGEN: Update summary LSA <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">3</span> <span class="number">80000005</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.791</span>: OSPF<span class="number">-2</span> LSGEN: Rate limit LSA generation <span class="keyword">for</span> <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">3</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.795</span>: OSPF<span class="number">-2</span> LSMAX: Rcv Maxage LSA, Type <span class="number">3</span>, LSID <span class="number">192.168</span><span class="number">.78</span><span class="number">.0</span>, Adv rtr <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, age <span class="number">3600</span>, seq <span class="number">0x80000001</span>, from <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.799</span>: OSPF<span class="number">-2</span> LSGEN: Update summary LSA <span class="number">192.168</span><span class="number">.78</span><span class="number">.0</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">3</span> <span class="number">80000001</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">27.803</span>: OSPF<span class="number">-2</span> LSGEN: Rate limit LSA generation <span class="keyword">for</span> <span class="number">192.168</span><span class="number">.78</span><span class="number">.0</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">3</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">28.611</span>: OSPF<span class="number">-2</span> LSGEN: Scheduling rtr LSA <span class="keyword">for</span> area <span class="number">0</span></span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">29.111</span>: OSPF<span class="number">-2</span> LSGEN: Rate limit LSA generation <span class="keyword">for</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">1</span></span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">31.779</span>: OSPF<span class="number">-2</span> LSMAX: Rcv Maxage LSA, Type <span class="number">1</span>, LSID <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, Adv rtr <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, age <span class="number">3600</span>, seq <span class="number">0x80000006</span>, from <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">31.787</span>: OSPF<span class="number">-2</span> LSGEN: Update router LSA <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">1</span> <span class="number">80000006</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">31.791</span>: OSPF<span class="number">-2</span> LSGEN: Rate limit LSA generation <span class="keyword">for</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">1</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">32.071</span>: OSPF<span class="number">-2</span> LSMAX: Rcv Maxage LSA, Type <span class="number">1</span>, LSID <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, Adv rtr <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, age <span class="number">3600</span>, seq <span class="number">0x80000006</span>, from <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">32.075</span>: OSPF<span class="number">-2</span> LSGEN: Update router LSA <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">1</span> <span class="number">80000006</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">32.079</span>: OSPF<span class="number">-2</span> LSGEN: Rate limit LSA generation <span class="keyword">for</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">1</span></span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">32.107</span>: OSPF<span class="number">-2</span> LSGEN: Build router LSA <span class="keyword">for</span> area <span class="number">0</span>, router ID <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, seq <span class="number">0x80000007</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">32.715</span>: OSPF<span class="number">-2</span> LSMAX: Rcv Maxage LSA, Type <span class="number">3</span>, LSID <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span>, Adv rtr <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, age <span class="number">3600</span>, seq <span class="number">0x80000001</span>, from <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">32.719</span>: OSPF<span class="number">-2</span> LSMAX: Rcv Maxage LSA, Type <span class="number">3</span>, LSID <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, Adv rtr <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, age <span class="number">3600</span>, seq <span class="number">0x80000001</span>, from <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">32.723</span>: OSPF<span class="number">-2</span> LSMAX: Rcv Maxage LSA, Type <span class="number">3</span>, LSID <span class="number">44.44</span><span class="number">.44</span><span class="number">.44</span>, Adv rtr <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, age <span class="number">3600</span>, seq <span class="number">0x80000005</span>, from <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">R1#</span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">32.727</span>: OSPF<span class="number">-2</span> LSMAX: Rcv Maxage LSA, Type <span class="number">3</span>, LSID <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>, Adv rtr <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, age <span class="number">3600</span>, seq <span class="number">0x80000005</span>, from <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">*Mar <span class="number">18</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">32.727</span>: OSPF<span class="number">-2</span> LSMAX: Rcv Maxage LSA, Type <span class="number">3</span>, LSID <span class="number">192.168</span><span class="number">.78</span><span class="number">.0</span>, Adv rtr <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>, age <span class="number">3600</span>, seq <span class="number">0x80000001</span>, from <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line"><span class="comment">//可以看到，正如之前的结论，PE1（R1）收到关于VPN A站点2中前缀的LSA是类型3的LSA；</span></span><br><span class="line"><span class="comment">//证实了PE2（R4）将这些类型为1和2的LSA转换为类型3的LSA后，再将其发送给PE1（R1）；</span></span><br></pre></td></tr></table></figure>

<h2 id="实验2：OSPF-Sham-Link-in-MPLS-VPN"><a href="#实验2：OSPF-Sham-Link-in-MPLS-VPN" class="headerlink" title="实验2：OSPF Sham Link in MPLS VPN"></a>实验2：OSPF Sham Link in MPLS VPN</h2><h3 id="理论概述："><a href="#理论概述：" class="headerlink" title="理论概述："></a>理论概述：</h3><p>在OSPF看来，MPLS VPN超骨干网络超越了OSPF骨干区域Area0，MPLS VPN超骨干网络神似OSPF骨干区域Area0，<br>但它又和OSPF骨干区域Area0不同，所以PE路由器会执行ABR的功能，会将类型为1和2的LSA转换为类型3的LSA；<br>所以当PE在收到来自对端远程PE发来的OSPF区域内路由（O）时，会将OSPF区域内路由转换为OSPF区域间路由（O IA）。<br>为了避免PE将类型1和类型2的LSA转换为类型3的LSA，可以在PE之间创建OSPF Sham Link；这样，当LSA在Sham Link中<br>进行洪泛时，所有的OSPF路由类型都不会改变，不会转变为类型3或者类型5的LSA；</p>
<h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><p>在PE上配置OSPF Sham Link；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router ospf 2 vrf A-Site1</span></span><br><span class="line">R1(config-router)<span class="meta">#area 0 sham-link 11.11.11.11 44.44.44.44</span></span><br><span class="line"><span class="comment">//注意：必须将Sham Link的源地址和目的地址所在的接口划分进VRF；</span></span><br><span class="line"></span><br><span class="line">R4(config)<span class="meta">#router ospf 2 vrf A-Site2</span></span><br><span class="line">R4(config-router)<span class="meta">#area 0 sham-link 44.44.44.44 11.11.11.11</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：在OSPF VRF进程中配置完sham link后发现sham link反复震荡；</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*Mar <span class="number">20</span> <span class="number">15</span>:<span class="number">39</span>:<span class="number">37.859</span>: %OSPF<span class="number">-5</span>-ADJCHG: Process <span class="number">2</span>, Nbr <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> on OSPF_SL0 from LOADING to FULL, Loading Done</span><br><span class="line"><span class="title function_">R4</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 20 15:39:42.979: %OSPF-5-ADJCHG: Process 2, Nbr 11.11.11.11 on OSPF_SL0 from FULL to DOWN, Neighbor Down: Interface down or detached</span><br><span class="line"><span class="title function_">R4</span><span class="params">(config)</span># </span><br><span class="line">*Mar 20 15:39:48.703: %OSPF-5-ADJCHG: Process 2, Nbr 11.11.11.11 on OSPF_SL0 from LOADING to FULL, Loading Done</span><br><span class="line"><span class="title function_">R4</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 20 15:39:52.999: %OSPF-5-ADJCHG: Process 2, Nbr 11.11.11.11 on OSPF_SL0 from FULL to DOWN, Neighbor Down: Interface down or detached</span><br><span class="line"><span class="title function_">R4</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 20 15:39:58.743: %OSPF-5-ADJCHG: Process 2, Nbr 11.11.11.11 on OSPF_SL0 from LOADING to FULL, Loading Done</span><br><span class="line"><span class="title function_">R4</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 20 15:40:03.011: %OSPF-5-ADJCHG: Process 2, Nbr 11.11.11.11 on OSPF_SL0 from FULL to DOWN, Neighbor Down: Interface down or detached</span><br><span class="line"><span class="title function_">R4</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 20 15:40:08.879: %OSPF-5-ADJCHG: Process 2, Nbr 11.11.11.11 on OSPF_SL0 from LOADING to FULL, Loading Done</span><br><span class="line"><span class="title function_">R4</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 20 15:40:13.039: %OSPF-5-ADJCHG: Process 2, Nbr 11.11.11.11 on OSPF_SL0 from FULL to DOWN, Neighbor Down: Interface down or detached</span><br><span class="line"><span class="comment">//注意：必须在PE上将各自用作Sham Link的源地址的接口地址通告进MP-BGP的IPv4 VRF地址族，否则Sham Link会反复震荡；</span></span><br></pre></td></tr></table></figure>

<p>将接口Loopback1的地址以路由的形式通告进MP-BGP的IPv4 VRF地址族；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#address-family ipv4 vrf A-Site1</span></span><br><span class="line">R1(config-router-af)<span class="meta">#network 11.11.11.11 mask 255.255.255.255</span></span><br><span class="line"></span><br><span class="line">R4(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R4(config-router)<span class="meta">#address-family ipv4 vrf A-Site2</span></span><br><span class="line">R4(config-router-af)<span class="meta">#network 44.44.44.44 mask 255.255.255.255</span></span><br></pre></td></tr></table></figure>

<p>注意：在将接口Loopback1的地址以路由的形式通告进MP-BGP的IPv4 VRF地址族，发现Sham Link依旧反复震荡；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config)#</span><br><span class="line">*Mar <span class="number">20</span> <span class="number">15</span>:<span class="number">39</span>:<span class="number">58.743</span>: %OSPF<span class="number">-5</span>-ADJCHG: Process <span class="number">2</span>, Nbr <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> on OSPF_SL0 from LOADING to FULL, Loading Done</span><br><span class="line"><span class="title function_">R4</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 20 15:40:03.011: %OSPF-5-ADJCHG: Process 2, Nbr 11.11.11.11 on OSPF_SL0 from FULL to DOWN, Neighbor Down: Interface down or detached</span><br><span class="line"><span class="title function_">R4</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 20 15:40:08.879: %OSPF-5-ADJCHG: Process 2, Nbr 11.11.11.11 on OSPF_SL0 from LOADING to FULL, Loading Done</span><br><span class="line"><span class="title function_">R4</span><span class="params">(config)</span>#</span><br><span class="line">*Mar 20 15:40:13.039: %OSPF-5-ADJCHG: Process 2, Nbr 11.11.11.11 on OSPF_SL0 from FULL to DOWN, Neighbor Down: Interface down or detached</span><br><span class="line"><span class="comment">//注意：作为Sham Link源地址和目的地址的接口不能被通告进OSPF VRF进程；</span></span><br></pre></td></tr></table></figure>
<p>将作为Sham Link源地址，并且同时也作为了对方PE Sham Link目的地址的接口移除OSPF VRF进程；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router ospf 2 vrf A-Site1               </span></span><br><span class="line">R1(config-router)<span class="meta">#no network 11.11.11.11 0.0.0.0 area 0</span></span><br><span class="line"></span><br><span class="line">R4(config)<span class="meta">#router ospf 2 vrf A-Site2</span></span><br><span class="line">R4(config-router)<span class="meta">#no network 44.44.44.44 0.0.0.0 area 0</span></span><br></pre></td></tr></table></figure>

<p><strong>OSPF Sham Link持续稳定！</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config-router)#</span><br><span class="line">*Mar <span class="number">20</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">35.779</span>: %OSPF<span class="number">-5</span>-ADJCHG: Process <span class="number">2</span>, Nbr <span class="number">44.44</span><span class="number">.44</span><span class="number">.44</span> on OSPF_SL0 from LOADING to FULL, Loading Done</span><br><span class="line"></span><br><span class="line"><span class="title function_">R4</span><span class="params">(config-router)</span>#</span><br><span class="line">*Mar 20 16:19:36.067: %OSPF-5-ADJCHG: Process 2, Nbr 11.11.11.11 on OSPF_SL0 from LOADING to FULL, Loading Done</span><br></pre></td></tr></table></figure>

<h3 id="验证与调试："><a href="#验证与调试：" class="headerlink" title="验证与调试："></a>验证与调试：</h3><p>查看R6的路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R6<span class="meta">#sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">5.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">5.5</span><span class="number">.5</span><span class="number">.5</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">57</span>:<span class="number">04</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">6.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">6.6</span><span class="number">.6</span><span class="number">.6</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">7.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">7.7</span><span class="number">.7</span><span class="number">.7</span> [<span class="number">110</span>/<span class="number">5</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">10</span>:<span class="number">36</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">8.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> [<span class="number">110</span>/<span class="number">6</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">10</span>:<span class="number">36</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">11.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O E2     <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> [<span class="number">110</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">18</span>:<span class="number">37</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">44.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O E2     <span class="number">44.44</span><span class="number">.44</span><span class="number">.44</span> [<span class="number">110</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">10</span>:<span class="number">36</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">2</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">57</span>:<span class="number">04</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.47</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">4</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">10</span>:<span class="number">36</span>, FastEthernet0/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.56</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.56</span><span class="number">.6</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">0</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.78</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">5</span>] via <span class="number">192.168</span><span class="number">.56</span><span class="number">.5</span>, <span class="number">00</span>:<span class="number">10</span>:<span class="number">36</span>, FastEthernet0/<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>注意到，现在关于R6上看到关于站点2的路由就变成了OSPF区域内路由（O）；但是，由于关于11.11.11.11&#x2F;32和44.44.44.44&#x2F;32的路由，由于它们并不是在OSPF里进行通告的,而是通告进BGP，然后才被重分发进OSPF的，所以都变成了OSPF外部路由（O E2）；</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>MPLS</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLS 实验9：OSPF Sham Link and Backdoor Link in MPLS VPN</title>
    <url>/2014/MPLS_Lab_9/</url>
    <content><![CDATA[<h1 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h1><ul>
<li>模拟器：GNS3 0.8.6</li>
<li>Cisco IOS：c7200-adventerprisek9-mz.151-4.M2.image</li>
</ul>
<h1 id="实验拓扑："><a href="#实验拓扑：" class="headerlink" title="实验拓扑："></a>实验拓扑：</h1><p><img src="/2014/MPLS_Lab_9/topo.png"></p>
<span id="more"></span>

<h1 id="基本预配置："><a href="#基本预配置：" class="headerlink" title="基本预配置："></a>基本预配置：</h1><h2 id="R1："><a href="#R1：" class="headerlink" title="R1："></a>R1：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">ip vrf A-Site1</span><br><span class="line">    rd <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">    route-target export <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">    route-target import <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface Loopback1</span><br><span class="line">    ip vrf forwarding A-Site1</span><br><span class="line">    ip address <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.12</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip  </span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">    ip vrf forwarding A-Site1</span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.13</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">2</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">2</span> vrf A-Site1</span><br><span class="line">    router-id <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span></span><br><span class="line">    redistribute bgp <span class="number">1</span> subnets</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">    router-id <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">1</span></span><br><span class="line">    bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">    neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> remote-as <span class="number">1</span></span><br><span class="line">    neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> update-source Loopback0</span><br><span class="line">    neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> next-hop-self</span><br><span class="line">    !</span><br><span class="line">    address-family vpnv4</span><br><span class="line">    neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> activate</span><br><span class="line">    neighbor <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> send-community both</span><br><span class="line">    <span class="built_in">exit</span>-address-family</span><br><span class="line">    !</span><br><span class="line">    address-family ipv4 vrf A-Site1</span><br><span class="line">    redistribute connected</span><br><span class="line">    redistribute ospf <span class="number">2</span> match internal external <span class="number">1</span> external <span class="number">2</span></span><br><span class="line">    <span class="built_in">exit</span>-address-family</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">    exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="R2"><a href="#R2" class="headerlink" title="R2:"></a>R2:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">ip vrf A-Site2</span><br><span class="line">    rd <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    route-target export <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">    route-target import <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">!</span><br><span class="line">mpls label protocol ldp</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface Loopback1</span><br><span class="line">    ip vrf forwarding A-Site2</span><br><span class="line">    ip address <span class="number">22.22</span><span class="number">.22</span><span class="number">.22</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">0</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">mpls ip  </span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">    ip vrf forwarding A-Site2</span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.24</span><span class="number">.2</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">2</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">2</span> vrf A-Site2</span><br><span class="line">    router-id <span class="number">22.22</span><span class="number">.22</span><span class="number">.22</span></span><br><span class="line">    redistribute bgp <span class="number">1</span> subnets</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">    router-id <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">!</span><br><span class="line">router bgp <span class="number">1</span></span><br><span class="line">    bgp <span class="built_in">log</span>-neighbor-changes</span><br><span class="line">    neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> remote-as <span class="number">1</span></span><br><span class="line">    neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> update-source Loopback0</span><br><span class="line">    neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> next-hop-self</span><br><span class="line">    !</span><br><span class="line">    address-family vpnv4</span><br><span class="line">    neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> activate</span><br><span class="line">    neighbor <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> send-community both</span><br><span class="line">    <span class="built_in">exit</span>-address-family</span><br><span class="line">    !</span><br><span class="line">    address-family ipv4 vrf A-Site2</span><br><span class="line">    redistribute connected</span><br><span class="line">    redistribute ospf <span class="number">2</span> match internal external <span class="number">1</span> external <span class="number">2</span></span><br><span class="line">    <span class="built_in">exit</span>-address-family</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 force</span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">    exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R3"><a href="#R3" class="headerlink" title="R3:"></a>R3:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R3</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.13</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface Serial1/<span class="number">0</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">    clock rate <span class="number">64000</span></span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">    router-id <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">    exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="R4"><a href="#R4" class="headerlink" title="R4:"></a>R4:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hostname R4</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line">    ip address <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">!</span><br><span class="line">interface FastEthernet0/<span class="number">1</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.24</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">interface Serial1/<span class="number">0</span></span><br><span class="line">    ip address <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">    ip ospf <span class="number">1</span> area <span class="number">0</span></span><br><span class="line">    no shutdown</span><br><span class="line">!</span><br><span class="line">router ospf <span class="number">1</span></span><br><span class="line">    router-id <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span></span><br><span class="line">!</span><br><span class="line">line con <span class="number">0</span></span><br><span class="line">    exec-timeout <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    logging synchronous</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="实验与调试："><a href="#实验与调试：" class="headerlink" title="实验与调试："></a>实验与调试：</h1><h2 id="实验1：当在VPN站点之间存在后门备份链路时，使用OSPF-Sham-Link解决后门链路优先于MPLS-VPN链路的问题；"><a href="#实验1：当在VPN站点之间存在后门备份链路时，使用OSPF-Sham-Link解决后门链路优先于MPLS-VPN链路的问题；" class="headerlink" title="实验1：当在VPN站点之间存在后门备份链路时，使用OSPF Sham Link解决后门链路优先于MPLS VPN链路的问题；"></a>实验1：当在VPN站点之间存在后门备份链路时，使用OSPF Sham Link解决后门链路优先于MPLS VPN链路的问题；</h2><p>查看R3的路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R3<span class="meta">#show ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">3.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">4.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> [<span class="number">110</span>/<span class="number">65</span>] via <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">03</span>:<span class="number">07</span>, Serial1/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.13</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.13</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.13</span><span class="number">.3</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.24</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">65</span>] via <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span>, <span class="number">00</span>:<span class="number">03</span>:<span class="number">07</span>, Serial1/<span class="number">0</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, Serial1/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span>/<span class="number">32</span> is directly connected, Serial1/<span class="number">0</span></span><br><span class="line"><span class="comment">//此时，R3去往4.4.4.4/32和192.168.24.0/24是通过走后门链路；</span></span><br><span class="line"><span class="comment">//而后门链路通常是作为备份链路，在主链路正常的情况下，通常不希望，走备份链路；</span></span><br></pre></td></tr></table></figure>
<p>查看R3的OSPF Database；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R3(config-<span class="keyword">if</span>)<span class="meta">#do sh ip  ospf 1 database</span></span><br><span class="line">            OSPF Router with <span class="title function_">ID</span> <span class="params">(<span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span>)</span> <span class="params">(Process ID <span class="number">1</span>)</span></span><br><span class="line">                Router Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">3.3.3.3         3.3.3.3         10          0x80000006 0x003904 4</span><br><span class="line">4.4.4.4         4.4.4.4         11          0x80000004 0x0049D4 4</span><br><span class="line">11.11.11.11     11.11.11.11     110         0x80000001 0x00B333 1</span><br><span class="line">22.22.22.22     22.22.22.22     95          0x80000002 0x0075FF 1</span><br><span class="line">192.168.24.4    192.168.24.4    1384        0x80000005 0x00DADF 4</span><br><span class="line">                Net Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum</span><br><span class="line">192.168.13.3    3.3.3.3         108         0x80000001 0x007408</span><br><span class="line">192.168.24.4    4.4.4.4         94          0x80000001 0x001D1F</span><br><span class="line">                Summary Net Link <span class="title function_">States</span> <span class="params">(Area <span class="number">0</span>)</span></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum</span><br><span class="line">3.3.3.3         22.22.22.22     99          0x80000001 0x00F461</span><br><span class="line">4.4.4.4         11.11.11.11     89          0x80000001 0x00126C</span><br><span class="line">192.168.13.0    22.22.22.22     99          0x80000001 0x0034B8</span><br><span class="line">192.168.24.0    11.11.11.11     99          0x80000001 0x000608</span><br><span class="line">                Type-5 AS External Link States</span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Tag</span><br><span class="line">11.11.11.11     22.22.22.22     99          0x80000001 0x00E478 3489660929</span><br><span class="line">22.22.22.22     11.11.11.11     109         0x80000001 0x003429 3489660929</span><br></pre></td></tr></table></figure>
<p>注意到，从MPLS VPN过来的LSA是类型3的LSA，而从后门链路过来的LSA是类型1的LSA；以前的实验说过，在OSPF看来，MPLS VPN超骨干网络超越了OSPF骨干区域Area0，MPLS VPN超骨干网络神似OSPF骨干区域Area0，但它又和OSPF骨干区域Area0不同，所以PE路由器会执行ABR的功能，会将类型为1和2的LSA转换为类型3的LSA；所以当PE在收到来自对端远程PE发来的OSPF区域内路由（O）时，会将OSPF区域内路由转换为OSPF区域间路由（O IA）。</p>
<p>为了避免PE将类型1和类型2的LSA转换为类型3的LSA，可以在PE之间创建OSPF Sham Link；这样，当LSA在Sham Link中进行洪泛时，所有的OSPF路由类型都不会改变，不会转变为类型3或者类型5的LSA；</p>
<p><strong>在PE上配置OSPF Sham Link；</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">注意：必须将Sham Link的源地址和目的地址所在的接口划分进VRF；</span><br><span class="line">R1(config)<span class="meta">#router ospf 2 vrf A-Site1</span></span><br><span class="line">R1(config-router)<span class="meta">#area 0 sham-link 11.11.11.11 22.22.22.22</span></span><br><span class="line"></span><br><span class="line">R2(config)<span class="meta">#router ospf 2 vrf A-Site2</span></span><br><span class="line">R2(config-router)<span class="meta">#area 0 sham-link 22.22.22.22 11.11.11.11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将接口Loopback1的地址以路由的形式通告进MP-BGP的IPv4 VRF地址族；</span></span><br><span class="line"><span class="comment">//注意：必须在PE上将各自用作Sham Link的源地址的接口地址通告进MP-BGP的IPv4 VRF地址族，否则Sham Link会反复震荡；</span></span><br><span class="line">R1(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R1(config-router)<span class="meta">#address-family ipv4 vrf A-Site1</span></span><br><span class="line">R1(config-router-af)<span class="meta">#network 11.11.11.11 mask 255.255.255.255</span></span><br><span class="line"></span><br><span class="line">R2(config)<span class="meta">#router bgp 1</span></span><br><span class="line">R2(config-router)<span class="meta">#address-family ipv4 vrf A-Site2</span></span><br><span class="line">R2(config-router-af)<span class="meta">#network 22.22.22.22 mask 255.255.255.255</span></span><br></pre></td></tr></table></figure>
<p>将作为Sham Link源地址，并且同时也作为了对方PE Sham Link目的地址的接口移除OSPF VRF进程；</p>
<blockquote>
<p>备注：虽然在此次实验中，我没有将R1和R2的Loopback1通告进OSPF VRF进程，但仍需注意这一点；</p>
</blockquote>
<blockquote>
<p>注意：确保作为Sham Link源地址和目的地址的接口不能被通告进OSPF VRF进程；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router ospf 2 vrf A-Site1               </span></span><br><span class="line">R1(config-router)<span class="meta">#no network 11.11.11.11 0.0.0.0 area 0</span></span><br><span class="line"></span><br><span class="line">R2(config)<span class="meta">#router ospf 2 vrf A-Site2</span></span><br><span class="line">R2(config-router)<span class="meta">#no network 22.22.22.22 0.0.0.0 area 0</span></span><br></pre></td></tr></table></figure>
<p>查看R3的路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R3(config-<span class="keyword">if</span>)<span class="meta">#do sh ip route           </span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">3.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">4.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> [<span class="number">110</span>/<span class="number">4</span>] via <span class="number">192.168</span><span class="number">.13</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">01</span>:<span class="number">09</span>, FastEthernet0/<span class="number">1</span> <span class="comment">//注意路由的度量值；</span></span><br><span class="line">        <span class="number">11.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O E2     <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> [<span class="number">110</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.13</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">03</span>:<span class="number">04</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">22.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O E2     <span class="number">22.22</span><span class="number">.22</span><span class="number">.22</span> [<span class="number">110</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.13</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">15</span>:<span class="number">51</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.13</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.13</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.13</span><span class="number">.3</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.24</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.13</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">01</span>:<span class="number">09</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, Serial1/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span>/<span class="number">32</span> is directly connected, Serial1/<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>查看R4的路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#do sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">3.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> [<span class="number">110</span>/<span class="number">4</span>] via <span class="number">192.168</span><span class="number">.24</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">02</span>:<span class="number">12</span>, FastEthernet0/<span class="number">1</span> <span class="comment">//注意路由的度量值；</span></span><br><span class="line">        <span class="number">4.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">11.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O E2     <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> [<span class="number">110</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.24</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">16</span>:<span class="number">39</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">22.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O E2     <span class="number">22.22</span><span class="number">.22</span><span class="number">.22</span> [<span class="number">110</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.24</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">02</span>:<span class="number">12</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.13</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">3</span>] via <span class="number">192.168</span><span class="number">.24</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">02</span>:<span class="number">12</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.24</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.24</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.24</span><span class="number">.4</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, Serial1/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span>/<span class="number">32</span> is directly connected, Serial1/<span class="number">0</span></span><br><span class="line"><span class="comment">//可以看到R3和R4现在都通过MPLS VPN去往对方所在站点；</span></span><br></pre></td></tr></table></figure>

<p>在必要时还可以修改Sham Link的开销，让Sham Link比后门链路的度量值更低，以便优先选择作为主链路的MPLS VPN，而不是备份的后门链路；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="meta">#router ospf 2 vrf A-Site1</span></span><br><span class="line">R1(config-router)<span class="meta"># area 0 sham-link 11.11.11.11 22.22.22.22 cost 10</span></span><br><span class="line"></span><br><span class="line">R2(config-router-af)<span class="meta">#router ospf 2 vrf A-Site2</span></span><br><span class="line">R2(config-router)<span class="meta">#area 0 sham-link 22.22.22.22 11.11.11.11 cost 10</span></span><br></pre></td></tr></table></figure>

<p>查看R3的路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R3(config-<span class="keyword">if</span>)<span class="meta">#do sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">3.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">4.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> [<span class="number">110</span>/<span class="number">13</span>] via <span class="number">192.168</span><span class="number">.13</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">58</span>, FastEthernet0/<span class="number">1</span> <span class="comment">//注意路由的度量值变化；</span></span><br><span class="line">        <span class="number">11.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O E2     <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> [<span class="number">110</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.13</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">04</span>:<span class="number">59</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">22.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O E2     <span class="number">22.22</span><span class="number">.22</span><span class="number">.22</span> [<span class="number">110</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.13</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">17</span>:<span class="number">46</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.13</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.13</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.13</span><span class="number">.3</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.24</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">12</span>] via <span class="number">192.168</span><span class="number">.13</span><span class="number">.1</span>, <span class="number">00</span>:<span class="number">00</span>:<span class="number">58</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, Serial1/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.34</span><span class="number">.3</span>/<span class="number">32</span> is directly connected, Serial1/<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>查看R4的路由表；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R4(config-<span class="keyword">if</span>)<span class="meta">#do sh ip route</span></span><br><span class="line">Codes: L - local, C - connected, S - <span class="type">static</span>, R - RIP, M - mobile, B - BGP</span><br><span class="line">        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area </span><br><span class="line">        N1 - OSPF NSSA external type <span class="number">1</span>, N2 - OSPF NSSA external type <span class="number">2</span></span><br><span class="line">        E1 - OSPF external type <span class="number">1</span>, E2 - OSPF external type <span class="number">2</span></span><br><span class="line">        i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="number">-1</span>, L2 - IS-IS level<span class="number">-2</span></span><br><span class="line">        ia - IS-IS inter area, * - candidate <span class="keyword">default</span>, U - per-user <span class="type">static</span> route</span><br><span class="line">        o - ODR, P - periodic downloaded <span class="type">static</span> route, H - NHRP, l - LISP</span><br><span class="line">        + - replicated route, % - next hop override</span><br><span class="line">Gateway of last resort is not <span class="built_in">set</span></span><br><span class="line">        <span class="number">3.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O        <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span> [<span class="number">110</span>/<span class="number">13</span>] via <span class="number">192.168</span><span class="number">.24</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">02</span>:<span class="number">11</span>, FastEthernet0/<span class="number">1</span> <span class="comment">//注意路由的度量值变化；</span></span><br><span class="line">        <span class="number">4.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">C        <span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span> is directly connected, Loopback0</span><br><span class="line">        <span class="number">11.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O E2     <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> [<span class="number">110</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.24</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">19</span>:<span class="number">40</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">22.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">32</span> is subnetted, <span class="number">1</span> subnets</span><br><span class="line">O E2     <span class="number">22.22</span><span class="number">.22</span><span class="number">.22</span> [<span class="number">110</span>/<span class="number">1</span>] via <span class="number">192.168</span><span class="number">.24</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">05</span>:<span class="number">13</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">O     <span class="number">192.168</span><span class="number">.13</span><span class="number">.0</span>/<span class="number">24</span> [<span class="number">110</span>/<span class="number">12</span>] via <span class="number">192.168</span><span class="number">.24</span><span class="number">.2</span>, <span class="number">00</span>:<span class="number">02</span>:<span class="number">11</span>, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.24</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.24</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.24</span><span class="number">.4</span>/<span class="number">32</span> is directly connected, FastEthernet0/<span class="number">1</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line">C        <span class="number">192.168</span><span class="number">.34</span><span class="number">.0</span>/<span class="number">24</span> is directly connected, Serial1/<span class="number">0</span></span><br><span class="line">L        <span class="number">192.168</span><span class="number">.34</span><span class="number">.4</span>/<span class="number">32</span> is directly connected, Serial1/<span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>MPLS</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>BIG-IP Local Traffic Manager Concepts v11.5.0</title>
    <url>/2017/BIG-IP-Local-Traffic-Manager-Concepts-v11-5-0/</url>
    <content><![CDATA[<blockquote>
<p>本文是 F5官方文档 <a href="https://techdocs.f5.com/kb/en-us/products/big-ip_ltm/manuals/product/ltm-concepts-11-5-0.html">BIG-IP Local Traffic Manager Concepts v11.5.0</a> 的中文翻译版。初次于2017年11月30日发布在 <a href="https://github.com/filefi/CN_BIG-IP_Local_Traffic_Manager_Concepts_v11.5.0">此repo</a>。</p>
</blockquote>
<h1 id="第1章-介绍本地流量管理器（Local-Traffic-Manager）"><a href="#第1章-介绍本地流量管理器（Local-Traffic-Manager）" class="headerlink" title="第1章 介绍本地流量管理器（Local Traffic Manager）"></a>第1章 介绍本地流量管理器（Local Traffic Manager）</h1><h2 id="1-1-什么是BIG-IP本地流量管理器？"><a href="#1-1-什么是BIG-IP本地流量管理器？" class="headerlink" title="1.1 什么是BIG-IP本地流量管理器？"></a>1.1 什么是BIG-IP本地流量管理器？</h2><p>BIG-IP本地流量管理（Local Traffic Manager）控制流入或流出局域网LAN（包括内联网intranet）的网络流量。</p>
<p>出于智能地调整网络服务器上负载的目的，LTM的一个常用功能是它拦截和重定向入站网络流量的能力。但是，调整服务器负载并不是唯一的本地流量管理方式。</p>
<p>LTM包含了各种功能，例如，执行检查和转换报头和内容数据，管理基于SSL证书的认证，以及压缩HTTP响应。这样做，BIG-IP系统不仅会定向流量到适合的服务器资源，而且还通过执行Web服务器通常执行的任务来增强了网络安全，并释放了服务器资源。</p>
<blockquote>
<p>注意： BIG-IP LTM是组成BIG-IP产品系列的几种产品之一。BIG-IP产品线中的所有产品都运行在强大的流量管理操作系统（Traffic Management Operating System）（通常称为TMOS）上。</p>
</blockquote>
<span id="more"></span>

<h2 id="1-2-连接（Connection）和会话（Session）的超时设置"><a href="#1-2-连接（Connection）和会话（Session）的超时设置" class="headerlink" title="1.2 连接（Connection）和会话（Session）的超时设置"></a>1.2 连接（Connection）和会话（Session）的超时设置</h2><p>LTM有一些可以被设置，以促进活动（active）连接管理的超时设置。只要连接仍然处于活动状态（active），系统就会通过跟踪连接表中的连接来显式地管理每个连接。连接表（Connection table）包含关于客户端（client-side）和服务器端（server-side）连接的状态信息，以及客户端与服务器端之间的关系的状态信息。</p>
<p>连接表中每个连接都消耗系统资源来维护连接表条目和检查连接状态。当LTM必须判断一个连接何时不再处于活动状态（active），然后撤销（retire）连接，以避免耗尽关键系统资源。如果连接表不断增长，并保持未检查状态（unchecked），如内存和处理器周期这样的资源将存在风险。</p>
<p>当使用会话保持（Session persistence）时，你也可以管理会话保持表中的条目的持续时间。</p>
<h2 id="1-3-连接收割（Connection-reaping）"><a href="#1-3-连接收割（Connection-reaping）" class="headerlink" title="1.3 连接收割（Connection reaping）"></a>1.3 连接收割（Connection reaping）</h2><p>以正常方式关闭和重置的连接会自动从连接表中撤销（retire）。然而，由于许多原因，大量连接通常保持空闲，而没有正常关闭。因此，一旦这些连接被判断为处于非活跃状态（inactive），LTM必须收割（reap）这些连接。收割（reaping）是撤销或回收原本处于空闲的连接的过程。</p>
<p>由于你可以在多个地方配置超时设置，所以有时可能有不止一个超时设置在影响同一个连接。理解这一点很重要。最佳的超时配置是：为了保留系统资源，在确定连接处于非活动状态（inactive）并应该被撤销（retire）之前，将空闲连接保持一段适当的时间（取决于具体应用）。</p>
<h2 id="1-4-空闲超时选项"><a href="#1-4-空闲超时选项" class="headerlink" title="1.4 空闲超时选项"></a>1.4 空闲超时选项</h2><p>通过与处理连接的虚拟服务器（virtual server）相关联的模板（protocol profiles）或SNAT，空闲连接可以被超时。基于SNAT automap 或 VLAN group设置，没有被虚拟服务器（virtual server）管理的连接也可以被超时。</p>
<p>应用于一个连接的最短超时值是始终生效的。但是，在某些情况下，你可以想要修改此行为。</p>
<p>例如，你可能已经配置了一个用于处理长期连接（long-standing connections）的forwarding virtual server，并且这些连接可能会长时间处于空闲状态（例如SSH会话）。在这种情况下，你可以在相关的protocol profile（在这个例子中，SSH使用的是TCP）中配置一个很长的空闲超时值。但是，如果SNAT automap功能也被启用，则默认的300秒静态超时值仍然生效。</p>
<h3 id="影响连接收割的空闲超时设置"><a href="#影响连接收割的空闲超时设置" class="headerlink" title="影响连接收割的空闲超时设置"></a>影响连接收割的空闲超时设置</h3><p>以下是一个包含影响连接收割的空闲连接超时设置的对象列表。对于每种对象类型，表中列出了默认值，以及该值是否是用户可配置的。</p>
<table>
<thead>
<tr>
<th>配置对象类型</th>
<th>默认值（秒）</th>
<th>用户可配置</th>
</tr>
</thead>
<tbody><tr>
<td>Fast L4, Fast HTTP, TCP, SCTP profiles</td>
<td>300</td>
<td>是</td>
</tr>
<tr>
<td>UDP profiles</td>
<td>60</td>
<td>是</td>
</tr>
<tr>
<td>SNAT automap</td>
<td>300</td>
<td>否</td>
</tr>
<tr>
<td>VLAN group</td>
<td>300</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="1-5-其他超时设置"><a href="#1-5-其他超时设置" class="headerlink" title="1.5 其他超时设置"></a>1.5 其他超时设置</h2><p>LTM包含其他2个超时设置，但这些设置不影响连接收割。这些设置出现在 OneConnect™ 和 会话保持（persistence profile）中。</p>
<p>OneConnect超时值控制着空闲的服务器端（server-side）连接可用于重用（re-use）的时长。也就是说，在服务器端（server-side）连接空闲了一段时间之后，这个超时值可能会导致系统关闭此服务器端（server-side）连接。在这种情况下，由于连接从未被主动使用，所以没有活动的（active）客户端（client-side）连接受到影响，并且系统会为新连接透明地选择或建立另一个服务器端（server-side）连接。OneConnect超时设置不需要与其他模板（profile）的超时设置相一致。</p>
<p>会话保持（Persistence）超时设置其实是一个会话（Session）的空闲超时设置，而不是单个连接（connection）。因此，会话保持超时设置通常应该被设置为稍大于适用的连接空闲超时设置，以此来允许会话继续，即使该会话中的连接已经过期。</p>
<h3 id="不影响连接收割的空闲超时设置"><a href="#不影响连接收割的空闲超时设置" class="headerlink" title="不影响连接收割的空闲超时设置"></a>不影响连接收割的空闲超时设置</h3><p>LTM包括其他2个空闲超时设置，但这些设置不会影响连接收割。这些设置出现在 <em><strong>OneConnect</strong></em> 和 <strong>persistence <em>profile</em></strong> 中。此表展示了这些设置的默认值以及设置是否是用户可配置的。</p>
<table>
<thead>
<tr>
<th>配置对象类型</th>
<th>默认值（秒）</th>
<th>用户可配置</th>
</tr>
</thead>
<tbody><tr>
<td>OneConnect™ profiles</td>
<td>disabled</td>
<td>是</td>
</tr>
<tr>
<td>Cookie Hash, Destination Address Affinity, Hash, SIP, Source Address Affinity, and Universal persistence profiles</td>
<td>180</td>
<td>是</td>
</tr>
<tr>
<td>MSRDP and SSL persistence profiles</td>
<td>300</td>
<td>是</td>
</tr>
</tbody></table>
<h2 id="1-6-关于network-map"><a href="#1-6-关于network-map" class="headerlink" title="1.6 关于network map"></a>1.6 关于network map</h2><p>BIG-IP Configuration utility 包括被称为network map的功能。<em><strong>network map</strong></em> 显示一个本地流量对象的汇总，以及BIG-IP系统上的virtual server，pool和pool member的可视化示意图。对于本地流量汇总和network map，你都可以使用检索机制来自定义显示内容，该机制根据您指定的条件过滤要显示的内容。系统会以蓝色来高亮显示所有检索操作的匹配结果。</p>
<h3 id="过滤机制"><a href="#过滤机制" class="headerlink" title="过滤机制"></a>过滤机制</h3><p>通过使用过滤框（filter bar）中的Type和Status列表，以及Search Box，你可以过滤network map功能的结果。有了Search box，你可以选择输入特定的字符串。图1.1 展示了Network Map界面中的过滤选项。</p>
<p><img src="https://support.f5.com/kb/global/manual_images/MAN-0377-06_v6/filter_screen.png" alt="image"><br><strong>图1：Network Map界面中的过滤选项</strong></p>
<p>当使用Search Box时，你可以指定在搜索操作中系统所使用的文本字符串。默认值是星号（*）。Status和Type字段的设置决定了搜索的范围。系统使用所指定的搜索字符串来过滤显示在屏幕上的结果。</p>
<p>例如，如果你限制搜索的内容为只包括IP地址包含10.10的不可用结点（Node），此操作将返回这些结点（Nodes），连同Pool的成员（Members），Pool本身，相关联的VS，以及你显式应用于VS的iRules。系统会按VS Name的字母顺序对结果排序。</p>
<p>系统支持搜索以IPv4和IPv6的地址格式搜索名字，IP地址，以及IP地址：端口组合。如果会像有星号通配符包围着字符串那样来处理字符串。例如，你指定了<code>10</code>，系统会像你输入了<code>*10*</code>那样来进行有效查找。当然你也可以明确地包含星号通配符。例如，你可以使用下列字搜索字符串:<code>10.10.10.*:80</code>,<code>10.10.*</code>和<code>*:80</code>。如果你明确地包含通配符，系统也会相应地处理该字符串。例如，如果你指定<code>10*</code>，则系统假设你希望搜索IP地址以10开头的对象。</p>
<blockquote>
<p>提示：在浏览器运行变慢和停止处理之前，浏览器可以渲染数据的量是有限制的。映射大型配置可能会接近这些限制; 因此，内存限制可能会阻止系统生成整个配置的network map<br>。如果发生这种情况，系统会发布一个警告（alert），指出您可以使用Network Map汇总界面来确定配置的复杂程度。这可以给你关于所生成的network map大小的指示。您可以修改搜索条件以返回较少的结果，这样生成的network map就不会遇到这些限制了。</p>
</blockquote>
<h3 id="对象汇总"><a href="#对象汇总" class="headerlink" title="对象汇总"></a>对象汇总</h3><p>当你第一次打开Network Map界面，该界面将显示本地流量对象的汇总摘要。此汇总摘要包括使用搜索机制指定的对象类型，每种对象类型的数量，以及对于每种对象类型，不同状态对象的数量。</p>
<p>汇总摘要会显示以下对象类型的数据：</p>
<ul>
<li>Virtual Server</li>
<li>Pools</li>
<li>Pool members</li>
<li>Nodes</li>
<li>iRules</li>
</ul>
<blockquote>
<p>注意：本地流量摘要仅包含被VS引用的那些对象。例如，如果您已经在系统上配置了一个Pool，但没有引用该Pool的VS，则本地流量摘要不包括此Pool，及其成员或摘要中的关联的节点。</p>
</blockquote>
<p>此图显示了汇总系统上本地流量对象的network map界面的示例。</p>
<p><img src="https://support.f5.com/kb/global/manual_images/MAN-0377-06_v6/i_net_map_summary.png" alt="image"></p>
<p><strong>图2：本地流量汇总摘要</strong></p>
<h3 id="network-map显示"><a href="#network-map显示" class="headerlink" title="network map显示"></a>network map显示</h3><p>Network Map 显示了在系统上定义的对象名称和状态的可视化层次结构，这些对象类型包括 VS，Pools，Pool Member，Nodes以及iRules。Network Map能够显示上下文中的所有对象，并从顶部的VS开始。在屏幕顶部的 Status，Type 和 Search 设置决定了 Network Map 包含的对象。</p>
<p>当你将光标放在 Network map 中的一个对象上时，系统将显示悬停文本，其中包含关于该对象的信息。当你把光标放在伴随对象的状态图标上时，系统将显示悬停文本，其中包含关于该对象状态信息，文本也将出现 在Pool 的 Properties 界面。</p>
<p>系统按字母表顺序对对象进行排序，然后以层次化结构的方式组织依赖对象。</p>
<p>由于 Network Map 在上下文中显示对象的方式，更新后的界面（screen）也会显示与这些对象相关的其他状态、类型和名字的对象。这是因为 Network Map 在显示对象时， 总是在上下文中显示那些依赖它们的对象，以及它们依赖的对象。</p>
<p>例如，如果你有一个可用的 VS 和一个可用的 Pool，以及2个 Pool Member（其中1个可用，1个离线），然后从 Status 列表中选择 Offline，这将导致系统在上下文中显示离线（offline）的 Pool Member，以及可用的 VS 和 可用的 Pool。这是因为可用的 VS 和可用的 Pool 依赖于离线的 Pool Member。</p>
]]></content>
      <categories>
        <category>F5</category>
      </categories>
      <tags>
        <tag>F5</tag>
        <tag>LoadBalance</tag>
      </tags>
  </entry>
  <entry>
    <title>BIG-IP System iRules Concepts v11.6</title>
    <url>/2017/BIG-IP-System-iRules-Concepts-v11-6/</url>
    <content><![CDATA[<blockquote>
<p>本文是 F5官方文档 <a href="https://support.f5.com/kb/en-us/products/big-ip_ltm/manuals/product/bigip-system-irules-concepts-11-6-0.html">BIG-IP System iRules Concepts v11.6</a> 的中文翻译版。初次于2017年11月30日发布在 <a href="https://github.com/filefi/CN_BIG-IP_System_iRules_Concepts_v11.6">此repo</a>。</p>
</blockquote>
<h1 id="1-iRules介绍"><a href="#1-iRules介绍" class="headerlink" title="1 iRules介绍"></a>1 iRules介绍</h1><h2 id="什么是iRule"><a href="#什么是iRule" class="headerlink" title="什么是iRule"></a>什么是iRule</h2><p>iRule是BIG-IP本地流量管理器（LTM）中的一个强大而灵活的功能，你可以用它来管理你的网络流量。使用基于行业标准工具命令语言（Tcl）的语法，iRules功能不仅允许您根据报头数据（header data）选择Pools，还可以通过搜索您自定义的任何类型的内容数据来定向流量。因此，iRules功能显著地增强了您自定义内容交换（content switching）以适应您确切需求的能力。</p>
<blockquote>
<p>重要：有关iRules语法的完整和详细信息，请参阅F5 Networks DevCentral网站 <a href="http://devcentral.f5.com.请注意,irules必须符合标准的tcl语法规则/">http://devcentral.f5.com。请注意，iRules必须符合标准的Tcl语法规则</a>; 因此，有关Tcl语法的更多信息，请参见 <a href="http://tmml.sourceforge.net/doc/tcl/index.html%E3%80%82">http://tmml.sourceforge.net/doc/tcl/index.html。</a></p>
</blockquote>
<p>如果您想要单独的连接来命中（target）除为Virtual Server定义的默认Pool之外的Pool，则你就可以写这样一个iRule脚本。iRules允许您更直接地指定要将流量定向到你想要的目的地。使用iRules，您不仅可以将流量发送到Pool，还可以向单个Pool Member，端口或URI发送流量。您创建的iRules可以很简单，也可以很复杂，具体取决于您的内容交换（content-switching）需求。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">when CLIENT_ACCEPTED &#123;</span><br><span class="line">    <span class="keyword">if</span> &#123; [IP::addr [IP::client_addr] equals <span class="number">10.10</span><span class="number">.10</span><span class="number">.10</span>] &#125; &#123;</span><br><span class="line">        pool my_pool </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当客户端连接被接受时，这条iRule会被触发。这时，如果客户端的地址与 <code>10.10.10.10</code> 相匹配，将使得本地流量管理器（LTM）将数据包发送到my_pool池。</p>
<span id="more"></span>

<p>使用称为通用检查引擎（Universal Inspection Engine）的功能，您可以编写一个搜索数据包头部或实际数据包内容的iRule，然后根据该检索结果来定向数据包。iRules还可以根据客户端认证的结果来定向数据包。</p>
<p>iRules不仅可以将流量定向到特定Pool，还可以将流量定向到单个Pool Member，甚至包括特定端口号和URI路径，以实现会话保持（persistence）或满足特定的负载均衡要求。</p>
<p>用于编写iRules的语法是基于工具命令语言（Tcl）编程标准。因此，您可以使用许多标准Tcl命令，以及本地流量管理器（LTM）提供的强大的扩展集，以帮助您进一步提高负载均衡效率。</p>
<blockquote>
<p>重要提示：引用iRule中的对象时，必须包含对象的完整路径名。</p>
</blockquote>
<h3 id="iRule命令"><a href="#iRule命令" class="headerlink" title="iRule命令"></a>iRule命令</h3><p>iRule中的 <em><strong>iRule命令</strong></em> 会使本地流量管理器（LTM）采取一些动作，如查询数据，操作数据，或指定流量的目的地。您可以在iRules中包含的命令类型有：</p>
<h4 id="声明命令（Statement-Commands）"><a href="#声明命令（Statement-Commands）" class="headerlink" title="声明命令（Statement Commands）"></a>声明命令（Statement Commands）</h4><p>这些命令会引起诸如选择流量目的地或分配SNAT转换地址等动作。语句命令的一个例子是<code>pool &lt;name&gt;</code>，它将流量引导到命名的负载平衡池（Pool）。</p>
<h4 id="查询或操纵数据的命令"><a href="#查询或操纵数据的命令" class="headerlink" title="查询或操纵数据的命令"></a>查询或操纵数据的命令</h4><p>一些命令会搜索报头（header）和内容数据，而其他命令执行数据操作，例如将header插入到HTTP请求中。查询命令的一个例子是 <code>IP:: remote_addr</code>，它搜索并返回连接的远程IP地址。数据操作命令的一个例子是<code>HTTP::header remove &lt;name&gt;</code>，它从请求或响应中删除命名的header的最后一次事件（occurrence）。</p>
<h4 id="工具命令（Utility-Commands）"><a href="#工具命令（Utility-Commands）" class="headerlink" title="工具命令（Utility Commands）"></a>工具命令（Utility Commands）</h4><p>这些命令是对解析和操作内容非常有用的功能。一个工具命令的例子是<code>decode_uri &lt;string&gt;</code>，它使用HTTP URI编码解码命名的字符串并返回结果。</p>
<h3 id="事件声明"><a href="#事件声明" class="headerlink" title="事件声明"></a>事件声明</h3><p>iRules是事件驱动的，这意味着本地流量管理器(LTM)会根据您在iRule中指定的事件来触发iRule。<em><strong>事件声明</strong></em> 是iRule中一个事件的详细描述，这个事件会导致本地流量管理器（LTM）不论何时，只要事件发生就触发iRule。事件<code>HTTP_REQUEST</code>是触发iRule事件声明的例子，每当系统收到HTTP请求时，此事件会触发iRule；还有事件<code> CLIENT_ACCCEPTED</code>，此事件会在客户端建立连接时触发iRule。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">when HTTP_REQUEST &#123; </span><br><span class="line">    <span class="keyword">if</span> &#123; [HTTP::uri] contains <span class="string">&quot;aol&quot;</span> &#125; &#123;</span><br><span class="line">        pool aol_pool </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        pool all_pool </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>iRule运算符会比较表达式中的两个操作数。</p>
<p>例如，您可以使用<code>contains</code>运算符将变量操作数与常量进行比较。您可以通过创建一个if语句来表示以下内容：“如果HTTP URI包含aol，发送到aol_pool池。</p>
<h2 id="创建iRule"><a href="#创建iRule" class="headerlink" title="创建iRule"></a>创建iRule</h2><p>您创建一个iRule来自定义BIG-IP系统处理流量的方式。</p>
<ol>
<li>在主选项卡（Main Tab）上，以此点击<strong>Local Traffic &gt; iRules</strong>.</li>
<li>点击<strong>Create</strong>。</li>
<li>在<strong>Name</strong>字段中，键入名称，如my_irule.iRule的完整路径名称不能超过255个字符.</li>
<li>在<strong>Definition</strong>字段中，使用“工具命令语言（Tcl）”语法键入iRule的语法。 有关iRules语法的完整和详细信息，请参阅F5 Networks DevCentral网站 <a href="http://devcentral.f5.com/">http://devcentral.f5.com</a>.</li>
<li>点击<strong>Finished</strong>.</li>
</ol>
<hr>
<h1 id="2-iRule命令"><a href="#2-iRule命令" class="headerlink" title="2 iRule命令"></a>2 iRule命令</h1><h2 id="iRule命令类型"><a href="#iRule命令类型" class="headerlink" title="iRule命令类型"></a>iRule命令类型</h2><p>有三种iRule命令类型：</p>
<ul>
<li>声明命令（Statement Commands）</li>
<li>查询与操作命令（Query and Manipulation Commands）</li>
<li>工具（Utility）命令（也称为函数）</li>
</ul>
<h3 id="声明命令"><a href="#声明命令" class="headerlink" title="声明命令"></a>声明命令</h3><p>iRules中一些可用的命令被称为声明命令（Statement Commands）。<em><strong>声明命令</strong></em> 使得LTM能够执行各种不同的动作。例如，其中一些命令可以指定要使用LTM来重定向的pool和server。其他命令指定实现SNAT连接的翻译地址（Translation Address）。还有其他命令用于指定类似data group或者persistence profile的对象。</p>
<blockquote>
<p>有关语句命令的完整列表，请参阅F5 Networks DevCentral网站 <a href="http://devcentral.f5.com./">http://devcentral.f5.com。</a></p>
</blockquote>
<h3 id="查询和操作命令"><a href="#查询和操作命令" class="headerlink" title="查询和操作命令"></a>查询和操作命令</h3><p>使用iRules命令，你可以查询包含在一个请求或相应的头部（Header）或内容中的特定数据，或者操作这些数据。数据处理指的是插入，替换和删除数据，以及设置在头部（Header）和Cookie中找到的某些值。</p>
<p>例如，使用iRules中的<code>IP::idle_timeout</code>命令，你可以查询当前被设置在数据包报头中的空闲超时（Idle Timeout）值，然后相对应地对数据包进行负载均衡。你也可以使用<code>IP :: idle_timeout</code>命令将空闲超时设置为您选择的特定值。</p>
<blockquote>
<p>有关iRules命令的命名空间的完整列表，请参阅F5 Networks DevCentral网站 <a href="http://devcentral.f5.com./">http://devcentral.f5.com。</a></p>
</blockquote>
<h3 id="工具命令"><a href="#工具命令" class="headerlink" title="工具命令"></a>工具命令</h3><p>LTM包括一些你可以在iRules中使用的工具命令。你可以使用这些命令来解析和检索内容，将数据编码为ASCII格式，校验数据完整性，以及检索关于Active的pool和pool member的信息。</p>
<h2 id="pool命令"><a href="#pool命令" class="headerlink" title="pool命令"></a>pool命令</h2><p>一旦你已经在iRules中指定了一个查询，你就可以使用<code>pool</code>命令来选择一个你希望LTM向其发送请求的负载均衡Pool。这是一个此命令的示例：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">when HTTP_REQUEST &#123; </span><br><span class="line">    <span class="keyword">set</span> uri [HTTP::uri] </span><br><span class="line">    <span class="keyword">if</span> &#123; <span class="variable">$uri</span> ends_with <span class="string">&quot;.gif&quot;</span> &#125; &#123;</span><br><span class="line">        pool my_pool </span><br><span class="line">    &#125; elseif &#123; <span class="variable">$uri</span> ends_with <span class="string">&quot;.jpg&quot;</span> &#125; &#123;</span><br><span class="line">        pool your_pool</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="node命令"><a href="#node命令" class="headerlink" title="node命令"></a>node命令</h2><p>作为<code>pool</code>命令的替代命令，你也可以写一个定向流量到指定服务器（server）的iRule。要这样做，你可以使用<code>node</code>命令。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">when HTTP_REQUEST &#123; </span><br><span class="line">    <span class="keyword">if</span> &#123; [HTTP::uri] ends_with <span class="string">&quot;.gif&quot;</span> &#125; &#123;</span><br><span class="line">        node <span class="number">10.1</span><span class="number">.2</span><span class="number">.200</span> <span class="number">80</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择缓存服务器池（pool）的命令"><a href="#选择缓存服务器池（pool）的命令" class="headerlink" title="选择缓存服务器池（pool）的命令"></a>选择缓存服务器池（pool）的命令</h2><p>你可以创建一个iRule，这个iRule可以从缓存服务器池（pool）中选择一个服务器（Server）。这是一个从缓存服务器池中选择一个服务器的示例：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">when HTTP_REQUEST &#123;</span><br><span class="line"><span class="comment">    # This line specifies the expressions that determine whether the BIG-IP system sends requests to the cache pool:</span></span><br><span class="line">    <span class="keyword">if</span> &#123; [HTTP::uri] ends_with <span class="string">&quot;html&quot;</span> or [HTTP::uri] ends_with <span class="string">&quot;gif&quot;</span> &#125; &#123;</span><br><span class="line">        pool cache_pool</span><br><span class="line">        <span class="keyword">set</span> key [crc32 [<span class="keyword">concat</span> [domain [HTTP::host] <span class="number">2</span>] [HTTP::uri]]]</span><br><span class="line">        <span class="keyword">set</span> cache_mbr [persist lookup hash <span class="variable">$key</span> node]</span><br><span class="line">        <span class="keyword">if</span> &#123; <span class="variable">$cache_mbr</span> ne <span class="string">&quot;&quot;</span> &#125; &#123;</span><br><span class="line"><span class="comment">            # This line verifies that the request is not coming from the cache:</span></span><br><span class="line">            <span class="keyword">if</span> &#123; [IP::addr [IP::remote_addr] equals <span class="variable">$cache_mbr</span>] &#125; &#123;</span><br><span class="line"><span class="comment">                # This line sends the request from the cache to the origin pool:</span></span><br><span class="line">                pool origin_pool</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">    #These lines ensure that the persistence record is added for this host/URI:</span></span><br><span class="line">    persist hash <span class="variable">$key</span></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pool origin_pool</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：LTM是在BIG-IP系统接收到URI的请求时，重定向URI到一个新的缓存服务器，而不是在pool member变为不可用时进行这一重定向操作。</p>
</blockquote>
<h2 id="HTTP-redirect命令"><a href="#HTTP-redirect命令" class="headerlink" title="HTTP::redirect命令"></a><code>HTTP::redirect</code>命令</h2><p>除了配置iRule来选择指定的pool，你也可以使用 <code>HTTP::redirect</code> iRule命令来重定向HTTP请求到特定位置（location）。这个位置（location）可以是一个主机名或是一个URI。</p>
<p>以下是一个被配置来重定向HTTP响应的iRule。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">when HTTP_RESPONSE &#123;</span><br><span class="line">    <span class="keyword">if</span> &#123; [HTTP::status] contains <span class="string">&quot;404&quot;</span>&#125; &#123;</span><br><span class="line">        HTTP::redirect <span class="string">&quot;http://www.siterequest.com/&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个重定向HTTP请求的iRule示例：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">when HTTP_REQUEST &#123;</span><br><span class="line">    <span class="keyword">if</span> &#123; [HTTP::uri] contains <span class="string">&quot;secure&quot;</span>&#125; &#123; </span><br><span class="line">        HTTP::redirect <span class="string">&quot;https://[HTTP::host][HTTP::uri]&quot;</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="snat和snatpool命令"><a href="#snat和snatpool命令" class="headerlink" title="snat和snatpool命令"></a><code>snat</code>和<code>snatpool</code>命令</h2><p>iRules功能包括2个声明命令<code>snat</code>和<code>snatpool</code>。使用<code>snat</code>命令可以为iRule中的初始（Original）IP地址分配一个指定的翻译地址（Translation Address），而不是使用BIG-IP Configuration utility中的SNAT界面。</p>
<p>使用<code>snatpool</code>命令也可以为初始（Original）IP地址分配翻译地址（Translation Address），尽管不像<code>snat</code>命令，<code>snatpool</code>命令使得LTM从你之前创建的一个特定SNAT池（pool）中选择翻译地址。</p>
<hr>
<h1 id="3-iRule评估（evaluation）"><a href="#3-iRule评估（evaluation）" class="headerlink" title="3 iRule评估（evaluation）"></a>3 iRule评估（evaluation）</h1><h2 id="关于iRule评估（evaluation）"><a href="#关于iRule评估（evaluation）" class="headerlink" title="关于iRule评估（evaluation）"></a>关于iRule评估（evaluation）</h2><p>在不存在iRule的基本系统配置中，LTM将入站流量引导到接收这些流量的VS的默认pool。然而，你可能想让LTM引导某些连接到其他目的地。如果想这样做，可以写一个引导流量到其他目的地的iRule，但这依赖于某种类型的事件发生。否则，流量继续被引导到给VS所分配的默认pool。</p>
<p>因此，每当一个你已经在iRule中指定的事件发生时，iRules都将被评估（evaluate）。例如，如果iRule包含事件声明<code>CLIENT_ACCEPTED</code>，那么每当LTM接受一个客户端连接，iRule将被触发。然后，LTM遵循iRule的剩余部分来决定数据包的目的地。</p>
<blockquote>
<p>注意：当你对iRule进行持久化修改，如果连接表中已经存在连接，那么，修改只有在连接到期后才会生效。同理，当你启用iRule的日志，然后修改iRule（或者变更日志消息本身），也是类似的。</p>
</blockquote>
<h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>iRule命令语法包括几种你可以在iRule中指定的事件声明类型。例如：</p>
<ul>
<li>全局事件，例如<code>CLIENT_ACCEPTED</code></li>
<li>HTTP事件，例如<code>HTTP_REQUEST</code></li>
<li>SSL事件，例如<code>CLIENTSSL_HANDSAKE</code></li>
<li>认证（Authentication）事件，例如<code>AUTH_SUCCESS</code></li>
</ul>
<blockquote>
<p>有关iRule事件及其说明的完整列表，请参阅F5 Networks DevCentral网站 <a href="http://devcentral.f5.com./">http://devcentral.f5.com。</a></p>
</blockquote>
<h2 id="iRule上下文（context）"><a href="#iRule上下文（context）" class="headerlink" title="iRule上下文（context）"></a>iRule上下文（context）</h2><p>对于每个你在iRule中指定的事件，你也可以指定由关键字<code>clientside</code>或<code>serverside</code>所表示的上下文（context）。因为每个事件都有与之关联的默认上下文，所以，如果你想要修改默认的上下文（context），你只需要声明一个上下文（context）。</p>
<p>这个例子展示了<code>my_iRule1</code>，它包含事件声明 <code>CLIENT_ACCEPTED</code>，以及iRule命令<code>IP::remote_addr</code>。在这种情况下，iRule命令返回的IP地址是客户端的IP地址。因为事件声明<code>CLIENT_ACCEPED</code>的默认上下文（context）是<code>clientside</code>。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">when CLIENT_ACCEPTED &#123; </span><br><span class="line">    <span class="keyword">if</span> &#123; [IP::addr [IP::remote_addr] equals <span class="number">10.1</span><span class="number">.1</span><span class="number">.80</span>] &#125; &#123;</span><br><span class="line">        pool my_pool1 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样地，如果你在iRule中包括事件声明<code>SERVER_CONNECTED</code>，以及iRule命令<code>IP::remote_addr</code>，那么iRule命令返回的IP地址就是服务器的IP地址。因为，事件声明<code>SERVER_CONNECTED</code>的默认上下文是<code>serverside</code>。</p>
<p>上述例子展示了当你在处理iRule命令时，编写使用默认上下文（context）的iRule<br>将发生什么。然而，你可以显式地指定关键字<code>clientside</code>和<code>serverside</code>来变更iRule命令的行为。</p>
<p>继续之前的例子，下面的例子展示了事件声明<code>SERVER_CONNECTED</code>和显式地为iRule命令<code>IP::remote_addr</code>指定关键字<code>clientside</code>。在这种情况下，iRule命令返回的IP地址就是客户端的IP地址，尽管事件声明的默认上下文是服务器端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">when SERVER_CONNECTED &#123;</span><br><span class="line">    if &#123; [IP::addr [IP::addr [clientside &#123;IP::remote_addr&#125;] equals 10.1.1.80] &#125; &#123;</span><br><span class="line">        discard </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：你可以通过使用一个紧跟在事件名后的关键字<code>when</code>在iRule中进行事件声明。这展示了iRule中事件声明的一个例子。</p>
</blockquote>
<h2 id="VS的iRules分配"><a href="#VS的iRules分配" class="headerlink" title="VS的iRules分配"></a>VS的iRules分配</h2><p>当你将多个iRules作为资源分配给VS时，考虑这些iRules在VS中被列出的顺序是很重要的。这是因为LTM以可用的iRules被列出的顺序来处理重复的iRule事件。因此，一个iRule事件可以终结事件触发，从而阻止LTM触发随后的事件。</p>
<blockquote>
<p>如果一个iRule引用了一个profile，LTM最后处理这种类型的iRule，而不管它本身在VS的iRules列表中的顺序。</p>
</blockquote>
<hr>
<h1 id="4-iRules与管理分区"><a href="#4-iRules与管理分区" class="headerlink" title="4 iRules与管理分区"></a>4 iRules与管理分区</h1><p>你应该了解与管理分区相关的某些iRule配置概念：</p>
<ul>
<li>iRule可以引用任何对象，无论所引用的对象属于哪个分区。例如，贮存（reside）在分区 <em>partition_a</em> 的iRule可以包含指定了贮存（reside）在分区 <em>partition_b</em> 的pool对象的pool语句。</li>
<li>你可以只从贮存（reside）在当前写入分区（Write Partition）或分区 <em>Common</em> 中的VS里删除iRule分配。</li>
<li>注意：你可以只将iRule与贮存（reside）在当前写分区（Write partition）或分区 <em>Common</em> 中的VS进行关联。</li>
<li>你可以将现有的iRule与多个VS进行关联。在这种情况下，iRule将成为与在当前写分区（Write partition）中的每个VS相关联的唯一iRule。因为这条命令覆盖了之前所有的iRule分配。F5不推荐使用此命令。</li>
</ul>
<hr>
<h1 id="5-iRules与本地流量Profiles"><a href="#5-iRules与本地流量Profiles" class="headerlink" title="5 iRules与本地流量Profiles"></a>5 iRules与本地流量Profiles</h1><h2 id="iRules与模板（Profiles）"><a href="#iRules与模板（Profiles）" class="headerlink" title="iRules与模板（Profiles）"></a>iRules与模板（Profiles）</h2><p>当你在写iRule时，你可能想要iRule识别特定模板（profile）配置的值，以便能够做出更加有根据的流量管理决定。幸运的是，iRules功能包括这样一个命令，这个命令是专门设计来读取你在iRule脚本中指定的模板（profile）设置的值。</p>
<p>iRule不仅可以读取模板（profile）配置的值，还可以覆盖某些设置的值。这意味着你可以针对个别连接（connection）应用不同的配置值。这里的个别连接指的是所配置的值与LTM应用于大多数通过VS的连接的配置值所不同的连接。</p>
<h2 id="profile命令"><a href="#profile命令" class="headerlink" title="profile命令"></a><code>profile</code>命令</h2><p>iRules功能包含一个叫作<code>PROFILE</code>的命令。当你在iRule中指定<code>PROFILE</code>命令和指定模板（profile）类型和设置，iRule会读取指定模板（profile）的配置值。为此，iRule会找到分配给VS的指定模板（profile）类型，然后读取你在<code>PROFILE</code>中命令序列中指定的配置值。然后，iRule可以使用此信息来管理流量。</p>
<p>例如，你可以在你的iRule中指定命令<code>PROFILE::tcp idle_timeout</code>。然后，LTM会找到分配给VS的TCP profile（比如，<code>my_tcp</code>）,并查询你给空闲超时（Idel Timeout）设置所分配的值。</p>
<h2 id="覆盖模板（profile）配置的命令"><a href="#覆盖模板（profile）配置的命令" class="headerlink" title="覆盖模板（profile）配置的命令"></a>覆盖模板（profile）配置的命令</h2><p>一些用于查询和造作报头和数据内容的iRule命令在各种profile中有着等价的配置。当你在iRule中使用这些命令，并且一个事件触发了这条iRule，LTM将使用在iRule中指定的值覆盖这些profile设置的值。</p>
<p>例如，HTTP profile可能指定某个用于压缩HTTP数据的缓冲区大小，但是你可能想要为特定类型的HTTP连接指定一个不同的缓冲区大小。在这种情况下，你可以在你的iRule中包含命令<code>HTTP::compress_buffer_size</code>，以指定一个不同于profile中的值。</p>
<hr>
<h1 id="6-数据组-Data-Groups"><a href="#6-数据组-Data-Groups" class="headerlink" title="6 数据组 - Data Groups"></a>6 数据组 - Data Groups</h1><h2 id="关于数据组"><a href="#关于数据组" class="headerlink" title="关于数据组"></a>关于数据组</h2><p>编写iRules时，数据组是非常有用的。一个数据组只是一组相关的元素，例如AOL客户端的一组IP地址。当您用<code>class match</code>命令或 运算符<code>contains</code>指定数据组时，您不需要在iRule表达式中列出多个值作为参数。</p>
<p>您可以定义三种类型的数据组：地址，整数和字符串。</p>
<p>BIG-IP系统包括三个预配置数据组： <em>private_net</em>，<em>images</em>，和 <em>aol</em>。</p>
<p>要了解数据组的有用性，首先要了解<code>class match</code>命令和运算符<code>contains</code>。</p>
<blockquote>
<p>注意：您只能根据你的用户角色和分区访问分配来管理您有权限管理的那些数据组。</p>
</blockquote>
<blockquote>
<p>警告：不要试图修改或删除三种预配置数据组中的任何一种（private_net，images，和aol）。否则可能会产生不良后果。</p>
</blockquote>
<h3 id="关于class-match命令"><a href="#关于class-match命令" class="headerlink" title="关于class match命令"></a>关于<code>class match</code>命令</h3><p>BIG-IP系统包括一个称为<code>class</code>的iRule命令 ，此命令具有一个<code>match</code>选项，根据iRule中使用的命令是否表示特定数据组的成员，您可以使用该命令来选择Pool。当你使用<code>class</code>命令，BIG-IP系统知道跟在标识符后面的字符串是数据组的名称。</p>
<p>例如，如果<code>IP::remote_addr</code>命令的值是数据组AOL的成员，使用<code>class</code>命令，您可以使BIG-IP系统将所有入站的AOL连接负载均衡到aol_pool池。在这种情况下，<code>class match</code>命令表示命名为aol的对象是一个值的集合（即一个数据组）。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">when CLIENT_ACCEPTED &#123; </span><br><span class="line">    <span class="keyword">if</span> &#123; [class match [IP::remote_addr] equals aol] &#125; &#123;</span><br><span class="line">        pool aol_pool </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pool all_pool</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="存储选项"><a href="#存储选项" class="headerlink" title="存储选项"></a>存储选项</h3><p>使用LTM，你能够以2种方式存储数据，<em>内嵌存储（in-line storage）</em> 或者 <em>外部存储</em>。</p>
<h4 id="内嵌存储（in-line-storage）"><a href="#内嵌存储（in-line-storage）" class="headerlink" title="内嵌存储（in-line storage）"></a>内嵌存储（in-line storage）</h4><p>当你创建data group时，LTM会自动把所创建的data group完整地保存在配置文件<code>bigip.conf</code>中。这种存储类型称为</p>
<p>一般来说，由于对大数据组（data group）有大量检索要求，<em>内嵌存储（in-line storage）</em> 会使用额外的系统资源。因此，LTM向你提供了外部存储数据的能力，也就是，存储在<code>bigip.conf</code>文件以外的文件。</p>
<h4 id="外部存储（External-storage）"><a href="#外部存储（External-storage）" class="headerlink" title="外部存储（External storage）"></a>外部存储（External storage）</h4><p>你可以选择将数据组（data group）存储在BIG-IP系统上的其他位置，也就是说，<code>bigip.conf</code>以外的文件。这样的数据组（data group）称为<em>外部数据组（external data groups）</em>。因为数据组（data group）被存储在其他位置，<code>bigip.conf</code>文件本身只包含数据组（data group）的文件名和元数据（meta-data）。在外部存储的数据组（data group）文件中的数据以逗号分隔的值的列表（CSV格式）被存储。</p>
<blockquote>
<p>重要：如果你尝试加载包含外部数据组（data group）元数据（meta-data）的<code>bigip.conf</code>文件，并且此文件是BIP-IP 系统v9.4之前的版本创建的，系统将产生错误。外部数据组的元数据（meta-data）包含关键字<code>extern</code>，也就是这个关键字导致了加载过程中错误的产生。BIP-IP 系统v9.4及其以后版本，<code>bigip.conf</code>文件已经不再需要关键字<code>extern</code>了。</p>
</blockquote>
<p>为了创建外部数据组，你要先使用BIG-IP Configuration utility的 <strong>System</strong> 选项从其他位置导入一个文件。然后，使用<strong>Local Traffic iRules</strong>配置界面，来创建一个基于该导入文件的外部数据组。</p>
<p>根据平台硬件和可用内存（建议使用8GB或更多内存）外部数据组（external data group）扩展到超过10,000,000条条目。拥有更大数据项目的数据组可以用较少条目的外部数据来支持。此外，对外部数据组的更新是完全原子的（atomic）：例如，只有新数据成功完成加载后，系统才会更新数据组。你可以使用命令<code>[class exists xyz]</code>来检查数据组是否已经完成加载了。</p>
<h3 id="关于data-groups的文件导入"><a href="#关于data-groups的文件导入" class="headerlink" title="关于data groups的文件导入"></a>关于data groups的文件导入</h3><p>使用BIG-IP Configuration utility，你可以导入包含你想要在data group中使用的内容的外部文件。当你将一个现有文件导入BIG-IP系统，那么BIG-IP系统会创建一个包含指定内容（地址，字符串或整数）类型的data group。</p>
<h4 id="导入data-group的文件"><a href="#导入data-group的文件" class="headerlink" title="导入data group的文件"></a>导入data group的文件</h4><p>使用BIG-IP Configuration utility，你可以从外部系统导入文件，并使用此文件来创建data group。</p>
<ol>
<li>在主标签页，依次点击 <strong>System &gt; File Management &gt; Data Group File List &gt; Import</strong>。</li>
<li>对于文件名设置，点击 <strong>Browse</strong>。系统将打开一个浏览窗口，以便你可以定位到你希望导入到BIG-IP系统的文件。</li>
<li>在<strong>Name</strong>字段中，为导入的文件输入一个新名字。</li>
<li>从<strong>File Content</strong>列表中选择数据组的内容类型。</li>
<li>在<strong>Key&#x2F;Value Pair Separator</strong>字段中，保留默认值或删除值，然后指定一个新的分隔符。</li>
<li>在<strong>Data Group Name</strong>字段中，输入data group的名字。</li>
<li>点击<strong>Import</strong>按钮。</li>
</ol>
<h4 id="查看已导入的data-group文件的列表"><a href="#查看已导入的data-group文件的列表" class="headerlink" title="查看已导入的data group文件的列表"></a>查看已导入的data group文件的列表</h4><p>使用BIG-IP Configuration utility，你可以查看已经导入到BIG-IP系统的data group文件的列表。</p>
<ol>
<li>在主界标签页，依次点击 <strong>System &gt; File Management &gt; Data Group File List</strong>。</li>
<li>在名字列，查看文件的列表。</li>
</ol>
<hr>
<h1 id="7-iFiles"><a href="#7-iFiles" class="headerlink" title="7 iFiles"></a>7 iFiles</h1><h2 id="关于iRules文件的导入"><a href="#关于iRules文件的导入" class="headerlink" title="关于iRules文件的导入"></a>关于iRules文件的导入</h2><p>如果你想要写iRule，而这个iRule要引用一个贮存（reside）在其他系统上的文件，你必须先将此文件导入到BIG-IP系统里。然后，你可以将此文件转换为iRule可以引用的iFile。</p>
<h3 id="为iRule导入文件"><a href="#为iRule导入文件" class="headerlink" title="为iRule导入文件"></a>为iRule导入文件</h3><p>在你执行此操作之前，你想要导入的此文件必须贮存（reside）在你指定的系统上。</p>
<p>你可以将文件从其他系统导入到BIG-IP系统，这是编写引用该文件的iRule的第一步。</p>
<ol>
<li>在主标签页，依次点击 <strong>System &gt; File Management &gt; iFile List &gt; Import</strong>。</li>
<li>对于<strong>File Name</strong>的设置，点击 <strong>Browse</strong>。系统将打开一个浏览窗口，以便你可以定位到你希望导入到BIG-IP系统的文件。</li>
<li>浏览文件，然后点击<strong>Open</strong>。你选择的文件的名字将出现在<strong>File Name</strong>设置中。</li>
<li>在<strong>Name</strong>字段，输入新的文件名，例如<em>1k.html</em>。新的文件名将出现在导入的文件的列表中。</li>
<li>点击<strong>Import</strong>按钮。</li>
</ol>
<p>在你执行此任务后，你导入的文件将贮存（reside）在BIG-IP系统上。</p>
<h3 id="查看已导入文件的列表"><a href="#查看已导入文件的列表" class="headerlink" title="查看已导入文件的列表"></a>查看已导入文件的列表</h3><p>出于在iRule中引用这些文件的目的，你可以执行此操作来查看已经导入到BIG-IP系统的文件的列表。</p>
<ol>
<li>在主标签页，依次点击 <strong>System &gt; File Management &gt; iFile List</strong>。</li>
<li>在名字列，查看iFiles的列表。</li>
<li>点击<strong>Cancel</strong>按钮。</li>
</ol>
<h2 id="关于iFiles"><a href="#关于iFiles" class="headerlink" title="关于iFiles"></a>关于iFiles</h2><p>使用BIG-IP Configuration utility，你可以创建被称为iFile的特殊文件。一个 <em>iFile</em>是一个文件，此文件基于你之前从其他系统导入到BIG-IP系统上的外部文件。基于所指定的一个iRule事件，你可以从iRule中引用一个iFile。</p>
<p>为了创建一个iFile，并在iRule中使用它，你要从主标签页的<strong>Local Traffic</strong>选项开始。</p>
<blockquote>
<p>重要：在创建iFile之前，你必须将文件从其他系统导入到BIG-IP系统。</p>
</blockquote>
<h3 id="查看iFiles列表"><a href="#查看iFiles列表" class="headerlink" title="查看iFiles列表"></a>查看iFiles列表</h3><p>出于在iRule中引用这些文件的目的，你可以执行此操作来查看已经导入到BIG-IP系统的文件的列表。</p>
<ol>
<li>在主标签页，依次点击 <strong>Local Traffic &gt; iRules &gt; iFile List</strong>。</li>
<li>在名字列，查看你之前在BIG-IP上创建的iFiles的列表。</li>
</ol>
<h3 id="创建iFile"><a href="#创建iFile" class="headerlink" title="创建iFile"></a>创建iFile</h3><p>作为先决条件，确保当前管理分区被设置为你想要保存（reside）iFile的分区。还要确保该文件已经导入到BIG-IP系统了。</p>
<p>你可以执行此操作来创建你之后能够在iRule中引用的iFile。</p>
<ol>
<li>在主标签页，依次点击 <strong>Local Traffic &gt; iRules &gt; iFile List</strong>。</li>
<li>点击<strong>Create</strong>。</li>
<li>在<strong>Name</strong>字段中，输入新的iFile文件名，例如 <em>ifileURL</em>。</li>
<li>从<strong>File Name</strong>列表中，选择导入的文件对象的名字，例如 <em>1k.html</em>。</li>
<li>点击<strong>Finished</strong>。新的iFile就会出现在iFiles列表中。</li>
</ol>
<p>这个操作的结果是，你现在有了一个iRule可以引用的文件。</p>
<h2 id="引用iFile的iRule命令"><a href="#引用iFile的iRule命令" class="headerlink" title="引用iFile的iRule命令"></a>引用iFile的iRule命令</h2><p>有了这些iRule命令，你可以从iRule中引用新的iFile：</p>
<ul>
<li><code>[ifile get IFILENAME]</code></li>
<li><code>[ifile listall]</code></li>
<li><code>[ifile attributes IFILENAME]</code></li>
<li><code>[ifile size IFILENAME]</code></li>
<li><code>[ifile last_updated_by IFILENAME]</code></li>
<li><code>[ifile last_update_time IFILENAME]</code></li>
<li><code>[ifile revision IFILENAME]</code></li>
<li><code>[ifile checksum IFILENAME]</code></li>
<li><code>array set [file attributes IFILENAME]</code></li>
</ul>
<p>这个简单的iRule展示这些命令中的其中一些：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">ltm rule ifile_rule &#123; </span><br><span class="line">    when HTTP_RESPONSE &#123; </span><br><span class="line"><span class="comment">        # return a list of iFiles in all partitions </span></span><br><span class="line">        <span class="keyword">set</span> listifiles [ifile listall]</span><br><span class="line">        log local0. <span class="string">&quot;list of ifiles: $listifiles&quot;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">        # return the attributes of an iFile specified </span></span><br><span class="line">        <span class="keyword">array</span> <span class="keyword">set</span> array_attributes [ifile attributes <span class="string">&quot;/Common/ifileURL&quot;</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">foreach</span> &#123;<span class="keyword">array</span> attr&#125; [<span class="keyword">array</span> get array_attributes ] &#123;</span><br><span class="line">            log local0. <span class="string">&quot;$array : $attr&quot;</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line"><span class="comment">        # serve an iFile when http status is 404. </span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">file</span> [ifile get <span class="string">&quot;Common/ifileURL&quot;</span>] </span><br><span class="line">        log local0. <span class="string">&quot;file: $ifile&quot;</span> </span><br><span class="line">        <span class="keyword">if</span> &#123; [HTTP::status] equals <span class="string">&quot;404&quot;</span> &#125; &#123;</span><br><span class="line">            HTTP::respond <span class="number">200</span> ifile <span class="string">&quot;/Common/ifileURL&quot;</span> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>F5</category>
      </categories>
      <tags>
        <tag>F5</tag>
        <tag>LoadBalance</tag>
      </tags>
  </entry>
  <entry>
    <title>How does the Recycle Bin in Windows work?</title>
    <url>/2022/How-does-the-Recycle-Bin-in-Windows-work/</url>
    <content><![CDATA[<blockquote>
<p>References from:</p>
<p><a href="https://superuser.com/questions/368890/how-does-the-recycle-bin-in-windows-work/1736690#1736690">https://superuser.com/questions/368890/how-does-the-recycle-bin-in-windows-work/1736690#1736690</a></p>
<p><a href="https://en.wikipedia.org/wiki/Trash_(computing)#Microsoft_Windows">https://en.wikipedia.org/wiki/Trash_(computing)#Microsoft_Windows</a></p>
</blockquote>
<span id="more"></span>

<p>The actual location of the Recycle Bin depends on the type of operating system and file system. On older <a href="https://en.wikipedia.org/wiki/File_Allocation_Table">FAT</a> file systems (typically Windows 98 and prior), it is located in <em>Drive:\RECYCLED</em>. In the <a href="https://en.wikipedia.org/wiki/NTFS">NTFS</a> filesystem (Windows 2000, XP, NT) it is <em>Drive:\RECYCLER</em>. On Windows Vista and above it is <em>Drive:$Recycle.Bin</em> folder.[<a href="https://en.wikipedia.org/wiki/Trash_(computing)#cite_note-35">35]</a></p>
<p>The Recycle Bin can be accessed from the desktop or Windows Explorer,[<em><a href="https://en.wikipedia.org/wiki/Wikipedia:Please_clarify">how?</a></em>] or by typing “shell:RecycleBinFolder” in the <a href="https://en.wikipedia.org/wiki/Run_command">Run dialog box</a> (⊞ Win+R). It is the only icon shown by default on the Windows XP desktop. When accessed from the desktop, the Recycle Bin options and information are different from those of the physical Recycle Bin folders seen on each partition in <a href="https://en.wikipedia.org/wiki/Windows_Explorer">Windows Explorer</a>. From <a href="https://en.wikipedia.org/wiki/Windows_XP">Windows XP</a> onwards, with <a href="https://en.wikipedia.org/wiki/NTFS">NTFS</a>, different users cannot see the contents of each other’s Recycle Bins.</p>
<p>Prior to Windows Vista, a file in the Recycle Bin is stored in its physical location and renamed as <code>D&lt;original drive letter of file&gt;&lt;#&gt;.&lt;original extension&gt;</code>.[<a href="https://en.wikipedia.org/wiki/Trash_(computing)#cite_note-RBOverview-16">16]</a> A hidden file called <em>info2</em> (<em>info</em> in Windows 95 without the <a href="https://en.wikipedia.org/wiki/Windows_Desktop_Update">Windows Desktop Update</a>) stores the file’s original path and original name in binary format.[<a href="https://en.wikipedia.org/wiki/Trash_(computing)#cite_note-RBOverview-16">16]</a> Since Windows Vista, the “meta” information of each file is saved as <code>$I&lt;number&gt;.&lt;original extension&gt;</code> and the original file is renamed to <code>$R&lt;number&gt;.&lt;original extension&gt;</code>.</p>
<p>When the user views the Recycle Bin, the files are displayed with their original names. When the file is “Restored” from the Recycle Bin, it is returned to its original directory and name.[<a href="https://en.wikipedia.org/wiki/Trash_(computing)#cite_note-RBOverview-16">16]</a></p>
<hr>
<p>When you delete file in the Bin, it is not actually moved to it.</p>
<p>First, lets take a look at the subfolders of <code>$Recycle.Bin</code>:</p>
<ul>
<li><code>C:\$Recycle.Bin\S-1-5-18</code> is folder for built-in SYSTEM account</li>
<li><code>C:\$Recycle.Bin\S-1-5-21-XXXXXXXXXX-XXXXXXXXXX-XXXXXXXXXX-1XXX\</code>, starting from 1000 are non-built in user folders. You should first check which one of them is the one you need by typing <code>whoami /all</code> in command prompt to get your <a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/well-known-sids">SID</a>, or <code>wmic useraccount get name,sid</code> to get all local accounts SIDs, then choose the folder matching with SID.</li>
</ul>
<blockquote>
<p>The subfolders name such as <code>S-1-5-21-XXXXXXXXXX-XXXXXXXXXX-XXXXXXXXXX-1XXX</code> is a User <a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/well-known-sids">SID</a></p>
</blockquote>
<p>If you give security rights to your account to all this folders, Explorer might show your deleted files in every folder, however its just Explorer bug. If you navigate to, say, <code>C:\$Recycle.Bin\S-1-5-18</code> folder and type <code>dir /a</code>, you will see that its actually empty, and only folder that match with your SID contains your deleted files.</p>
<p>Note that even if you are the only user on the PC, you might still have folder <code>C:\$Recycle.Bin\S-1-5-21-XXXXXXXXXX-XXXXXXXXXX-XXXXXXXXXX-1000\</code> that most likely will be empty. Then your actual folder will be <code>...-1001\</code>. User “1000” seems to be dangling folder for user that was created automatically by Windows on installation or some updates, then deleted. But <code>Recycle.Bin</code> folder wasn’t destroyed and just stayed there. I assume that its safe to delete this dangling folder. I’m not so sure about <code>C:\$Recycle.Bin\S-1-5-18</code>, but I’m fairly sure its safe too, as there is no need for OS SYSTEM account to use the Bin, anyway.</p>
<p>So, here is deletion algorithm:</p>
<ol>
<li>System creates <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/hard-links-and-junctions">hardlink</a> of the deleted file in <code>C:\$Recycle.Bin\S-1-5-21-XXXXXXXXXX-XXXXXXXXXX-XXXXXXXXXX-1XXX\</code> folder with the name <code>$RXXXXXX.&lt;file_ext&gt;</code>, where <code>XXXXXX</code> is 6 symbols HASH calculated based on the file contents, as I assume.</li>
<li>Metadata file is created in the same folder with the name <code>$IXXXXXX.&lt;file_ext&gt;</code>. I will show you the content of this file later.</li>
<li>Original file is deleted, but because of extra hardlink in <code>$Recycle.Bin</code>, actual file’s data stays in the same location on the drive as if file where never touched. It is not moved anywhere. This is why each logical volume must have it’s own <code>$Recycle.Bin</code> folder, as hardlinks only work within the same volume.</li>
</ol>
<p>That’s about it. Restoration algorithm:</p>
<ol>
<li>Metadata file is read and hardlink of <code>$RXXXXXX.&lt;file_ext&gt;</code> is created based on <code>$IXXXXXX.&lt;file_ext&gt;</code>‘s info in original file location, with original file name.</li>
<li>Both metadata and backup file are deleted from <code>$Recycle.Bin</code></li>
</ol>
<p>Pretty simple, ain’t it?</p>
<p>Now, the most interesting part is that metadata file:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000  02 00 00 00 00 00 00 00  &lt;-- File header (QW)</span><br><span class="line">0008  00 7C 0A 00 00 00 00 00  &lt;-- File size (QW)</span><br><span class="line">0010  90 83 72 44 28 9C D8 01  &lt;-- File deletion date (QW)</span><br><span class="line">0018  18 00 00 00|43 00 3A 00  &lt;-- File path string length (DW)</span><br><span class="line">0020  5C 00 24 00 52 00 65 00  </span><br><span class="line">0028  63 00 79 00 63 00 6C 00</span><br><span class="line">0030  65 00 2E 00 42 00 69 00</span><br><span class="line">0038  6E 00 5C 00 66 00 73 00</span><br><span class="line">0040  73 00 2E 00 65 00 78 00</span><br><span class="line">0048  65 00 00 00|             &lt;-- |Null-terminated path string| (wchar_t)</span><br></pre></td></tr></table></figure>

<p>All values are in <a href="https://en.wikipedia.org/wiki/Endianness">Little Endian</a> format.</p>
<p>Header is fixed and its identical for all the files. Be warned that some <code>$I</code> files might have some junk bytes <code>FF FE</code> appear before the Header. I have no idea what are this for, so you should check for full header before reading further.</p>
<p>Deletion date is in <a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> format and can be converted to usual <a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> via <a href="https://docs.microsoft.com/en-us/windows/win32/api/timezoneapi/nf-timezoneapi-filetimetosystemtime">FileTimeToSystemTime</a>. It represents 100-nanosecond intervals since January 1, 1601 (UTC).</p>
<p>So it’s not super complicated file format, but quite interesting design.</p>
<p>To reclaim all of that storage, We can open an elevated command prompt and execute the following command:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rd /s /q c:\$Recycle.Bin</span><br></pre></td></tr></table></figure>

<p>Following a reboot, the <code>$RECYCLE.BIN</code> folder will be recreated and each Windows user profile will now have an empty recycle bin.</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>配置和管理逻辑卷管理器 (Logical Volume Manager)</title>
    <url>/2022/Logical_Volume_Manager_Administration/</url>
    <content><![CDATA[<h1 id="1-逻辑卷管理概述"><a href="#1-逻辑卷管理概述" class="headerlink" title="1. 逻辑卷管理概述"></a>1. 逻辑卷管理概述</h1><p>逻辑卷管理 (LVM) 在物理存储上创建抽象层，帮助您创建逻辑存储卷。这比直接使用物理存储的方式具有更大的灵活性。</p>
<p>此外，硬件存储配置在软件中隐藏，因此可以调整大小并移动，无需停止应用或卸载文件系统。这可降低操作成本。</p>
<span id="more"></span>

<h2 id="1-1-LVM-组件"><a href="#1-1-LVM-组件" class="headerlink" title="1.1 LVM 组件"></a>1.1 LVM 组件</h2><p> LVM 具有以下基本组件：</p>
<ul>
<li><strong>物理卷 (Physical Volume, PV)</strong> ：物理卷 (PV) 是指定为 LVM 使用的物理硬盘分区或整个硬盘。如需更多信息，请参阅<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_logical_volumes/managing-lvm-physical-volumes_configuring-and-managing-logical-volumes">管理 LVM 物理卷</a>。</li>
<li><strong>卷组 (Volume Group, VG)</strong> ：卷组 (VG) 是物理卷 (PV) 的集合，它会创建一个磁盘空间资源池，可以从中分配逻辑卷 (LV)。如需更多信息，请参阅<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_logical_volumes/managing-lvm-volume-groups_configuring-and-managing-logical-volumes">管理 LVM 卷组</a>。</li>
<li><strong>逻辑卷 (Logical Volume, LV)</strong> ：逻辑卷 (LV) 代表可挂载的存储设备，用于创建文件系统。如需更多信息，请参阅<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_logical_volumes/managing-lvm-logical-volumes_configuring-and-managing-logical-volumes">管理 LVM 逻辑卷</a>。</li>
</ul>
<p><img src="/2022/Logical_Volume_Manager_Administration/basic-lvm-volume-components.png" alt="LVM 逻辑卷组件"></p>
<ul>
<li><strong>物理扩展 (Physical Extend, PE)</strong> ：物理扩展 (PE) 是增大或者减小逻辑卷容量的最小值。当使用物理卷创建卷组时，默认情况下每个物理扩展 (PE) 的大小为 4MB。如果默认物理扩展 (PE) 大小不合适，可以使用 <code>-s</code> 选项为 <code>vgcreate</code> 命令指定范围大小。</li>
</ul>
<p><img src="/2022/Logical_Volume_Manager_Administration/pe_vg.gif" alt="VG和PE关系图"></p>
<p>如上图所示，VG 中的 PE 分配给虚线部分的 LV。如果未来要扩充 VG ，为这个 VG 添加其他的 PV 即可。如果要扩充 LV，也是通过分配 VG 中未使用的 PE 给 LV 实现的。</p>
<h2 id="1-2-LVM-的优点"><a href="#1-2-LVM-的优点" class="headerlink" title="1.2 LVM 的优点"></a>1.2 LVM 的优点</h2><p>与直接使用物理存储相比，逻辑卷具有以下优势：</p>
<ul>
<li><strong>灵活的容量</strong> ：使用逻辑卷时，您可以将设备和分区聚合到一个逻辑卷中。借助此功能，文件系统可以扩展到多个设备中，就像它们是一个单一的大型设备一样。</li>
<li><strong>存储卷大小</strong> ：您可以使用简单的软件命令扩展逻辑卷或减小逻辑卷大小，而无需重新格式化和重新分区基础设备。</li>
<li><strong>在线数据重新定位</strong> ：部署更新、更快或者更弹性的存储子系统，可以在系统活跃时移动数据。在磁盘处于使用状态时可以重新分配磁盘。例如，您可以在删除热插拔磁盘前将其清空。</li>
<li><strong>方便的设备命名</strong> ：逻辑卷可以使用用户定义的名称和自定义名称进行管理。</li>
<li><strong>条带化卷</strong> ：您可以创建一个在两个或者多个设备间条带化分布数据的逻辑卷。这可显著提高吞吐量。</li>
<li><strong>RAID 卷</strong> ：逻辑卷为您对数据配置 RAID 提供了一种便捷的方式。这可防止设备故障并提高性能。</li>
<li><strong>卷快照</strong> ：您可以对数据进行快照（逻辑卷在一个特点时间点上的副本）用于一致性备份或测试更改的影响，而不影响实际数据。</li>
<li><strong>精简卷</strong> ：逻辑卷可以使用精简模式置备。这可让您创建大于可用物理空间的逻辑卷。</li>
<li><strong>缓存卷</strong> ：缓存逻辑卷使用快速块设备，如 SSD 驱动器，以提高更大、较慢的块设备的性能。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>LVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Slice Tricks</title>
    <url>/2022/Slice-Tricks/</url>
    <content><![CDATA[<blockquote>
<p>reference from <a href="https://github.com/golang/go/wiki/SliceTricks">https://github.com/golang/go/wiki/SliceTricks</a></p>
</blockquote>
<p>Since the introduction of the <code>append</code> built-in, most of the functionality of the <code>container/vector</code> package, which was removed in Go 1, can be replicated using <code>append</code> and <code>copy</code>.</p>
<p>Here are the vector methods and their slice-manipulation analogues:</p>
<h4 id="AppendVector"><a href="#AppendVector" class="headerlink" title="AppendVector"></a>AppendVector</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a, b...)</span><br></pre></td></tr></table></figure>

<h4 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">copy</span>(b, a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// These two are often a little slower than the above one,</span></span><br><span class="line"><span class="comment">// but they would be more efficient if there are more</span></span><br><span class="line"><span class="comment">// elements to be appended to b after copying.</span></span><br><span class="line">b = <span class="built_in">append</span>([]T(<span class="literal">nil</span>), a...)</span><br><span class="line">b = <span class="built_in">append</span>(a[:<span class="number">0</span>:<span class="number">0</span>], a...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// This one-line implementation is equivalent to the above</span></span><br><span class="line"><span class="comment">// two-line make+copy implementation logically. But it is</span></span><br><span class="line"><span class="comment">// actually a bit slower (as of Go toolchain v1.16).</span></span><br><span class="line">b = <span class="built_in">append</span>(<span class="built_in">make</span>([]T, <span class="number">0</span>, <span class="built_in">len</span>(a)), a...)</span><br></pre></td></tr></table></figure>

<h4 id="Cut"><a href="#Cut" class="headerlink" title="Cut"></a>Cut</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a[:i], a[j:]...)</span><br></pre></td></tr></table></figure>

<h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>:]...)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">a = a[:i+<span class="built_in">copy</span>(a[i:], a[i+<span class="number">1</span>:])]</span><br></pre></td></tr></table></figure>

<h4 id="Delete-without-preserving-order"><a href="#Delete-without-preserving-order" class="headerlink" title="Delete without preserving order"></a>Delete without preserving order</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[i] = a[<span class="built_in">len</span>(a)<span class="number">-1</span>] </span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>NOTE</strong> If the type of the element is a <em>pointer</em> or a struct with pointer fields, which need to be garbage collected, the above implementations of <code>Cut</code> and <code>Delete</code> have a potential <em>memory leak</em> problem: some elements with values are still referenced by slice <code>a</code> and thus can not be collected. The following code can fix this problem:</p>
<blockquote>
<p><strong>Cut</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(a[i:], a[j:])</span><br><span class="line"><span class="keyword">for</span> k, n := <span class="built_in">len</span>(a)-j+i, <span class="built_in">len</span>(a); k &lt; n; k++ &#123;</span><br><span class="line">	a[k] = <span class="literal">nil</span> <span class="comment">// or the zero value of T</span></span><br><span class="line">&#125;</span><br><span class="line">a = a[:<span class="built_in">len</span>(a)-j+i]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Delete</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(a[i:], a[i+<span class="number">1</span>:])</span><br><span class="line">a[<span class="built_in">len</span>(a)<span class="number">-1</span>] = <span class="literal">nil</span> <span class="comment">// or the zero value of T</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Delete without preserving order</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[i] = a[<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">a[<span class="built_in">len</span>(a)<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="Expand"><a href="#Expand" class="headerlink" title="Expand"></a>Expand</h4><p>Insert <code>n</code> elements at position <code>i</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>(<span class="built_in">make</span>([]T, n), a[i:]...)...)</span><br></pre></td></tr></table></figure>

<h4 id="Extend"><a href="#Extend" class="headerlink" title="Extend"></a>Extend</h4><p>Append <code>n</code> elements:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a, <span class="built_in">make</span>([]T, n)...)</span><br></pre></td></tr></table></figure>

<h4 id="Extend-Capacity"><a href="#Extend-Capacity" class="headerlink" title="Extend Capacity"></a>Extend Capacity</h4><p>Make sure there is space to append <code>n</code> elements without re-allocating:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span>(a)-<span class="built_in">len</span>(a) &lt; n &#123;</span><br><span class="line">	a = <span class="built_in">append</span>(<span class="built_in">make</span>([]T, <span class="number">0</span>, <span class="built_in">len</span>(a)+n), a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Filter-in-place"><a href="#Filter-in-place" class="headerlink" title="Filter (in place)"></a>Filter (in place)</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">	<span class="keyword">if</span> keep(x) &#123;</span><br><span class="line">		a[n] = x</span><br><span class="line">		n++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">a = a[:n]</span><br></pre></td></tr></table></figure>

<h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]T&#123;x&#125;, a[i:]...)...)</span><br></pre></td></tr></table></figure>
<p><strong>NOTE</strong>: The second <code>append</code> creates a new slice with its own underlying storage and  copies elements in <code>a[i:]</code> to that slice, and these elements are then copied back to slice <code>a</code> (by the first <code>append</code>). The creation of the new slice (and thus memory garbage) and the second copy can be avoided by using an alternative way:</p>
<blockquote>
<p><strong>Insert</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span> <span class="comment">/* use the zero value of the element type */</span>)</span><br><span class="line"><span class="built_in">copy</span>(s[i+<span class="number">1</span>:], s[i:])</span><br><span class="line">s[i] = x</span><br></pre></td></tr></table></figure>

<h4 id="InsertVector"><a href="#InsertVector" class="headerlink" title="InsertVector"></a>InsertVector</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>(b, a[i:]...)...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The above one-line way copies a[i:] twice and</span></span><br><span class="line"><span class="comment">// allocates at least once.</span></span><br><span class="line"><span class="comment">// The following verbose way only copies elements</span></span><br><span class="line"><span class="comment">// in a[i:] once and allocates at most once.</span></span><br><span class="line"><span class="comment">// But, as of Go toolchain 1.16, due to lacking of</span></span><br><span class="line"><span class="comment">// optimizations to avoid elements clearing in the</span></span><br><span class="line"><span class="comment">// &quot;make&quot; call, the verbose way is not always faster.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future compiler optimizations might implement</span></span><br><span class="line"><span class="comment">// both in the most efficient ways.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Assume element type is int.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(s []<span class="type">int</span>, k <span class="type">int</span>, vs ...<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n := <span class="built_in">len</span>(s) + <span class="built_in">len</span>(vs); n &lt;= <span class="built_in">cap</span>(s) &#123;</span><br><span class="line">		s2 := s[:n]</span><br><span class="line">		<span class="built_in">copy</span>(s2[k+<span class="built_in">len</span>(vs):], s[k:])</span><br><span class="line">		<span class="built_in">copy</span>(s2[k:], vs)</span><br><span class="line">		<span class="keyword">return</span> s2</span><br><span class="line">	&#125;</span><br><span class="line">	s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(s) + <span class="built_in">len</span>(vs))</span><br><span class="line">	<span class="built_in">copy</span>(s2, s[:k])</span><br><span class="line">	<span class="built_in">copy</span>(s2[k:], vs)</span><br><span class="line">	<span class="built_in">copy</span>(s2[k+<span class="built_in">len</span>(vs):], s[k:])</span><br><span class="line">	<span class="keyword">return</span> s2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = Insert(a, i, b...)</span><br></pre></td></tr></table></figure>

<h4 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a, x)</span><br></pre></td></tr></table></figure>

<h4 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x, a = a[<span class="built_in">len</span>(a)<span class="number">-1</span>], a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="Push-Front-Unshift"><a href="#Push-Front-Unshift" class="headerlink" title="Push Front&#x2F;Unshift"></a>Push Front&#x2F;Unshift</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">append</span>([]T&#123;x&#125;, a...)</span><br></pre></td></tr></table></figure>

<h4 id="Pop-Front-Shift"><a href="#Pop-Front-Shift" class="headerlink" title="Pop Front&#x2F;Shift"></a>Pop Front&#x2F;Shift</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x, a = a[<span class="number">0</span>], a[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>

<h2 id="Additional-Tricks"><a href="#Additional-Tricks" class="headerlink" title="Additional Tricks"></a>Additional Tricks</h2><h3 id="Filtering-without-allocating"><a href="#Filtering-without-allocating" class="headerlink" title="Filtering without allocating"></a>Filtering without allocating</h3><p>This trick uses the fact that a slice shares the same backing array and capacity as the original, so the storage is reused for the filtered slice. Of course, the original contents are modified.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := a[:<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> _, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">	<span class="keyword">if</span> f(x) &#123;</span><br><span class="line">		b = <span class="built_in">append</span>(b, x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For elements which must be garbage collected, the following code can be included afterwards:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(b); i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">	a[i] = <span class="literal">nil</span> <span class="comment">// or the zero value of T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reversing"><a href="#Reversing" class="headerlink" title="Reversing"></a>Reversing</h3><p>To replace the contents of a slice with the same elements but in reverse order:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a)/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">	opp := <span class="built_in">len</span>(a)<span class="number">-1</span>-i</span><br><span class="line">	a[i], a[opp] = a[opp], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The same thing, except with two indices:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> left, right := <span class="number">0</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>; left &lt; right; left, right = left+<span class="number">1</span>, right<span class="number">-1</span> &#123;</span><br><span class="line">	a[left], a[right] = a[right], a[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Shuffling"><a href="#Shuffling" class="headerlink" title="Shuffling"></a>Shuffling</h3><p>Fisher–Yates algorithm:</p>
<blockquote>
<p>Since go1.10, this is available at <a href="https://pkg.go.dev/math/rand#Shuffle">math&#x2F;rand.Shuffle</a></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">    j := rand.Intn(i + <span class="number">1</span>)</span><br><span class="line">    a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Batching-with-minimal-allocation"><a href="#Batching-with-minimal-allocation" class="headerlink" title="Batching with minimal allocation"></a>Batching with minimal allocation</h3><p>Useful if you want to do batch processing on large slices.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">actions := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">batchSize := <span class="number">3</span></span><br><span class="line">batches := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, (<span class="built_in">len</span>(actions) + batchSize - <span class="number">1</span>) / batchSize)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> batchSize &lt; <span class="built_in">len</span>(actions) &#123;</span><br><span class="line">    actions, batches = actions[batchSize:], <span class="built_in">append</span>(batches, actions[<span class="number">0</span>:batchSize:batchSize])</span><br><span class="line">&#125;</span><br><span class="line">batches = <span class="built_in">append</span>(batches, actions)</span><br></pre></td></tr></table></figure>

<p>Yields the following:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>] [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>] [<span class="number">6</span> <span class="number">7</span> <span class="number">8</span>] [<span class="number">9</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="In-place-deduplicate-comparable"><a href="#In-place-deduplicate-comparable" class="headerlink" title="In-place deduplicate (comparable)"></a>In-place deduplicate (comparable)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line">in := []<span class="type">int</span>&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>&#125; <span class="comment">// any item can be sorted</span></span><br><span class="line">sort.Ints(in)</span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(in); i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> in[j] == in[i] &#123;</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	j++</span><br><span class="line">	<span class="comment">// preserve the original data</span></span><br><span class="line">	<span class="comment">// in[i], in[j] = in[j], in[i]</span></span><br><span class="line">	<span class="comment">// only set what is required</span></span><br><span class="line">	in[j] = in[i]</span><br><span class="line">&#125;</span><br><span class="line">result := in[:j+<span class="number">1</span>]</span><br><span class="line">fmt.Println(result) <span class="comment">// [1 2 3 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="Move-to-front-or-prepend-if-not-present-in-place-if-possible"><a href="#Move-to-front-or-prepend-if-not-present-in-place-if-possible" class="headerlink" title="Move to front, or prepend if not present, in place if possible."></a>Move to front, or prepend if not present, in place if possible.</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// moveToFront moves needle to the front of haystack, in place if possible.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveToFront</span><span class="params">(needle <span class="type">string</span>, haystack []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(haystack) != <span class="number">0</span> &amp;&amp; haystack[<span class="number">0</span>] == needle &#123;</span><br><span class="line">		<span class="keyword">return</span> haystack</span><br><span class="line">	&#125;</span><br><span class="line">	prev := needle</span><br><span class="line">	<span class="keyword">for</span> i, elem := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> i == <span class="number">0</span>:</span><br><span class="line">			haystack[<span class="number">0</span>] = needle</span><br><span class="line">			prev = elem</span><br><span class="line">		<span class="keyword">case</span> elem == needle:</span><br><span class="line">			haystack[i] = prev</span><br><span class="line">			<span class="keyword">return</span> haystack</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			haystack[i] = prev</span><br><span class="line">			prev = elem</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(haystack, prev)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">haystack := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>&#125; <span class="comment">// [a b c d e]</span></span><br><span class="line">haystack = moveToFront(<span class="string">&quot;c&quot;</span>, haystack)         <span class="comment">// [c a b d e]</span></span><br><span class="line">haystack = moveToFront(<span class="string">&quot;f&quot;</span>, haystack)         <span class="comment">// [f c a b d e]</span></span><br></pre></td></tr></table></figure>

<h3 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slidingWindow</span><span class="params">(size <span class="type">int</span>, input []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// returns the input slice as the first element</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(input) &lt;= size &#123;</span><br><span class="line">		<span class="keyword">return</span> [][]<span class="type">int</span>&#123;input&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allocate slice at the precise size we need</span></span><br><span class="line">	r := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(input)-size+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, size; j &lt;= <span class="built_in">len</span>(input); i, j = i+<span class="number">1</span>, j+<span class="number">1</span> &#123;</span><br><span class="line">		r = <span class="built_in">append</span>(r, input[i:j])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertOne</span><span class="params">(s []<span class="type">int</span>, pos <span class="type">int</span>, num <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">	<span class="built_in">copy</span>(s[pos+<span class="number">1</span>:], s[pos:<span class="built_in">len</span>(s)<span class="number">-1</span>])</span><br><span class="line">	s[pos] = num</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertOneP</span><span class="params">(s *[]<span class="type">int</span>, pos <span class="type">int</span>, num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	*s = <span class="built_in">append</span>(*s, <span class="number">0</span>)</span><br><span class="line">	<span class="built_in">copy</span>((*s)[pos+<span class="number">1</span>:], (*s)[pos:<span class="built_in">len</span>(*s)<span class="number">-1</span>])</span><br><span class="line">	(*s)[pos] = num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertMany</span><span class="params">(dst []<span class="type">int</span>, pos <span class="type">int</span>, src []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(dst[:pos], <span class="built_in">append</span>(src, dst[pos:]...)...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertManyP</span><span class="params">(dst *[]<span class="type">int</span>, pos <span class="type">int</span>, src *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	*dst = <span class="built_in">append</span>((*dst)[:pos], <span class="built_in">append</span>(*src, (*dst)[pos:]...)...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span></span> InsertOne(pos <span class="type">int</span>, num <span class="type">int</span>) &#123;</span><br><span class="line">	*s = <span class="built_in">append</span>(*s, <span class="number">0</span>)</span><br><span class="line">	<span class="built_in">copy</span>((*s)[pos+<span class="number">1</span>:], (*s)[pos:<span class="built_in">len</span>(*s)<span class="number">-1</span>])</span><br><span class="line">	(*s)[pos] = num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>slice</tag>
      </tags>
  </entry>
  <entry>
    <title>This beta version of Typora is expired</title>
    <url>/2022/This-beta-version-of-Typora-is-expired/</url>
    <content><![CDATA[<span id="more"></span>

<p><img src="/2022/This-beta-version-of-Typora-is-expired/dealwith0.webp"></p>
<p>通过修改注册表，可以解决这个问题：</p>
<ol>
<li>win+r 打开运行窗口</li>
<li>在搜索栏输入<code>regedit</code>，回车后打开注册表</li>
<li>在注册表中找到：<code>计算机\HKEY_CURRENT_USER\Software\Typora</code></li>
<li>鼠标右键Typora，选择权限</li>
<li>选择<code>Administraors</code>，将下面的权限选择为拒绝</li>
</ol>
<p><img src="/2022/This-beta-version-of-Typora-is-expired/dealwith.webp"></p>
<ol start="6">
<li>重新打开Typora，发现可以正常运行了</li>
</ol>
]]></content>
      <categories>
        <category>Miscellaneous</category>
      </categories>
      <tags>
        <tag>Editor</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible 用户指南</title>
    <url>/2022/ansible_user_guide/</url>
    <content><![CDATA[<h1 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h1><h2 id="安装-Ansible"><a href="#安装-Ansible" class="headerlink" title="安装 Ansible"></a>安装 Ansible</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><h4 id="控制节点要求-（Control-node-requirements）"><a href="#控制节点要求-（Control-node-requirements）" class="headerlink" title="控制节点要求 （Control node requirements）"></a>控制节点要求 （<a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#id8">Control node requirements</a>）</h4><p>除Windows外，其他任何安装了 Python 3.8 或更新版本的计算机都能成为控制节点，包括 RHEL，Debian，CentOS 以及任何 BSD 等等。</p>
<h4 id="被管理节点要求-（Managed-node-requirements）"><a href="#被管理节点要求-（Managed-node-requirements）" class="headerlink" title="被管理节点要求 （Managed node requirements）"></a>被管理节点要求 （<a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#id9">Managed node requirements</a>）</h4><p>对于大多数被管理的节点，Ansible使用SSH和SFTP来创建连接。但如果SFTP不可用，也可以使用SCP。同时，还需要运行Python。</p>
<h3 id="选择要安装的Ansible版本"><a href="#选择要安装的Ansible版本" class="headerlink" title="选择要安装的Ansible版本"></a>选择要安装的Ansible版本</h3><p>有2种方式安装Ansible：S</p>
<ul>
<li>使用各操作系统的包管理器安装预编译的Ansible包</li>
<li>使用<code>pip</code>安装Ansible</li>
</ul>
<h3 id="使用pip安装并升级Ansible"><a href="#使用pip安装并升级Ansible" class="headerlink" title="使用pip安装并升级Ansible"></a>使用<code>pip</code>安装并升级Ansible</h3><h4 id="使用pip安装Ansible"><a href="#使用pip安装Ansible" class="headerlink" title="使用pip安装Ansible"></a>使用<code>pip</code>安装Ansible</h4><p>安装Ansible：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python -m pip install --user ansible</span><br></pre></td></tr></table></figure>

<p>安装paramiko：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python -m pip install --user paramiko</span><br></pre></td></tr></table></figure>

<p>全局安装Ansible：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo python -m pip install ansible</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Running <code>pip</code> with <code>sudo</code> will make global changes to the system. Since <code>pip</code> does not coordinate with system package managers, it could make changes to your system that leaves it in an inconsistent or non-functioning state. This is particularly true for macOS. Installing with <code>--user</code> is recommended unless you understand fully the implications of modifying global files on the system.</p>
</blockquote>
<h4 id="在虚拟环境中使用pip安装Ansible"><a href="#在虚拟环境中使用pip安装Ansible" class="headerlink" title="在虚拟环境中使用pip安装Ansible"></a>在虚拟环境中使用<code>pip</code>安装Ansible</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python -m virtualenv ansible  <span class="comment"># Create a virtualenv if one does not already exist</span></span><br><span class="line">$ <span class="built_in">source</span> ansible/bin/activate   <span class="comment"># Activate the virtual environment</span></span><br><span class="line">$ python -m pip install ansible</span><br></pre></td></tr></table></figure>

<blockquote>
<p>高版本的Python3都自带了虚拟环境模块<code>venv</code>，不需要单独安装<code>virtualenv</code></p>
</blockquote>
<span id="more"></span>

<h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>不管使用哪种安装方式都可以使用以下命令验证Ansible安装正确：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ansible all -m ping --ask-pass</span><br></pre></td></tr></table></figure>

<h3 id="为Ansible命令添加Shell补全功能"><a href="#为Ansible命令添加Shell补全功能" class="headerlink" title="为Ansible命令添加Shell补全功能"></a>为Ansible命令添加Shell补全功能</h3><h4 id="在RHEL-CentOS-or-Fedora上安装argcomplete"><a href="#在RHEL-CentOS-or-Fedora上安装argcomplete" class="headerlink" title="在RHEL, CentOS, or Fedora上安装argcomplete"></a><a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#installing-argcomplete-on-rhel-centos-or-fedora">在RHEL, CentOS, or Fedora上安装<code>argcomplete</code></a></h4><p>在Fedora上:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dnf install python-argcomplete</span><br></pre></td></tr></table></figure>

<p>在RHEL and CentOS上:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install epel-release</span><br><span class="line">$ sudo yum install python-argcomplete</span><br></pre></td></tr></table></figure>

<h4 id="使用pip安装argcomplete"><a href="#使用pip安装argcomplete" class="headerlink" title="使用pip安装argcomplete"></a><a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#id41">使用<code>pip</code>安装<code>argcomplete</code></a></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python -m pip install argcomplete</span><br></pre></td></tr></table></figure>

<h4 id="配置argcomplete"><a href="#配置argcomplete" class="headerlink" title="配置argcomplete"></a><a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#id42">配置<code>argcomplete</code></a></h4><p>有2种方式可以配置<code>argcomplete</code>：</p>
<ul>
<li>全局配置（Global configuration）</li>
<li>每命令配置 （Per command configuration）</li>
</ul>
<p>全局补全配置要求bash 4.2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo activate-global-python-argcomplete</span><br></pre></td></tr></table></figure>

<p>如果没有bash 4.2，则必须为每个脚本独立注册。将以下命令放入shell配置文件<code>~/.profile</code> 或者 <code>~/.bash_profile</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> $(register-python-argcomplete ansible)</span><br><span class="line">$ <span class="built_in">eval</span> $(register-python-argcomplete ansible-config)</span><br><span class="line">$ <span class="built_in">eval</span> $(register-python-argcomplete ansible-console)</span><br><span class="line">$ <span class="built_in">eval</span> $(register-python-argcomplete ansible-doc)</span><br><span class="line">$ <span class="built_in">eval</span> $(register-python-argcomplete ansible-galaxy)</span><br><span class="line">$ <span class="built_in">eval</span> $(register-python-argcomplete ansible-inventory)</span><br><span class="line">$ <span class="built_in">eval</span> $(register-python-argcomplete ansible-playbook)</span><br><span class="line">$ <span class="built_in">eval</span> $(register-python-argcomplete ansible-pull)</span><br><span class="line">$ <span class="built_in">eval</span> $(register-python-argcomplete ansible-vault)</span><br></pre></td></tr></table></figure>

<h2 id="Ansible配置文件"><a href="#Ansible配置文件" class="headerlink" title="Ansible配置文件"></a>Ansible配置文件</h2><h3 id="获取最新的配置"><a href="#获取最新的配置" class="headerlink" title="获取最新的配置"></a>获取最新的配置</h3><p>如果是从包管理器安装Ansible，则最新的<code>ansible.cfg</code>文件应该在<code>/etc/ansible</code>中。</p>
<p>如果使用<code>pip</code>安装Ansible，你可能需要手动创建此文件以覆盖旧的Ansible配置。可以从github获取<a href="https://github.com/ansible/ansible/blob/devel/examples/ansible.cfg">最新的<code>ansible.cfg</code>实例</a>。</p>
<p>从Ansible 2.4开始，可以使用<code>ansible-config</code>命令行工具查看所有可用的选项并检查当前的值。</p>
<p>从Ansible 2.12(core) 开始，要生成示例配置文件（所有默认<code>disabled</code>的配置都被注释）可以使用<code>ansible-config init</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ansible-config init --disabled &gt; ansible.cfg</span><br></pre></td></tr></table></figure>

<p>通过包含存在的插件还生成更完整的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ansible-config init --disabled -t all &gt; ansible.cfg</span><br></pre></td></tr></table></figure>

<p>要获得所有可用的配置请访问<a href="https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings">configuration_settings</a>.</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>Ansible也允许使用环境变量配置。如果这些环境变量被设置，则从配置文件加载的配置将被覆盖。</p>
<p>要获得所有可用的环境变量，请访问<a href="https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings">Ansible Configuration Settings</a></p>
<h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><p>命令行只包含最常用的配置选项。命令行中的参数将覆盖从配置文件和环境变量传入的配置。</p>
<h1 id="用户手册"><a href="#用户手册" class="headerlink" title="用户手册"></a>用户手册</h1><h2 id="Ansible中的概念"><a href="#Ansible中的概念" class="headerlink" title="Ansible中的概念"></a>Ansible中的概念</h2><ul>
<li>控制节点 (Control node)：必须是Linux。需要安装Python。</li>
<li>被管理节点 (Managed nodes)：</li>
<li>Inventory:</li>
<li>Collections:</li>
<li>Modules:</li>
<li>Tasks</li>
<li>Playbooks</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>批量将某li某li特定关注组中的UP修改为悄悄关注</title>
    <url>/2022/batch_modify_bilibili_follow_group/</url>
    <content><![CDATA[<p>如题，调用batchModify函数即可批量将某li某li特定关注组中的UP修改为悄悄关注。</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*将bilibili某个关注组中的所有up批量改为悄悄关注</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> mid &#123;number&#125; 自己的id</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> tagid &#123;number&#125; 要被批量修改的关注组的组id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">batchModify</span>(<span class="params">mid, tagid, maxPageNum=<span class="number">100</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> csrf;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">split</span>(<span class="string">&#x27;; &#x27;</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.<span class="title function_">startsWith</span>(<span class="string">&#x27;bili_jct&#x27;</span>)) &#123;</span><br><span class="line">            csrf = item.<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> pn = <span class="number">1</span>; pn &lt;= maxPageNum; pn++) &#123;</span><br><span class="line">        <span class="keyword">const</span> resp = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://api.bilibili.com/x/relation/tag?mid=<span class="subst">$&#123;mid&#125;</span>&amp;tagid=<span class="subst">$&#123;tagid&#125;</span>&amp;pn=<span class="subst">$&#123;pn&#125;</span>&amp;ps=20&amp;json=json&amp;callback=__jp16`</span>, &#123;</span><br><span class="line">        <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;accept&quot;</span>: <span class="string">&quot;*/*&quot;</span>,</span><br><span class="line">          <span class="string">&quot;accept-language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>,</span><br><span class="line">          <span class="string">&quot;cache-control&quot;</span>: <span class="string">&quot;no-cache&quot;</span>,</span><br><span class="line">          <span class="string">&quot;pragma&quot;</span>: <span class="string">&quot;no-cache&quot;</span>,</span><br><span class="line">          <span class="string">&quot;sec-ch-ua&quot;</span>: <span class="string">&quot;\&quot; Not A;Brand\&quot;;v=\&quot;99\&quot;, \&quot;Chromium\&quot;;v=\&quot;101\&quot;, \&quot;Google Chrome\&quot;;v=\&quot;101\&quot;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;sec-ch-ua-mobile&quot;</span>: <span class="string">&quot;?0&quot;</span>,</span><br><span class="line">          <span class="string">&quot;sec-ch-ua-platform&quot;</span>: <span class="string">&quot;\&quot;Windows\&quot;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;sec-fetch-dest&quot;</span>: <span class="string">&quot;script&quot;</span>,</span><br><span class="line">          <span class="string">&quot;sec-fetch-mode&quot;</span>: <span class="string">&quot;cors&quot;</span>,</span><br><span class="line">          <span class="string">&quot;sec-fetch-site&quot;</span>: <span class="string">&quot;same-site&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;referrer&quot;</span>: <span class="string">`https://space.bilibili.com/<span class="subst">$&#123;mid&#125;</span>/fans/follow?tagid=<span class="subst">$&#123;tagid&#125;</span>`</span>,</span><br><span class="line">        <span class="string">&quot;referrerPolicy&quot;</span>: <span class="string">&quot;no-referrer-when-downgrade&quot;</span>,</span><br><span class="line">        <span class="string">&quot;body&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="string">&quot;method&quot;</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;cors&quot;</span>,</span><br><span class="line">        <span class="string">&quot;credentials&quot;</span>: <span class="string">&quot;include&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> json = <span class="keyword">await</span> resp.<span class="title function_">json</span>();</span><br><span class="line">        <span class="keyword">if</span> (json.<span class="property">data</span>.<span class="property">length</span> === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> json.<span class="property">data</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(item.<span class="property">mid</span>);</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">modify</span>(item.<span class="property">mid</span>, csrf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将用户id为fid的up注改为悄悄关注</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fid &#123;number&#125; 要修改为悄悄关注的up的用户id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">modify</span>(<span class="params">fid, csrf</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://api.bilibili.com/x/relation/modify&quot;</span>, &#123;</span><br><span class="line">      <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;accept&quot;</span>: <span class="string">&quot;application/json, text/plain, */*&quot;</span>,</span><br><span class="line">        <span class="string">&quot;accept-language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cache-control&quot;</span>: <span class="string">&quot;no-cache&quot;</span>,</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pragma&quot;</span>: <span class="string">&quot;no-cache&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sec-ch-ua&quot;</span>: <span class="string">&quot;\&quot; Not A;Brand\&quot;;v=\&quot;99\&quot;, \&quot;Chromium\&quot;;v=\&quot;101\&quot;, \&quot;Google Chrome\&quot;;v=\&quot;101\&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sec-ch-ua-mobile&quot;</span>: <span class="string">&quot;?0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sec-ch-ua-platform&quot;</span>: <span class="string">&quot;\&quot;Windows\&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sec-fetch-dest&quot;</span>: <span class="string">&quot;empty&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sec-fetch-mode&quot;</span>: <span class="string">&quot;cors&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sec-fetch-site&quot;</span>: <span class="string">&quot;same-site&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;referrer&quot;</span>: <span class="string">&quot;https://space.bilibili.com/14629610/?spm_id_from=333.999.0.0&quot;</span>,</span><br><span class="line">      <span class="string">&quot;referrerPolicy&quot;</span>: <span class="string">&quot;no-referrer-when-downgrade&quot;</span>,</span><br><span class="line">      <span class="string">&quot;body&quot;</span>: <span class="string">`fid=<span class="subst">$&#123;fid&#125;</span>&amp;act=3&amp;re_src=11&amp;spmid=333.999.0.0&amp;extend_content=%7B%22entity%22%3A%22user%22%2C%22entity_id%22%3A14629610%2C%22fp%22%3A%220%5Cu00011920%2C%2C1080%5Cu0001Win32%5Cu000116%5Cu00018%5Cu000124%5Cu00011%5Cu0001zh-CN%5Cu00011%5Cu00010%2C%2C0%2C%2C0%5Cu0001Mozilla%2F5.0%20%28Windows%20NT%2010.0%3B%20Win64%3B%20x64%29%20AppleWebKit%2F537.36%20%28KHTML%2C%20like%20Gecko%29%20Chrome%2F101.0.4951.67%20Safari%2F537.36%22%7D&amp;jsonp=jsonp&amp;csrf=<span class="subst">$&#123;csrf&#125;</span>`</span>,</span><br><span class="line">      <span class="string">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">      <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;cors&quot;</span>,</span><br><span class="line">      <span class="string">&quot;credentials&quot;</span>: <span class="string">&quot;include&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Reverse</tag>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>Cheat Engine Tutorial 学习笔记1：精确/模糊值扫描</title>
    <url>/2022/cheat_engine_tutorial1/</url>
    <content><![CDATA[<p>本文重点介绍：</p>
<ul>
<li>精确&#x2F;模糊数值扫描</li>
</ul>
<p>CE版本如下：</p>
<ul>
<li><p>Cheat Engine Version: 7.4和7.5</p>
</li>
<li><p>Tutorial Version: v3.6</p>
</li>
</ul>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1:"></a>Step 1:</h2><p><img src="/2022/cheat_engine_tutorial1/image-20220215145201605.png"></p>
<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Welcome to the Cheat Engine Tutorial (v3.6)</span><br><span class="line"></span><br><span class="line">This tutorial will teach you the basics of cheating in video games. It will also show you foundational aspects of using Cheat Engine (or CE for short). Follow the steps below to get started.</span><br><span class="line"></span><br><span class="line">1: Open Cheat Engine if it currently isn&#x27;t running.</span><br><span class="line">2: Click on the &quot;Open Process&quot; icon (it&#x27;s the top-left icon with the computer on it, below &quot;File&quot;.).</span><br><span class="line">3: With the Process List window now open, look for this tutorial&#x27;s process in the list. It will look something like &quot;00001F98-Tutorial-x86_64.exe&quot; or &quot;0000047C-Tutorial-i386.exe&quot;. (The first 8 numbers/letters will probably be different.)</span><br><span class="line">4: Once you&#x27;ve found the process, click on it to select it, then click the &quot;Open&quot; button. (Don&#x27;t worry about all the other buttons right now. You can learn about them later if you&#x27;re interested.)</span><br><span class="line"></span><br><span class="line">Congratulations! If you did everything correctly, the process window should be gone with Cheat Engine now attached to the tutorial (you will see the process name towards the top-center of CE).</span><br><span class="line"></span><br><span class="line">Click the &quot;Next&quot; button below to continue, or fill in the password and click the &quot;OK&quot; button to proceed to that step.)</span><br><span class="line"></span><br><span class="line">If you&#x27;re having problems, simply head over to forum.cheatengine.org, then click on &quot;Tutorials&quot; to view beginner-friendly guides!</span><br></pre></td></tr></table></figure>

<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>步骤1：选择要附加的进程</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215145836858.png"></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215150314077.png"></p>
<!-- more -->

<h1 id="精确值扫描"><a href="#精确值扫描" class="headerlink" title="精确值扫描"></a>精确值扫描</h1><h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Step 2: Exact Value scanning (PW=090453)</span><br><span class="line">Now that you have opened the tutorial with Cheat Engine let&#x27;s get on with the next step.</span><br><span class="line"></span><br><span class="line">You can see at the bottom of this window is the text Health: xxx</span><br><span class="line">Each time you click &#x27;Hit me&#x27;  your health gets decreased.</span><br><span class="line"></span><br><span class="line">To get to the next step you have to find this value and change it to 1000</span><br><span class="line"></span><br><span class="line">To find the value there are different ways, but I&#x27;ll tell you about the easiest, &#x27;Exact Value&#x27;:</span><br><span class="line">First make sure value type is set to at least 2-bytes or 4-bytes. 1-byte will also work, but you&#x27;ll run into an easy to fix problem when you&#x27;ve found the address and want to change it. The 8-byte may perhaps works if the bytes after the address are 0, but I wouldn&#x27;t take the bet.</span><br><span class="line">Single, double, and the other scans just don&#x27;t work, because they store the value in a different way.</span><br><span class="line"></span><br><span class="line">When the value type is set correctly, make sure the scantype is set to &#x27;Exact Value&#x27;</span><br><span class="line">Then fill in the number your health is in the value box. And click &#x27;First Scan&#x27;</span><br><span class="line">After a while (if you have an extremely slow pc) the scan is done and the results are shown in the list on the left.</span><br><span class="line"></span><br><span class="line">If you find more than 1 address and you don&#x27;t know for sure which address it is, click &#x27;Hit me&#x27;, fill in the new health value into the value box, and click &#x27;Next Scan&#x27;</span><br><span class="line">repeat this until you&#x27;re sure you&#x27;ve found it. (that includes that there&#x27;s only 1 address in the list.....)</span><br><span class="line"></span><br><span class="line">Now double click the address in the list on the left. This makes the address pop-up in the list at the bottom, showing you the current value.</span><br><span class="line">Double click the value, (or select it and press enter), and change the value to 1000.</span><br><span class="line"></span><br><span class="line">If everything went ok the Next button should become enabled, and you&#x27;re ready for the next step.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">If you did anything wrong while scanning, click &quot;New Scan&quot; and repeat the scanning again.</span><br><span class="line">Also, try playing around with the value and click &#x27;Hit me&#x27;.</span><br></pre></td></tr></table></figure>

<p><strong>操作：</strong></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215151801088.png"></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215152155476.png"></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215152500187.png"></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215152558471.png"></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215152638141.png"></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215152855906.png"></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215153108418.png"></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215153634400.png"></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215153905170.png"></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215154113896.png"></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215154508980.png"></p>
<h2 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Step 4: Floating points (PW=890124)</span><br><span class="line">In the previous tutorial we used bytes to scan, but some games store information in so called &#x27;floating point&#x27; notations. </span><br><span class="line">(probably to prevent simple memory scanners from finding it the easy way)</span><br><span class="line">a floating point is a value with some digits behind the point. (like 5.12 or 11321.1)</span><br><span class="line"></span><br><span class="line">Below you see your health and ammo. Both are stored as Floating point notations, but health is stored as a float and ammo is stored as a double.</span><br><span class="line">Click on hit me to lose some health, and on shoot to decrease your ammo with 0.5</span><br><span class="line"> </span><br><span class="line">You have to set BOTH values to 5000 or higher to proceed.</span><br><span class="line"></span><br><span class="line">Exact value scan will work fine here, but you may want to experiment with other types too.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hint: It is recommended to disable &quot;Fast Scan&quot; for type double</span><br></pre></td></tr></table></figure>

<p>Step 4 主要是介绍了 float 和 double 值类型的精确值扫描，基本操作和整型的精确值扫描类似。</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430100922143.png"></p>
<p>执行<code>Exact Value</code>扫描，并将<code>Value Type</code>设为<code>Float</code>，填入要扫描的值，开始扫描：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430101837596.png"></p>
<p>点击<code>Hit me</code>修改 Health 的值：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430102319944.png"></p>
<p>填入修改后的值，执行下一次精确值扫描：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430102652795.png"></p>
<p>将得到的备选地址加入 addresslist 进行验证：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430103435764.png"></p>
<p>修改地址保存的值之后，需要点击<code>Hit me</code>触发一下显示的值的修改：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430103942060.png"></p>
<p>可以看到，点击<code>Hit me</code>之后，地址中保存的值也相应地变化了：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430104225544.png"></p>
<p>开始新扫描，准备扫描 Ammo 的地址：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430104504605.png"></p>
<p>设置值类型为<code>Double</code>，填入值，开始首次扫描：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430104955721.png"></p>
<p>点击<code>Fire</code>修改 Ammo 的值：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430105152459.png"></p>
<p>填入修改后的值，进行下一次扫描：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430105312568.png"></p>
<p>得到两个备选地址：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430105529833.png"></p>
<p>再次修改值，以便对备选地址进行过滤：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430105631230.png"></p>
<p>填入修改后的值，进行下一次扫描：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430105741906.png"></p>
<p>依然还是得到两个地址，将它们加入 addresslist 逐个进行验证：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430105850638.png"></p>
<p>修改地址中的值：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430110323596.png"></p>
<p>可以看到，点击<code>Fire</code>后，addresslist中的第一个备选地址中的值也相应地改变了，而第二个备选地址中的值则没有变化。那么，基本可以断定，第一个备选地址是我们要找的。</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430110755464.png"></p>
<p>修改第二个备选地址中的值，对第二个备选地址进行验证：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430111148365.png"></p>
<p>修改第二个备选地址中的值后，点击<code>Fire</code>触发 Ammo 显示值的变化。可以看到，修改第二个备选地址中的值后，没有对 Ammo 的值产生影响，点击<code>Fire</code>后，第二个备选地址中值依旧没有变化。那么，现在可以确定第一个备选地址是我们要找的，第二个则不是。</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430111509913.png"></p>
<p>将第二个备选地址从 addresslist 中删除：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430111946289.png"></p>
<p>接下来，由于 Step 4 这一关需要 Health 和 Ammo两个值同时大于或等于5000，我们再修改一下 Health 地址中的值，使其满足过关条件：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430112302524.png"></p>
<p>修改 Health 地址中的值后，甚至还没有点击<code>Hit me</code>触发显示的值变化，Next 按钮就已经可以点击了：</p>
<p><img src="/2022/cheat_engine_tutorial1/image-20240430112531318.png"></p>
<h1 id="模糊值扫描"><a href="#模糊值扫描" class="headerlink" title="模糊值扫描"></a>模糊值扫描</h1><h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Step 3: Unknown initial value (PW=419482)</span><br><span class="line">Ok, seeing that you&#x27;ve figured out how to find a value using exact value let&#x27;s move on to the next step.</span><br><span class="line"></span><br><span class="line">First things first though. Since you are doing a new scan, you have to click on New Scan first, to start a new scan. (You may think this is straighforward, but you&#x27;d be surprised how many people get stuck on that step) I won&#x27;t be explaining this step again, so keep this in mind.</span><br><span class="line">Now that you&#x27;ve started a new scan, let&#x27;s continue.</span><br><span class="line"></span><br><span class="line">In the previous test we knew the initial value so we could do an exact value search, but now we have a status bar where we don&#x27;t know the starting value.</span><br><span class="line">We only know that the value is between 0 and 500. And each time you click &#x27;Hit me&#x27; you lose some health. The amount you lose each time is shown above the status bar.</span><br><span class="line"></span><br><span class="line">Again there are several different ways to find the value. (like doing a decreased value by... scan), but I&#x27;ll only explain the easiest. &quot;Unknown initial value&quot;, and decreased value.</span><br><span class="line">Because you don&#x27;t know the value it is right now, exact value wont do any good, so choose as scantype &#x27;Unknown initial value&#x27;, again, the value type is 4-bytes. (Most windows apps use 4-bytes.) Click First scan and wait till it&#x27;s done.</span><br><span class="line"></span><br><span class="line">When it is done click &#x27;Hit me&#x27;. You&#x27;ll lose some of your health. (the amount you lost shows for a few seconds and then disappears, but you don&#x27;t need that)</span><br><span class="line">Now go to Cheat Engine, and choose &#x27;Decreased Value&#x27; and click &#x27;Next Scan&#x27;</span><br><span class="line">When that scan is done, click &#x27;Hit me&#x27; again, and repeat the above till you only find a few. </span><br><span class="line"></span><br><span class="line">We know the value is between 0 and 500, so pick the one that is most likely the address we need, and add it to the list.</span><br><span class="line">Now change the health to 5000, to proceed to the next step.</span><br></pre></td></tr></table></figure>

<p><strong>操作：</strong></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215173831872.png"></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215173929270.png"><img src="/2022/cheat_engine_tutorial1/image-20220215174056856.png"></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215174649344.png"></p>
<p><img src="/2022/cheat_engine_tutorial1/image-20220215174800299.png"><img src="/2022/cheat_engine_tutorial1/image-20220215174937499.png"><img src="/2022/cheat_engine_tutorial1/image-20220215175020697.png"></p>
]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
        <tag>PWN</tag>
        <tag>CheatEngine</tag>
      </tags>
  </entry>
  <entry>
    <title>gobyexample 学习笔记</title>
    <url>/2022/learn_gobyexample/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>我们的第一个程序将打印传说中的 “hello world” 消息，右边是完整的程序代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要运行这个程序，将这些代码放到 <code>hello-world.go</code> 中并且使用 <code>go run</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run hello-world.go</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>有时候我们想将我们的程序编译成二进制文件。我们可以通过 go build 命来达到目的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build hello-world.go</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">hello-world	hello-world.go</span><br></pre></td></tr></table></figure>

<p>然后我们可以直接运行这个二进制文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./hello-world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="值"><a href="#值" class="headerlink" title="值"></a>值</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 字符串可以通过 + 连接。</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;go&quot;</span> + <span class="string">&quot;lang&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 整数和浮点数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;1+1 =&quot;</span>, <span class="number">1</span>+<span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;7.0/3.0 =&quot;</span>, <span class="number">7.0</span>/<span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 布尔型，还有你想要的逻辑运算符。</span></span><br><span class="line">    fmt.Println(<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>)</span><br><span class="line">    fmt.Println(<span class="literal">true</span> || <span class="literal">false</span>)</span><br><span class="line">    fmt.Println(!<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run values.go</span><br><span class="line">golang</span><br><span class="line">1+1 = 2</span><br><span class="line">7.0/3.0 = 2.3333333333333335</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// var 声明 1 个或者多个变量。</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;initial&quot;</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 你可以申明一次性声明多个变量。</span></span><br><span class="line">    <span class="keyword">var</span> b, c <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    fmt.Println(b, c)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// Go 将自动推断已经初始化的变量类型。</span></span><br><span class="line">    <span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line">    fmt.Println(d)</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 声明变量且没有给出对应的初始值时，变量将会初始化为零值 。例如，一个 int 的零值是 0。</span></span><br><span class="line">    <span class="keyword">var</span> e <span class="type">int</span></span><br><span class="line">    fmt.Println(e)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// := 语句是申明并初始化变量的简写，例如这个例子中的 var f string = &quot;short&quot;。</span></span><br><span class="line">    f := <span class="string">&quot;short&quot;</span></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run variables.go</span><br><span class="line">initial</span><br><span class="line">1 2</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">0</span><br><span class="line">short</span><br></pre></td></tr></table></figure>



<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 用于声明一个常量。</span></span><br><span class="line"><span class="keyword">const</span> s <span class="type">string</span> = <span class="string">&quot;constant&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新赋值会报错</span></span><br><span class="line">    s = <span class="string">&quot;yoyo&quot;</span> <span class="comment">// cannot assign to s (constant &quot;constant&quot; of type string)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s <span class="type">int</span> = <span class="number">100</span> <span class="comment">// 重新定义局部变量则不会报错</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 语句可以出现在任何 var 语句可以出现的地方</span></span><br><span class="line">    <span class="keyword">const</span> n = <span class="number">500000000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//常数表达式可以执行任意精度的运算</span></span><br><span class="line">    <span class="keyword">const</span> d = <span class="number">3e20</span> / n</span><br><span class="line">    fmt.Println(d)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数值型常量是没有确定的类型的，直到它们被给定了一个类型，比如说一次显示的类型转化。</span></span><br><span class="line">    fmt.Println(<span class="type">int64</span>(d))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当上下文需要时，一个数可以被给定一个类型，比如变量赋值或者函数调用。举个例子，这里的 math.Sin函数需要一个 float64 的参数。</span></span><br><span class="line">    fmt.Println(math.Sin(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run constant.go </span><br><span class="line">constant</span><br><span class="line">6e+11</span><br><span class="line">600000000000</span><br><span class="line">-0.28470407323754404</span><br></pre></td></tr></table></figure>

<h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><p><code>for</code> 是 Go 中唯一的循环结构。这里有 <code>for</code> 循环的三个基本使用方式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 最常用的方式，带单个循环条件。</span></span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 经典的初始化/条件/后续形式 for 循环。</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">7</span>; j &lt;= <span class="number">9</span>; j++ &#123;</span><br><span class="line">        fmt.Println(j)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不带条件的 for 循环将一直执行，直到在循环体内使用了 break 或者 return 来跳出循环。</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;loop&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run for.go</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">loop</span><br></pre></td></tr></table></figure>

<h1 id="if-else-分支"><a href="#if-else-分支" class="headerlink" title="if&#x2F;else 分支"></a>if&#x2F;else 分支</h1><p>注意，在 Go 中，你可以不适用圆括号，但是花括号是需要的。Go 里没有<a href="http://en.wikipedia.org/wiki/%3F:">三目运算符</a>，所以即使你只需要基本的条件判断，你仍需要使用完整的 <code>if</code> 语句。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="number">7</span>%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;7 is even&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;7 is odd&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你可以不要 else 只用 if 语句。</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">8</span>%<span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;8 is divisible by 4&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 在条件语句之前可以有一个语句；任何在这里声明的变量都可以在所有的条件分支中使用。</span></span><br><span class="line">    <span class="keyword">if</span> num := <span class="number">9</span>; num &lt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(num, <span class="string">&quot;is negative&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="number">10</span> &#123;</span><br><span class="line">        fmt.Println(num, <span class="string">&quot;has 1 digit&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(num, <span class="string">&quot;has multiple digits&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run if-else.go </span><br><span class="line">7 is odd</span><br><span class="line">8 is divisible by 4</span><br><span class="line">9 has 1 digit</span><br></pre></td></tr></table></figure>

<h1 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 一个基本的 switch。</span></span><br><span class="line">    i := <span class="number">2</span></span><br><span class="line">    fmt.Print(<span class="string">&quot;write &quot;</span>, i, <span class="string">&quot; as &quot;</span>)</span><br><span class="line">    <span class="keyword">switch</span> i &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;one&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;two&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;three&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在一个 case 语句中，你可以使用逗号来分隔多个表达式。</span></span><br><span class="line">  <span class="comment">// 在这个例子中，我们很好的使用了可选的 default 分支。</span></span><br><span class="line">    <span class="keyword">switch</span> time.Now().Weekday() &#123;</span><br><span class="line">    <span class="keyword">case</span> time.Saturday, time.Sunday:</span><br><span class="line">        fmt.Println(<span class="string">&quot;it&#x27;s the weekend&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;it&#x27;s a weekday&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不带表达式的 switch 是实现 if/else 逻辑的另一种方式。这里展示了 case 表达式是如何使用非常量的。</span></span><br><span class="line">    t := time.Now()</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;it&#x27;s before noon&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;it&#x27;s after noon&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run switch.go </span><br><span class="line">write 2 as two</span><br><span class="line">it<span class="string">&#x27;s the weekend</span></span><br><span class="line"><span class="string">it&#x27;</span>s before noon</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>在 Go 中，<strong>数组</strong> 是一个固定长度的数列。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里我们创建了一个数组 a 来存放刚好 5 个 int。元素的类型和长度都是数组类型的一部分。数组默认是零值的，对于 int 数组来说也就是 0。</span></span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;emp:&quot;</span>, a)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 我们可以使用 array[index] = value 语法来设置数组指定位置的值，或者用 array[index] 得到值。</span></span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;set:&quot;</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;get:&quot;</span>, a[<span class="number">4</span>])</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 使用内置函数 len 返回数组的长度</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(a))</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 使用这个语法在一行内初始化一个数组</span></span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="comment">// 上面语句可简写为 var b = [5]int&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line">    <span class="comment">// 进一步简写为 b := [5]int&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;dcl:&quot;</span>, b)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 数组的存储类型是单一的，但是你可以组合这些数据来构造多维的数据结构。</span></span><br><span class="line">    <span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">            twoD[i][j] = i + j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;2d: &quot;</span>, twoD) <span class="comment">// 注意，在使用 fmt.Println 来打印数组的时候，会使用[v1 v2 v3 ...] 的格式显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run arrays.go</span><br><span class="line">emp: [0 0 0 0 0]</span><br><span class="line"><span class="built_in">set</span>: [0 0 0 0 100]</span><br><span class="line">get: 100</span><br><span class="line">len: 5</span><br><span class="line">dcl: [1 2 3 4 5]</span><br><span class="line">2d:  [[0 1 2] [1 2 3]]</span><br></pre></td></tr></table></figure>
<p>在典型的 Go 程序中，相对于数组而言，<strong>slice</strong> 使用的更多。我们将在后面讨论 <strong>slice</strong>。</p>
<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p><strong>Slice</strong> 是 Go 中一个关键的数据类型，是一个比数组更加强大的序列接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 不像数组，slice 的类型仅由它所包含的元素决定（不像数组中还需要元素的个数）。</span></span><br><span class="line">    <span class="comment">// 要创建一个长度非零的空slice，需要使用内建函数 make。</span></span><br><span class="line">    <span class="comment">// 这里我们创建了一个长度为3的 string 类型 slice（初始化为零值）。</span></span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;emp:&quot;</span>, s) <span class="comment">// emp: [  ]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们可以和数组一样设置和得到值</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span></span><br><span class="line">    s[<span class="number">1</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">    s[<span class="number">2</span>] = <span class="string">&quot;c&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;set:&quot;</span>, s)    <span class="comment">// set: [a b c]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;get:&quot;</span>, s[<span class="number">2</span>]) <span class="comment">// get: c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如你所料，len 返回 slice 的长度</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(s)) <span class="comment">// len: 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 作为基本操作的补充，slice 支持比数组更多的操作。其中一个是内建的 append，它返回一个包含了一个或者多个新值的 slice。注意我们接受返回由 append返回的新的 slice 值。</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;apd:&quot;</span>, s) <span class="comment">// apd: [a b c d e f]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slice 也可以被 copy。这里我们创建一个空的和 s 有相同长度的 slice c，并且将 s 复制给 c。</span></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="built_in">copy</span>(c, s)</span><br><span class="line">    fmt.Println(<span class="string">&quot;cpy:&quot;</span>, c) <span class="comment">// cpy: [a b c d e f]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slice 支持通过 slice[low:high] 语法进行“切片”操作。例如，这里得到一个包含元素 s[2], s[3],s[4] 的 slice。</span></span><br><span class="line">    l := s[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;sl1:&quot;</span>, l) <span class="comment">// sl1: [c d e]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个 slice 从 s[0] 到（但是包含）s[5]。</span></span><br><span class="line">    l = s[:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;sl2:&quot;</span>, l) <span class="comment">// sl2: [a b c d e]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个 slice 从（包含）s[2] 到 slice 的后一个值。</span></span><br><span class="line">    l = s[<span class="number">2</span>:]</span><br><span class="line">    fmt.Println(<span class="string">&quot;sl3:&quot;</span>, l) <span class="comment">// sl3: [c d e f]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们可以在一行代码中声明并初始化一个 slice 变量。</span></span><br><span class="line">    <span class="keyword">var</span> t []<span class="type">string</span> = []<span class="type">string</span>&#123;<span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;i&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 上面语句可简写为 var t = []string &#123;&quot;g&quot;, &quot;h&quot;, &quot;i&quot;&#125;</span></span><br><span class="line">    <span class="comment">// 进一步简写为 t := []string&#123;&quot;g&quot;, &quot;h&quot;, &quot;i&quot;&#125;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;dcl:&quot;</span>, t) <span class="comment">// dcl: [g h i]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slice 可以组成多维数据结构。内部的 slice 长度可以不同，这和多位数组不同。</span></span><br><span class="line">    twoD := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        innerLen := i + <span class="number">1</span></span><br><span class="line">        twoD[i] = <span class="built_in">make</span>([]<span class="type">int</span>, innerLen)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; innerLen; j++ &#123;</span><br><span class="line">            twoD[i][j] = i + j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;2d: &quot;</span>, twoD) <span class="comment">// 2d:  [[0] [1 2] [2 3 4]]</span></span><br><span class="line">    <span class="comment">// 注意，slice 和数组不同，虽然它们通过 fmt.Println 输出差不多。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run slices.go</span><br><span class="line">emp: [  ]</span><br><span class="line"><span class="built_in">set</span>: [a b c]</span><br><span class="line">get: c</span><br><span class="line">len: 3</span><br><span class="line">apd: [a b c d e f]</span><br><span class="line">cpy: [a b c d e f]</span><br><span class="line">sl1: [c d e]</span><br><span class="line">sl2: [a b c d e]</span><br><span class="line">sl3: [c d e f]</span><br><span class="line">dcl: [g h i]</span><br><span class="line">2d:  [[0] [1 2] [2 3 4]]</span><br></pre></td></tr></table></figure>
<p>看看这个由 Go 团队撰写的一篇<a href="http://blog.golang.org/2011/01/go-slices-usage-and-internals.html">很棒的博文</a>，获得更多关于 Go 中 slice 的设计和实现细节。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array 和 slice 的字面量声明的区别在于方括号[]中是否指定长度</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">string</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="built_in">append</span>(a, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>) <span class="comment">// 此时会报错：first argument to append must be a slice; have a (variable of type [3]string)</span></span><br></pre></td></tr></table></figure>

<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>现在，我们已经看过了数组和 slice，接下来我们将看看 Go 中的另一个关键的内建数据类型：map。</p>
<p>map 是 Go 内置关联数据类型（在一些其他的语言中称为哈希 或者字典 ）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 要创建一个空 map，需要使用内建函数make</span></span><br><span class="line">    <span class="comment">// 其形式为：make(map[key-type]val-type).</span></span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用典型的 name[key] = val 语法来设置键值对。</span></span><br><span class="line">    m[<span class="string">&quot;k1&quot;</span>] = <span class="number">7</span></span><br><span class="line">    m[<span class="string">&quot;k2&quot;</span>] = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用例如 Println 来打印一个 map 将会输出所有的键值对。</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;map:&quot;</span>, m) <span class="comment">// map: map[k1:7 k2:13]</span></span><br><span class="line">    <span class="comment">// 注意一个 map 在使用 fmt.Println 打印的时候，是以 map[k:v k:v]的格式输出的。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 name[key] 来获取一个键的值</span></span><br><span class="line">    v1 := m[<span class="string">&quot;k1&quot;</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1: &quot;</span>, v1) <span class="comment">// v1:  7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当对一个 map 调用内建的 len 时，返回的是键值对数目</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(m)) <span class="comment">// len: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内建的 delete 可以从一个 map 中移除键值对</span></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">&quot;k2&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;map:&quot;</span>, m) <span class="comment">// map: map[k1:7]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当从一个 map 中取值时，可选的第二返回值指示这个键是在这个 map 中。这可以用来消除键不存在和键有零值，像 0 或者 &quot;&quot; 而产生的歧义。</span></span><br><span class="line">    <span class="comment">// _, prs := m[&quot;k2&quot;]</span></span><br><span class="line">    k2, prs := m[<span class="string">&quot;k2&quot;</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;prs:&quot;</span>, prs) <span class="comment">// prs: false</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;k2:&quot;</span>, k2)   <span class="comment">// k2: 0</span></span><br><span class="line"></span><br><span class="line">    k1, prs := m[<span class="string">&quot;k1&quot;</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;prs:&quot;</span>, prs) <span class="comment">// prs: true</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;k1:&quot;</span>, k1)   <span class="comment">// k1: 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你也可以通过这个语法在同一行申明和初始化一个新的map。</span></span><br><span class="line">    n := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;foo&quot;</span>: <span class="number">1</span>, <span class="string">&quot;bar&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;map:&quot;</span>, n) <span class="comment">// map: map[bar:2 foo:1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run maps.go </span><br><span class="line">map: map[k1:7 k2:13]</span><br><span class="line">v1:  7</span><br><span class="line">len: 2</span><br><span class="line">map: map[k1:7]</span><br><span class="line">prs: <span class="literal">false</span></span><br><span class="line">k2: 0</span><br><span class="line">prs: <span class="literal">true</span></span><br><span class="line">k1: 7</span><br><span class="line">map: map[bar:2 foo:1]</span><br></pre></td></tr></table></figure>

<h1 id="range遍历"><a href="#range遍历" class="headerlink" title="range遍历"></a>range遍历</h1><p><code>range</code> 迭代各种各样的数据结构。让我们来看看如何在我们已经学过的数据结构上使用 <code>range</code> 吧。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里我们使用 range 来统计一个 slice 的元素个数。数组也可以采用这种方法。</span></span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123; <span class="comment">// 这里我们不需要索引，所以使用 空值定义符_ 来忽略它。有时候我们实际上是需要这个索引的。</span></span><br><span class="line">		sum += num</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;sum:&quot;</span>, sum) <span class="comment">// sum: 9</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// range 在数组和 slice 中都同样提供每个项的索引和值。</span></span><br><span class="line">	<span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">if</span> num == <span class="number">3</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;index:&quot;</span>, i) <span class="comment">// index: 1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// range 在 map 中迭代键值对。</span></span><br><span class="line">	kvs := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">		<span class="comment">// a -&gt; apple</span></span><br><span class="line">		<span class="comment">// b -&gt; banana</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The first value is the starting byte index of the rune and the second the rune itself.</span></span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">&quot;go&quot;</span> &#123;</span><br><span class="line">		fmt.Println(i, c)</span><br><span class="line">		<span class="comment">// 0 103</span></span><br><span class="line">		<span class="comment">// 1 111</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, r := <span class="keyword">range</span> <span class="string">&quot;啊哈&quot;</span> &#123;</span><br><span class="line">		fmt.Println(i, r, <span class="type">string</span>(r))</span><br><span class="line">		<span class="comment">// 0 21834 啊</span></span><br><span class="line">		<span class="comment">//3 21704 哈</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">$ go run range.go </span><br><span class="line"><span class="built_in">sum</span>: 9</span><br><span class="line">index: 1</span><br><span class="line">a -&gt; apple</span><br><span class="line">b -&gt; banana</span><br><span class="line">0 103</span><br><span class="line">1 111</span><br><span class="line">0 21834 啊</span><br><span class="line">3 21704 哈</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是一个函数，接受两个 int 并返回它们的和，返回值为int类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// Go 需要明确的返回值，例如，它不会自动返回最后一个表达式的值</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 正如你期望的那样，通过 name(args) 来调用一个函数，</span></span><br><span class="line">    res := plus(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;1+2 =&quot;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run functions.go</span><br><span class="line">1+2 = 3</span><br></pre></td></tr></table></figure>

<h2 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h2><p>Go 内建<em>多返回值</em> 支持。这个特性在 Go 语言中经常被用到，例如用来同时返回一个函数的结果和错误信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (int, int) 在这个函数中标志着这个函数返回 2 个 int。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">vals</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>, <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里我们通过多赋值 操作来使用这两个不同的返回值。</span></span><br><span class="line">    a, b := vals()</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Println(b)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你仅仅想返回值的一部分的话，你可以使用空白标识符 _。</span></span><br><span class="line">    _, c := vals()</span><br><span class="line">    fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run multiple-return-values.go</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h2 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h2><p><a href="http://zh.wikipedia.org/wiki/%E5%8F%AF%E8%AE%8A%E5%8F%83%E6%95%B8%E5%87%BD%E6%95%B8"><em>可变参数函数</em></a>。可以用任意数量的参数调用。例如，<code>fmt.Println</code> 是一个常见的变参函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数使用任意数目的 int 作为参数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Print(nums, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        total += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 变参函数使用常规的调用方式，除了参数比较特殊。</span></span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 如果你的 slice 已经有了多个值，想把它们作为变参使用，你要这样调用 func(slice...)。</span></span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sum(nums...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run variadic-functions.go </span><br><span class="line">[1 2] 3</span><br><span class="line">[1 2 3] 6</span><br><span class="line">[1 2 3 4] 10</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Go 支持 <a href="http://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><em>匿名函数</em></a>，可以形成 <a href="http://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)"><em>闭包</em></a> 。当您想定义一个内联函数而不必命名时，匿名函数很有用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 intSeq 函数返回另一个在 intSeq 函数体内定义的匿名函数。</span></span><br><span class="line"><span class="comment">// 这个返回的匿名函数返回一个int类型；</span></span><br><span class="line"><span class="comment">// 同时，这个返回的函数使用闭包的方式 隐藏 变量 i。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSeq</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//我们调用 intSeq 函数，将返回值（也是一个函数）赋给nextInt。</span></span><br><span class="line">    <span class="comment">// 这个函数的值包含了自己的值 i，这样在每次调用 nextInt 时都会更新 i 的值。</span></span><br><span class="line">    nextInt := intSeq()</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 通过多次调用 nextInt 来看看闭包的效果。</span></span><br><span class="line">    fmt.Println(nextInt()) <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(nextInt()) <span class="comment">// 2</span></span><br><span class="line">    fmt.Println(nextInt()) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了确认这个状态对于这个特定的函数是唯一的，我们重新创建并测试一下。</span></span><br><span class="line">    newInts := intSeq()</span><br><span class="line">    fmt.Println(newInts()) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run closures.go</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是一个经典的阶乘示例。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fact</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123; <span class="comment">// face 函数在到达 face(0) 前一直调用自身。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(fact(<span class="number">7</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run recursion.go </span><br><span class="line">5040</span><br></pre></td></tr></table></figure>

<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>Go 支持 <em><a href="http://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">指针</a></em>，允许在程序中通过引用传递值或者数据结构。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将通过两个函数：zeroval 和 zeroptr 来比较指针和值类型的不同。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// zeroval 有一个 int 型参数，所以使用值传递。zeroval 将从调用它的那个函数中得到一个 ival形参的拷贝。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroval</span><span class="params">(ival <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    ival = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zeroptr 有一个和上面不同的 *int 参数，意味着它用了一个 int指针。</span></span><br><span class="line"><span class="comment">// 函数体内的 *iptr 接着解引用 这个指针，从它内存地址得到这个地址对应的当前值。</span></span><br><span class="line"><span class="comment">// 对一个解引用的指针赋值将会改变这个指针引用的真实地址的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroptr</span><span class="params">(iptr *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *iptr = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;initial:&quot;</span>, i) <span class="comment">// 1</span></span><br><span class="line">    zeroval(i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;zeroval:&quot;</span>, i) <span class="comment">// 1</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 通过 &amp;i 语法来取得 i 的内存地址，例如一个变量i 的指针。</span></span><br><span class="line">    zeroptr(&amp;i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;zeroptr:&quot;</span>, i) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针也是可以被打印的。</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;pointer:&quot;</span>, &amp;i) <span class="comment">// 0x42131100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// zeroval 在 main 函数中不能改变 i 的值，但是zeroptr 可以，因为它有一个这个变量的内存地址的引用。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run pointers.go</span><br><span class="line">initial: 1</span><br><span class="line">zeroval: 1</span><br><span class="line">zeroptr: 0</span><br><span class="line">pointer: 0x42131100</span><br></pre></td></tr></table></figure>



<h1 id="Strings-and-Runes"><a href="#Strings-and-Runes" class="headerlink" title="Strings and Runes"></a>Strings and Runes</h1><p>A Go string is a read-only slice of bytes. The language and the standard library treat strings specially - as containers of text encoded in <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>. In other languages, strings are made of “characters”. In Go, the concept of a character is called a <code>rune</code> - it’s an integer that represents a Unicode code point. <a href="https://go.dev/blog/strings">This Go blog post</a> is a good introduction to the topic.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s is a string assigned a literal value representing the word “hello” in the Thai language. </span></span><br><span class="line">    <span class="comment">// Go string literals are UTF-8 encoded text.</span></span><br><span class="line">    <span class="keyword">const</span> s = <span class="string">&quot;สวัสดี&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since strings are equivalent to []byte, this will produce the length of the raw bytes stored within.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Len:&quot;</span>, <span class="built_in">len</span>(s)) <span class="comment">// Len: 18</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indexing into a string produces the raw byte values at each index. </span></span><br><span class="line">    <span class="comment">// This loop generates the hex values of all the bytes that constitute the code points in s.</span></span><br><span class="line">    <span class="comment">// 对字符串进行索引会在每个索引处生成原始字节值。</span></span><br><span class="line">    <span class="comment">// 此循环生成构成 s 中代码点的所有字节的十六进制值。</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%x &quot;</span>, s[i]) <span class="comment">// e0 b8 aa e0 b8 a7 e0 b8 b1 e0 b8 aa e0 b8 94 e0 b8 b5 </span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To count how many runes are in a string, we can use the utf8 package. </span></span><br><span class="line">    <span class="comment">// Note that the run-time of RuneCountInString dependes on the size of the string, because it has to decode each UTF-8 rune sequentially. </span></span><br><span class="line">    <span class="comment">// Some Thai characters are represented by multiple UTF-8 code points, so the result of this count may be surprising.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Rune count:&quot;</span>, utf8.RuneCountInString(s)) <span class="comment">// Rune count: 6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// A range loop handles strings specially and decodes each rune along with its offset in the string.</span></span><br><span class="line">    <span class="keyword">for</span> idx, runeValue := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#U starts at %d\n&quot;</span>, runeValue, idx)</span><br><span class="line">        <span class="comment">// U+0E2A &#x27;ส&#x27; starts at 0</span></span><br><span class="line">	   <span class="comment">// U+0E27 &#x27;ว&#x27; starts at 3</span></span><br><span class="line">	   <span class="comment">// U+0E31 &#x27;ั&#x27; starts at 6</span></span><br><span class="line">       <span class="comment">// U+0E2A &#x27;ส&#x27; starts at 9</span></span><br><span class="line">       <span class="comment">// U+0E14 &#x27;ด&#x27; starts at 12</span></span><br><span class="line">       <span class="comment">// U+0E35 &#x27;ี&#x27; starts at 15</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can achieve the same iteration by using the utf8.DecodeRuneInString function explicitly.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;\nUsing DecodeRuneInString&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, w := <span class="number">0</span>, <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i += w &#123;</span><br><span class="line">        runeValue, width := utf8.DecodeRuneInString(s[i:])</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#U starts at %d\n&quot;</span>, runeValue, i)</span><br><span class="line">        w = width</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This demonstrates passing a rune value to a function.</span></span><br><span class="line">        examineRune(runeValue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Using DecodeRuneInString</span></span><br><span class="line">    <span class="comment">// U+0E2A &#x27;ส&#x27; starts at 0</span></span><br><span class="line">    <span class="comment">// found so sua</span></span><br><span class="line">    <span class="comment">// U+0E27 &#x27;ว&#x27; starts at 3</span></span><br><span class="line">    <span class="comment">// U+0E31 &#x27;ั&#x27; starts at 6</span></span><br><span class="line">    <span class="comment">// U+0E2A &#x27;ส&#x27; starts at 9</span></span><br><span class="line">    <span class="comment">// found so sua</span></span><br><span class="line">    <span class="comment">// U+0E14 &#x27;ด&#x27; starts at 12</span></span><br><span class="line">    <span class="comment">// U+0E35 &#x27;ี&#x27; starts at 15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">examineRune</span><span class="params">(r <span class="type">rune</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values enclosed in single quotes are rune literals. </span></span><br><span class="line">    <span class="comment">// We can compare a rune value to a rune literal directly.</span></span><br><span class="line">    <span class="keyword">if</span> r == <span class="string">&#x27;t&#x27;</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;found tee&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> r == <span class="string">&#x27;ส&#x27;</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;found so sua&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run strings-and-runes.go</span><br><span class="line">Len: 18</span><br><span class="line">e0 b8 aa e0 b8 a7 e0 b8 b1 e0 b8 aa e0 b8 94 e0 b8 b5 </span><br><span class="line">Rune count: 6</span><br><span class="line">U+0E2A <span class="string">&#x27;ส&#x27;</span> starts at 0</span><br><span class="line">U+0E27 <span class="string">&#x27;ว&#x27;</span> starts at 3</span><br><span class="line">U+0E31 <span class="string">&#x27;ั&#x27;</span> starts at 6</span><br><span class="line">U+0E2A <span class="string">&#x27;ส&#x27;</span> starts at 9</span><br><span class="line">U+0E14 <span class="string">&#x27;ด&#x27;</span> starts at 12</span><br><span class="line">U+0E35 <span class="string">&#x27;ี&#x27;</span> starts at 15</span><br><span class="line"></span><br><span class="line">Using DecodeRuneInString</span><br><span class="line">U+0E2A <span class="string">&#x27;ส&#x27;</span> starts at 0</span><br><span class="line">found so sua</span><br><span class="line">U+0E27 <span class="string">&#x27;ว&#x27;</span> starts at 3</span><br><span class="line">U+0E31 <span class="string">&#x27;ั&#x27;</span> starts at 6</span><br><span class="line">U+0E2A <span class="string">&#x27;ส&#x27;</span> starts at 9</span><br><span class="line">found so sua</span><br><span class="line">U+0E14 <span class="string">&#x27;ด&#x27;</span> starts at 12</span><br><span class="line">U+0E35 <span class="string">&#x27;ี&#x27;</span> starts at 15</span><br></pre></td></tr></table></figure>



<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go 的<em>结构体(struct)</em> 是带类型的字段(fields)集合。 这在组织数据时非常有用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This person struct type has name and age fields.</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newPerson constructs a new person struct with the given name.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name <span class="type">string</span>)</span></span> *person &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You can safely return a pointer to local variable as a local variable will survive the scope of the function.</span></span><br><span class="line">    p := person&#123;name: name&#125;</span><br><span class="line">    p.age = <span class="number">42</span></span><br><span class="line">    <span class="keyword">return</span> &amp;p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This syntax creates a new struct.</span></span><br><span class="line">    fmt.Println(person&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;) <span class="comment">// &#123;Bob 20&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You can name the fields when initializing a struct.</span></span><br><span class="line">    fmt.Println(person&#123;name: <span class="string">&quot;Alice&quot;</span>, age: <span class="number">30</span>&#125;) <span class="comment">// &#123;Alice 30&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Omitted fields will be zero-valued.</span></span><br><span class="line">    fmt.Println(person&#123;name: <span class="string">&quot;Fred&quot;</span>&#125;) <span class="comment">// &#123;Fred 0&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// An &amp; prefix yields a pointer to the struct.</span></span><br><span class="line">    fmt.Println(&amp;person&#123;name: <span class="string">&quot;Ann&quot;</span>, age: <span class="number">40</span>&#125;) <span class="comment">// &amp;&#123;Ann 40&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// It’s idiomatic to encapsulate new struct creation in constructor functions</span></span><br><span class="line">    fmt.Println(newPerson(<span class="string">&quot;Jon&quot;</span>)) <span class="comment">// &amp;&#123;Jon 42&#125;</span></span><br><span class="line"></span><br><span class="line">    s := person&#123;name: <span class="string">&quot;Sean&quot;</span>, age: <span class="number">50</span>&#125;</span><br><span class="line">    <span class="comment">// Access struct fields with a dot.</span></span><br><span class="line">    fmt.Println(s.name) <span class="comment">// Sean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You can also use dots with struct pointers - the pointers are automatically dereferenced.</span></span><br><span class="line">    sp := &amp;s</span><br><span class="line">    fmt.Println(sp.age) <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Structs are mutable.</span></span><br><span class="line">    sp.age = <span class="number">51</span></span><br><span class="line">    fmt.Println(sp.age) <span class="comment">// 51</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run structs.go</span><br><span class="line">&#123;Bob 20&#125;</span><br><span class="line">&#123;Alice 30&#125;</span><br><span class="line">&#123;Fred 0&#125;</span><br><span class="line">&amp;&#123;Ann 40&#125;</span><br><span class="line">&amp;&#123;Jon 42&#125;</span><br><span class="line">Sean</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td></tr></table></figure>

<p>结构体中可以包含函数类型的字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">	say  <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="comment">// 结构体中可以包含函数类型的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name <span class="type">string</span>)</span></span> *person &#123;</span><br><span class="line"></span><br><span class="line">	p := person&#123;name: name&#125;</span><br><span class="line">	p.age = <span class="number">42</span></span><br><span class="line">	p.say = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;yoyo&quot;</span>) &#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := person&#123;name: <span class="string">&quot;Peter&quot;</span>, age: <span class="number">12</span>, say: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;haha&quot;</span>) &#125;&#125;</span><br><span class="line">	fmt.Println(p) <span class="comment">// &#123;Peter 12 0xede5c0&#125;</span></span><br><span class="line">	p.say()        <span class="comment">// haha</span></span><br><span class="line"></span><br><span class="line">	p1 := newPerson(<span class="string">&quot;Neo&quot;</span>)</span><br><span class="line">	fmt.Println(p1) <span class="comment">// &amp;&#123;Neo 42 0xaae480&#125;</span></span><br><span class="line">	p1.say()        <span class="comment">// yoyo</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run demo.go</span><br><span class="line">&#123;Peter 12 0xede5c0&#125;</span><br><span class="line">haha</span><br><span class="line">&amp;&#123;Neo 42 0xaae480&#125;</span><br><span class="line">yoyo</span><br></pre></td></tr></table></figure>



<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Go 支持为结构体类型定义 <em><strong>方法</strong> (methods)</em>  。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// area 是一个方法，该方法拥有一个 *rect 类型（rect类型的指针）的接收器(receiver)。</span></span><br><span class="line"><span class="comment">// You may want to use a pointer receiver type to avoid copying on method calls or to allow the method to mutate the receiving struct.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rect)</span></span> area() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法的接收器(receiver)类型可以被定义为值类型或者指针类型。</span></span><br><span class="line"><span class="comment">// 这是一个值类型接收器的例子。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span></span> perim() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rect&#123;width: <span class="number">10</span>, height: <span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 这里我们调用上面为结构体定义的两个方法。</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;area: &quot;</span>, r.area()) <span class="comment">// area:  50</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;perim:&quot;</span>, r.perim()) <span class="comment">// perim: 30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Go automatically handles conversion between values and pointers for method calls.</span></span><br><span class="line">    rp := &amp;r</span><br><span class="line">    fmt.Println(<span class="string">&quot;area: &quot;</span>, rp.area()) <span class="comment">// area:  50</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;perim:&quot;</span>, rp.perim()) <span class="comment">// perim: 30</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 与上面等价，注意，需要在取地址符外加上括号</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;(&amp;r).area(): &quot;</span>, (&amp;r).area()) <span class="comment">// (&amp;r).area():  50</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;(&amp;r).perim():&quot;</span>, (&amp;r).perim()) <span class="comment">// (&amp;r).perim(): 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run methods.go</span><br><span class="line">area:  50</span><br><span class="line">perim: 30</span><br><span class="line">area:  50</span><br><span class="line">perim: 30</span><br><span class="line">(&amp;r).area():  50</span><br><span class="line">(&amp;r).perim(): 30</span><br></pre></td></tr></table></figure>

<p>使用接收器类型为指针的方法，既可以避免方法调用时的值拷贝，也允许方法修改接收到的结构体中的字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> SayHello() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;my name is&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> ChangeName(<span class="built_in">new</span> <span class="type">string</span>) &#123;</span><br><span class="line">	p.name = <span class="built_in">new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> ChangeNameInPlace(<span class="built_in">new</span> <span class="type">string</span>) &#123;</span><br><span class="line">	p.name = <span class="built_in">new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := person&#123;name: <span class="string">&quot;Peter&quot;</span>, age: <span class="number">12</span>&#125;</span><br><span class="line">	pp := &amp;p</span><br><span class="line"></span><br><span class="line">	fmt.Println(p)  <span class="comment">// &#123;Peter 12&#125;</span></span><br><span class="line">	fmt.Println(pp) <span class="comment">// &amp;&#123;Peter 12&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在调用方法时，Go会自动处理值和指针的转换；</span></span><br><span class="line">	<span class="comment">// 你可以直接使用结构体的值来调用方法，也可以使用结构体的指针来调用方法；</span></span><br><span class="line">	p.SayHello()  <span class="comment">// my name is Peter</span></span><br><span class="line">	pp.SayHello() <span class="comment">// my name is Peter</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不管是使用值调用方法还是使用结构体指针调用方法，都无法直接修改结构体中的字段；</span></span><br><span class="line">	p.ChangeName(<span class="string">&quot;Guy&quot;</span>)</span><br><span class="line">	fmt.Println(p.name) <span class="comment">// Peter</span></span><br><span class="line">	pp.ChangeName(<span class="string">&quot;Goodman&quot;</span>)</span><br><span class="line">	fmt.Println(p.name) <span class="comment">// Peter</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 只有在方法的接收器类型是指针时，方法才能修改接收到的结构体的字段。</span></span><br><span class="line">	p.ChangeNameInPlace(<span class="string">&quot;Guy&quot;</span>)</span><br><span class="line">	fmt.Println(p.name) <span class="comment">// Guy</span></span><br><span class="line">	pp.ChangeNameInPlace(<span class="string">&quot;Goodman&quot;</span>)</span><br><span class="line">	fmt.Println(p.name) <span class="comment">// Goodman</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run .\demo1.go</span><br><span class="line">&#123;Peter 12&#125;</span><br><span class="line">&amp;&#123;Peter 12&#125;</span><br><span class="line">my name is Peter</span><br><span class="line">my name is Peter</span><br><span class="line">Peter</span><br><span class="line">Peter</span><br><span class="line">Guy</span><br><span class="line">Goodman</span><br></pre></td></tr></table></figure>



<h1 id="接口-Interfaces"><a href="#接口-Interfaces" class="headerlink" title="接口 (Interfaces)"></a>接口 (Interfaces)</h1><p>方法签名的集合叫做 <em><strong>接口</strong> (Interfaces)</em>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个几何形状的基本接口。</span></span><br><span class="line"><span class="keyword">type</span> geometry <span class="keyword">interface</span> &#123;</span><br><span class="line">    area() <span class="type">float64</span></span><br><span class="line">    perim() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个例子中，我们将为 rect 和 circle 实现该接口。</span></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要在 Go 中实现一个接口，我们只需要实现接口中的所有方法。</span></span><br><span class="line"><span class="comment">// 为 rect 实现 geometry 接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span></span> perim() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 circle 实现 geometry 接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span></span> perim() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个变量实现了某个接口，我们就可以调用指定接口中的方法。 </span></span><br><span class="line"><span class="comment">// 这有一个通用的 measure 函数，我们可以通过它来使用所有的 geometry。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(g geometry)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;g :&quot;</span>, g) </span><br><span class="line">	fmt.Println(<span class="string">&quot;g.area() :&quot;</span>, g.area())</span><br><span class="line">	fmt.Println(<span class="string">&quot;g.perim() :&quot;</span>, g.perim())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rect&#123;width: <span class="number">3</span>, height: <span class="number">4</span>&#125;</span><br><span class="line">    c := circle&#123;radius: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体类型 circle 和 rect 都实现了 geometry 接口， 所以我们可以将其实例作为 measure 的参数。</span></span><br><span class="line">    measure(r)</span><br><span class="line">    measure(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run interfaces.go</span><br><span class="line">g : &#123;3 4&#125;</span><br><span class="line">g.area() : 12                </span><br><span class="line">g.perim() : 14               </span><br><span class="line">g : &#123;5&#125;                      </span><br><span class="line">g.area() : 78.53981633974483 </span><br><span class="line">g.perim() : 31.41592653589793</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义animal接口</span></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	eat()</span><br><span class="line">	speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person类型实现animal接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> eat() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s eat KFC.\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> speak() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;my name is %s.\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog类型实现animal接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> eat() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;dog eat meat.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> speak() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Woof woof~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call函数接受一个animal接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">(a animal)</span></span> &#123;</span><br><span class="line">	a.eat()</span><br><span class="line">	a.speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := person&#123;name: <span class="string">&quot;Peter&quot;</span>, age: <span class="number">12</span>&#125;</span><br><span class="line">	d := dog&#123;name: <span class="string">&quot;Dog&quot;</span>, age: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">	call(p)</span><br><span class="line">	call(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Peter eat KFC.</span><br><span class="line">my name is Peter.</span><br><span class="line">dog eat meat.</span><br><span class="line">Woof woof~</span><br></pre></td></tr></table></figure>



<h1 id="Struct-Embedding"><a href="#Struct-Embedding" class="headerlink" title="Struct Embedding"></a>Struct Embedding</h1><p>Go supports <em>embedding</em> of structs and interfaces to express a more seamless <em>composition</em> of types. This is not to be confused with <code>//go:embed</code> which is a go directive introduced in Go version 1.16+ to embed files and folders into the application binary.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 base 结构体</span></span><br><span class="line"><span class="keyword">type</span> base <span class="keyword">struct</span> &#123;</span><br><span class="line">    num <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个base类型的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b base)</span></span> describe() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;base with num=%v&quot;</span>, b.num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 container 结构体，在 container 中嵌入 base。</span></span><br><span class="line"><span class="keyword">type</span> container <span class="keyword">struct</span> &#123;</span><br><span class="line">    base <span class="comment">// “嵌入”看起来像是没有名称的字段</span></span><br><span class="line">    str <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// When creating structs with literals, we have to initialize the embedding explicitly; here the embedded type serves as the field name.</span></span><br><span class="line">    <span class="comment">// 当使用字面量创建结构体时，必须显式地初始化“嵌入”。</span></span><br><span class="line">    co := container&#123;</span><br><span class="line">        base: base&#123; <span class="comment">// 这里为被嵌入的类型提供一个字段名 base。</span></span><br><span class="line">            num: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        str: <span class="string">&quot;some name&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// We can access the base’s fields directly on co, e.g. co.num.</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;co=&#123;num: %v, str: %v&#125;\n&quot;</span>, co.num, co.str) <span class="comment">// co=&#123;num: 1, str: some name&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Alternatively, we can spell out the full path using the embedded type name.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;co.base.num: &quot;</span>, co.base.num) <span class="comment">// co.base.num:  1</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// Since container embeds base, the methods of base also become methods of a container. Here we invoke a method that was embedded from base directly on co.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;co.describe(): &quot;</span>, co.describe()) <span class="comment">// co.describe():  base with num=1  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;co.base.describe(): &quot;</span>, co.base.describe()) <span class="comment">// co.base.describe():  base with num=1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> describer <span class="keyword">interface</span> &#123;</span><br><span class="line">        describe() <span class="type">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// Embedding structs with methods may be used to bestow interface implementations onto other structs. Here we see that a container now implements the describer interface because it embeds base.</span></span><br><span class="line">    <span class="comment">// 使用方法嵌入结构体可用于将接口实现赋予其他结构体。</span></span><br><span class="line">    <span class="comment">// 因为 container 嵌入了 base, 所以 container 也就实现了 describer 接口</span></span><br><span class="line">    <span class="keyword">var</span> d describer = co</span><br><span class="line">    fmt.Println(<span class="string">&quot;d.describe(): &quot;</span>, d.describe()) <span class="comment">// d.describe():  base with num=1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run embedding.go</span><br><span class="line">co=&#123;num: 1, str: some name&#125;</span><br><span class="line">co.base.num:  1</span><br><span class="line">co.describe():  base with num=1</span><br><span class="line">co.base.describe():  base with num=1</span><br><span class="line">d.describe():  base with num=1</span><br></pre></td></tr></table></figure>

<h1 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h1><p>Starting with version 1.18, Go has added support for <em>generics</em>, also known as <em>type parameters</em>.</p>
<p>As an example of a generic function, <code>MapKeys</code> takes a map of any type and returns a slice of its keys. This function has two type parameters - <code>K</code> and <code>V</code>; <code>K</code> has the <code>comparable</code> <em>constraint</em>, meaning that we can compare values of this type with the <code>==</code> and <code>!=</code> operators. This is required for map keys in Go. <code>V</code> has the <code>any</code> constraint, meaning that it’s not restricted in any way (<code>any</code> is an alias for <code>interface&#123;&#125;</code>).</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapKeys</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span></span> []K &#123;</span><br><span class="line">    r := <span class="built_in">make</span>([]K, <span class="number">0</span>, <span class="built_in">len</span>(m))</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">        r = <span class="built_in">append</span>(r, k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// As an example of a generic type, List is a singly-linked list with values of any type.</span></span><br><span class="line"><span class="keyword">type</span> List[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    head, tail *element[T]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> element[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    next *element[T]</span><br><span class="line">    val  T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can define methods on generic types just like we do on regular types, but we have to keep the type parameters in place. </span></span><br><span class="line"><span class="comment">// The type is List[T], not List.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lst *List[T])</span></span> Push(v T) &#123;</span><br><span class="line">    <span class="keyword">if</span> lst.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">        lst.head = &amp;element[T]&#123;val: v&#125;</span><br><span class="line">        lst.tail = lst.head</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lst.tail.next = &amp;element[T]&#123;val: v&#125;</span><br><span class="line">        lst.tail = lst.tail.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lst *List[T])</span></span> GetAll() []T &#123;</span><br><span class="line">    <span class="keyword">var</span> elems []T</span><br><span class="line">    <span class="keyword">for</span> e := lst.head; e != <span class="literal">nil</span>; e = e.next &#123;</span><br><span class="line">        elems = <span class="built_in">append</span>(elems, e.val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elems</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;2&quot;</span>, <span class="number">2</span>: <span class="string">&quot;4&quot;</span>, <span class="number">4</span>: <span class="string">&quot;8&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When invoking generic functions, we can often rely on type inference. </span></span><br><span class="line">    <span class="comment">// Note that we don’t have to specify the types for K and V when calling MapKeys - the compiler infers them automatically.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;keys m:&quot;</span>, MapKeys(m))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// though we could also specify them explicitly.</span></span><br><span class="line">    _ = MapKeys[<span class="type">int</span>, <span class="type">string</span>](m)</span><br><span class="line"></span><br><span class="line">    lst := List[<span class="type">int</span>]&#123;&#125;</span><br><span class="line">    lst.Push(<span class="number">10</span>)</span><br><span class="line">    lst.Push(<span class="number">13</span>)</span><br><span class="line">    lst.Push(<span class="number">23</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;list:&quot;</span>, lst.GetAll())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keys: [4 1 2]</span><br><span class="line">list: [10 13 23]</span><br></pre></td></tr></table></figure>

<h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>In Go it’s idiomatic to communicate errors via an explicit, separate return value. This contrasts with the exceptions used in languages like Java and Ruby and the overloaded single result &#x2F; error value sometimes used in C. Go’s approach makes it easy to see which functions return errors and to handle them using the same language constructs employed for any other, non-error tasks.</p>
<p>符合 Go 语言习惯的做法是使用一个独立、明确的返回值来传递错误信息。 这与 Java、Ruby 使用的异常（exception） 以及在 C 语言中有时用到的重载 (overloaded) 的单返回&#x2F;错误值有着明显的不同。 Go 语言的处理方式能清楚的知道哪个函数返回了错误，并使用跟其他（无异常处理的）语言类似的方式来处理错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照惯例，错误通常是最后一个返回值并且是 error 类型，它是一个内建的接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(arg <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> arg == <span class="number">42</span> &#123;</span><br><span class="line">        <span class="comment">// errors.New 使用给定的错误信息构造一个基本的 error 值。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">&quot;can&#x27;t work with 42&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// A nil value in the error position indicates that there was no error.</span></span><br><span class="line">    <span class="comment">// 返回的错误值为 nil 代表没有错误。</span></span><br><span class="line">    <span class="keyword">return</span> arg + <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// It’s possible to use custom types as errors by implementing the Error() method on them. Here’s a variant on the example above that uses a custom type to explicitly represent an argument error.</span></span><br><span class="line"><span class="comment">// 你还可以通过实现 Error() 方法来自定义 error 类型。 </span></span><br><span class="line"><span class="comment">// 这里是上面示例的一个变体，使用自定义错误类型来表示参数错误。</span></span><br><span class="line"><span class="keyword">type</span> argError <span class="keyword">struct</span> &#123;</span><br><span class="line">    arg  <span class="type">int</span></span><br><span class="line">    prob <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *argError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d - %s&quot;</span>, e.arg, e.prob)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(arg <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> arg == <span class="number">42</span> &#123;</span><br><span class="line">		<span class="comment">// In this case we use &amp;argError syntax to build a new struct, supplying values for the two fields arg and prob.</span></span><br><span class="line">        <span class="comment">// 在这个例子中，我们使用 &amp;argError 语法来建立一个新的结构体， 并提供了 arg 和 prob 两个字段的值。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, &amp;argError&#123;arg, <span class="string">&quot;can&#x27;t work with it&quot;</span>&#125; </span><br><span class="line">        <span class="comment">// return -1, &amp;(argError&#123;arg, &quot;can&#x27;t work with it&quot;&#125;)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arg + <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// The two loops below test out each of our error-returning functions.</span></span><br><span class="line">    <span class="comment">// 下面的两个循环测试了我们的每个错误返回函数</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">42</span>&#125; &#123;</span><br><span class="line">        <span class="comment">// Note that the use of an inline error check on the if line is a common idiom in Go code.</span></span><br><span class="line">        <span class="keyword">if</span> r, e := f1(i); e != <span class="literal">nil</span> &#123; <span class="comment">// 请注意，在 if 行上使用内联错误检查是 Go 代码中的常见习惯用法。</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;f1 failed:&quot;</span>, e)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;f1 worked:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">42</span>&#125; &#123;</span><br><span class="line">        <span class="keyword">if</span> r, e := f2(i); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;f2 failed:&quot;</span>, e)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;f2 worked:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// If you want to programmatically use the data in a custom error, you’ll need to get the error as an instance of the custom error type via type assertion.</span></span><br><span class="line">    <span class="comment">// 如果你想在程序中使用自定义错误类型的数据， 你需要通过类型断言来得到这个自定义错误类型的实例。</span></span><br><span class="line">    _, e := f2(<span class="number">42</span>)</span><br><span class="line">    <span class="keyword">if</span> ae, ok := e.(*argError); ok &#123;</span><br><span class="line">        fmt.Println(ae.arg)</span><br><span class="line">        fmt.Println(ae.prob)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run errors.go</span><br><span class="line">f1 worked: 10</span><br><span class="line">f1 failed: can<span class="string">&#x27;t work with 42</span></span><br><span class="line"><span class="string">f2 worked: 10</span></span><br><span class="line"><span class="string">f2 failed: 42 - can&#x27;</span>t work with it</span><br><span class="line">42</span><br><span class="line">can<span class="string">&#x27;t work with it</span></span><br></pre></td></tr></table></figure>

<h1 id="Go协程"><a href="#Go协程" class="headerlink" title="Go协程"></a>Go协程</h1><p><em>协程(goroutine)</em> 是轻量级的执行线程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(from <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Println(from, <span class="string">&quot;:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 假设我们有一个函数叫做 f(s)。 我们一般会这样 同步地 调用它</span></span><br><span class="line">    f(<span class="string">&quot;direct&quot;</span>)</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 使用 go f(s) 在一个协程中调用这个函数。 这个新的 Go 协程将会 并发地 执行这个函数。</span></span><br><span class="line">    <span class="keyword">go</span> f(<span class="string">&quot;goroutine&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你也可以为匿名函数启动一个协程。</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    &#125;(<span class="string">&quot;going&quot;</span>)</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 现在两个协程在独立的协程中 异步地 运行， 然后等待两个协程完成（更好的方法是使用 WaitGroup）。</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当我们运行这个程序时，首先会看到阻塞式调用的输出，然后是两个协程的交替输出。 这种交替的情况表示 Go runtime 是以并发的方式运行协程的。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run goroutines.go</span><br><span class="line">direct : 0</span><br><span class="line">direct : 1</span><br><span class="line">direct : 2</span><br><span class="line">goroutine : 0</span><br><span class="line">going</span><br><span class="line">goroutine : 1</span><br><span class="line">goroutine : 2</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>



<h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p><em>通道(channels)</em> 是连接多个协程的管道。 你可以从一个协程将值发送到通道，然后在另一个协程中接收。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 make(chan val-type) 创建一个新的通道。 通道类型就是他们需要传递值的类型。</span></span><br><span class="line">    messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 使用 channel &lt;- 语法 发送 一个新的值到通道中。 这里我们在一个新的协程中发送 &quot;ping&quot; 到上面创建的 messages 通道中。</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; messages &lt;- <span class="string">&quot;ping&quot;</span> &#125;()</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 使用 &lt;-channel 语法从通道中 接收 一个值。 这里我们会收到在上面发送的 &quot;ping&quot; 消息并将其打印出来。</span></span><br><span class="line">    msg := &lt;-messages</span><br><span class="line">    fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们运行程序时，通过通道， 成功的将消息 &quot;ping&quot; 从一个协程传送到了另一个协程中。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run channels.go</span><br><span class="line">ping</span><br></pre></td></tr></table></figure>

<p>默认发送和接收操作是阻塞的、同步的，直到发送方和接收方都就绪。 这个特性允许我们，不使用任何其它的同步操作， 就可以在程序结尾处等待消息 “ping”。</p>
<h1 id="通道缓冲"><a href="#通道缓冲" class="headerlink" title="通道缓冲"></a>通道缓冲</h1><p>默认情况下，通道是 <em>无缓冲</em> 的，这意味着只有对应的接收（<code>&lt;- chan</code>） 通道准备好接收时，才允许进行发送（<code>chan &lt;-</code>）。 <em>有缓冲的通道 (<em>Buffered channels</em>)</em> 允许在没有对应接收者的情况下，缓存一定数量的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里我们 make 了一个字符串通道，最多允许缓存 2 个值。</span></span><br><span class="line">    messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 由于此通道是有缓冲的， 因此我们可以将这些值发送到通道中，而无需并发的接收。</span></span><br><span class="line">    messages &lt;- <span class="string">&quot;buffered&quot;</span></span><br><span class="line">    messages &lt;- <span class="string">&quot;channel&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 然后我们可以正常接收这两个值。</span></span><br><span class="line">    fmt.Println(&lt;-messages)</span><br><span class="line">    fmt.Println(&lt;-messages)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run channel-buffering.go </span><br><span class="line">buffered</span><br><span class="line">channel</span><br></pre></td></tr></table></figure>



<h1 id="通道同步"><a href="#通道同步" class="headerlink" title="通道同步"></a>通道同步</h1><p>我们可以使用通道来同步协程之间的执行状态。 这有一个例子，使用阻塞接收的方式，实现了等待另一个协程完成。 如果需要等待多个协程，<strong><a href="https://gobyexample-cn.github.io/waitgroups">WaitGroup</a></strong> 是一个更好的选择。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将要在协程中运行这个函数。 done 通道将被用于通知其他协程这个函数已经完成工作。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;working...&quot;</span>)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;done...&quot;</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 发送一个值来通知我们已经完工啦。</span></span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 运行一个 worker 协程，并给予用于通知的通道。</span></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> worker(done)</span><br><span class="line">	<span class="comment">// 程序将一直阻塞，直至收到 worker 使用通道发送的通知。</span></span><br><span class="line">    &lt;-done <span class="comment">// 如果你把 &lt;- done 这行代码从程序中移除， 程序甚至可能在 worker 开始运行前就结束了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run channel-synchronization.go</span><br><span class="line">working...</span><br><span class="line"><span class="keyword">done</span>...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Firewall 学习笔记</title>
    <url>/2022/linux_firewall/</url>
    <content><![CDATA[<h1 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h1><h2 id="netfilter-和-iptables"><a href="#netfilter-和-iptables" class="headerlink" title="netfilter 和 iptables"></a>netfilter 和 iptables</h2><ul>
<li>netfilter：内核态，即不以文件的形式存在的防火墙。</li>
<li>iptables：用户态，在<code>/sbin/iptables</code>存在的防火墙。</li>
</ul>
<h2 id="防火墙的分类"><a href="#防火墙的分类" class="headerlink" title="防火墙的分类"></a>防火墙的分类</h2><p>按保护范围划分:</p>
<ul>
<li>主机防火墙:服务范围为当前一台主机</li>
<li>网络防火墙:服务范围为防火墙一侧的局域网</li>
</ul>
<h2 id="4-Tables"><a href="#4-Tables" class="headerlink" title="4 Tables"></a>4 Tables</h2><ul>
<li>filter</li>
<li>nat</li>
<li>mangle</li>
<li>raw</li>
<li>security</li>
</ul>
<h2 id="5-Chains"><a href="#5-Chains" class="headerlink" title="5 Chains"></a>5 Chains</h2><ul>
<li>PREROUTING</li>
<li>INPUT</li>
<li>FORWARD</li>
<li>OUTPUT</li>
<li>POSTROUTING</li>
</ul>
<span id="more"></span>

<h2 id="Targets"><a href="#Targets" class="headerlink" title="Targets"></a>Targets</h2><p>A  firewall rule specifies criteria for a packet and a target.  If the packet does not match, the next rule in the chain is examined; if it does match, then the next rule is specified by the value of the target, which can be the name of a user-defined chain, one of the  targets  described in <em>iptables-extensions(8)</em>, or one of the special values <code>ACCEPT</code>, <code>DROP</code> or <code>RETURN</code>. </p>
<ul>
<li><code>ACCEPT</code>  : means to let the packet through. </li>
<li><code>DROP</code> : means to drop the packet on the floor. </li>
<li><code>RETURN</code> : means stop traversing this chain and resume at the next rule in the previous (calling) chain.  If the end of a built-in chain is reached or a rule in  a  built-in  chain  with  target  <code>RETURN</code>  is matched, the target specified by the chain policy determines the fate of the packet.<code>RETURN</code>代表停止遍历当前链，然后返回之前的链（调用当前链的链），并继续匹配之前链中的下一条规则。如果到达了内建链的底部，或者某条内建链中目标（target）为<code>RETURN</code>的规则被匹配，那么这条内建链的默认策略 (policy)决定了当前数据包的归宿。</li>
</ul>
<h1 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h1><p>基于zone概念：</p>
<ol>
<li>源IP或源网段关联到zone；</li>
<li>接口（网卡）关联到zone；</li>
<li>没有被源IP（源网段）或接口关联的zone所匹配时，关联到default zone；<strong>所以，default zone中不要轻易放置服务！</strong></li>
</ol>
<h2 id="查看默认zone"><a href="#查看默认zone" class="headerlink" title="查看默认zone"></a>查看默认zone</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --get-default-zone</span></span><br><span class="line">public</span><br></pre></td></tr></table></figure>

<h2 id="设置默认zone"><a href="#设置默认zone" class="headerlink" title="设置默认zone"></a>设置默认zone</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --set-default-zone=home</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --get-default-zone</span></span><br><span class="line">home</span><br></pre></td></tr></table></figure>

<h2 id="将源网段关联到zone"><a href="#将源网段关联到zone" class="headerlink" title="将源网段关联到zone"></a>将源网段关联到zone</h2><p>相关命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --help | grep source</span></span><br><span class="line">  --get-zone-of-source=&lt;<span class="built_in">source</span>&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;</span><br><span class="line">                       Print name of the zone the <span class="built_in">source</span> is bound to [P]</span><br><span class="line">  --service=&lt;service&gt; --add-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Add a new <span class="built_in">source</span> port to service [P only]</span><br><span class="line">  --service=&lt;service&gt; --remove-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Remove a <span class="built_in">source</span> port from service [P only]</span><br><span class="line">  --service=&lt;service&gt; --query-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Return whether the <span class="built_in">source</span> port has been added <span class="keyword">for</span> service [P only]</span><br><span class="line">  --service=&lt;service&gt; --get-source-ports</span><br><span class="line">                       List <span class="built_in">source</span> ports of service [P only]</span><br><span class="line">  --list-source-ports  List <span class="built_in">source</span> ports added [P] [Z] [O]</span><br><span class="line">  --add-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Add the <span class="built_in">source</span> port [P] [Z] [O] [T]</span><br><span class="line">  --remove-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Remove the <span class="built_in">source</span> port [P] [Z] [O]</span><br><span class="line">  --query-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Return whether the <span class="built_in">source</span> port has been added [P] [Z] [O]</span><br><span class="line">                       sources <span class="keyword">in</span> a zone [P] [Z] [T]</span><br><span class="line">                       sources <span class="keyword">in</span> a zone [P] [Z]</span><br><span class="line">                       and sources has been enabled <span class="keyword">for</span> a zone [P] [Z]</span><br><span class="line">  --list-sources       List sources that are bound to a zone [P] [Z]</span><br><span class="line">  --add-source=&lt;<span class="built_in">source</span>&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;</span><br><span class="line">                       Bind the <span class="built_in">source</span> to a zone [P] [Z]</span><br><span class="line">  --change-source=&lt;<span class="built_in">source</span>&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;</span><br><span class="line">                       Change zone the <span class="built_in">source</span> is bound to [Z]</span><br><span class="line">  --query-source=&lt;<span class="built_in">source</span>&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;</span><br><span class="line">                       Query whether the <span class="built_in">source</span> is bound to a zone [P] [Z]</span><br><span class="line">  --remove-source=&lt;<span class="built_in">source</span>&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;</span><br><span class="line">                       Remove binding of the <span class="built_in">source</span> from a zone [P] [Z]</span><br></pre></td></tr></table></figure>

<p>将源网段192.168.16.0&#x2F;24关联到zone home：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --permanent --add-source=192.168.16.0/24 --zone=home</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<p>查看配置没有生效，需要重新加载配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-all --zone=home</span></span><br><span class="line">home (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: ens160</span><br><span class="line">  sources: </span><br><span class="line">  services: cockpit dhcpv6-client mdns samba-client ssh</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  forward: no</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br></pre></td></tr></table></figure>

<p>重新加载配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<p>再次查看zone配置，发现配置已生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-all --zone=home</span></span><br><span class="line">home (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: ens160</span><br><span class="line">  sources: 192.168.16.0/24</span><br><span class="line">  services: cockpit dhcpv6-client mdns samba-client ssh</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  forward: no</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br></pre></td></tr></table></figure>

<p>查询某个网段是否被添加到某个zone：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --query-source=192.168.16.0/24 --zone=home</span></span><br><span class="line"><span class="built_in">yes</span></span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --query-source=192.168.1.0/24 --zone=home</span></span><br><span class="line">no</span><br></pre></td></tr></table></figure>

<p>将某个zone中的网段切换到另一个zone中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --change-source=192.168.16.0/24 --zone=public --permanent</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-all --zone=public</span></span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: 192.168.16.0/24</span><br><span class="line">  services: cockpit dhcpv6-client ssh</span><br><span class="line">  ports: 8080/tcp 3306/tcp 8090/tcp 8001/tcp 8002/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  forward: no</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --query-source=192.168.16.0/24 --zone=public</span></span><br><span class="line"><span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>从一个zone中移除关联的网段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --remove-source=192.168.16.0/24 --zone=public --permanent</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-all --zone=public</span></span><br><span class="line">public</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: cockpit dhcpv6-client ssh</span><br><span class="line">  ports: 8080/tcp 3306/tcp 8090/tcp 8001/tcp 8002/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  forward: no</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-sources --zone=public</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="将接口（网卡）关联到zone"><a href="#将接口（网卡）关联到zone" class="headerlink" title="将接口（网卡）关联到zone"></a>将接口（网卡）关联到zone</h2><p>相关命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd -h | grep interface</span></span><br><span class="line">  --get-default-zone   Print default zone <span class="keyword">for</span> connections and interfaces</span><br><span class="line">  --get-zone-of-interface=&lt;interface&gt;</span><br><span class="line">                       Print name of the zone the interface is bound to [P]</span><br><span class="line">  --add-forward        Enable forwarding of packets between interfaces and</span><br><span class="line">  --remove-forward     Disable forwarding of packets between interfaces and</span><br><span class="line">  --query-forward      Return whether forwarding of packets between interfaces</span><br><span class="line">  --list-interfaces    List interfaces that are bound to a zone [P] [Z]</span><br><span class="line">  --add-interface=&lt;interface&gt;</span><br><span class="line">                       Bind the &lt;interface&gt; to a zone [P] [Z]</span><br><span class="line">  --change-interface=&lt;interface&gt;</span><br><span class="line">                       Change zone the &lt;interface&gt; is bound to [P] [Z]</span><br><span class="line">  --query-interface=&lt;interface&gt;</span><br><span class="line">                       Query whether &lt;interface&gt; is bound to a zone [P] [Z]</span><br><span class="line">  --remove-interface=&lt;interface&gt;</span><br><span class="line">                       Remove binding of &lt;interface&gt; from a zone [P] [Z]</span><br></pre></td></tr></table></figure>

<p>查看zone所绑定的接口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-all --zone=public</span></span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: ens160</span><br><span class="line">  sources: </span><br><span class="line">  services: cockpit dhcpv6-client ssh</span><br><span class="line">  ports: 8080/tcp 3306/tcp 8090/tcp 8001/tcp 8002/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  forward: no</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-interfaces --zone=public</span></span><br><span class="line">ens160</span><br></pre></td></tr></table></figure>

<p>将接口添加进zone：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --add-interface=ens160 --zone=public --permanent</span></span><br><span class="line">Warning: ZONE_ALREADY_SET: <span class="string">&#x27;ens160&#x27;</span> already bound to <span class="string">&#x27;public&#x27;</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-all --zone=public</span></span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: ens160</span><br><span class="line">  sources: </span><br><span class="line">  services: cockpit dhcpv6-client ssh</span><br><span class="line">  ports: 8080/tcp 3306/tcp 8090/tcp 8001/tcp 8002/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  forward: no</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-interfaces --zone=public</span></span><br><span class="line">ens160</span><br></pre></td></tr></table></figure>

<p>将接口从zone中删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --remove-interface=ens160 --zone=public --permanent</span></span><br><span class="line">The interface is under control of NetworkManager and already bound to the default zone</span><br><span class="line">The interface is under control of NetworkManager, setting zone to default.</span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-interface --zone=public</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-all --zone=public</span></span><br><span class="line">public</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: cockpit dhcpv6-client ssh</span><br><span class="line">  ports: 8080/tcp 3306/tcp 8090/tcp 8001/tcp 8002/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  forward: no</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br></pre></td></tr></table></figure>

<p>注意：当将一个接口（网卡）从一个zone中移除时，NetworkManager服务会自动将其添加进default zone。下例中，将接口<code>ens160</code>从zone public中移除，但default zone正好就是zone public，所以NetworkManager又将接口<code>ens160</code>绑定回了default zone即 zone public：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --get-default-zone</span></span><br><span class="line">public</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --remove-interface=ens160 --zone=public --permanent</span></span><br><span class="line">The interface is under control of NetworkManager and already bound to the default zone</span><br><span class="line">The interface is under control of NetworkManager, setting zone to default.</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><p>firewalld基本规则只能以白名单方式添加端口或服务。</p>
<h3 id="添加服务"><a href="#添加服务" class="headerlink" title="添加服务"></a>添加服务</h3><p>相关命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd -h | grep service</span></span><br><span class="line">  --get-services       Print predefined services [P]</span><br><span class="line">  --new-service=&lt;service&gt;</span><br><span class="line">                       Add a new service [P only]</span><br><span class="line">  --new-service-from-file=&lt;filename&gt; [--name=&lt;service&gt;]</span><br><span class="line">                       Add a new service from file with optional name [P only]</span><br><span class="line">  --delete-service=&lt;service&gt;</span><br><span class="line">                       Delete an existing service [P only]</span><br><span class="line">  --load-service-defaults=&lt;service&gt;</span><br><span class="line">  --info-service=&lt;service&gt;</span><br><span class="line">                       Print information about a service</span><br><span class="line">  --path-service=&lt;service&gt;</span><br><span class="line">                       Print file path of a service [P only]</span><br><span class="line">  --service=&lt;service&gt; --set-description=&lt;description&gt;</span><br><span class="line">                       Set new description to service [P only]</span><br><span class="line">  --service=&lt;service&gt; --get-description</span><br><span class="line">                       Print description <span class="keyword">for</span> service [P only]</span><br><span class="line">  --service=&lt;service&gt; --set-short=&lt;description&gt;</span><br><span class="line">                       Set new short description to service [P only]</span><br><span class="line">  --service=&lt;service&gt; --get-short</span><br><span class="line">                       Print short description <span class="keyword">for</span> service [P only]</span><br><span class="line">  --service=&lt;service&gt; --add-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Add a new port to service [P only]</span><br><span class="line">  --service=&lt;service&gt; --remove-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Remove a port from service [P only]</span><br><span class="line">  --service=&lt;service&gt; --query-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Return whether the port has been added <span class="keyword">for</span> service [P only]</span><br><span class="line">  --service=&lt;service&gt; --get-ports</span><br><span class="line">                       List ports of service [P only]</span><br><span class="line">  --service=&lt;service&gt; --add-protocol=&lt;protocol&gt;</span><br><span class="line">                       Add a new protocol to service [P only]</span><br><span class="line">  --service=&lt;service&gt; --remove-protocol=&lt;protocol&gt;</span><br><span class="line">                       Remove a protocol from service [P only]</span><br><span class="line">  --service=&lt;service&gt; --query-protocol=&lt;protocol&gt;</span><br><span class="line">                       Return whether the protocol has been added <span class="keyword">for</span> service [P only]</span><br><span class="line">  --service=&lt;service&gt; --get-protocols</span><br><span class="line">                       List protocols of service [P only]</span><br><span class="line">  --service=&lt;service&gt; --add-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Add a new <span class="built_in">source</span> port to service [P only]</span><br><span class="line">  --service=&lt;service&gt; --remove-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Remove a <span class="built_in">source</span> port from service [P only]</span><br><span class="line">  --service=&lt;service&gt; --query-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Return whether the <span class="built_in">source</span> port has been added <span class="keyword">for</span> service [P only]</span><br><span class="line">  --service=&lt;service&gt; --get-source-ports</span><br><span class="line">                       List <span class="built_in">source</span> ports of service [P only]</span><br><span class="line">  --service=&lt;service&gt; --add-helper=&lt;helper&gt;</span><br><span class="line">                       Add a new helper to service [P only]</span><br><span class="line">  --service=&lt;service&gt; --remove-helper=&lt;helper&gt;</span><br><span class="line">                       Remove a helper from service [P only]</span><br><span class="line">  --service=&lt;service&gt; --query-helper=&lt;helper&gt;</span><br><span class="line">                       Return whether the helper has been added <span class="keyword">for</span> service [P only]</span><br><span class="line">  --service=&lt;service&gt; --get-service-helpers</span><br><span class="line">                       List helpers of service [P only]</span><br><span class="line">  --service=&lt;service&gt; --set-destination=&lt;ipv&gt;:&lt;address&gt;[/&lt;mask&gt;]</span><br><span class="line">                       Set destination <span class="keyword">for</span> ipv to address <span class="keyword">in</span> service [P only]</span><br><span class="line">  --service=&lt;service&gt; --remove-destination=&lt;ipv&gt;</span><br><span class="line">                       Disable destination <span class="keyword">for</span> ipv i service [P only]</span><br><span class="line">  --service=&lt;service&gt; --query-destination=&lt;ipv&gt;:&lt;address&gt;[/&lt;mask&gt;]</span><br><span class="line">                       Return whether destination ipv is <span class="built_in">set</span> <span class="keyword">for</span> service [P only]</span><br><span class="line">  --service=&lt;service&gt; --get-destinations</span><br><span class="line">                       List destinations <span class="keyword">in</span> service [P only]</span><br><span class="line">  --service=&lt;service&gt; --add-include=&lt;service&gt;</span><br><span class="line">                       Add a new include to service [P only]</span><br><span class="line">  --service=&lt;service&gt; --remove-include=&lt;service&gt;</span><br><span class="line">                       Remove a include from service [P only]</span><br><span class="line">  --service=&lt;service&gt; --query-include=&lt;service&gt;</span><br><span class="line">                       Return whether the include has been added <span class="keyword">for</span> service [P only]</span><br><span class="line">  --service=&lt;service&gt; --get-includes</span><br><span class="line">                       List includes of service [P only]</span><br><span class="line">  --list-services      List services added [P] [Z]</span><br><span class="line">  --add-service=&lt;service&gt;</span><br><span class="line">                       Add a service [P] [Z] [O] [T]</span><br><span class="line">  --remove-service=&lt;service&gt;</span><br><span class="line">                       Remove a service [P] [Z] [O]</span><br><span class="line">  --query-service=&lt;service&gt;</span><br><span class="line">                       Return whether service has been added [P] [Z] [O]</span><br></pre></td></tr></table></figure>

<p>添加服务到指定zone：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-all --zone=public</span></span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: ens160</span><br><span class="line">  sources: </span><br><span class="line">  services: cockpit dhcpv6-client ssh</span><br><span class="line">  ports: 8080/tcp 3306/tcp 8090/tcp 8001/tcp 8002/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  forward: no</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --add-service=http --zone=public --permanent</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-all --zone=public</span></span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: ens160</span><br><span class="line">  sources: </span><br><span class="line">  services: cockpit dhcpv6-client http ssh</span><br><span class="line">  ports: 8080/tcp 3306/tcp 8090/tcp 8001/tcp 8002/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  forward: no</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br></pre></td></tr></table></figure>

<p>将http服务从zone public中移除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --permanent --remove-service=http --zone=public</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-services --zone=public</span></span><br><span class="line">cockpit dhcpv6-client ssh</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-all --zone=public</span></span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: ens160</span><br><span class="line">  sources: </span><br><span class="line">  services: cockpit dhcpv6-client ssh</span><br><span class="line">  ports: 8080/tcp 3306/tcp 8090/tcp 8001/tcp 8002/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  forward: no</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br></pre></td></tr></table></figure>



<h3 id="添加端口"><a href="#添加端口" class="headerlink" title="添加端口"></a>添加端口</h3><p>相关命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd -h | grep port</span></span><br><span class="line">  --get-ipset-types    Print the supported ipset types</span><br><span class="line">  --service=&lt;service&gt; --add-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Add a new port to service [P only]</span><br><span class="line">  --service=&lt;service&gt; --remove-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Remove a port from service [P only]</span><br><span class="line">  --service=&lt;service&gt; --query-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Return whether the port has been added <span class="keyword">for</span> service [P only]</span><br><span class="line">  --service=&lt;service&gt; --get-ports</span><br><span class="line">                       List ports of service [P only]</span><br><span class="line">  --service=&lt;service&gt; --add-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Add a new <span class="built_in">source</span> port to service [P only]</span><br><span class="line">  --service=&lt;service&gt; --remove-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Remove a <span class="built_in">source</span> port from service [P only]</span><br><span class="line">  --service=&lt;service&gt; --query-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Return whether the <span class="built_in">source</span> port has been added <span class="keyword">for</span> service [P only]</span><br><span class="line">  --service=&lt;service&gt; --get-source-ports</span><br><span class="line">                       List <span class="built_in">source</span> ports of service [P only]</span><br><span class="line">  --list-ports         List ports added [P] [Z] [O]</span><br><span class="line">  --add-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Add the port [P] [Z] [O] [T]</span><br><span class="line">  --remove-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Remove the port [P] [Z] [O]</span><br><span class="line">  --query-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Return whether the port has been added [P] [Z] [O]</span><br><span class="line">  --list-source-ports  List <span class="built_in">source</span> ports added [P] [Z] [O]</span><br><span class="line">  --add-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Add the <span class="built_in">source</span> port [P] [Z] [O] [T]</span><br><span class="line">  --remove-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Remove the <span class="built_in">source</span> port [P] [Z] [O]</span><br><span class="line">  --query-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Return whether the <span class="built_in">source</span> port has been added [P] [Z] [O]</span><br><span class="line">  --list-forward-ports List IPv4 forward ports added [P] [Z] [O]</span><br><span class="line">  --add-forward-port=port=&lt;portid&gt;[-&lt;portid&gt;]:proto=&lt;protocol&gt;[:toport=&lt;portid&gt;[-&lt;portid&gt;]][:toaddr=&lt;address&gt;[/&lt;mask&gt;]]</span><br><span class="line">                       Add the IPv4 forward port [P] [Z] [O] [T]</span><br><span class="line">  --remove-forward-port=port=&lt;portid&gt;[-&lt;portid&gt;]:proto=&lt;protocol&gt;[:toport=&lt;portid&gt;[-&lt;portid&gt;]][:toaddr=&lt;address&gt;[/&lt;mask&gt;]]</span><br><span class="line">                       Remove the IPv4 forward port [P] [Z] [O]</span><br><span class="line">  --query-forward-port=port=&lt;portid&gt;[-&lt;portid&gt;]:proto=&lt;protocol&gt;[:toport=&lt;portid&gt;[-&lt;portid&gt;]][:toaddr=&lt;address&gt;[/&lt;mask&gt;]]</span><br><span class="line">                       Return whether the IPv4 forward port has been added [P] [Z] [O]</span><br><span class="line">  --helper=&lt;helper&gt; --add-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Add a new port to helper [P only]</span><br><span class="line">  --helper=&lt;helper&gt; --remove-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Remove a port from helper [P only]</span><br><span class="line">  --helper=&lt;helper&gt; --query-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</span><br><span class="line">                       Return whether the port has been added <span class="keyword">for</span> helper [P only]</span><br><span class="line">  --helper=&lt;helper&gt; --get-ports</span><br><span class="line">                       List ports of helper [P only]</span><br></pre></td></tr></table></figure>

<p>添加tcp端口8888到zone public：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-all --zone=public</span></span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: ens160</span><br><span class="line">  sources: </span><br><span class="line">  services: cockpit dhcpv6-client ssh</span><br><span class="line">  ports: 8080/tcp 3306/tcp 8090/tcp 8001/tcp 8002/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  forward: no</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --permanent --add-port=8888/tcp --zone=public</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-all --zone=public</span></span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: ens160</span><br><span class="line">  sources: </span><br><span class="line">  services: cockpit dhcpv6-client ssh</span><br><span class="line">  ports: 8080/tcp 3306/tcp 8090/tcp 8001/tcp 8002/tcp 8888/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  forward: no</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br></pre></td></tr></table></figure>

<p>将tcp端口8888从zone public中移除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --permanent --remove-port=8888/tcp --zone=public</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-ports --zone=public</span></span><br><span class="line">3306/tcp 8001/tcp 8002/tcp 8080/tcp 8090/tcp</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --list-all --zone=public</span></span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: ens160</span><br><span class="line">  sources: </span><br><span class="line">  services: cockpit dhcpv6-client ssh</span><br><span class="line">  ports: 8080/tcp 3306/tcp 8090/tcp 8001/tcp 8002/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  forward: no</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br></pre></td></tr></table></figure>

<h2 id="富规则（Rich-Rules）"><a href="#富规则（Rich-Rules）" class="headerlink" title="富规则（Rich Rules）"></a>富规则（Rich Rules）</h2><p>使用<code>--add-rich-rule</code>参数添加富规则。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>iptables</tag>
        <tag>firewalld</tag>
        <tag>nftables</tag>
      </tags>
  </entry>
  <entry>
    <title>《Docker 从入门到实践》学习笔记</title>
    <url>/2022/docker_practice/</url>
    <content><![CDATA[<h1 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h1><p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.google.cn/">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">OverlayFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p>
<p><img src="/2022/docker_practice/docker-on-linux-16488874880822.png" alt="Docker在Linux中的架构"></p>
<h2 id="传统虚拟机-VS-Docker"><a href="#传统虚拟机-VS-Docker" class="headerlink" title="传统虚拟机 VS Docker"></a>传统虚拟机 VS Docker</h2><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><img src="/2022/docker_practice/vm.png" alt="传统虚拟机"></p>
<p><img src="/2022/docker_practice/docker.png" alt="Docker"></p>
<span id="more"></span>

<h1 id="Docker-的三个基本概念"><a href="#Docker-的三个基本概念" class="headerlink" title="Docker 的三个基本概念"></a>Docker 的三个基本概念</h1><h2 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（<code>Image</code>）</h2><p><strong>Docker 镜像</strong> 是一个特殊的root文件系统，比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统 (RootFS)。镜像除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。<strong>镜像 <em>不包含</em> 任何动态数据，其内容在构建之后也不会被改变。</strong></p>
<h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><ul>
<li>镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</li>
<li>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</li>
<li>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</li>
</ul>
<p><img src="/2022/docker_practice/image-20220412153434717.png"></p>
<h2 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（<code>Container</code>）</h2><ul>
<li>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统 (RootFS)、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。</li>
<li>镜像也使用分层存储。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，<strong>任何保存于容器存储层的信息都会随容器删除而丢失。</strong></li>
<li><strong>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。</strong> 所有的文件写入操作，都应该使用 <a href="">数据卷（Volume）</a>、或者 <a href="">绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</li>
</ul>
<h2 id="仓库（Repository）"><a href="#仓库（Repository）" class="headerlink" title="仓库（Repository）"></a>仓库（<code>Repository</code>）</h2><p><a href="">Docker Registry</a> 是一个集中的存储、分发镜像的服务。</p>
<p>一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>
<h3 id="公有-Docker-Registry"><a href="#公有-Docker-Registry" class="headerlink" title="公有 Docker Registry"></a>公有 Docker Registry</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<h3 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。</p>
<h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p>安装Docker的3种方式：</p>
<ul>
<li>使用包管理器软件源安装，如<code>yum</code>、<code>dnf</code>、<code>apt</code>等；</li>
<li>下载预编译二进制安装包，如rpm，deb等；</li>
<li>使用便捷脚本（convenience scripts）安装Docker（不建议在生产环境部署时使用此方法）；</li>
</ul>
<h2 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h2><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。<br>建立 docker 组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure>
<p>将当前用户加入 docker 组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>
<p>退出当前终端并重新登录，进行如下测试。</p>
<h2 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h2><p>在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.baidubce.com&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>之后重新启动服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>执行 <code>docker info</code>，如果从结果中看到了如下内容，说明配置成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker info</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https://hub-mirror.c.163.com/</span><br></pre></td></tr></table></figure>

<h1 id="Docker-镜像管理"><a href="#Docker-镜像管理" class="headerlink" title="Docker 镜像管理"></a>Docker 镜像管理</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。通过 <code>docker pull --help</code> 命令查看具体选项。其命令格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>

<p>镜像名称的格式：</p>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub(<code>docker.io</code>)。</li>
<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li>
</ul>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">92dc2a97ff99: Pull complete</span><br><span class="line">be13a9d27eb8: Pull complete</span><br><span class="line">c8299583700a: Pull complete</span><br><span class="line">Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span><br><span class="line">docker.io/library/ubuntu:18.04</span><br></pre></td></tr></table></figure>



<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> ubuntu:18.04 bash</span><br><span class="line"></span><br><span class="line">root@e7009c6ce357:/<span class="comment"># cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">&quot;Ubuntu&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;18.04.1 LTS (Bionic Beaver)&quot;</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">&quot;Ubuntu 18.04.1 LTS&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;18.04&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.ubuntu.com/&quot;</span></span><br><span class="line">SUPPORT_URL=<span class="string">&quot;https://help.ubuntu.com/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span></span><br><span class="line">VERSION_CODENAME=bionic</span><br><span class="line">UBUNTU_CODENAME=bionic</span><br></pre></td></tr></table></figure>

<p>使用命令<code>docker run</code> 运行容器，具体格式我们会在 <a href="">容器</a> 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>镜像名:标签</code>：这是指用特定镜像为基础来启动容器，如 <code>ubuntu:18.04</code> 。</li>
<li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
</ul>
<h2 id="列出本地镜像"><a href="#列出本地镜像" class="headerlink" title="列出本地镜像"></a>列出本地镜像</h2><p>查看本地镜像可以使用：</p>
<ul>
<li><code>docker images</code></li>
<li><code>docker image ls</code></li>
</ul>
<p>使用<code>docker image ls --help</code>查看命令帮助：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker image <span class="built_in">ls</span> [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">List images</span><br><span class="line"></span><br><span class="line">Aliases:</span><br><span class="line">  <span class="built_in">ls</span>, list</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             Show all images (default hides intermediate images)</span><br><span class="line">      --digests         Show digests</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-<span class="built_in">print</span> images using a Go template</span><br><span class="line">      --no-trunc        Don<span class="string">&#x27;t truncate output</span></span><br><span class="line"><span class="string">  -q, --quiet           Only show image IDs</span></span><br></pre></td></tr></table></figure>

<p><code>docker image ls</code>默认列出所有顶层镜像，列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis                latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx                latest              05a60462f8ba        5 days ago          181 MB</span><br><span class="line">mongo                3.2                 fe9198c04d62        5 days ago          342 MB</span><br><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br><span class="line">ubuntu               18.04               329ed837d508        3 days ago          63.3MB</span><br><span class="line">ubuntu               bionic              329ed837d508        3 days ago          63.3MB</span><br></pre></td></tr></table></figure>

<h3 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h3><p><code>docker image ls</code>列出的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:18.04</code> 镜像大小，在这里是 <code>63.3MB</code>，但是在 <a href="https://hub.docker.com/layers/ubuntu/library/ubuntu/bionic/images/sha256-32776cc92b5810ce72e77aca1d949de1f348e1d281d3f00ebcc22a3adcdc9f42?context=explore">Docker Hub</a> 显示的却是 <code>25.47 MB</code>。Docker Hub 中显示的体积是压缩后的体积，而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开后的各层所占空间的总和。</p>
<p><code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<p>镜像、容器、数据卷实际所占用的空间通过 <code>docker system df</code> 或<code>docker system df -v</code>命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker system <span class="built_in">df</span></span><br><span class="line"></span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              24                  0                   1.992GB             1.992GB (100%)</span><br><span class="line">Containers          1                   0                   62.82MB             62.82MB (100%)</span><br><span class="line">Local Volumes       9                   0                   652.2MB             652.2MB (100%)</span><br><span class="line">Build Cache                                                 0B                  0B</span><br></pre></td></tr></table></figure>

<h3 id="虚悬镜像-dangling-image"><a href="#虚悬镜像-dangling-image" class="headerlink" title="虚悬镜像 (dangling image)"></a>虚悬镜像 (dangling image)</h3><p><code>docker pull</code> 和<code>docker build</code> 操作可能导致<strong>虚悬镜像 (dangling image)</strong>。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。</p>
<p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure>

<p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。</p>
<p>这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -f dangling=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure>

<p>一般来说，虚悬镜像已经失去了存在的价值，可以用下面的命令删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image prune</span><br></pre></td></tr></table></figure>

<h3 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h3><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。</p>
<p>默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure>

<p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p>
<h3 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h3><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。</p>
<p>根据仓库名列出镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               329ed837d508        3 days ago          63.3MB</span><br><span class="line">ubuntu              bionic              329ed837d508        3 days ago          63.3MB</span><br></pre></td></tr></table></figure>

<p>列出特定的某个镜像，也就是说指定仓库名和标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> ubuntu:18.04</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               329ed837d508        3 days ago          63.3MB</span><br></pre></td></tr></table></figure>

<p>除此以外，<code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>mongo:3.2</code> 之后建立的镜像，可以用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -f since=mongo:3.2</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx               latest              05a60462f8ba        5 days ago          181 MB</span><br></pre></td></tr></table></figure>

<p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p>
<p>此外，如果镜像构建时，定义了 <code>LABEL</code>，还可以通过 <code>LABEL</code> 来过滤。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -f label=com.example.version=0.1</span><br></pre></td></tr></table></figure>

<h3 id="只显示镜像ID"><a href="#只显示镜像ID" class="headerlink" title="只显示镜像ID"></a>只显示镜像ID</h3><p>使用 <code>-q</code> 参数只显示镜像ID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -q</span><br><span class="line">5f515359c7f8</span><br><span class="line">05a60462f8ba</span><br><span class="line">fe9198c04d62</span><br><span class="line">00285df0df87</span><br><span class="line">329ed837d508</span><br><span class="line">329ed837d508</span><br></pre></td></tr></table></figure>

<p><code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 ID 列表，然后送给另一个 <code>docker</code> 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。</p>
<h3 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h3><p>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 <a href="https://gohugo.io/templates/introduction/">Go 的模板语法</a>。</p>
<p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> --format <span class="string">&quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span></span><br><span class="line">5f515359c7f8: redis</span><br><span class="line">05a60462f8ba: nginx</span><br><span class="line">fe9198c04d62: mongo</span><br><span class="line">00285df0df87: &lt;none&gt;</span><br><span class="line">329ed837d508: ubuntu</span><br><span class="line">329ed837d508: ubuntu</span><br></pre></td></tr></table></figure>

<p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot;</span></span><br><span class="line">IMAGE ID            REPOSITORY          TAG</span><br><span class="line">5f515359c7f8        redis               latest</span><br><span class="line">05a60462f8ba        nginx               latest</span><br><span class="line">fe9198c04d62        mongo               3.2</span><br><span class="line">00285df0df87        &lt;none&gt;              &lt;none&gt;</span><br><span class="line">329ed837d508        ubuntu              18.04</span><br><span class="line">329ed837d508        ubuntu              bionic</span><br></pre></td></tr></table></figure>

<h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>如果要删除本地的镜像，可以使用以下2个命令：</p>
<ul>
<li><p><code>docker rmi</code>命令</p>
</li>
<li><p><code>docker image rm</code> 命令</p>
</li>
</ul>
<p>其格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker rmi [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br><span class="line">$ docker image <span class="built_in">rm</span> [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure>

<h3 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h3><p>比如我们有这么一些镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB</span><br><span class="line">redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB</span><br><span class="line">docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB</span><br><span class="line">nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;镜像&gt;</code> 可以是：</p>
<ul>
<li><code>镜像长 ID</code>：镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。</li>
<li><code>镜像短 ID</code>：<code>docker image ls</code> 默认列出的是短 ID 。通常情况下，镜像ID不需要写完整，只要短ID的前几个字符能唯一确定一个镜像即可。</li>
<li><code>镜像名</code> ：即 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>。</li>
<li><code>镜像摘要</code>：镜像的sha256哈希摘要。</li>
</ul>
<p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，短ID<code>501ad78535f0</code>的前3个字符<code>501</code>就可以唯一确定此镜像，可以执行<code>docker image rm 501</code>删除此镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> 501</span><br><span class="line">Untagged: redis:alpine</span><br><span class="line">Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d</span><br><span class="line">Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7</span><br><span class="line">Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b</span><br><span class="line">Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23</span><br><span class="line">Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa</span><br><span class="line">Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3</span><br><span class="line">Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</span><br></pre></td></tr></table></figure>

<p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> centos</span><br><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span><br><span class="line">Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br><span class="line">Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span><br></pre></td></tr></table></figure>

<p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> --digests</span><br><span class="line">REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE</span><br><span class="line">node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB</span><br><span class="line"></span><br><span class="line">$ docker image <span class="built_in">rm</span> node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br><span class="line">Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image <span class="built_in">rm</span> $(docker image <span class="built_in">ls</span> -q redis)</span><br></pre></td></tr></table></figure>

<p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> $(docker image <span class="built_in">ls</span> -q -f before=mongo:3.2)</span><br></pre></td></tr></table></figure>

<h3 id="镜像的Untagged-和-Deleted"><a href="#镜像的Untagged-和-Deleted" class="headerlink" title="镜像的Untagged 和 Deleted"></a>镜像的Untagged 和 Deleted</h3><p><img src="/2022/docker_practice/image-20220412153434717.png"></p>
<ul>
<li>镜像由多层镜像联合组成，包含对其父镜像、父镜像的父镜像、祖先镜像等直至基础镜像的所有操作的总和。</li>
<li>对基础镜像或已有镜像进行修改，可产生新的顶层镜像。被修改的基础进行或已有镜像就成为新的顶层镜像的父镜像。新产生的顶层镜像会引用其父镜像（同时父镜像也会引用自己的父镜像），并作为一个整体形成一个完整的新镜像。</li>
<li>镜像的唯一标识是其 ID 和摘要。</li>
<li>多个不同镜像可能依赖的“层”完全相同，换句话说，多个依赖（引用）的“层”完全相同的镜像可以是不同镜像，因为它们ID不同。例如，可以使用<code>docker commit</code>将同一个容器进行<code>commit</code>为多个不同镜像，并设置不同标签。</li>
<li>删除镜像时，删除行为分为2个阶段：<code>Untagged</code>和<code>Deleted</code>。首先会对该镜像取消标签 (untag) ，然后再删除 (delete)该镜像。但当该镜像被其他镜像依赖（引用）时，只能先将镜像<code>Untagged</code>，但无法立即<code>Deleted</code>该镜像。直到没有任何层依赖当前镜像时，才会真实的删除当前镜像。</li>
<li>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。</li>
</ul>
<h2 id="由容器创建镜像"><a href="#由容器创建镜像" class="headerlink" title="由容器创建镜像"></a>由容器创建镜像</h2><p>镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器以镜像为基础层，在其基础上加一层可读写的容器存储层。镜像是静态的，容器是动态的。在容器运行过程中，可以动态的修改容器。</p>
<p>使用<code>docker commit</code>命令可以将容器的存储层保存为镜像，即将修改后的容器状态固化为镜像。</p>
<p><code>ocker commit</code> 的语法格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure>

<p>例如，运行ubuntu镜像，创建容器<code>ub</code>，在<code>ub</code>中创建文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost docker]<span class="comment"># docker run -it --name=ub ubuntu bash</span></span><br><span class="line">root@3f67f307e836:/<span class="comment"># touch f1.txt</span></span><br><span class="line">root@3f67f307e836:/<span class="comment"># echo &quot;create file f1.txt&quot; &gt; f1.txt </span></span><br><span class="line">root@3f67f307e836:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>并将修改后的容器<code>ub</code>固化为镜像<code>from-ub:latest</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost docker]<span class="comment"># docker commit -m &#x27;create file f1.txt&#x27; ub from-ub:latest</span></span><br><span class="line">sha256:ccc63c912efae74b3f547a6c0d23f0434fc3215d538f625f09fe4cc5f7d4d7d8</span><br></pre></td></tr></table></figure>

<p>查看本地镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost docker]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">from-ub       latest    ccc63c912efa   12 minutes ago   72.8MB</span><br><span class="line">ubuntu        latest    825d55fb6340   5 days ago       72.8MB</span><br><span class="line">nginx         1.21.6    12766a6745ee   12 days ago      142MB</span><br><span class="line">hello-world   latest    feb5d9fea6a5   6 months ago     13.3kB</span><br></pre></td></tr></table></figure>

<p>使用<code>docker diff</code>检查对容器文件系统中文件或目录的修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost docker]<span class="comment"># docker diff ub</span></span><br><span class="line">C /root</span><br><span class="line">A /root/.bash_history</span><br><span class="line">A /f1.txt</span><br></pre></td></tr></table></figure>

<p>使用<code>docker image history</code>命令查看对镜像的修改历史：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost docker]<span class="comment"># docker image history from-ub:latest</span></span><br><span class="line">IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT</span><br><span class="line">ccc63c912efa   35 seconds ago   bash                                            73B       create file f1.txt</span><br><span class="line">825d55fb6340   5 days ago       /bin/sh -c <span class="comment">#(nop)  CMD [&quot;bash&quot;]                 0B        </span></span><br><span class="line">&lt;missing&gt;      5 days ago       /bin/sh -c <span class="comment">#(nop) ADD file:b83df51ab7caf8a4d…   72.8MB    </span></span><br><span class="line">[root@localhost docker]<span class="comment"># docker image history ubuntu:latest </span></span><br><span class="line">IMAGE          CREATED      CREATED BY                                      SIZE      COMMENT</span><br><span class="line">825d55fb6340   5 days ago   /bin/sh -c <span class="comment">#(nop)  CMD [&quot;bash&quot;]                 0B        </span></span><br><span class="line">&lt;missing&gt;      5 days ago   /bin/sh -c <span class="comment">#(nop) ADD file:b83df51ab7caf8a4d…   72.8MB</span></span><br></pre></td></tr></table></figure>

<h3 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用 docker commit"></a>慎用 <code>docker commit</code></h3><p>由于容器是动态的，在容器运行过程中，容器文件系统中的很多文件都可能被修改过。所以由<code>docker commit</code>生成镜像，可能会有大量的无关内容被添加进来，将会导致镜像极为臃肿。而且对于这些修改，我们是无法确切知道到底是做了哪些修改的。</p>
<h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>使用Dockerfile允许我们以一个镜像作为基础，在其上进行定制。Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，<em><strong>每一条指令构建一层</strong></em>，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>在 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official">Docker Hub</a> 上有非常多的高质量的官方镜像，可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p>
<p>下面以定制 <code>nginx</code> 镜像为例，使用 Dockerfile 来定制镜像<code>mynginx</code>。在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> mynginx</span><br><span class="line">$ <span class="built_in">cd</span> mynginx</span><br><span class="line">$ <span class="built_in">touch</span> Dockerfile</span><br></pre></td></tr></table></figure>

<p>编辑<code>Dockerfile</code>内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>

<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在<code>Dockerfile</code>所在目录中执行<code>docker build</code>命令构建镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM nginx</span><br><span class="line"> ---&gt; e43d811ce2f4</span><br><span class="line">Step 2 : RUN <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 9cdc27646c7b</span><br><span class="line"> ---&gt; 44aa4490ce2c</span><br><span class="line">Removing intermediate container 9cdc27646c7b</span><br><span class="line">Successfully built 44aa4490ce2c</span><br></pre></td></tr></table></figure>

<p>从命令的输出结果可以看到，在 <code>Step 2</code> 中，<code>RUN</code> 指令启动了一个中间容器 <code>9cdc27646c7b</code>，执行了所要求的命令，随后删除了所用到的这个中间容器 <code>9cdc27646c7b</code>，并最后提交了这一层 <code>44aa4490ce2c</code>。</p>
<h3 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h3><p>Docker 是基于C&#x2F;S架构设计的，分为 Docker 引擎（也就是服务端守护进程）和客户端工具。表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。</p>
<p>刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定 <em><strong>上下文的目录</strong></em>，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>
<p>因此，类似<code>COPY</code> 这类指令中的 <em><strong>源文件的路径</strong></em> 都是<em><strong>相对路径</strong></em>，引用的是打包上传后的上下文目录。 所以<code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 是无法使用的，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。</p>
<p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br></pre></td></tr></table></figure>

<p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p>
<h3 id="docker-build的其他构建方式"><a href="#docker-build的其他构建方式" class="headerlink" title="docker build的其他构建方式"></a><code>docker build</code>的其他构建方式</h3><h4 id="由URL构建"><a href="#由URL构建" class="headerlink" title="由URL构建"></a>由URL构建</h4><p><code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $env:DOCKER_BUILDKIT=0</span></span><br><span class="line"><span class="comment"># export DOCKER_BUILDKIT=0</span></span><br><span class="line"></span><br><span class="line">$ docker build -t hello-world https://github.com/docker-library/hello-world.git<span class="comment">#master:amd64/hello-world</span></span><br><span class="line"></span><br><span class="line">Step 1/3 : FROM scratch</span><br><span class="line"> ---&gt;</span><br><span class="line">Step 2/3 : COPY hello /</span><br><span class="line"> ---&gt; ac779757d46e</span><br><span class="line">Step 3/3 : CMD [<span class="string">&quot;/hello&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> d2a513a760ed</span><br><span class="line">Removing intermediate container d2a513a760ed</span><br><span class="line"> ---&gt; 038ad4142d2b</span><br><span class="line">Successfully built 038ad4142d2b</span><br></pre></td></tr></table></figure>

<p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="由标准输入构建"><a href="#由标准输入构建" class="headerlink" title="由标准输入构建"></a>由标准输入构建</h4><p>从标准输入中读取 Dockerfile 进行构建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> Dockerfile | docker build -</span><br></pre></td></tr></table></figure>

<p>或者，从标准输入中读取上下文压缩包进行构建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</strong></p>
<h2 id="Dockerfile指令详解"><a href="#Dockerfile指令详解" class="headerlink" title="Dockerfile指令详解"></a><code>Dockerfile</code>指令详解</h2><h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a><code>FROM</code> 指定基础镜像</h3><p> <code>FROM</code> 指定以一个镜像为 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第1条指令。</p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a><code>RUN</code> 执行命令</h3><p><code>RUN</code>用来执行命令行命令。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有2种：</p>
<ul>
<li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。</li>
<li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<p>Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。<strong>每一个 <code>RUN</code> 的行为会创建一层镜像。而下面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且产生非常臃肿、非常多层的镜像。</strong></p>
<blockquote>
<p><strong>注意：Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</strong></p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y gcc libc6-dev make wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure>

<p>上面写法应改为下面这样：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x; buildDeps=<span class="string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> redis.tar.gz \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -r /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br></pre></td></tr></table></figure>

<p>这里没有使用很多个 <code>RUN</code>指令，而是仅仅通过一个 <code>RUN</code> 指令，使用 <code>&amp;&amp;</code> 将各个命令串联起来，并使用<code>\</code>将行尾换行符转义。从而将之前的 7 层镜像，简化为了 1 层。</p>
<p>可以看到，为了尽可能减少镜像体积，避免构建出臃肿的镜像；这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。</p>
<h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a><code>COPY</code> 复制文件</h3><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件&#x2F;目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。</p>
<p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure>

<p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match"><code>filepath.Match</code></a> 规则，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>

<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>**使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。**比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">COPY --<span class="built_in">chown</span>=55:mygroup files* /mydir/</span><br><span class="line">COPY --<span class="built_in">chown</span>=bin files* /mydir/</span><br><span class="line">COPY --<span class="built_in">chown</span>=1 files* /mydir/</span><br><span class="line">COPY --<span class="built_in">chown</span>=10:11 files* /mydir/</span><br></pre></td></tr></table></figure>

<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a><code>ADD</code> 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p>
<p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>。</p>
<p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p>
<p>在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，应遵循 Docker 官方的 <a href="">Dockerfile 最佳实践文档</a> 中提出的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ADD --<span class="built_in">chown</span>=55:mygroup files* /mydir/</span><br><span class="line">ADD --<span class="built_in">chown</span>=bin files* /mydir/</span><br><span class="line">ADD --<span class="built_in">chown</span>=1 files* /mydir/</span><br><span class="line">ADD --<span class="built_in">chown</span>=10:11 files* /mydir/</span><br></pre></td></tr></table></figure>

<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a><code>CMD</code> 容器启动命令</h3><p><code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。</p>
<p><code>CMD</code> 指令的格式：</p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p>
<p>Docker 不是虚拟机，<strong>容器中的应用都应该以前台执行</strong>，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p>
<p><strong>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</strong></p>
<p>一些初学者将 <code>CMD</code> 写为：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> service nginx start</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a><code>ENTRYPOINT</code> 入口点</h3><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p>
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; <span class="string">&quot;&lt;CMD&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="场景1：让镜像变成像命令一样使用"><a href="#场景1：让镜像变成像命令一样使用" class="headerlink" title="场景1：让镜像变成像命令一样使用"></a>场景1：让镜像变成像命令一样使用</h4><p>假设我们要构建一个得知自己当前公网 IP 的镜像。</p>
<h5 id="（1）使用CMD来实现："><a href="#（1）使用CMD来实现：" class="headerlink" title="（1）使用CMD来实现："></a>（1）使用<code>CMD</code>来实现：</h5><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>docker build -t myip .</code> 来构建镜像，然后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure>

<p>假如我们修改镜像执行curl的参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run myip -i</span><br><span class="line">docker: Error response from daemon: invalid header field value <span class="string">&quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in <span class="variable">$PATH</span>\&quot;\n&quot;</span>.</span><br></pre></td></tr></table></figure>

<p>跟在镜像名后面的是 <code>command</code>，运行时会替换 Dockerfile中<code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了一个新的 <code>CMD</code>指令。自然是找不到<code>-i</code>这个命令的。</p>
<p>如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run myip curl -s http://myip.ipip.net -i</span><br></pre></td></tr></table></figure>



<h5 id="（2）使用ENTRYPOINT来实现："><a href="#（2）使用ENTRYPOINT来实现：" class="headerlink" title="（2）使用ENTRYPOINT来实现："></a>（2）使用<code>ENTRYPOINT</code>来实现：</h5><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>直接使用 <code>docker run myip -i</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br><span class="line"></span><br><span class="line">$ docker run myip -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.8.0</span><br><span class="line">Date: Tue, 22 Nov 2016 05:12:40 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP/5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2</span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure>

<p>当存在 <code>ENTRYPOINT</code> 时，<code>CMD</code> 的内容将会作为参数传给（追加给） <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl -s http://myip.ipip.net</code>，从而达到了我们预期的效果。</p>
<h4 id="场景2：应用运行前的准备工作"><a href="#场景2：应用运行前的准备工作" class="headerlink" title="场景2：应用运行前的准备工作"></a>场景2：应用运行前的准备工作</h4><p>有时候，启动容器（启动容器就是启动主进程）前，需要一些准备工作。比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。</p>
<p>这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM alpine:3.4</span><br><span class="line">...</span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis</span><br><span class="line">...</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;docker-entrypoint.sh&quot;</span>]</span><br><span class="line"></span><br><span class="line">EXPOSE 6379</span><br><span class="line">CMD [ <span class="string">&quot;redis-server&quot;</span> ]</span><br></pre></td></tr></table></figure>

<p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">	find . \! -user redis -<span class="built_in">exec</span> <span class="built_in">chown</span> redis <span class="string">&#x27;&#123;&#125;&#x27;</span> +</span><br><span class="line">	<span class="built_in">exec</span> gosu redis <span class="string">&quot;<span class="variable">$0</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it redis <span class="built_in">id</span></span><br><span class="line">uid=0(root) gid=0(root) <span class="built_in">groups</span>=0(root)</span><br></pre></td></tr></table></figure>

<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a><code>ENV</code> 设置环境变量</h3><p><code>ENV</code> 指令设置环境变量，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<p>格式：</p>
<ul>
<li><p><code>ENV &lt;key&gt; &lt;value&gt;</code></p>
</li>
<li><p><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></p>
</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> VERSION=<span class="number">1.0</span> DEBUG=on \</span><br><span class="line">    NAME=<span class="string">&quot;Happy Feet&quot;</span></span><br></pre></td></tr></table></figure>

<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; grep <span class="string">&quot; node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$&quot;</span> SHASUMS256.txt | <span class="built_in">sha256sum</span> -c - \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; tar -xJf <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> -C /usr/local --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> SHASUMS256.txt.asc SHASUMS256.txt \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">ln</span> -s /usr/local/bin/node /usr/local/bin/nodejs</span></span><br></pre></td></tr></table></figure>
<p>在这里先定义了环境变量 NODE_VERSION，其后的 RUN 这层里，多次使用 $NODE_VERSION 来进行操作定制。</p>
<p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。</p>
<h3 id="ARG-构建时环境变量"><a href="#ARG-构建时环境变量" class="headerlink" title="ARG 构建时环境变量"></a><code>ARG</code> 构建时环境变量</h3><p>格式：</p>
<ul>
<li><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></li>
</ul>
<p>构建参数和 <code>ENV</code> 的效果类似，也可以设置环境变量。不同的是，<code>ARG</code> 所设置的是构建环境时的环境变量，在将来容器运行时是不会存在这些环境变量的。</p>
<blockquote>
<p>注意：不要使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p>
</blockquote>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。灵活的使用 <code>ARG</code> 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像。</p>
<p>ARG 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>使用上述 Dockerfile 会发现无法输出 <code>$&#123;DOCKER_USERNAME&#125;</code> 变量的值，要想正常输出，你必须在 <code>FROM</code> 之后再次指定 <code>ARG</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只在 FROM 中生效</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要想在 FROM 之后使用，必须再次指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>对于多阶段构建，尤其要注意这个问题。下面2个 <code>FROM</code> 指令都可以使用 <code>$&#123;DOCKER_USERNAME&#125;</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个变量在每个 FROM 中都生效</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> 2</span></span><br></pre></td></tr></table></figure>

<p>对于在各个阶段中使用的变量都必须在每个阶段分别指定：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a><code>VOLUME</code> 定义匿名卷</h3><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，可以使用<code>VOLUME</code>指令事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。格式为：</p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>下面的 <code>/data</code> 目录就会在容器运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /data</span></span><br></pre></td></tr></table></figure>

<p>运行容器时可以覆盖这个挂载设置。比如，使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure>

<h3 id="EXPOSE-暴露端口"><a href="#EXPOSE-暴露端口" class="headerlink" title="EXPOSE 暴露端口"></a><code>EXPOSE</code> 暴露端口</h3><p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。格式为：</p>
<ul>
<li><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></li>
</ul>
<p>在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a><code>WORKDIR</code> 指定工作目录</h3><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。格式为：</p>
<ul>
<li><code>WORKDIR &lt;工作目录路径&gt;</code></li>
</ul>
<p>其中，<em>工作目录路径</em> 是容器的文件系统目录。</p>
<p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure>

<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；**而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。**这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p>
<p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure>

<p>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>

<p><code>RUN pwd</code> 的工作目录为 <code>/a/b/c</code>。</p>
<h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a><code>USER</code> 指定当前用户</h3><p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。格式：</p>
<ul>
<li><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></li>
</ul>
<p>注意，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="keyword">USER</span> redis</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;redis-server&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a href="https://github.com/tianon/gosu"><code>gosu</code></a>。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/gosu <span class="string">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/gosu \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; gosu nobody <span class="literal">true</span></span></span><br><span class="line"><span class="comment"># 设置 CMD，并以另外的用户执行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;gosu&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;redis-server&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a><code>HEALTHCHECK</code> 健康检查</h3><p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常。其格式如下：</p>
<ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li>
<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p>
<p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p>
<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p>
<p><code>HEALTHCHECK</code> 支持下列选项：</p>
<ul>
<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li>
<li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>
<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li>
</ul>
<p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p>
<p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><span class="line">HEALTHCHECK --interval=5s --<span class="built_in">timeout</span>=3s \</span><br><span class="line">  CMD curl -fs http://localhost/ || <span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure>

<p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p>
<p>使用 <code>docker build</code> 来构建这个镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t myweb:v1 .</span><br></pre></td></tr></table></figure>

<p>构建好了后，我们启动一个容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d --name web -p 80:80 myweb:v1</span><br></pre></td></tr></table></figure>



<h3 id="ONBUILD-作为基础镜像构建新镜像时执行"><a href="#ONBUILD-作为基础镜像构建新镜像时执行" class="headerlink" title="ONBUILD 作为基础镜像构建新镜像时执行"></a><code>ONBUILD</code> 作为基础镜像构建新镜像时执行</h3><p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。仅当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。格式：</p>
<ul>
<li><code>ONBUILD &lt;其它指令&gt;</code></li>
</ul>
<p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p>
<p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。让我们用 <code>ONBUILD</code> 写一下基础镜像的 <code>Dockerfile</code>:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。只有在以此镜像作为基础镜像构建新镜像时，这三行才会被执行。</p>
<p>假设有其他类似的Node.js项目，各个Node.js项目的 <code>Dockerfile</code> 就变成了下面简单的一行：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br></pre></td></tr></table></figure>

<p>当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p>
<h3 id="LABEL-为镜像添加元数据"><a href="#LABEL-为镜像添加元数据" class="headerlink" title="LABEL 为镜像添加元数据"></a>LABEL 为镜像添加元数据</h3><p><code>LABEL</code> 指令用来给镜像以键值对的形式添加一些元数据（metadata）：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure>

<p>我们还可以用一些标签来申明镜像的作者、文档地址等：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.authors=<span class="string">&quot;yeasy&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.documentation=<span class="string">&quot;https://yeasy.gitbooks.io&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>具体可以参考 <a href="https://github.com/opencontainers/image-spec/blob/master/annotations.md">https://github.com/opencontainers/image-spec/blob/master/annotations.md</a></p>
<h3 id="SHELL-指令"><a href="#SHELL-指令" class="headerlink" title="SHELL 指令"></a>SHELL 指令</h3><p>格式：<code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]</code></p>
<p><code>SHELL</code> 指令可以指定 <code>RUN</code> <code>ENTRYPOINT</code> <code>CMD</code> 指令的 shell，Linux 中默认为<code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> lll ; <span class="built_in">ls</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-cex&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> lll ; <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure>

<p>两个 <code>RUN</code> 运行同一命令，第二个 <code>RUN</code> 运行的命令会打印出每条命令并当遇到错误时退出。</p>
<p>当 <code>ENTRYPOINT</code> <code>CMD</code> 以 shell 格式指定时，<code>SHELL</code> 指令所指定的 shell 也会成为这两个指令的 shell：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-cex&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /bin/sh -cex &quot;nginx&quot;</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> nginx</span></span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-cex&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /bin/sh -cex &quot;nginx&quot;</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> nginx</span></span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><code>Dockerfie</code> 官方文档：<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></li>
<li><code>Dockerfile</code> 最佳实践文档：<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a></li>
<li><code>Docker</code> 官方镜像 <code>Dockerfile</code>：<a href="https://github.com/docker-library/docs">https://github.com/docker-library/docs</a></li>
</ul>
<h2 id="Dockerfile-多阶段构建"><a href="#Dockerfile-多阶段构建" class="headerlink" title="Dockerfile 多阶段构建"></a>Dockerfile 多阶段构建</h2><p>Docker v17.05 开始支持多阶段构建 (<code>multistage builds</code>)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 <code>Dockerfile</code>：</p>
<p>例如，编写 <code>Dockerfile</code> 文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/go/helloworld/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v github.com/go-sql-driver/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest as prod</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /go/src/github.com/go/helloworld/app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>构建镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t go/helloworld:3 .</span><br></pre></td></tr></table></figure>

<h4 id="只构建某一阶段的镜像"><a href="#只构建某一阶段的镜像" class="headerlink" title="只构建某一阶段的镜像"></a>只构建某一阶段的镜像</h4><p>我们可以使用 <code>as</code> 来为某一阶段命名，例如</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br></pre></td></tr></table></figure>

<p>例如当我们只想构建 <code>builder</code> 阶段的镜像时，增加 <code>--target=builder</code> 参数即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build --target builder -t username/imagename:tag .</span><br></pre></td></tr></table></figure>

<h4 id="构建时从其他镜像复制文件"><a href="#构建时从其他镜像复制文件" class="headerlink" title="构建时从其他镜像复制文件"></a>构建时从其他镜像复制文件</h4><p>上面例子中我们使用 <code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code> 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">COPY</span><span class="language-bash"> --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span></span><br></pre></td></tr></table></figure>

<h4 id="实战多阶段构建-Laravel-镜像"><a href="#实战多阶段构建-Laravel-镜像" class="headerlink" title="实战多阶段构建 Laravel 镜像"></a>实战多阶段构建 Laravel 镜像</h4><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>新建一个 <code>Laravel</code> 项目或在已有的 <code>Laravel</code> 项目根目录下新建 <code>Dockerfile</code> <code>.dockerignore</code> <code>laravel.conf</code> 文件。</p>
<p>在 <code>.dockerignore</code> 文件中写入以下内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.idea/</span><br><span class="line">.git/</span><br><span class="line">vendor/</span><br><span class="line">node_modules/</span><br><span class="line">public/js/</span><br><span class="line">public/css/</span><br><span class="line">public/mix-manifest.json</span><br><span class="line">yarn-error.log</span><br><span class="line">bootstrap/cache/*</span><br><span class="line">storage/</span><br><span class="line"><span class="comment"># 自行添加其他需要排除的文件，例如 .env.* 文件</span></span><br></pre></td></tr></table></figure>

<p>在 <code>laravel.conf</code> 文件中写入 nginx 配置。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">  <span class="attribute">root</span> /app/laravel/public;</span><br><span class="line">  <span class="attribute">index</span> index.php index.html;</span><br><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">      <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php?<span class="variable">$query_string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="section">location</span> <span class="regexp">~ .*\.php(\/.*)*$</span> &#123;</span><br><span class="line">    <span class="attribute">fastcgi_pass</span>   laravel:<span class="number">9000</span>;</span><br><span class="line">    <span class="attribute">include</span>        fastcgi.conf;</span><br><span class="line">    <span class="comment"># fastcgi_connect_timeout 300;</span></span><br><span class="line">    <span class="comment"># fastcgi_send_timeout 300;</span></span><br><span class="line">    <span class="comment"># fastcgi_read_timeout 300;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="前端构建"><a href="#前端构建" class="headerlink" title="前端构建"></a>前端构建</h5><p>第一阶段进行前端构建。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:alpine as frontend</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json /app/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">cd</span> /app \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; npm install --registry=https://registry.npmmirror.com</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> webpack.mix.js webpack.config.js tailwind.config.js /app/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> resources/ /app/resources/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">cd</span> /app \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">touch</span> artisan \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">mkdir</span> -p public \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; npm run production</span></span><br></pre></td></tr></table></figure>

<h5 id="安装-Composer-依赖"><a href="#安装-Composer-依赖" class="headerlink" title="安装 Composer 依赖"></a>安装 Composer 依赖</h5><p>第二阶段安装 Composer 依赖。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> composer as composer</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> database/ /app/database/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> composer.json composer.lock /app/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">cd</span> /app \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; composer install \</span></span><br><span class="line"><span class="language-bash">           --ignore-platform-reqs \</span></span><br><span class="line"><span class="language-bash">           --no-interaction \</span></span><br><span class="line"><span class="language-bash">           --no-plugins \</span></span><br><span class="line"><span class="language-bash">           --no-scripts \</span></span><br><span class="line"><span class="language-bash">           --prefer-dist</span></span><br></pre></td></tr></table></figure>

<h5 id="整合以上阶段所生成的文件"><a href="#整合以上阶段所生成的文件" class="headerlink" title="整合以上阶段所生成的文件"></a>整合以上阶段所生成的文件</h5><p>第三阶段对以上阶段生成的文件进行整合。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> php:<span class="number">7.4</span>-fpm-alpine as laravel</span><br><span class="line"><span class="keyword">ARG</span> LARAVEL_PATH=/app/laravel</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=composer /app/vendor/ <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/vendor/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . <span class="variable">$&#123;LARAVEL_PATH&#125;</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=frontend /app/public/js/ <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public/js/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=frontend /app/public/css/ <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public/css/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=frontend /app/public/mix-manifest.json <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public/mix-manifest.json</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">cd</span> <span class="variable">$&#123;LARAVEL_PATH&#125;</span> \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">mkdir</span> -p storage \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">mkdir</span> -p storage/framework/cache \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">mkdir</span> -p storage/framework/sessions \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">mkdir</span> -p storage/framework/testing \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">mkdir</span> -p storage/framework/views \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">mkdir</span> -p storage/logs \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">chmod</span> -R 777 storage \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; php artisan package:discover</span></span><br></pre></td></tr></table></figure>

<h5 id="最后一个阶段构建-NGINX-镜像"><a href="#最后一个阶段构建-NGINX-镜像" class="headerlink" title="最后一个阶段构建 NGINX 镜像"></a>最后一个阶段构建 NGINX 镜像</h5><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:alpine as nginx</span><br><span class="line"><span class="keyword">ARG</span> LARAVEL_PATH=/app/laravel</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> laravel.conf /etc/nginx/conf.d/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=laravel <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public</span></span><br></pre></td></tr></table></figure>

<h5 id="构建-Laravel-及-Nginx-镜像"><a href="#构建-Laravel-及-Nginx-镜像" class="headerlink" title="构建 Laravel 及 Nginx 镜像"></a>构建 Laravel 及 Nginx 镜像</h5><p>使用 <code>docker build</code> 命令构建镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t my/laravel --target=laravel .</span><br><span class="line">$ docker build -t my/nginx --target=nginx .</span><br></pre></td></tr></table></figure>

<h5 id="启动容器并测试"><a href="#启动容器并测试" class="headerlink" title="启动容器并测试"></a>启动容器并测试</h5><p>新建 Docker 网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker network create laravel</span><br></pre></td></tr></table></figure>

<p>启动 laravel 容器， <code>--name=laravel</code> 参数设定的名字必须与 <code>nginx</code> 配置文件中的 <code>fastcgi_pass laravel:9000;</code> 一致：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -dit --<span class="built_in">rm</span> --name=laravel --network=laravel my/laravel</span><br></pre></td></tr></table></figure>

<p>启动 nginx 容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -dit --<span class="built_in">rm</span> --network=laravel -p 8080:80 my/nginx</span><br></pre></td></tr></table></figure>

<p>浏览器访问 <code>127.0.0.1:8080</code> 可以看到 Laravel 项目首页。</p>
<blockquote>
<p>也许 Laravel 项目依赖其他外部服务，例如 redis、MySQL，请自行启动这些服务之后再进行测试，本小节不再赘述。</p>
</blockquote>
<h5 id="生产环境优化"><a href="#生产环境优化" class="headerlink" title="生产环境优化"></a>生产环境优化</h5><p>本小节内容为了方便测试，将配置文件直接放到了镜像中，实际在使用时 <strong>建议</strong> 将配置文件作为 <code>config</code> 或 <code>secret</code> 挂载到容器中，请读者自行学习 <code>Swarm mode</code> 或 <code>Kubernetes</code> 的相关内容。</p>
<p>由于篇幅所限本小节只是简单列出，更多内容可以参考 <a href="https://github.com/khs1994-docker/laravel-demo">https://github.com/khs1994-docker/laravel-demo</a> 项目。</p>
<h5 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h5><p>完整的 <code>Dockerfile</code> 文件如下。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:alpine as frontend</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json /app/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">cd</span> /app \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; npm install --registry=https://registry.npmmirror.com</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> webpack.mix.js webpack.config.js tailwind.config.js /app/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> resources/ /app/resources/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">cd</span> /app \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">touch</span> artisan \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">mkdir</span> -p public \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; npm run production</span></span><br><span class="line"><span class="keyword">FROM</span> composer as composer</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> database/ /app/database/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> composer.json /app/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">cd</span> /app \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; composer install \</span></span><br><span class="line"><span class="language-bash">           --ignore-platform-reqs \</span></span><br><span class="line"><span class="language-bash">           --no-interaction \</span></span><br><span class="line"><span class="language-bash">           --no-plugins \</span></span><br><span class="line"><span class="language-bash">           --no-scripts \</span></span><br><span class="line"><span class="language-bash">           --prefer-dist</span></span><br><span class="line"><span class="keyword">FROM</span> php:<span class="number">7.4</span>-fpm-alpine as laravel</span><br><span class="line"><span class="keyword">ARG</span> LARAVEL_PATH=/app/laravel</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=composer /app/vendor/ <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/vendor/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . <span class="variable">$&#123;LARAVEL_PATH&#125;</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=frontend /app/public/js/ <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public/js/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=frontend /app/public/css/ <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public/css/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=frontend /app/public/mix-manifest.json <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public/mix-manifest.json</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">cd</span> <span class="variable">$&#123;LARAVEL_PATH&#125;</span> \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">mkdir</span> -p storage \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">mkdir</span> -p storage/framework/cache \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">mkdir</span> -p storage/framework/sessions \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">mkdir</span> -p storage/framework/testing \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">mkdir</span> -p storage/framework/views \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">mkdir</span> -p storage/logs \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; <span class="built_in">chmod</span> -R 777 storage \</span></span><br><span class="line"><span class="language-bash">      &amp;&amp; php artisan package:discover</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:alpine as nginx</span><br><span class="line"><span class="keyword">ARG</span> LARAVEL_PATH=/app/laravel</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> laravel.conf /etc/nginx/conf.d/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=laravel <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public</span></span><br></pre></td></tr></table></figure>

<h2 id="构建多种系统架构支持的-Docker-镜像-–-docker-manifest-命令详解"><a href="#构建多种系统架构支持的-Docker-镜像-–-docker-manifest-命令详解" class="headerlink" title="构建多种系统架构支持的 Docker 镜像 – docker manifest 命令详解"></a>构建多种系统架构支持的 Docker 镜像 – docker manifest 命令详解</h2><p>我们知道使用镜像创建一个容器，该镜像必须与 Docker 宿主机系统架构一致，例如 <code>Linux x86_64</code> 架构的系统中只能使用 <code>Linux x86_64</code> 的镜像创建容器。</p>
<blockquote>
<p>Windows、macOS 除外，其使用了 <a href="https://docs.docker.com/docker-for-mac/multi-arch/">binfmt_misc</a> 提供了多种架构支持，在 Windows、macOS 系统上 (x86_64) 可以运行 arm 等其他架构的镜像。</p>
</blockquote>
<p>例如我们在 <code>Linux x86_64</code> 中构建一个 <code>username/test</code> 镜像。</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> 1</span></span><br></pre></td></tr></table></figure>

<p>构建镜像后推送到 Docker Hub，之后我们尝试在树莓派 <code>Linux arm64v8</code> 中使用这个镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> username/test</span><br></pre></td></tr></table></figure>

<p>可以发现这个镜像根本获取不到。</p>
<p>要解决这个问题，通常采用的做法是通过镜像名区分不同系统架构的镜像，例如在 <code>Linux x86_64</code> 和 <code>Linux arm64v8</code> 分别构建 <code>username/test</code> 和 <code>username/arm64v8-test</code> 镜像。运行时使用对应架构的镜像即可。</p>
<p>这样做显得很繁琐，那么有没有一种方法让 Docker 引擎根据系统架构自动拉取对应的镜像呢？</p>
<p>我们发现在 <code>Linux x86_64</code> 和 <code>Linux arm64v8</code> 架构的计算机中分别使用 <code>golang:alpine</code> 镜像运行容器 <code>$ docker run golang:alpine go version</code> 时，容器能够正常的运行。</p>
<p>这是什么原因呢？</p>
<p>原因就是 <code>golang:alpine</code> 官方镜像有一个 <a href="https://docs.docker.com/registry/spec/manifest-v2-2/"><code>manifest</code> 列表 (<code>manifest list</code>)</a>。</p>
<p>当用户获取一个镜像时，Docker 引擎会首先查找该镜像是否有 <code>manifest</code> 列表，如果有的话 Docker 引擎会按照 Docker 运行环境（系统及架构）查找出对应镜像（例如 <code>golang:alpine</code>）。如果没有的话会直接获取镜像（例如上例中我们构建的 <code>username/test</code>）。</p>
<p>我们可以使用 <code>$ docker manifest inspect golang:alpine</code> 查看这个 <code>manifest</code> 列表的结构。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest inspect golang:alpine</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;schemaVersion&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;mediaType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/vnd.docker.distribution.manifest.list.v2+json&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;manifests&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;mediaType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1365</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:5e28ac423243b187f464d635bcfe1e909f4a31c6c8bce51d0db0a1062bec9e16&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;architecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span></span><br><span class="line">         <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;mediaType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1365</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:2945c46e26c9787da884b4065d1de64cf93a3b81ead1b949843dda1fcd458bae&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;architecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arm&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;variant&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v7&quot;</span></span><br><span class="line">         <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;mediaType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1365</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:87fff60114fd3402d0c1a7ddf1eea1ded658f171749b57dc782fd33ee2d47b2d&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;architecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arm64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;variant&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v8&quot;</span></span><br><span class="line">         <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;mediaType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1365</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:607b43f1d91144f82a9433764e85eb3ccf83f73569552a49bc9788c31b4338de&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;architecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;386&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span></span><br><span class="line">         <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;mediaType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1365</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:25ead0e21ed5e246ce31e274b98c09aaf548606788ef28eaf375dc8525064314&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;architecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ppc64le&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span></span><br><span class="line">         <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;mediaType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1365</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:69f5907fa93ea591175b2c688673775378ed861eeb687776669a48692bb9754d&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;architecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s390x&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span></span><br><span class="line">         <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看出 <code>manifest</code> 列表中包含了不同系统架构所对应的镜像 <code>digest</code> 值，这样 Docker 就可以在不同的架构中使用相同的 <code>manifest</code> (例如 <code>golang:alpine</code>) 获取对应的镜像。</p>
<p>下面介绍如何使用 <code>$ docker manifest</code> 命令创建并推送 <code>manifest</code> 列表到 Docker Hub。</p>
<h3 id="构建镜像-1"><a href="#构建镜像-1" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>首先在 <code>Linux x86_64</code> 构建 <code>username/x8664-test</code> 镜像。并在 <code>Linux arm64v8</code> 中构建 <code>username/arm64v8-test</code> 镜像，构建好之后推送到 Docker Hub。</p>
<h3 id="创建-manifest-列表"><a href="#创建-manifest-列表" class="headerlink" title="创建 manifest 列表"></a>创建 <code>manifest</code> 列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $ docker manifest create MANIFEST_LIST MANIFEST [MANIFEST...]</span></span><br><span class="line">$ docker manifest create username/test \</span><br><span class="line">      username/x8664-<span class="built_in">test</span> \</span><br><span class="line">      username/arm64v8-<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>当要修改一个 <code>manifest</code> 列表时，可以加入 <code>-a</code> 或 <code>--amend</code> 参数。</p>
<h3 id="设置-manifest-列表"><a href="#设置-manifest-列表" class="headerlink" title="设置 manifest 列表"></a>设置 <code>manifest</code> 列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $ docker manifest annotate [OPTIONS] MANIFEST_LIST MANIFEST</span></span><br><span class="line">$ docker manifest annotate username/test \</span><br><span class="line">      username/x8664-<span class="built_in">test</span> \</span><br><span class="line">      --os linux --<span class="built_in">arch</span> x86_64</span><br><span class="line">$ docker manifest annotate username/test \</span><br><span class="line">      username/arm64v8-<span class="built_in">test</span> \</span><br><span class="line">      --os linux --<span class="built_in">arch</span> arm64 --variant v8</span><br></pre></td></tr></table></figure>

<p>这样就配置好了 <code>manifest</code> 列表。</p>
<h3 id="查看-manifest-列表"><a href="#查看-manifest-列表" class="headerlink" title="查看 manifest 列表"></a>查看 <code>manifest</code> 列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest inspect username/test</span><br></pre></td></tr></table></figure>

<h3 id="推送-manifest-列表"><a href="#推送-manifest-列表" class="headerlink" title="推送 manifest 列表"></a>推送 <code>manifest</code> 列表</h3><p>最后我们可以将其推送到 Docker Hub。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest push username/test</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们在 <code>Linux x86_64</code> <code>Linux arm64v8</code> 中分别执行 <code>$ docker run -it --rm username/test</code> 命令，发现可以正确的执行。</p>
<h3 id="官方博客"><a href="#官方博客" class="headerlink" title="官方博客"></a>官方博客</h3><p>详细了解 <code>manifest</code> 可以阅读官方博客。</p>
<ul>
<li><a href="https://www.docker.com/blog/multi-arch-all-the-things/">https://www.docker.com/blog/multi-arch-all-the-things/</a></li>
</ul>
<h2 id="其它制作镜像的方式"><a href="#其它制作镜像的方式" class="headerlink" title="其它制作镜像的方式"></a>其它制作镜像的方式</h2><p>除了标准的使用 <code>Dockerfile</code> 生成镜像的方法外，由于各种特殊需求和历史原因，还提供了一些其它方法用以生成镜像。</p>
<h3 id="从-rootfs-压缩包导入"><a href="#从-rootfs-压缩包导入" class="headerlink" title="从 rootfs 压缩包导入"></a>从 rootfs 压缩包导入</h3><p>格式：<code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></p>
<p>压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 <code>/</code> 目录展开，并直接作为镜像第一层提交。</p>
<p>比如我们想要创建一个 <a href="https://openvz.org/">OpenVZ</a> 的 Ubuntu 16.04 <a href="https://wiki.openvz.org/Download/template/precreated">模板</a>的镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker import \</span><br><span class="line">    http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz \</span><br><span class="line">    openvz/ubuntu:16.04</span><br><span class="line">Downloading from http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz</span><br><span class="line">sha256:412b8fc3e3f786dca0197834a698932b9c51b69bd8cf49e100c35d38c9879213</span><br></pre></td></tr></table></figure>

<p>这条命令自动下载了 <code>ubuntu-16.04-x86_64.tar.gz</code> 文件，并且作为根文件系统展开导入，并保存为镜像 <code>openvz/ubuntu:16.04</code>。</p>
<p>导入成功后，我们可以用 <code>docker image ls</code> 看到这个导入的镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> openvz/ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">openvz/ubuntu       16.04               412b8fc3e3f7        55 seconds ago      505MB</span><br></pre></td></tr></table></figure>

<p>如果我们查看其历史的话，会看到描述中有导入的文件链接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">history</span> openvz/ubuntu:16.04</span><br><span class="line">IMAGE               CREATED              CREATED BY          SIZE                COMMENT</span><br><span class="line">f477a6e18e98        About a minute ago                       214.9 MB            Imported from http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="Docker-镜像的导入和导出-docker-save-和-docker-load"><a href="#Docker-镜像的导入和导出-docker-save-和-docker-load" class="headerlink" title="Docker 镜像的导入和导出 docker save 和 docker load"></a>Docker 镜像的导入和导出 <code>docker save</code> 和 <code>docker load</code></h3><p>Docker 还提供了 <code>docker save</code> 和 <code>docker load</code> 命令，用以将镜像保存为一个文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。</p>
<h4 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h4><p>使用 <code>docker save</code> 命令可以将镜像保存为归档文件。</p>
<p>比如我们希望保存这个 <code>alpine</code> 镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> alpine</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">alpine              latest              baa5d63471ea        5 weeks ago         4.803 MB</span><br></pre></td></tr></table></figure>

<p>保存镜像的命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker save alpine -o filename</span><br><span class="line">$ file filename</span><br><span class="line">filename: POSIX tar archive</span><br></pre></td></tr></table></figure>

<p>这里的 filename 可以为任意名称甚至任意后缀名，但文件的本质都是归档文件</p>
<p><strong>注意：如果同名则会覆盖（没有警告）</strong></p>
<p>若使用 <code>gzip</code> 压缩：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker save alpine | gzip &gt; alpine-latest.tar.gz</span><br></pre></td></tr></table></figure>

<p>然后我们将 <code>alpine-latest.tar.gz</code> 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker load -i alpine-latest.tar.gz</span><br><span class="line">Loaded image: alpine:latest</span><br></pre></td></tr></table></figure>

<p>如果我们结合这两个命令以及 <code>ssh</code> 甚至 <code>pv</code> 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; <span class="string">&#x27;cat | docker load&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Docker镜像实现原理"><a href="#Docker镜像实现原理" class="headerlink" title="Docker镜像实现原理"></a>Docker镜像实现原理</h2><p>Docker 镜像是怎么实现增量的修改和维护的？</p>
<p>每个镜像都由很多层次构成，Docker 使用 <a href="https://en.wikipedia.org/wiki/UnionFS">Union FS</a> 将这些不同的层结合到一个镜像中去。</p>
<p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。</p>
<p>Docker 在 OverlayFS 上构建的容器也是利用了类似的原理。</p>
<h1 id="Docker-容器管理"><a href="#Docker-容器管理" class="headerlink" title="Docker 容器管理"></a>Docker 容器管理</h1><p>容器是 Docker 又一核心概念。</p>
<p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<p>本章将具体介绍如何来管理一个容器，包括创建、启动和停止等。</p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器有2种方式：</p>
<ul>
<li>基于镜像新建一个容器并启动；</li>
<li>将在终止状态（<code>exited</code>）的容器重新启动。</li>
</ul>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h3 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h3><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从 <a href="../repository/README.md">registry</a> 下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/echo <span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>

<p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p>
<p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:18.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@af8bae53bdd3:/<span class="comment"># pwd</span></span><br><span class="line">/</span><br><span class="line">root@af8bae53bdd3:/<span class="comment"># ls</span></span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure>

<h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ba267838cc1b:/<span class="comment"># ps</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:00 bash</span><br><span class="line">   11 ?        00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p>
<p>如果不使用 <code>-d</code> 参数运行容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>容器会把输出的结果 (STDOUT) 打印到宿主机上面。</p>
<p>如果使用了 <code>-d</code> 参数运行容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d ubuntu:18.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line">77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure>

<p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p>
<blockquote>
<p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p>
</blockquote>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker ps</code>命令或<code>docker container ls</code> 命令来查看容器信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line">CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES</span><br><span class="line">77b2dc01fe0f  ubuntu:18.04  /bin/sh -c <span class="string">&#x27;while tr  2 minutes ago  Up 1 minute        agitated_wright</span></span><br></pre></td></tr></table></figure>

<p>可以通过<code>docker logs</code>命令或 <code>docker container logs</code> 命令获取容器的输出信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container logs [container ID or NAMES]</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>可以使用 <code>docker stop</code>命令或<code>docker container stop</code> 来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span> -a</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">ba267838cc1b        ubuntu:18.04             <span class="string">&quot;/bin/bash&quot;</span>            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</span><br></pre></td></tr></table></figure>

<p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p>
<p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p>
<p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p>
<h3 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h3><p>下面示例如何使用 <code>docker attach</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">243c32535da7        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span><br><span class="line">$ docker attach 243c</span><br><span class="line">root@243c32535da7:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p>
<h3 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h3><h4 id="i-t-参数"><a href="#i-t-参数" class="headerlink" title="-i -t 参数"></a><code>-i</code> <code>-t</code> 参数</h4><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</span><br><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">69d137adef7a        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>         18 seconds ago      Up 17 seconds                           zealous_swirles</span><br><span class="line">$ docker <span class="built_in">exec</span> -i 69d1 bash</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">...</span><br><span class="line">$ docker <span class="built_in">exec</span> -it 69d1 bash</span><br><span class="line">root@69d137adef7a:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p>
<p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p>
<h2 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span> -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">7691a814370e        ubuntu:18.04        <span class="string">&quot;/bin/bash&quot;</span>         36 hours ago        Exited (0) 21 hours ago                       <span class="built_in">test</span></span><br><span class="line">$ docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>

<p>这样将导出容器快照到本地文件。</p>
<h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line"><span class="built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure>

<p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>

<p><em>注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用 <code>docker rm</code>命令或<code>docker container rm</code>命令 来删除一个处于终止状态的容器。例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container <span class="built_in">rm</span> trusting_newton</span><br><span class="line">trusting_newton</span><br></pre></td></tr></table></figure>

<p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p>
<h3 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h3><p>使用 <code>docker ps -a</code>命令或<code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container prune</span><br></pre></td></tr></table></figure>

<h1 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h1><p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>docker.io/ubuntu</code> 来说，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p>
<p>大部分时候，并不需要严格区分这两者的概念。</p>
<h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/">Docker Hub</a>。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>你可以在 <a href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>你可以通过 <code>docker logout</code> 退出登录。</p>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p>
<p>例如以 <code>centos</code> 为关键词进行搜索：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker search centos</span><br><span class="line">NAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">centos                             The official build of CentOS.                   6449      [OK]</span><br><span class="line">ansible/centos7-ansible            Ansible on Centos7                              132                  [OK]</span><br><span class="line">consol/centos-xfce-vnc             Centos container with <span class="string">&quot;headless&quot;</span> VNC session…   126                  [OK]</span><br><span class="line">jdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   117                  [OK]</span><br><span class="line">centos/systemd                     systemd enabled base container.                 96                   [OK]</span><br></pre></td></tr></table></figure>

<p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（<code>OFFICIAL</code>）、是否自动构建 （<code>AUTOMATED</code>）。</p>
<p>根据是否是官方提供，可将镜像分为2类：</p>
<ul>
<li><p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p>
</li>
<li><p>一种是类似 <code>ansible/centos7-ansible</code> 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 ansible 用户。</p>
</li>
</ul>
<p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p>
<p>下载官方 <code>centos</code> 镜像到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull centos</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">7a0437f04f83: Pull complete</span><br><span class="line">Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:latest</span><br><span class="line">docker.io/library/centos:latest</span><br></pre></td></tr></table></figure>

<h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                                                   18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line">username/ubuntu                                          18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line">$ docker push username/ubuntu:18.04</span><br><span class="line">$ docker search username</span><br><span class="line">NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">username/ubuntu</span><br></pre></td></tr></table></figure>

<h3 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h3><blockquote>
<p>2021 年 7 月 26 日之后，该项功能仅限<a href="https://www.docker.com/blog/changes-to-docker-hub-autobuilds/">付费用户</a>使用。</p>
</blockquote>
<p>自动构建（<code>Automated Builds</code>）功能对于需要经常升级镜像内程序来说，十分方便。</p>
<p>有时候，用户构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。</p>
<p>而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a href="https://github.com/">GitHub</a> 或 <a href="https://bitbucket.org/">BitBucket</a>）上的项目，一旦项目发生新的提交 （<code>commit</code>）或者创建了新的标签（<code>tag</code>），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p>
<p>要配置自动构建，包括如下的步骤：</p>
<ul>
<li><p>登录 Docker Hub；</p>
</li>
<li><p>在 Docker Hub 点击右上角头像，在账号设置（<code>Account Settings</code>）中关联（<code>Linked Accounts</code>）目标网站；</p>
</li>
<li><p>在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code> 选项卡中选择 <code>Configure Automated Builds</code>；</p>
</li>
<li><p>选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</p>
</li>
<li><p>指定 <code>Dockerfile</code> 的位置，并保存。</p>
</li>
</ul>
<p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code> 选项卡中查看每次构建的状态。</p>
<h2 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h2><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p>
<p><a href="https://docs.docker.com/registry/"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a href="https://github.com/docker/distribution"><code>docker-registry</code></a> v2.x 版本。</p>
<h3 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h3><h4 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h4><p>你可以使用官方 <code>registry</code> 镜像来运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure>

<p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v /opt/data/registry:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure>

<h3 id="在私有仓库上传、搜索、下载镜像"><a href="#在私有仓库上传、搜索、下载镜像" class="headerlink" title="在私有仓库上传、搜索、下载镜像"></a>在私有仓库上传、搜索、下载镜像</h3><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p>
<p>先在本机查看已有的镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure>

<p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>。</p>
<p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br><span class="line">127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure>

<p>使用 <code>docker push</code> 上传标记的镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker push 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class="line">373a30c24545: Pushed</span><br><span class="line">a9148f5200b0: Pushed</span><br><span class="line">cdd3de0940ab: Pushed</span><br><span class="line">fc56279bbb33: Pushed</span><br><span class="line">b38367233d37: Pushed</span><br><span class="line">2aebd096e0e2: Pushed</span><br><span class="line">latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568</span><br></pre></td></tr></table></figure>

<p>用 <code>curl</code> 查看仓库中的镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl 127.0.0.1:5000/v2/_catalog</span><br><span class="line">&#123;<span class="string">&quot;repositories&quot;</span>:[<span class="string">&quot;ubuntu&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到 <code>&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</code>，表明镜像已经被成功上传了。</p>
<p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">$ docker pull 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">Pulling repository 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">ba5877dc9bec: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">9bad880da3d2: Download complete</span><br><span class="line">25f11f5fb0cb: Download complete</span><br><span class="line">ebc34468f71d: Download complete</span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure>

<h3 id="配置非-https-仓库地址"><a href="#配置非-https-仓库地址" class="headerlink" title="配置非 https 仓库地址"></a>配置非 https 仓库地址</h3><p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p>
<p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p>
<h3 id="Ubuntu-16-04-Debian-8-centos-7"><a href="#Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="Ubuntu 16.04+, Debian 8+, centos 7"></a>Ubuntu 16.04+, Debian 8+, centos 7</h3><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirror&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.baidubce.com&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;192.168.199.100:5000&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>对于 Docker Desktop for Windows 、 Docker Desktop for Mac 在设置中的 <code>Docker Engine</code> 中进行编辑 ，增加和上边一样的字符串即可。</p>
<h2 id="私有仓库高级配置"><a href="#私有仓库高级配置" class="headerlink" title="私有仓库高级配置"></a>私有仓库高级配置</h2><p>上一节我们搭建了一个具有基础功能的私有仓库，本小节我们来使用 <code>Docker Compose</code> 搭建一个拥有权限认证、TLS 的私有仓库。</p>
<p>新建一个文件夹，以下步骤均在该文件夹中进行。</p>
<h3 id="准备站点证书"><a href="#准备站点证书" class="headerlink" title="准备站点证书"></a>准备站点证书</h3><p>如果你拥有一个域名，国内各大云服务商均提供免费的站点证书。你也可以使用 <code>openssl</code> 自行签发证书。</p>
<p>这里假设我们将要搭建的私有仓库地址为 <code>docker.domain.com</code>，下面我们介绍使用 <code>openssl</code> 自行签发 <code>docker.domain.com</code> 的站点 SSL 证书。</p>
<p>第一步创建 <code>CA</code> 私钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl genrsa -out <span class="string">&quot;root-ca.key&quot;</span> 4096</span><br></pre></td></tr></table></figure>

<p>第二步利用私钥创建 <code>CA</code> 根证书请求文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl req \</span><br><span class="line">          -new -key <span class="string">&quot;root-ca.key&quot;</span> \</span><br><span class="line">          -out <span class="string">&quot;root-ca.csr&quot;</span> -sha256 \</span><br><span class="line">          -subj <span class="string">&#x27;/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=Your Company Name Docker Registry CA&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上命令中 <code>-subj</code> 参数里的 <code>/C</code> 表示国家，如 <code>CN</code>；<code>/ST</code> 表示省；<code>/L</code> 表示城市或者地区；<code>/O</code> 表示组织名；<code>/CN</code> 通用名称。</p>
</blockquote>
<p>第三步配置 <code>CA</code> 根证书，新建 <code>root-ca.cnf</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root_ca]</span><br><span class="line">basicConstraints = critical,CA:TRUE,pathlen:1</span><br><span class="line">keyUsage = critical, nonRepudiation, cRLSign, keyCertSign</span><br><span class="line">subjectKeyIdentifier=<span class="built_in">hash</span></span><br></pre></td></tr></table></figure>

<p>第四步签发根证书。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl x509 -req  -days 3650  -<span class="keyword">in</span> <span class="string">&quot;root-ca.csr&quot;</span> \</span><br><span class="line">               -signkey <span class="string">&quot;root-ca.key&quot;</span> -sha256 -out <span class="string">&quot;root-ca.crt&quot;</span> \</span><br><span class="line">               -extfile <span class="string">&quot;root-ca.cnf&quot;</span> -extensions \</span><br><span class="line">               root_ca</span><br></pre></td></tr></table></figure>

<p>第五步生成站点 <code>SSL</code> 私钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl genrsa -out <span class="string">&quot;docker.domain.com.key&quot;</span> 4096</span><br></pre></td></tr></table></figure>

<p>第六步使用私钥生成证书请求文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl req -new -key <span class="string">&quot;docker.domain.com.key&quot;</span> -out <span class="string">&quot;site.csr&quot;</span> -sha256 \</span><br><span class="line">          -subj <span class="string">&#x27;/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=docker.domain.com&#x27;</span></span><br></pre></td></tr></table></figure>

<p>第七步配置证书，新建 <code>site.cnf</code> 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints = critical,CA:FALSE</span><br><span class="line">extendedKeyUsage=serverAuth</span><br><span class="line">keyUsage = critical, digitalSignature, keyEncipherment</span><br><span class="line">subjectAltName = DNS:docker.domain.com, IP:127.0.0.1</span><br><span class="line">subjectKeyIdentifier=<span class="built_in">hash</span></span><br></pre></td></tr></table></figure>

<p>第八步签署站点 <code>SSL</code> 证书。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl x509 -req -days 750 -<span class="keyword">in</span> <span class="string">&quot;site.csr&quot;</span> -sha256 \</span><br><span class="line">    -CA <span class="string">&quot;root-ca.crt&quot;</span> -CAkey <span class="string">&quot;root-ca.key&quot;</span>  -CAcreateserial \</span><br><span class="line">    -out <span class="string">&quot;docker.domain.com.crt&quot;</span> -extfile <span class="string">&quot;site.cnf&quot;</span> -extensions server</span><br></pre></td></tr></table></figure>

<p>这样已经拥有了 <code>docker.domain.com</code> 的网站 SSL 私钥 <code>docker.domain.com.key</code> 和 SSL 证书 <code>docker.domain.com.crt</code> 及 CA 根证书 <code>root-ca.crt</code>。</p>
<p>新建 <code>ssl</code> 文件夹并将 <code>docker.domain.com.key</code> <code>docker.domain.com.crt</code> <code>root-ca.crt</code> 这三个文件移入，删除其他文件。</p>
<h3 id="配置私有仓库"><a href="#配置私有仓库" class="headerlink" title="配置私有仓库"></a>配置私有仓库</h3><p>私有仓库默认的配置文件位于 <code>/etc/docker/registry/config.yml</code>，我们先在本地编辑 <code>config.yml</code>，之后挂载到容器中。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">log:</span></span><br><span class="line">  <span class="attr">accesslog:</span></span><br><span class="line">    <span class="attr">disabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">formatter:</span> <span class="string">text</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">staging</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">delete:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">blobdescriptor:</span> <span class="string">inmemory</span></span><br><span class="line">  <span class="attr">filesystem:</span></span><br><span class="line">    <span class="attr">rootdirectory:</span> <span class="string">/var/lib/registry</span></span><br><span class="line"><span class="attr">auth:</span></span><br><span class="line">  <span class="attr">htpasswd:</span></span><br><span class="line">    <span class="attr">realm:</span> <span class="string">basic-realm</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/etc/docker/registry/auth/nginx.htpasswd</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="string">:443</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">https://docker.domain.com</span></span><br><span class="line">  <span class="attr">headers:</span></span><br><span class="line">    <span class="attr">X-Content-Type-Options:</span> [<span class="string">nosniff</span>]</span><br><span class="line">  <span class="attr">http2:</span></span><br><span class="line">    <span class="attr">disabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="attr">certificate:</span> <span class="string">/etc/docker/registry/ssl/docker.domain.com.crt</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">/etc/docker/registry/ssl/docker.domain.com.key</span></span><br><span class="line"><span class="attr">health:</span></span><br><span class="line">  <span class="attr">storagedriver:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line"><span class="attr">threshold:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="生成-http-认证文件"><a href="#生成-http-认证文件" class="headerlink" title="生成 http 认证文件"></a>生成 http 认证文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> auth</span><br><span class="line">$ docker run --<span class="built_in">rm</span> \</span><br><span class="line">    --entrypoint htpasswd \</span><br><span class="line">    httpd:alpine \</span><br><span class="line">    -Bbn username password &gt; auth/nginx.htpasswd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将上面的 <code>username</code> <code>password</code> 替换为你自己的用户名和密码。</p>
</blockquote>
<h3 id="编辑-docker-compose-yml"><a href="#编辑-docker-compose-yml" class="headerlink" title="编辑 docker-compose.yml"></a>编辑 <code>docker-compose.yml</code></h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/etc/docker/registry</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry-data:/var/lib/registry</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">registry-data:</span></span><br></pre></td></tr></table></figure>

<h3 id="修改-hosts"><a href="#修改-hosts" class="headerlink" title="修改 hosts"></a>修改 hosts</h3><p>编辑 <code>/etc/hosts</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1 docker.domain.com</span><br></pre></td></tr></table></figure>

<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>这样我们就搭建好了一个具有权限认证、TLS 的私有仓库，接下来我们测试其功能是否正常。</p>
<h3 id="测试私有仓库功能"><a href="#测试私有仓库功能" class="headerlink" title="测试私有仓库功能"></a>测试私有仓库功能</h3><p>由于自行签发的 CA 根证书不被系统信任，所以我们需要将 CA 根证书 <code>ssl/root-ca.crt</code> 移入 <code>/etc/docker/certs.d/docker.domain.com</code> 文件夹中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">mkdir</span> -p /etc/docker/certs.d/docker.domain.com</span><br><span class="line">$ sudo <span class="built_in">cp</span> ssl/root-ca.crt /etc/docker/certs.d/docker.domain.com/ca.crt</span><br></pre></td></tr></table></figure>

<p>登录到私有仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker login docker.domain.com</span><br></pre></td></tr></table></figure>

<p>尝试推送、拉取镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line">$ docker tag ubuntu:18.04 docker.domain.com/username/ubuntu:18.04</span><br><span class="line">$ docker push docker.domain.com/username/ubuntu:18.04</span><br><span class="line">$ docker image <span class="built_in">rm</span> docker.domain.com/username/ubuntu:18.04</span><br><span class="line">$ docker pull docker.domain.com/username/ubuntu:18.04</span><br></pre></td></tr></table></figure>

<p>如果我们退出登录，尝试推送镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">logout</span> docker.domain.com</span><br><span class="line">$ docker push docker.domain.com/username/ubuntu:18.04</span><br><span class="line">no basic auth credentials</span><br></pre></td></tr></table></figure>

<p>发现会提示没有登录，不能将镜像推送到私有仓库中。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果你本机占用了 <code>443</code> 端口，你可以配置 <a href="https://docs.docker.com/registry/recipes/nginx/">Nginx 代理</a>，这里不再赘述。</p>
<h2 id="Nexus3-x-的私有仓库"><a href="#Nexus3-x-的私有仓库" class="headerlink" title="Nexus3.x 的私有仓库"></a>Nexus3.x 的私有仓库</h2><p>使用 Docker 官方的 Registry 创建的仓库面临一些维护问题。比如某些镜像删除以后空间默认是不会回收的，需要一些命令去回收空间然后重启 Registry。在企业中把内部的一些工具包放入 <code>Nexus</code> 中是比较常见的做法，最新版本 <code>Nexus3.x</code> 全面支持 Docker 的私有镜像。所以使用 <a href="https://www.sonatype.com/product/repository-oss-download"><code>Nexus3.x</code></a> 一个软件来管理 <code>Docker</code> , <code>Maven</code> , <code>Yum</code> , <code>PyPI</code> 等是一个明智的选择。</p>
<h3 id="启动-Nexus-容器"><a href="#启动-Nexus-容器" class="headerlink" title="启动 Nexus 容器"></a>启动 Nexus 容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d --name nexus3 --restart=always \</span><br><span class="line">    -p 8081:8081 \</span><br><span class="line">    --mount src=nexus-data,target=/nexus-data \</span><br><span class="line">    sonatype/nexus3</span><br></pre></td></tr></table></figure>

<p>首次运行需等待 3-5 分钟，你可以使用 <code>docker logs nexus3 -f</code> 查看日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker logs nexus3 -f</span><br><span class="line">2021-03-11 15:31:21,990+0000 INFO  [jetty-main-1] *SYSTEM org.sonatype.nexus.bootstrap.jetty.JettyServer -</span><br><span class="line">-------------------------------------------------</span><br><span class="line">Started Sonatype Nexus OSS 3.30.0-01</span><br><span class="line">-------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>如果你看到以上内容，说明 <code>Nexus</code> 已经启动成功，你可以使用浏览器打开 <code>http://YourIP:8081</code> 访问 <code>Nexus</code> 了。</p>
<p>首次运行请通过以下命令获取初始密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> nexus3 <span class="built_in">cat</span> /nexus-data/admin.password</span><br><span class="line">9266139e-41a2-4abb-92ec-e4142a3532cb</span><br></pre></td></tr></table></figure>

<p>首次启动 Nexus 的默认帐号是 <code>admin</code> ，密码则是上边命令获取到的，点击右上角登录，首次登录需更改初始密码。</p>
<p>登录之后可以点击页面上方的齿轮按钮按照下面的方法进行设置。</p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>创建一个私有仓库的方法： <code>Repository-&gt;Repositories</code> 点击右边菜单 <code>Create repository</code> 选择 <code>docker (hosted)</code></p>
<ul>
<li><strong>Name</strong>: 仓库的名称</li>
<li><strong>HTTP</strong>: 仓库单独的访问端口（例如：<strong>5001</strong>）</li>
<li><strong>Hosted -&gt; Deployment pollcy</strong>: 请选择 <strong>Allow redeploy</strong> 否则无法上传 Docker 镜像。</li>
</ul>
<p>其它的仓库创建方法请各位自己摸索，还可以创建一个 <code>docker (proxy)</code> 类型的仓库链接到 DockerHub 上。再创建一个 <code>docker (group)</code> 类型的仓库把刚才的 <code>hosted</code> 与 <code>proxy</code> 添加在一起。主机在访问的时候默认下载私有仓库中的镜像，如果没有将链接到 DockerHub 中下载并缓存到 Nexus 中。</p>
<h3 id="添加访问权限"><a href="#添加访问权限" class="headerlink" title="添加访问权限"></a>添加访问权限</h3><p>菜单 <code>Security-&gt;Realms</code> 把 Docker Bearer Token Realm 移到右边的框中保存。</p>
<p>添加用户规则：菜单 <code>Security-&gt;Roles</code>-&gt;<code>Create role</code>  在 <code>Privlleges</code> 选项搜索 docker 把相应的规则移动到右边的框中然后保存。</p>
<p>添加用户：菜单 <code>Security-&gt;Users</code>-&gt;<code>Create local user</code> 在 <code>Roles</code> 选项中选中刚才创建的规则移动到右边的窗口保存。</p>
<h3 id="NGINX-加密代理"><a href="#NGINX-加密代理" class="headerlink" title="NGINX 加密代理"></a>NGINX 加密代理</h3><p>证书的生成请参见 <a href="registry_auth.md"><code>私有仓库高级配置</code></a> 里面证书生成一节。</p>
<p>NGINX 示例配置如下</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> register</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="string">&quot;YourHostName OR IP&quot;</span>:<span class="number">5001</span>; <span class="comment">#端口为上面添加私有镜像仓库时设置的 HTTP 选项的端口号</span></span><br><span class="line">    <span class="attribute">check</span> interval=<span class="number">3000</span> rise=<span class="number">2</span> fall=<span class="number">10</span> timeout=<span class="number">1000</span> type=http;</span><br><span class="line">    <span class="attribute">check_http_send</span> <span class="string">&quot;HEAD / HTTP/1.0\r\n\r\n&quot;</span>;</span><br><span class="line">    <span class="attribute">check_http_expect_alive</span> http_4xx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> YourDomainName;<span class="comment">#如果没有 DNS 服务器做解析，请删除此选项使用本机 IP 地址访问</span></span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> key/example.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> key/example.key;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>   <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">300m</span>;</span><br><span class="line">    <span class="attribute">client_body_buffer_size</span> <span class="number">512k</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span>   <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">proxy_send_timeout</span>   <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">proxy_buffer_size</span>    <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">proxy_buffers</span>       <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">proxy_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">proxy_temp_file_write_size</span> <span class="number">512k</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Port <span class="variable">$server_port</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="variable">$connection_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://register;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">900s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Docker-主机访问镜像仓库"><a href="#Docker-主机访问镜像仓库" class="headerlink" title="Docker 主机访问镜像仓库"></a>Docker 主机访问镜像仓库</h3><p>如果不启用 SSL 加密可以通过 <a href="./registry.md">前面章节</a> 的方法添加非 https 仓库地址到 Docker 的配置文件中然后重启 Docker。</p>
<p>使用 SSL 加密以后程序需要访问就不能采用修改配置的方式了。具体方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl s_client -showcerts -connect YourDomainName OR HostIP:443 &lt;/dev/null 2&gt;/dev/null|openssl x509 -outform PEM &gt;ca.crt</span><br><span class="line">$ <span class="built_in">cat</span> ca.crt | sudo <span class="built_in">tee</span> -a /etc/ssl/certs/ca-certificates.crt</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>使用 <code>docker login YourDomainName OR HostIP</code> 进行测试，用户名密码填写上面 Nexus 中设置的。</p>
<h1 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h1><p>这一章介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有3种方式：</p>
<ul>
<li>数据卷（Volumes）</li>
<li>挂载主机目录 (Bind mounts)</li>
<li>tmpfs mount</li>
</ul>
<p><img src="/2022/docker_practice/types-of-mounts.png"></p>
<h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><h3 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h3><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。本地目录的路径必须是绝对路径。</p>
<blockquote>
<p>注意：使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/usr/share/nginx/html \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/usr/share/nginx/html</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。</p>
<p>Docker 挂载主机目录的默认权限是 <em><strong>读写</strong></em>，用户也可以通过增加 <code>readonly</code> 指定为 <em><strong>只读</strong></em>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/usr/share/nginx/html,<span class="built_in">readonly</span> \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/share/nginx/html <span class="comment"># touch new.txt</span></span><br><span class="line"><span class="built_in">touch</span>: new.txt: Read-only file system</span><br></pre></td></tr></table></figure>

<h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure>

<p><strong>挂载主机目录</strong> 的配置信息在 “Mounts” 键下面，注意<code>Type</code>为<code>bind</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bind&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/src/webapp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/share/nginx/html&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;RW&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Propagation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rprivate&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --<span class="built_in">rm</span> -it \</span><br><span class="line">   --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="variable">$HOME</span>/.bash_history,target=/root/.bash_history \</span><br><span class="line">   ubuntu:18.04 \</span><br><span class="line">   bash</span><br><span class="line">root@2affd44b4667:/<span class="comment"># history</span></span><br><span class="line">1  <span class="built_in">ls</span></span><br><span class="line">2  diskutil list</span><br></pre></td></tr></table></figure>

<p>这样就可以记录在容器输入过的命令了。</p>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><strong>数据卷</strong> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li><p><strong>数据卷</strong> 可以在容器之间共享和重用</p>
</li>
<li><p>对 <strong>数据卷</strong> 的修改会立马生效</p>
</li>
<li><p>对 <strong>数据卷</strong> 的更新，不会影响镜像</p>
</li>
<li><p><strong>数据卷</strong> 默认会一直存在，即使容器被删除</p>
</li>
</ul>
<blockquote>
<p>注意：<strong>数据卷</strong> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>
</blockquote>
<h3 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br></pre></td></tr></table></figure>

<p>查看所有的 数据卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume <span class="built_in">ls</span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               my-vol</span><br></pre></td></tr></table></figure>

<p>在主机里使用以下命令可以查看指定 数据卷 的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2022-04-22T02:29:40+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;my-vol&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用 <code>docker run</code> 命令的时候，使用 <code>-v</code> 参数来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    -v my-vol:/usr/share/nginx/html \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<p>Docker 挂载数据卷的默认权限是<code>rw</code> <em><strong>读写</strong></em>，用户也可以通过增加 <code>ro</code> 指定为 <em><strong>只读</strong></em>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    -v my-vol:/usr/share/nginx/html:ro \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<p><code>-v</code>参数也可以直接挂载宿主机上的目录或文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    -v <span class="variable">$HOME</span>/.bash_history:/root/.bash_history \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>


<h3 id="查看数据卷的具体信息-1"><a href="#查看数据卷的具体信息-1" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure>

<p><strong>数据卷</strong> 的配置信息在 “Mounts” 键下面，注意<code>Type</code>为<code>volume</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-vol&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/share/nginx/html&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;RW&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Propagation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume <span class="built_in">rm</span> my-vol</span><br></pre></td></tr></table></figure>

<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p>
<p>无主的数据卷可能会占据很多空间，要清理请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure>


<h2 id="Docker-bind-Mounts和volume及tmpfs对比"><a href="#Docker-bind-Mounts和volume及tmpfs对比" class="headerlink" title="Docker bind Mounts和volume及tmpfs对比"></a>Docker bind Mounts和volume及tmpfs对比</h2><p>本文总结了 bind Mounts 和 volume 及 tmpfs 三种 Docker 管理容器数据方式的区别。</p>
<h3 id="bind-mounts"><a href="#bind-mounts" class="headerlink" title="bind mounts"></a>bind mounts</h3><p>根据官方文档的介绍：</p>
<blockquote>
<p>bind mounts have limited functionality compared to volumes. <strong>When you use a bind mount, a file or directory on the host machine is mounted into a container. The file or directory is referenced by its absolute path on the host machine.</strong> By contrast, when you use a volume, a new directory is created within Docker’s storage directory on the host machine, and Docker manages that directory’s contents.</p>
</blockquote>
<p><code>bind mounts</code>相比<code>volume</code>功能较为有限，创建一个 bind mount 之后，Host 上的一个文件&#x2F;文件夹就相当于被挂载到容器里了，该文件&#x2F;目录就被容器通过绝对路径引用了，<strong>意味着这个文件&#x2F;文件夹必须实现存在于 Host 上</strong>。</p>
<p>而使用使用<code>volume</code>时，会在 Host 主机上新建一个<strong>Docker 存储文件夹</strong>，文件夹里的内容由 Docker 管理。</p>
<blockquote>
<p>The file or directory does not need to exist on the Docker host already. It is created on demand if it does not yet exist. bind mounts are very performant, but they rely on the host machine’s filesystem having a specific directory structure available. If you are developing new Docker applications, consider using named volumes instead.</p>
</blockquote>
<p><code>volume</code>映射的文件&#x2F;目录不需要存在于 Host 上，它们是按需生成的，即可以被自动创建，不需要事先在 Host 上创建。</p>
<p><strong>虽然<code>bind mounts</code>很高效，但是它依赖 Host 上存在特定的目录结构</strong>，这对于部署到新主机上显然不是一件好事，所以推荐新应用使用<code>volume</code>。</p>
<h3 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h3><blockquote>
<p>Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker.</p>
</blockquote>
<p><code>volume</code>与<code>bind mounts</code>的区别在于后者依赖于 Host 上有特定的目录结构，而前者不需要，使用 volume 时文件的管理由 Docker 主导而不是 Host。</p>
<p><strong>文档还提到了<code>volume</code>相比于<code>bind mounts</code>的优点：</strong></p>
<ul>
<li><strong>更易于备份&#x2F;转移</strong></li>
<li>同时可用于 Linux&#x2F;Windows 容器</li>
<li>在多个容器间共享更安全</li>
<li><strong><code>volume</code>驱动能够让你在远程主机或云服务器上存储<code>volume</code>，还能实现数据加密等功能</strong></li>
<li>新容器可以提前填充内容到<code>volume</code>里</li>
<li>在 Mac 和 Windows 主机里<code>volume</code>性能比<code>bind mounts</code>好的多</li>
</ul>
<h3 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h3><p>若容器产生的数据不需要持久化，可以考虑使用<code>tmpfs</code>来避免持久化数据和写入容器层(writable layer)，从而提高性能。</p>
<p><code>tmpfs</code>是将文件写到内存中，可以避免写数据到容器层增加容器大小。</p>
<p>但<code>tmpfs</code>有两个缺点：</p>
<ul>
<li>只能在 Linux Host 上使用</li>
<li>不能在多个容器间共享</li>
</ul>
<p>下图解释了三者的关系：</p>
<p><img src="/2022/docker_practice/1.png" alt="bind-mounts volume tmpfs"></p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://docs.docker.com/storage/bind-mounts/">Use bind mounts</a></p>
<p><a href="https://docs.docker.com/storage/volumes/">Use volumes</a></p>
<p><a href="https://docs.docker.com/storage/tmpfs/">Use tmpfs mounts</a></p>
<h1 id="Docker-网络管理"><a href="#Docker-网络管理" class="headerlink" title="Docker 网络管理"></a>Docker 网络管理</h1><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射，以使外部可以访问容器中的服务。</p>
<p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p>
<p>使用 <code>docker container ls</code> 可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -P nginx:alpine</span><br><span class="line">$ docker container <span class="built_in">ls</span> -l</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">fae320d08268        nginx:alpine        <span class="string">&quot;/docker-entrypoint.…&quot;</span>   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty</span><br></pre></td></tr></table></figure>

<p>同样的，可以通过 <code>docker logs</code> 命令来查看访问记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker logs fa</span><br><span class="line">172.17.0.1 - - [25/Aug/2020:08:34:04 +0000] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 612 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
<h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure>

<p>此时默认会绑定本地所有接口上的所有地址。</p>
<h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:80:80 nginx:alpine</span><br></pre></td></tr></table></figure>

<h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1::80 nginx:alpine</span><br></pre></td></tr></table></figure>

<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</span><br></pre></td></tr></table></figure>

<h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker port fa 80</span><br><span class="line">0.0.0.0:32768</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</p>
</li>
<li><p><code>-p</code> 标记可以多次使用来绑定多个端口</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 80:80 \</span><br><span class="line">    -p 443:443 \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>如果你之前有 <code>Docker</code> 使用经验，你可能已经习惯了使用 <code>--link</code> 参数来使容器互联。随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p>
<h3 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h3><p>下面先创建一个新的 Docker 网络。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker network create -d bridge my-net</span><br></pre></td></tr></table></figure>

<p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 <a href="../swarm_mode/">Swarm mode</a>，在本小节中你可以忽略它。</p>
<h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> --name busybox1 --network my-net busybox sh</span><br></pre></td></tr></table></figure>

<p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure>

<p>再打开一个新的终端查看容器信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b47060aca56b        busybox             <span class="string">&quot;sh&quot;</span>                11 minutes ago      Up 11 minutes                           busybox2</span><br><span class="line">8720575823ec        busybox             <span class="string">&quot;sh&quot;</span>                16 minutes ago      Up 16 minutes                           busybox1</span><br></pre></td></tr></table></figure>

<p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<p>在 <code>busybox1</code> 容器输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox2</span></span><br><span class="line">PING busybox2 (172.19.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.3: <span class="built_in">seq</span>=0 ttl=64 time=0.072 ms</span><br><span class="line">64 bytes from 172.19.0.3: <span class="built_in">seq</span>=1 ttl=64 time=0.118 ms</span><br></pre></td></tr></table></figure>

<p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p>
<p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox1</span></span><br><span class="line">PING busybox1 (172.19.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.2: <span class="built_in">seq</span>=0 ttl=64 time=0.064 ms</span><br><span class="line">64 bytes from 172.19.0.2: <span class="built_in">seq</span>=1 ttl=64 time=0.143 ms</span><br></pre></td></tr></table></figure>

<p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<p><strong>如果你有多个容器之间需要互相连接，推荐使用 <a href="../compose">Docker Compose</a>。</strong></p>
<h2 id="配置-DNS"><a href="#配置-DNS" class="headerlink" title="配置 DNS"></a>配置 DNS</h2><p>如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</p>
<p>在容器中使用 <code>mount</code> 命令可以看到挂载信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mount</span><br><span class="line">/dev/disk/by-uuid/1fec...ebdf on /etc/hostname <span class="built_in">type</span> ext4 ...</span><br><span class="line">/dev/disk/by-uuid/1fec...ebdf on /etc/hosts <span class="built_in">type</span> ext4 ...</span><br><span class="line">tmpfs on /etc/resolv.conf <span class="built_in">type</span> tmpfs ...</span><br></pre></td></tr></table></figure>

<p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 <code>/etc/resolv.conf</code> 文件立刻得到更新。</p>
<p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dns&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code>。使用以下命令来证明其已经生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> ubuntu:18.04  <span class="built_in">cat</span> etc/resolv.conf</span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>

<p>如果用户想要手动指定容器的配置，可以在使用 <code>docker run</code> 命令启动容器时加入如下参数：</p>
<ul>
<li><p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p>
</li>
<li><p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p>
</li>
<li><p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p>
</li>
</ul>
<blockquote>
<p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 <code>/etc/resolv.conf</code> 来配置容器。</p>
</blockquote>
<h1 id="高级网络配置"><a href="#高级网络配置" class="headerlink" title="高级网络配置"></a>高级网络配置</h1><p>本章将介绍 Docker 的一些高级网络配置和选项。</p>
<p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>
<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href="https://datatracker.ietf.org/doc/html/rfc1918">RFC1918</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>
<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>
<p><img src="/2022/docker_practice/network.png" alt="Docker 网络"></p>
<p>接下来的部分将介绍在一些场景中，Docker 所有的网络定制配置。以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置。</p>
<h2 id="快速配置指南"><a href="#快速配置指南" class="headerlink" title="快速配置指南"></a>快速配置指南</h2><p><code>dockerd</code>命令可以设置Docker网络相关的配置。</p>
<p>以下选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效：</p>
<ul>
<li><code>-b BRIDGE</code> 或 <code>--bridge=BRIDGE</code> 指定容器挂载的网桥</li>
<li><code>--bip=CIDR</code> 定制 docker0 的掩码</li>
<li><code>-H SOCKET...</code> 或 <code>--host=SOCKET...</code> Docker 服务端接收命令的通道</li>
<li><code>--icc=true|false</code> 是否支持容器之间进行通信</li>
<li><code>--ip-forward=true|false</code> 请看下文容器之间的通信</li>
<li><code>--iptables=true|false</code> 是否允许 Docker 添加 iptables 规则</li>
<li><code>--mtu=BYTES</code> 容器网络中的 MTU</li>
</ul>
<p>下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker 服务启动的时候指定则会成为默认值，后面执行 <code>docker run</code> 时可以覆盖设置的默认值。</p>
<ul>
<li><code>--dns=IP_ADDRESS...</code> 使用指定的DNS服务器</li>
<li><code>--dns-search=DOMAIN...</code> 指定DNS搜索域</li>
</ul>
<p>以下这些选项只有在 <code>docker run</code> 执行时使用，因为它是针对容器的特性内容。</p>
<ul>
<li><code>-h HOSTNAME</code> 或 <code>--hostname=HOSTNAME</code> 配置容器主机名</li>
<li><code>--link=CONTAINER_NAME:ALIAS</code> 添加到另一个容器的连接</li>
<li><code>--net=bridge|none|container:NAME_or_ID|host</code> 配置容器的桥接模式</li>
<li><code>-p SPEC</code> 或 <code>--publish=SPEC</code> 映射容器端口到宿主主机</li>
<li><code>-P or --publish-all=true|false</code> 映射容器所有端口到宿主主机</li>
</ul>
<h2 id="容器访问控制"><a href="#容器访问控制" class="headerlink" title="容器访问控制"></a>容器访问控制</h2><p>容器的访问控制，主要通过 Linux 上的 <code>iptables</code> 防火墙来进行管理和实现。<code>iptables</code> 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。</p>
<h3 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h3><p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sysctl</span> net.ipv4.ip_forward</span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure>
<p>如果为 0，说明没有开启转发，则需要手动打开。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sysctl</span> -w net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure>
<p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code> 参数为 1。</p>
<h3 id="容器之间访问"><a href="#容器之间访问" class="headerlink" title="容器之间访问"></a>容器之间访问</h3><p>容器之间相互访问，需要两方面的支持：</p>
<ul>
<li>容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 <code>docker0</code> 网桥上。</li>
<li>本地系统的防火墙软件 – <code>iptables</code> 是否允许通过。</li>
</ul>
<h4 id="访问所有端口"><a href="#访问所有端口" class="headerlink" title="访问所有端口"></a>访问所有端口</h4><p>当启动 Docker 服务（即 dockerd）的时候，默认会添加一条转发策略到本地主机 iptables 的 FORWARD 链上。策略为通过（<code>ACCEPT</code>）还是禁止（<code>DROP</code>）取决于配置<code>--icc=true</code>（缺省值）还是 <code>--icc=false</code>。当然，如果手动指定 <code>--iptables=false</code> 则不会添加 <code>iptables</code> 规则。</p>
<p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 <code>/etc/docker/daemon.json</code> 文件中配置 <code>&#123;&quot;icc&quot;: false&#125;</code> 来禁止它。</p>
<h4 id="访问指定端口"><a href="#访问指定端口" class="headerlink" title="访问指定端口"></a>访问指定端口</h4><p>在通过 <code>-icc=false</code> 关闭网络访问后，还可以通过 <code>--link=CONTAINER_NAME:ALIAS</code> 选项来访问容器的开放端口。</p>
<p>例如，在启动 Docker 服务时，可以同时使用 <code>icc=false --iptables=true</code> 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 <code>iptables</code> 规则。</p>
<p>此时，系统中的 <code>iptables</code> 规则可能是类似</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo iptables -nL</span><br><span class="line">...</span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>之后，启动容器（<code>docker run</code>）时使用 <code>--link=CONTAINER_NAME:ALIAS</code> 选项。Docker 会在 <code>iptables</code> 中为 两个容器分别添加一条 <code>ACCEPT</code> 规则，允许相互访问开放的端口（取决于 <code>Dockerfile</code> 中的 <code>EXPOSE</code> 指令）。</p>
<p>当添加了 <code>--link=CONTAINER_NAME:ALIAS</code> 选项后，添加了 <code>iptables</code> 规则。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo iptables -nL</span><br><span class="line">...</span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">ACCEPT     tcp  --  172.17.0.2           172.17.0.3           tcp spt:80</span><br><span class="line">ACCEPT     tcp  --  172.17.0.3           172.17.0.2           tcp dpt:80</span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>

<p>注意：<code>--link=CONTAINER_NAME:ALIAS</code> 中的 <code>CONTAINER_NAME</code> 目前必须是 Docker 分配的名字，或使用 <code>--name</code> 参数指定的名字。主机名则不会被识别。</p>
<h2 id="映射容器端口到宿主主机"><a href="#映射容器端口到宿主主机" class="headerlink" title="映射容器端口到宿主主机"></a>映射容器端口到宿主主机</h2><p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p>
<h3 id="容器访问外部实现"><a href="#容器访问外部实现" class="headerlink" title="容器访问外部实现"></a>容器访问外部实现</h3><p>容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 <code>iptables</code> 的源地址伪装实现的。</p>
<p>查看主机的 NAT 规则。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo iptables -t nat -nL</span><br><span class="line">...</span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16       !172.17.0.0/16</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中，上述规则将所有源地址在 <code>172.17.0.0/16</code> 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</p>
<h3 id="外部访问容器实现"><a href="#外部访问容器实现" class="headerlink" title="外部访问容器实现"></a>外部访问容器实现</h3><p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。不管用那种办法，其实也是在本地的 <code>iptable</code> 的 nat 表中添加相应的规则。</p>
<p>使用 <code>-P</code> 时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iptables -t nat -nL</span><br><span class="line">...</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:49153 to:172.17.0.2:80</span><br></pre></td></tr></table></figure>

<p>使用 <code>-p 80:80</code> 时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iptables -t nat -nL</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>这里的规则映射了 <code>0.0.0.0</code>，意味着将接受主机来自所有接口的流量。用户可以通过 <code>-p IP:host_port:container_port</code> 或 <code>-p IP::port</code> 来指定允许访问容器的主机上的 IP、接口等，以制定更严格的规则。</p>
</li>
<li><p>如果希望永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容。</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置-docker0-网桥"><a href="#配置-docker0-网桥" class="headerlink" title="配置 docker0 网桥"></a>配置 <code>docker0</code> 网桥</h2><p>Docker 服务默认会创建一个 <code>docker0</code> 网桥（其上有一个 <code>docker0</code> 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p>
<p>Docker 默认指定了 <code>docker0</code> 接口 的 IP 地址、子网掩码、MTU、默认路由，让主机和容器之间可以通过网桥相互通信。<strong>这些值都可以在服务启动的时候进行配置：</strong></p>
<ul>
<li><code>--bip=CIDR</code> IP 地址加掩码格式，例如 192.168.1.5&#x2F;24</li>
<li><code>--mtu=BYTES</code> 覆盖默认的 Docker mtu 配置</li>
</ul>
<p><strong>也可以在配置文件中配置 DOCKER_OPTS，然后重启服务。</strong></p>
<p>由于目前 Docker 网桥是 Linux 网桥，用户可以使用 <code>brctl show</code> 来查看网桥和端口连接信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo brctl show</span><br><span class="line">bridge name     bridge <span class="built_in">id</span>               STP enabled     interfaces</span><br><span class="line">docker0         8000.3a1d7362b4ee       no              veth65f9</span><br><span class="line">                                             vethdda6</span><br></pre></td></tr></table></figure>
<p>*注：<code>brctl</code> 命令在 Debian、Ubuntu 中可以使用 <code>sudo apt-get install bridge-utils</code> 来安装。</p>
<p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -i -t --<span class="built_in">rm</span> base /bin/bash</span><br><span class="line">$ ip addr show eth0</span><br><span class="line">24: eth0: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 32:6f:e0:35:57:91 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.3/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::306f:e0ff:fe35:5791/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">$ ip route</span><br><span class="line">default via 172.17.42.1 dev eth0</span><br><span class="line">172.17.0.0/16 dev eth0  proto kernel  scope <span class="built_in">link</span>  src 172.17.0.3</span><br></pre></td></tr></table></figure>


<h2 id="自定义网桥"><a href="#自定义网桥" class="headerlink" title="自定义网桥"></a>自定义网桥</h2><p>除了默认的 <code>docker0</code> 网桥，用户也可以指定网桥来连接各个容器。</p>
<p>在启动 Docker 服务的时候，使用 <code>-b BRIDGE</code>或<code>--bridge=BRIDGE</code> 来指定使用的网桥。</p>
<p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl stop docker</span><br><span class="line">$ sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev docker0 down</span><br><span class="line">$ sudo brctl delbr docker0</span><br></pre></td></tr></table></figure>

<p>然后创建一个网桥 <code>bridge0</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo brctl addbr bridge0</span><br><span class="line">$ sudo ip addr add 192.168.5.1/24 dev bridge0</span><br><span class="line">$ sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev bridge0 up</span><br></pre></td></tr></table></figure>

<p>查看确认网桥创建并启动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip addr show bridge0</span><br><span class="line">4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.5.1/24 scope global bridge0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>启动 Docker 服务。</p>
<p>新建一个容器，可以看到它已经桥接到了 <code>bridge0</code> 上。</p>
<p>可以继续用 <code>brctl show</code> 命令查看桥接的信息。另外，在容器中可以使用 <code>ip addr</code> 和 <code>ip route</code> 命令来查看 IP 地址配置和路由信息。</p>
<h2 id="工具和示例"><a href="#工具和示例" class="headerlink" title="工具和示例"></a>工具和示例</h2><p>在介绍自定义网络拓扑之前，你可能会对一些外部工具和例子感兴趣：</p>
<h3 id="pipework"><a href="#pipework" class="headerlink" title="pipework"></a>pipework</h3><p>Jérôme Petazzoni 编写了一个叫 <a href="https://github.com/jpetazzo/pipework">pipework</a> 的 shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。</p>
<h3 id="playground"><a href="#playground" class="headerlink" title="playground"></a>playground</h3><p>Brandon Rhodes 创建了一个提供完整的 Docker 容器网络拓扑管理的 <a href="https://github.com/brandon-rhodes/fopnp/tree/m/playground">Python库</a>，包括路由、NAT 防火墙；以及一些提供 <code>HTTP</code> <code>SMTP</code> <code>POP</code> <code>IMAP</code> <code>Telnet</code> <code>SSH</code> <code>FTP</code> 的服务器。</p>
<h2 id="编辑网络配置文件"><a href="#编辑网络配置文件" class="headerlink" title="编辑网络配置文件"></a>编辑网络配置文件</h2><p>Docker 1.2.0 开始支持在运行中的容器里编辑 <code>/etc/hosts</code>, <code>/etc/hostname</code> 和 <code>/etc/resolv.conf</code> 文件。</p>
<p><strong>但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来，也不会被 <code>docker commit</code> 提交。</strong></p>
<h2 id="示例：创建一个点到点连接"><a href="#示例：创建一个点到点连接" class="headerlink" title="示例：创建一个点到点连接"></a>示例：创建一个点到点连接</h2><p>默认情况下，Docker 会将所有容器连接到由 <code>docker0</code> 提供的虚拟子网中。</p>
<p>用户有时候需要两个容器之间可以直连通信，而不用通过主机网桥进行桥接。</p>
<p>解决办法很简单：创建一对 <code>peer</code> 接口，分别放到两个容器中，配置成点到点链路类型即可。</p>
<p>首先启动 2 个容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -i -t --<span class="built_in">rm</span> --net=none base /bin/bash</span><br><span class="line">root@1f1f4c1f931a:/<span class="comment">#</span></span><br><span class="line">$ docker run -i -t --<span class="built_in">rm</span> --net=none base /bin/bash</span><br><span class="line">root@12e343489d2f:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>找到进程号，然后创建网络命名空间的跟踪文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> 1f1f4c1f931a</span><br><span class="line">2989</span><br><span class="line">$ docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> 12e343489d2f</span><br><span class="line">3004</span><br><span class="line">$ sudo <span class="built_in">mkdir</span> -p /var/run/netns</span><br><span class="line">$ sudo <span class="built_in">ln</span> -s /proc/2989/ns/net /var/run/netns/2989</span><br><span class="line">$ sudo <span class="built_in">ln</span> -s /proc/3004/ns/net /var/run/netns/3004</span><br></pre></td></tr></table></figure>

<p>创建一对 <code>peer</code> 接口，然后配置路由</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ip <span class="built_in">link</span> add A <span class="built_in">type</span> veth peer name B</span><br><span class="line">$ sudo ip <span class="built_in">link</span> <span class="built_in">set</span> A netns 2989</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> 2989 ip addr add 10.1.1.1/32 dev A</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> 2989 ip <span class="built_in">link</span> <span class="built_in">set</span> A up</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> 2989 ip route add 10.1.1.2/32 dev A</span><br><span class="line">$ sudo ip <span class="built_in">link</span> <span class="built_in">set</span> B netns 3004</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> 3004 ip addr add 10.1.1.2/32 dev B</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> 3004 ip <span class="built_in">link</span> <span class="built_in">set</span> B up</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> 3004 ip route add 10.1.1.1/32 dev B</span><br></pre></td></tr></table></figure>
<p>现在这 2 个容器就可以相互 ping 通，并成功建立连接。点到点链路不需要子网和子网掩码。</p>
<p>此外，也可以不指定 <code>--net=none</code> 来创建点到点链路。这样容器还可以通过原先的网络来通信。</p>
<p>利用类似的办法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 <code>--icc=false</code> 来关闭容器之间的通信。</p>
<h1 id="Docker-Compose-项目"><a href="#Docker-Compose-项目" class="headerlink" title="Docker Compose 项目"></a>Docker Compose 项目</h1><p><code>Docker Compose</code> 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。</p>
<p>本章将介绍 <code>Compose</code> 项目情况以及安装和使用。</p>
<h2 id="Compose-简介"><a href="#Compose-简介" class="headerlink" title="Compose 简介"></a>Compose 简介</h2><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>
<p>其代码目前在 <a href="https://github.com/docker/compose">https://github.com/docker/compose</a> 上开源。</p>
<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>
<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>
<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li><p>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</p>
</li>
<li><p>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</p>
</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>
<h2 id="Compose-V2"><a href="#Compose-V2" class="headerlink" title="Compose V2"></a>Compose V2</h2><p>目前 Docker 官方用 GO 语言 <a href="https://github.com/docker/compose-cli">重写</a> 了 Docker Compose，并将其作为了 docker cli 的子命令，称为 <code>Compose V2</code>。你可以参照官方文档安装，然后将熟悉的 <code>docker-compose</code> 命令替换为 <code>docker compose</code>，即可使用 Docker Compose。</p>
<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><ul>
<li><a href="https://docs.docker.com/compose/cli-command/">Compose V2 beta</a></li>
<li><a href="https://github.com/docker/compose">https://github.com/docker/compose</a></li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>首先介绍几个术语。</p>
<ul>
<li><p>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</p>
</li>
<li><p>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。</p>
</li>
</ul>
<p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<p>下面我们用 <code>Python</code> 来建立一个能够记录页面访问次数的 web 网站。</p>
<h4 id="web-应用"><a href="#web-应用" class="headerlink" title="web 应用"></a>web 应用</h4><p>新建文件夹，在该目录中编写 <code>app.py</code> 文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    count = redis.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! 该页面已被访问 &#123;&#125; 次。\n&#x27;</span>.<span class="built_in">format</span>(count)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>编写 <code>Dockerfile</code> 文件，内容为</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span>-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install redis flask</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><p>编写 <code>docker-compose.yml</code> 文件，这个是 Compose 使用的主模板文件。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="运行-compose-项目"><a href="#运行-compose-项目" class="headerlink" title="运行 compose 项目"></a>运行 compose 项目</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose up</span><br></pre></td></tr></table></figure>

<p>此时访问本地 <code>5000</code> 端口，每次刷新页面，计数就会加 1。</p>
<h2 id="Compose-命令说明"><a href="#Compose-命令说明" class="headerlink" title="Compose 命令说明"></a>Compose 命令说明</h2><h3 id="命令对象与格式"><a href="#命令对象与格式" class="headerlink" title="命令对象与格式"></a>命令对象与格式</h3><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>
<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>
<p><code>docker-compose</code> 命令的基本的使用格式是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure>

<h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><ul>
<li><p><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</p>
</li>
<li><p><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</p>
</li>
<li><p><code>--verbose</code> 输出更多调试信息。</p>
</li>
<li><p><code>-v, --version</code> 打印版本并退出。</p>
</li>
</ul>
<h3 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h3><h4 id="build"><a href="#build" class="headerlink" title="build"></a><code>build</code></h4><p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p>
<p>构建（重新构建）项目中的服务容器。</p>
<p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p>
<p>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p>
<p>选项包括：</p>
<ul>
<li><p><code>--force-rm</code> 删除构建过程中的临时容器。</p>
</li>
<li><p><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</p>
</li>
<li><p><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</p>
</li>
</ul>
<h4 id="config"><a href="#config" class="headerlink" title="config"></a><code>config</code></h4><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>
<h4 id="down"><a href="#down" class="headerlink" title="down"></a><code>down</code></h4><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h4><p>进入指定的容器。</p>
<h4 id="help"><a href="#help" class="headerlink" title="help"></a><code>help</code></h4><p>获得一个命令的帮助。</p>
<h4 id="images"><a href="#images" class="headerlink" title="images"></a><code>images</code></h4><p>列出 Compose 文件中包含的镜像。</p>
<h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a><code>kill</code></h4><p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p>
<p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p>
<p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">kill</span> -s SIGINT</span><br></pre></td></tr></table></figure>

<h4 id="logs"><a href="#logs" class="headerlink" title="logs"></a><code>logs</code></h4><p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p>
<p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p>
<p>该命令在调试问题的时候十分有用。</p>
<h4 id="pause"><a href="#pause" class="headerlink" title="pause"></a><code>pause</code></h4><p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p>
<p>暂停一个服务容器。</p>
<h4 id="port"><a href="#port" class="headerlink" title="port"></a><code>port</code></h4><p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p>
<p>打印某个容器端口所映射的公共端口。</p>
<p>选项：</p>
<ul>
<li><p><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</p>
</li>
<li><p><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</p>
</li>
</ul>
<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a><code>ps</code></h4><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>
<p>列出项目中目前的所有容器。</p>
<p>选项：</p>
<ul>
<li><code>-q</code> 只打印容器的 ID 信息。</li>
</ul>
<h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a><code>pull</code></h4><p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p>
<p>拉取服务依赖的镜像。</p>
<p>选项：</p>
<ul>
<li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li>
</ul>
<h4 id="push"><a href="#push" class="headerlink" title="push"></a><code>push</code></h4><p>推送服务依赖的镜像到 Docker 镜像仓库。</p>
<h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a><code>restart</code></h4><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>
<p>重启项目中的服务。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>
</ul>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h4><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>
<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>
<p>选项：</p>
<ul>
<li><p><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</p>
</li>
<li><p><code>-v</code> 删除容器所挂载的数据卷。</p>
</li>
</ul>
<h4 id="run"><a href="#run" class="headerlink" title="run"></a><code>run</code></h4><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p>
<p>在指定服务上执行一个命令。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose run ubuntu ping docker.com</span><br></pre></td></tr></table></figure>

<p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p>
<p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p>
<p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p>
<p>两个不同点：</p>
<ul>
<li><p>给定命令将会覆盖原有的自动运行命令；</p>
</li>
<li><p>不会自动创建端口，以避免冲突。</p>
</li>
</ul>
<p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose run --no-deps web python manage.py shell</span><br></pre></td></tr></table></figure>

<p>将不会启动 web 容器所关联的其它容器。</p>
<p>选项：</p>
<ul>
<li><p><code>-d</code> 后台运行容器。</p>
</li>
<li><p><code>--name NAME</code> 为容器指定一个名字。</p>
</li>
<li><p><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</p>
</li>
<li><p><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</p>
</li>
<li><p><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</p>
</li>
<li><p><code>--no-deps</code> 不自动启动关联的服务容器。</p>
</li>
<li><p><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</p>
</li>
<li><p><code>-p, --publish=[]</code> 映射容器端口到本地主机。</p>
</li>
<li><p><code>--service-ports</code> 配置服务端口并映射到本地主机。</p>
</li>
<li><p><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</p>
</li>
</ul>
<h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a><code>scale</code></h4><blockquote>
<p><strong>Deprecated in docker-compose v2 (use <code>compose up --scale</code> instead)</strong></p>
</blockquote>
<p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p>
<p>设置指定服务运行的容器个数。</p>
<p>通过 <code>service=num</code> 的参数来设置数量。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose scale web=3 db=2</span><br></pre></td></tr></table></figure>

<p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p>
<p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<h4 id="start"><a href="#start" class="headerlink" title="start"></a><code>start</code></h4><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>
<p>启动已经存在的服务容器。</p>
<h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a><code>stop</code></h4><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>
<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h4><p>查看各个服务容器内运行的进程。</p>
<h4 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a><code>unpause</code></h4><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>
<p>恢复处于暂停状态中的服务。</p>
<h4 id="up"><a href="#up" class="headerlink" title="up"></a><code>up</code></h4><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>
<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
<p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>
<p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>
<p>选项：</p>
<ul>
<li><p><code>-d</code> 在后台运行服务容器。</p>
</li>
<li><p><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</p>
</li>
<li><p><code>--no-deps</code> 不启动服务所链接的容器。</p>
</li>
<li><p><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</p>
</li>
<li><p><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</p>
</li>
<li><p><code>--no-build</code> 不自动构建缺失的服务镜像。</p>
</li>
<li><p><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</p>
</li>
</ul>
<h4 id="version"><a href="#version" class="headerlink" title="version"></a><code>version</code></h4><p>格式为 <code>docker-compose version</code>。</p>
<p>打印版本信息。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://docs.docker.com/compose/reference/overview/">官方文档</a></li>
</ul>
<h2 id="Compose-模板文件"><a href="#Compose-模板文件" class="headerlink" title="Compose 模板文件"></a>Compose 模板文件</h2><p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p>
<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">examples/web</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/data&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>
<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>
<p>下面分别介绍各个指令的用法。</p>
<h3 id="build-1"><a href="#build-1" class="headerlink" title="build"></a><code>build</code></h3><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./dir</span></span><br></pre></td></tr></table></figure>

<p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>
<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>
<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./dir</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">buildno:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>cache_from</code> 指定构建镜像的缓存</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">cache_from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">alpine:latest</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">corp/web_app:3.14</span></span><br></pre></td></tr></table></figure>

<h3 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a><code>cap_add, cap_drop</code></h3><p>指定容器的内核能力（capacity）分配。</p>
<p>例如，让容器拥有所有能力可以指定为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cap_add:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ALL</span></span><br></pre></td></tr></table></figure>

<p>去掉 NET_ADMIN 能力可以指定为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cap_drop:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br></pre></td></tr></table></figure>

<h3 id="command"><a href="#command" class="headerlink" title="command"></a><code>command</code></h3><p>覆盖容器启动后默认执行的命令。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="string">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="configs"><a href="#configs" class="headerlink" title="configs"></a><code>configs</code></h3><p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a href="../swarm_mode/"><code>Swarm mode</code></a> 一节。</p>
<h3 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a><code>cgroup_parent</code></h3><p>指定父 <code>cgroup</code> 组，意味着将继承该组的资源限制。</p>
<p>例如，创建了一个 cgroup 组名称为 <code>cgroups_1</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cgroup_parent:</span> <span class="string">cgroups_1</span></span><br></pre></td></tr></table></figure>

<h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a><code>container_name</code></h3><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">container_name:</span> <span class="string">docker-web-container</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>
</blockquote>
<h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a><code>deploy</code></h3><p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a href="../swarm_mode/"><code>Swarm mode</code></a> 一节</p>
<h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a><code>devices</code></h3><p>指定设备映射关系。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">devices:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;/dev/ttyUSB1:/dev/ttyUSB0&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a><code>depends_on</code></h3><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p>
</blockquote>
<h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a><code>dns</code></h3><p>自定义 <code>DNS</code> 服务器。可以是一个值，也可以是一个列表。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dns:</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br></pre></td></tr></table></figure>

<h3 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a><code>dns_search</code></h3><p>配置 <code>DNS</code> 搜索域。可以是一个值，也可以是一个列表。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dns_search:</span> <span class="string">example.com</span></span><br><span class="line"><span class="attr">dns_search:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain1.example.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">domain2.example.com</span></span><br></pre></td></tr></table></figure>

<h3 id="tmpfs-1"><a href="#tmpfs-1" class="headerlink" title="tmpfs"></a><code>tmpfs</code></h3><p>挂载一个 tmpfs 文件系统到容器。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tmpfs:</span> <span class="string">/run</span></span><br><span class="line"><span class="attr">tmpfs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/run</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/tmp</span></span><br></pre></td></tr></table></figure>

<h3 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a><code>env_file</code></h3><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>
<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>
<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">env_file: .<span class="built_in">env</span></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure>

<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure>

<h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a><code>environment</code></h3><p>设置环境变量。你可以使用数组或字典两种格式。</p>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">RACK_ENV:</span> <span class="string">development</span></span><br><span class="line">  <span class="attr">SESSION_SECRET:</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RACK_ENV=development</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SESSION_SECRET</span></span><br></pre></td></tr></table></figure>

<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">y|Y|<span class="built_in">yes</span>|Yes|YES|n|N|no|No|NO|<span class="literal">true</span>|True|TRUE|<span class="literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure>

<h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a><code>expose</code></h3><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>
<p>仅可以指定内部端口为参数</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">expose:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a><code>external_links</code></h3><blockquote>
<p>注意：不建议使用该指令。</p>
</blockquote>
<p>链接到 <code>docker-compose.yml</code> 外部的容器，甚至并非 <code>Compose</code> 管理的外部容器。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">external_links:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">redis_1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">project_db_1:mysql</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">project_db_1:postgresql</span></span><br></pre></td></tr></table></figure>

<h3 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a><code>extra_hosts</code></h3><p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;googledns:8.8.8.8&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;dockerhub:52.1.157.61&quot;</span></span><br></pre></td></tr></table></figure>

<p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure>

<h3 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a><code>healthcheck</code></h3><p>通过命令检查容器是否健康运行。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line">  <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h3><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">orchardup/postgresql</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">a4bc65fd</span></span><br></pre></td></tr></table></figure>

<h3 id="labels"><a href="#labels" class="headerlink" title="labels"></a><code>labels</code></h3><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="attr">com.startupteam.description:</span> <span class="string">&quot;webapp for a startup team&quot;</span></span><br><span class="line">  <span class="attr">com.startupteam.department:</span> <span class="string">&quot;devops department&quot;</span></span><br><span class="line">  <span class="attr">com.startupteam.release:</span> <span class="string">&quot;rc3 for v1.0&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="links"><a href="#links" class="headerlink" title="links"></a><code>links</code></h3><blockquote>
<p>注意：不推荐使用该指令。</p>
</blockquote>
<h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a><code>logging</code></h3><p>配置日志选项。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">syslog</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">syslog-address:</span> <span class="string">&quot;tcp://192.168.0.42:123&quot;</span></span><br></pre></td></tr></table></figure>

<p>目前支持三种日志驱动类型。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver:</span> <span class="string">&quot;json-file&quot;</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">&quot;syslog&quot;</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">&quot;none&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>options</code> 配置日志驱动的相关参数。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">options:</span></span><br><span class="line">  <span class="attr">max-size:</span> <span class="string">&quot;200k&quot;</span></span><br><span class="line">  <span class="attr">max-file:</span> <span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a><code>network_mode</code></h3><p>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;bridge&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;none&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;service:[service name]&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;container:[container name/id]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="networks"><a href="#networks" class="headerlink" title="networks"></a><code>networks</code></h3><p>配置容器连接的网络。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">some-service:</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">some-network</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">other-network</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">some-network:</span></span><br><span class="line">  <span class="attr">other-network:</span></span><br></pre></td></tr></table></figure>

<h3 id="pid"><a href="#pid" class="headerlink" title="pid"></a><code>pid</code></h3><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pid:</span> <span class="string">&quot;host&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a><code>ports</code></h3><p>暴露端口信息。</p>
<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;49100:22&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:8001:8001&quot;</span></span><br></pre></td></tr></table></figure>

<p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>
<h3 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a><code>secrets</code></h3><p>存储敏感数据，例如 <code>mysql</code> 服务密码。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.1&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/db_root_password</span></span><br><span class="line">  <span class="attr">secrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">db_root_password</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my_other_secret</span></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line">  <span class="attr">my_secret:</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">./my_secret.txt</span></span><br><span class="line">  <span class="attr">my_other_secret:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a><code>security_opt</code></h3><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">security_opt:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">label:user:USER</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">label:role:ROLE</span></span><br></pre></td></tr></table></figure>

<h3 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a><code>stop_signal</code></h3><p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stop_signal:</span> <span class="string">SIGUSR1</span></span><br></pre></td></tr></table></figure>

<h3 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a><code>sysctls</code></h3><p>配置容器内核参数。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="attr">net.core.somaxconn:</span> <span class="number">1024</span></span><br><span class="line">  <span class="attr">net.ipv4.tcp_syncookies:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.core.somaxconn=1024</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.ipv4.tcp_syncookies=0</span></span><br></pre></td></tr></table></figure>

<h3 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a><code>ulimits</code></h3><p>指定容器的 ulimits 限制值。</p>
<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line">  <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">  <span class="attr">nofile:</span></span><br><span class="line">    <span class="attr">soft:</span> <span class="number">20000</span></span><br><span class="line">    <span class="attr">hard:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure>

<h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a><code>volumes</code></h3><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>
<p>该指令中路径支持相对路径。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cache/:/tmp/cache</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">~/configs:/etc/configs/:ro</span></span><br></pre></td></tr></table></figure>

<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my_src:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span>  </span><br></pre></td></tr></table></figure>

<h3 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h3><p>此外，还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令，基本跟 <code>docker run</code> 中对应参数的功能一致。</p>
<p>指定服务容器启动后执行的入口文件。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">entrypoint:</span> <span class="string">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure>

<p>指定容器中运行应用的用户名。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">user:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<p>指定容器中工作目录。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">working_dir:</span> <span class="string">/code</span></span><br></pre></td></tr></table></figure>

<p>指定容器中搜索域名、主机名、mac 地址等。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">domainname:</span> <span class="string">your_website.com</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">mac_address:</span> <span class="number">08</span><span class="number">-00</span><span class="number">-27</span><span class="number">-00</span><span class="string">-0C-0A</span></span><br></pre></td></tr></table></figure>

<p>允许容器中运行一些特权命令。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">read_only:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>打开标准输入，可以接受外部输入。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stdin_open:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>模拟一个伪终端。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h3><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。</p>
<p>例如，下面的 Compose 文件将从运行它的环境中读取变量 <code>$&#123;MONGO_VERSION&#125;</code> 的值，并写入执行的指令中。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">&quot;mongo:$&#123;MONGO_VERSION&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果执行 <code>MONGO_VERSION=3.2 docker-compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code>MONGO_VERSION=2.8 docker-compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器。</p>
<p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker-compose</code> 命令时将从该文件中读取变量。</p>
<p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 支持 # 号注释</span></span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure>

<p>执行 <code>docker-compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p>
<h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://docs.docker.com/compose/compose-file/">官方文档</a></li>
<li><a href="https://github.com/docker/awesome-compose">awesome-compose</a></li>
</ul>
<h2 id="使用-Django"><a href="#使用-Django" class="headerlink" title="使用 Django"></a>使用 Django</h2><blockquote>
<p>本小节内容适合 <code>Python</code> 开发人员阅读。</p>
</blockquote>
<p>我们现在将使用 <code>Docker Compose</code> 配置并运行一个 <code>Django/PostgreSQL</code> 应用。</p>
<p>在一切工作开始前，需要先编辑好三个必要的文件。</p>
<p>第一步，因为应用将要运行在一个满足所有环境依赖的 Docker 容器里面，那么我们可以通过编辑 <code>Dockerfile</code> 文件来指定 Docker 容器要安装内容。内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3</span></span><br><span class="line"><span class="keyword">ENV</span> PYTHONUNBUFFERED <span class="number">1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt /code/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /code/</span></span><br></pre></td></tr></table></figure>

<p>以上内容指定应用将使用安装了 Python 以及必要依赖包的镜像。更多关于如何编写 <code>Dockerfile</code> 文件的信息可以查看 <a href="../image/dockerfile/README.md"> Dockerfile 使用</a>。</p>
<p>第二步，在 <code>requirements.txt</code> 文件里面写明需要安装的具体依赖包名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Django&gt;=2.0,&lt;3.0</span><br><span class="line">psycopg2&gt;=2.7,&lt;3.0</span><br></pre></td></tr></table></figure>

<p>第三步，<code>docker-compose.yml</code> 文件将把所有的东西关联起来。它描述了应用的构成（一个 web 服务和一个数据库）、使用的 Docker 镜像、镜像之间的连接、挂载到容器的卷，以及服务开放的端口。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">&#x27;postgres&#x27;</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">python</span> <span class="string">manage.py</span> <span class="string">runserver</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:8000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br></pre></td></tr></table></figure>

<p>查看 <a href="compose_file.md"><code>docker-compose.yml</code> 章节</a> 了解更多详细的工作机制。</p>
<p>现在我们就可以使用 <code>docker-compose run</code> 命令启动一个 <code>Django</code> 应用了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose run web django-admin startproject django_example .</span><br></pre></td></tr></table></figure>

<p>由于 web 服务所使用的镜像并不存在，所以 Compose 会首先使用 <code>Dockerfile</code> 为 web 服务构建一个镜像，接着使用这个镜像在容器里运行 <code>django-admin startproject django_example</code> 指令。</p>
<p>这将在当前目录生成一个 <code>Django</code> 应用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">Dockerfile       docker-compose.yml          django_example       manage.py       requirements.txt</span><br></pre></td></tr></table></figure>

<p>如果你的系统是 Linux,记得更改文件权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">chown</span> -R <span class="variable">$USER</span>:<span class="variable">$USER</span> .</span><br></pre></td></tr></table></figure>

<p>首先，我们要为应用设置好数据库的连接信息。用以下内容替换 <code>django_example/settings.py</code> 文件中 <code>DATABASES = ...</code> 定义的节点内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.postgresql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;postgres&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;postgres&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;db&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="number">5432</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;postgres&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些信息是在 <a href="https://hub.docker.com/_/postgres/">postgres</a> 镜像固定设置好的。然后，运行 <code>docker-compose up</code> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose up</span><br><span class="line">django_db_1 is up-to-date</span><br><span class="line">Creating django_web_1 ...</span><br><span class="line">Creating django_web_1 ... <span class="keyword">done</span></span><br><span class="line">Attaching to django_db_1, django_web_1</span><br><span class="line">db_1   | The files belonging to this database system will be owned by user <span class="string">&quot;postgres&quot;</span>.</span><br><span class="line">db_1   | This user must also own the server process.</span><br><span class="line">db_1   |</span><br><span class="line">db_1   | The database cluster will be initialized with locale <span class="string">&quot;en_US.utf8&quot;</span>.</span><br><span class="line">db_1   | The default database encoding has accordingly been <span class="built_in">set</span> to <span class="string">&quot;UTF8&quot;</span>.</span><br><span class="line">db_1   | The default text search configuration will be <span class="built_in">set</span> to <span class="string">&quot;english&quot;</span>.</span><br><span class="line">web_1  | Performing system checks...</span><br><span class="line">web_1  |</span><br><span class="line">web_1  | System check identified no issues (0 silenced).</span><br><span class="line">web_1  |</span><br><span class="line">web_1  | November 23, 2017 - 06:21:19</span><br><span class="line">web_1  | Django version 1.11.7, using settings <span class="string">&#x27;django_example.settings&#x27;</span></span><br><span class="line">web_1  | Starting development server at http://0.0.0.0:8000/</span><br><span class="line">web_1  | Quit the server with CONTROL-C.</span><br></pre></td></tr></table></figure>

<p>这个 <code>Django</code> 应用已经开始在你的 Docker 守护进程里监听着 <code>8000</code> 端口了。打开 <code>127.0.0.1:8000</code> 即可看到 <code>Django</code> 欢迎页面。</p>
<p>你还可以在 Docker 上运行其它的管理命令，例如对于同步数据库结构这种事，在运行完 <code>docker-compose up</code> 后，在另外一个终端进入文件夹运行以下命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose run web python manage.py syncdb</span><br></pre></td></tr></table></figure>

<h2 id="使用-Rails"><a href="#使用-Rails" class="headerlink" title="使用 Rails"></a>使用 Rails</h2><blockquote>
<p>本小节内容适合 <code>Ruby</code> 开发人员阅读。</p>
</blockquote>
<p>我们现在将使用 <code>Compose</code> 配置并运行一个 <code>Rails/PostgreSQL</code> 应用。</p>
<p>在一切工作开始前，需要先设置好三个必要的文件。</p>
<p>首先，因为应用将要运行在一个满足所有环境依赖的 Docker 容器里面，那么我们可以通过编辑 <code>Dockerfile</code> 文件来指定 Docker 容器要安装内容。内容如下：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ruby</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update -qq &amp;&amp; apt-get install -y build-essential libpq-dev</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /myapp</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /myapp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> Gemfile /myapp/Gemfile</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> bundle install</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /myapp</span></span><br></pre></td></tr></table></figure>

<p>以上内容指定应用将使用安装了 Ruby、Bundler 以及其依赖件的镜像。更多关于如何编写 Dockerfile 文件的信息可以查看 <a href="../image/dockerfile/README.md">Dockerfile 使用</a>。</p>
<p>下一步，我们需要一个引导加载 Rails 的文件 <code>Gemfile</code> 。 等一会儿它还会被 <code>rails new</code> 命令覆盖重写。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="string">&#x27;https://rubygems.org&#x27;</span></span><br><span class="line">gem <span class="string">&#x27;rails&#x27;</span>, <span class="string">&#x27;4.0.2&#x27;</span></span><br></pre></td></tr></table></figure>

<p>最后，<code>docker-compose.yml</code> 文件才是最神奇的地方。 <code>docker-compose.yml</code> 文件将把所有的东西关联起来。它描述了应用的构成（一个 web 服务和一个数据库）、每个镜像的来源（数据库运行在使用预定义的 PostgreSQL 镜像，web 应用侧将从本地目录创建）、镜像之间的连接，以及服务开放的端口。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5432&quot;</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rackup</span> <span class="string">-p</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/myapp</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br></pre></td></tr></table></figure>

<p>所有文件就绪后，我们就可以通过使用 <code>docker-compose run</code> 命令生成应用的骨架了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose run web rails new . --force --database=postgresql --skip-bundle</span><br></pre></td></tr></table></figure>

<p><code>Compose</code> 会先使用 <code>Dockerfile</code> 为 web 服务创建一个镜像，接着使用这个镜像在容器里运行 <code>rails new </code> 和它之后的命令。一旦这个命令运行完后，应该就可以看一个崭新的应用已经生成了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">Dockerfile   app          docker-compose.yml      tmp</span><br><span class="line">Gemfile      bin          lib          vendor</span><br><span class="line">Gemfile.lock condocker-compose       <span class="built_in">log</span></span><br><span class="line">README.rdoc  condocker-compose.ru    public</span><br><span class="line">Rakefile     db           <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>在新的 <code>Gemfile</code> 文件去掉加载 <code>therubyracer</code> 的行的注释，这样我们便可以使用 Javascript 运行环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gem <span class="string">&#x27;therubyracer&#x27;</span>, platforms: :ruby</span><br></pre></td></tr></table></figure>

<p>现在我们已经有一个新的 <code>Gemfile</code> 文件，需要再重新创建镜像。（这个会步骤会改变 Dockerfile 文件本身，所以需要重建一次）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose build</span><br></pre></td></tr></table></figure>

<p>应用现在就可以启动了，但配置还未完成。Rails 默认读取的数据库目标是 <code>localhost</code> ，我们需要手动指定容器的 <code>db</code> 。同样的，还需要把用户名修改成和 postgres 镜像预定的一致。<br>打开最新生成的 <code>database.yml</code> 文件。用以下内容替换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">development: &amp;default</span><br><span class="line">  adapter: postgresql</span><br><span class="line">  encoding: unicode</span><br><span class="line">  database: postgres</span><br><span class="line">  pool: 5</span><br><span class="line">  username: postgres</span><br><span class="line">  password:</span><br><span class="line">  host: db</span><br><span class="line"><span class="built_in">test</span>:</span><br><span class="line">  &lt;&lt;: *default</span><br><span class="line">  database: myapp_test</span><br></pre></td></tr></table></figure>

<p>现在就可以启动应用了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose up</span><br></pre></td></tr></table></figure>

<p>如果一切正常，你应该可以看到 PostgreSQL 的输出，几秒后可以看到这样的重复信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">myapp_web_1 | [2014-01-17 17:16:29] INFO  WEBrick 1.3.1</span><br><span class="line">myapp_web_1 | [2014-01-17 17:16:29] INFO  ruby 2.0.0 (2013-11-22) [x86_64-linux-gnu]</span><br><span class="line">myapp_web_1 | [2014-01-17 17:16:29] INFO  WEBrick::HTTPServer<span class="comment">#start: pid=1 port=3000</span></span><br></pre></td></tr></table></figure>

<p>最后， 我们需要做的是创建数据库，打开另一个终端，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose run web rake db:create</span><br></pre></td></tr></table></figure>

<p>这个 web 应用已经开始在你的 docker 守护进程里面监听着 3000 端口了。</p>
<h2 id="使用-WordPress"><a href="#使用-WordPress" class="headerlink" title="使用 WordPress"></a>使用 WordPress</h2><blockquote>
<p>本小节内容适合 <code>PHP</code> 开发人员阅读。</p>
</blockquote>
<p><code>Compose</code> 可以很便捷的让 <code>Wordpress</code> 运行在一个独立的环境中。</p>
<h3 id="创建空文件夹"><a href="#创建空文件夹" class="headerlink" title="创建空文件夹"></a>创建空文件夹</h3><p>假设新建一个名为 <code>wordpress</code> 的文件夹，然后进入这个文件夹。</p>
<h3 id="创建-docker-compose-yml-文件"><a href="#创建-docker-compose-yml-文件" class="headerlink" title="创建 docker-compose.yml 文件"></a>创建 <code>docker-compose.yml</code> 文件</h3><p><a href="https://github.com/yeasy/blob/master/compose/demo/wordpress/docker-compose.yml"><code>docker-compose.yml</code></a> 文件将开启一个 <code>wordpress</code> 服务和一个独立的 <code>MySQL</code> 实例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">   <span class="attr">db:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">     <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--default_authentication_plugin=mysql_native_password</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span>     </span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">db_data:/var/lib/mysql</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">       <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line">       <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">       <span class="attr">MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line">       <span class="attr">MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">   <span class="attr">wordpress:</span></span><br><span class="line">     <span class="attr">depends_on:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">wordpress:latest</span></span><br><span class="line">     <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;8000:80&quot;</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">db:3306</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db_data:</span></span><br></pre></td></tr></table></figure>

<h3 id="构建并运行项目"><a href="#构建并运行项目" class="headerlink" title="构建并运行项目"></a>构建并运行项目</h3><p>运行 <code>docker-compose up -d</code> Compose 就会拉取镜像再创建我们所需要的镜像，然后启动 <code>wordpress</code> 和数据库容器。 接着浏览器访问 <code>127.0.0.1:8000</code> 端口就能看到 <code>WordPress</code> 安装界面了。</p>
<h2 id="使用-compose-搭建-LNMP-环境"><a href="#使用-compose-搭建-LNMP-环境" class="headerlink" title="使用 compose 搭建 LNMP 环境"></a>使用 compose 搭建 LNMP 环境</h2><p>本项目的维护者 <a href="https://github.com/khs1994">khs1994</a> 的开源项目 <a href="https://github.com/khs1994-docker/lnmp">khs1994-docker&#x2F;lnmp</a> 使用 Docker Compose 搭建了一套 LNMP 环境，各位开发者可以参考该项目在 Docker 或 Kubernetes 中运行 LNMP。</p>
<h1 id="Swarm-mode"><a href="#Swarm-mode" class="headerlink" title="Swarm mode"></a>Swarm mode</h1><p>Docker 1.12 Swarm mode 已经内嵌入 Docker 引擎，成为了 docker 子命令 docker swarm。请注意与旧的 Docker Swarm 区分开来。</p>
<p>Swarm mode 内置 kv 存储功能，提供了众多的新特性，比如：具有容错能力的去中心化设计、内置服务发现、负载均衡、路由网格、动态伸缩、滚动更新、安全传输等。使得 Docker 原生的 Swarm 集群具备与 Mesos、Kubernetes 竞争的实力。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>Swarm</code> 是使用 <a href="https://github.com/docker/swarmkit/"><code>SwarmKit</code></a> 构建的 Docker 引擎内置（原生）的集群管理和编排工具。</p>
<p> 使用 <code>Swarm</code> 集群之前需要了解以下几个概念。</p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>运行 Docker 的主机可以主动初始化一个 <code>Swarm</code> 集群或者加入一个已存在的 <code>Swarm</code> 集群，这样这个运行 Docker 的主机就成为一个 <code>Swarm</code> 集群的节点 (<code>node</code>) 。</p>
<p>节点分为 <em><strong>管理 (<code>manager</code>) 节点</strong></em> 和 <em><strong>工作 (<code>worker</code>) 节点</strong></em>。</p>
<p>管理节点用于 <code>Swarm</code> 集群的管理，<code>docker swarm</code> 命令基本只能在管理节点执行（节点退出集群命令 <code>docker swarm leave</code> 可以在工作节点执行）。一个 <code>Swarm</code> 集群可以有多个管理节点，但只有一个管理节点可以成为 <code>leader</code>，<code>leader</code> 通过 <code>raft</code> 协议实现。</p>
<p>工作节点是任务执行节点，管理节点将服务 (<code>service</code>) 下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点。</p>
<p>来自 Docker 官网的这张图片形象的展示了集群中管理节点与工作节点的关系。</p>
<p><img src="/2022/docker_practice/swarm-diagram.png"></p>
<h3 id="服务和任务"><a href="#服务和任务" class="headerlink" title="服务和任务"></a>服务和任务</h3><p>***任务 （<code>Task</code>）***是 <code>Swarm</code> 中的最小的调度单位，目前来说就是一个单一的容器。</p>
<p><em><strong>服务 （<code>Services</code>）</strong></em> 是指一组任务的集合，服务定义了任务的属性。服务有2种模式：</p>
<ul>
<li><p><code>replicated services</code> 按照一定规则在各个工作节点上运行指定个数的任务。</p>
</li>
<li><p><code>global services</code> 每个工作节点上运行一个任务</p>
</li>
</ul>
<p>2种模式通过 <code>docker service create</code> 的 <code>--mode</code> 参数指定。</p>
<p>来自 Docker 官网的这张图片形象的展示了容器、任务、服务的关系。</p>
<p><img src="/2022/docker_practice/services-diagram-16509012472675.png"></p>
<h2 id="创建-Swarm-集群"><a href="#创建-Swarm-集群" class="headerlink" title="创建 Swarm 集群"></a>创建 Swarm 集群</h2><p>阅读 <a href="overview.md">基本概念</a> 一节我们知道 <code>Swarm</code> 集群由 <strong>管理节点</strong> 和 <strong>工作节点</strong> 组成。本节我们来创建一个包含一个管理节点和两个工作节点的最小 <code>Swarm</code> 集群。</p>
<h3 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h3><p>在已经安装好 Docker 的主机上执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker swarm init --advertise-addr 192.168.99.100</span><br><span class="line">Swarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.</span><br><span class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line">    docker swarm <span class="built_in">join</span> \</span><br><span class="line">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">To add a manager to this swarm, run <span class="string">&#x27;docker swarm join-token manager&#x27;</span> and follow the instructions.</span><br></pre></td></tr></table></figure>

<p>如果你的 Docker 主机有多个网卡，拥有多个 IP，必须使用 <code>--advertise-addr</code> 指定 IP。</p>
<blockquote>
<p>执行 <code>docker swarm init</code> 命令的节点自动成为管理节点。</p>
</blockquote>
<h3 id="增加工作节点"><a href="#增加工作节点" class="headerlink" title="增加工作节点"></a>增加工作节点</h3><p>上一步我们初始化了一个 <code>Swarm</code> 集群，拥有了一个管理节点，下面我们继续在两个 Docker 主机中分别执行如下命令，创建工作节点并加入到集群中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker swarm <span class="built_in">join</span> \</span><br><span class="line">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure>

<h3 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h3><p>经过上边的两步，我们已经拥有了一个最小的 <code>Swarm</code> 集群，包含一个管理节点和两个工作节点。</p>
<p>在管理节点使用 <code>docker node ls</code> 查看集群。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker node <span class="built_in">ls</span></span><br><span class="line">ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS</span><br><span class="line">03g1y59jwfg7cf99w4lt0f662    worker2   Ready   Active</span><br><span class="line">9j68exjopxe7wfl6yuxml7a7j    worker1   Ready   Active</span><br><span class="line">dxn1zf6l61qsb1josjja83ngz *  manager   Ready   Active        Leader</span><br></pre></td></tr></table></figure>

<h2 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h2><p>我们使用 <code>docker service</code> 命令来管理 <code>Swarm</code> 集群中的服务，该命令只能在管理节点运行。</p>
<h3 id="新建服务"><a href="#新建服务" class="headerlink" title="新建服务"></a>新建服务</h3><p>现在我们在上一节创建的 <code>Swarm</code> 集群中运行一个名为 <code>nginx</code> 服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker service create --replicas 3 -p 80:80 --name nginx nginx:1.13.7-alpine</span><br></pre></td></tr></table></figure>

<p>现在我们使用浏览器，输入任意节点 IP ，即可看到 nginx 默认页面。</p>
<h3 id="查看服务"><a href="#查看服务" class="headerlink" title="查看服务"></a>查看服务</h3><p>使用 <code>docker service ls</code> 来查看当前 <code>Swarm</code> 集群运行的服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker service <span class="built_in">ls</span></span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                 PORTS</span><br><span class="line">kc57xffvhul5        nginx               replicated          3/3                 nginx:1.13.7-alpine   *:80-&gt;80/tcp</span><br></pre></td></tr></table></figure>

<p>使用 <code>docker service ps</code> 来查看某个服务的详情。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker service ps nginx</span><br><span class="line">ID                  NAME                IMAGE                 NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">pjfzd39buzlt        nginx.1             nginx:1.13.7-alpine   swarm2              Running             Running about a minute ago</span><br><span class="line">hy9eeivdxlaa        nginx.2             nginx:1.13.7-alpine   swarm1              Running             Running about a minute ago</span><br><span class="line">36wmpiv7gmfo        nginx.3             nginx:1.13.7-alpine   swarm3              Running             Running about a minute ago</span><br></pre></td></tr></table></figure>

<p>使用 <code>docker service logs</code> 来查看某个服务的日志。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker service logs nginx</span><br><span class="line">nginx.3.36wmpiv7gmfo@swarm3    | 10.255.0.4 - - [25/Nov/2017:02:10:30 +0000] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 612 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">nginx.3.36wmpiv7gmfo@swarm3    | 10.255.0.4 - - [25/Nov/2017:02:10:30 +0000] <span class="string">&quot;GET /favicon.ico HTTP/1.1&quot;</span> 404 169 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">nginx.3.36wmpiv7gmfo@swarm3    | 2017/11/25 02:10:30 [error] 5<span class="comment">#5: *1 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 10.255.0.4, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;192.168.99.102&quot;</span></span><br><span class="line">nginx.1.pjfzd39buzlt@swarm2    | 10.255.0.2 - - [25/Nov/2017:02:10:26 +0000] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 612 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">nginx.1.pjfzd39buzlt@swarm2    | 10.255.0.2 - - [25/Nov/2017:02:10:27 +0000] <span class="string">&quot;GET /favicon.ico HTTP/1.1&quot;</span> 404 169 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">nginx.1.pjfzd39buzlt@swarm2    | 2017/11/25 02:10:27 [error] 5<span class="comment">#5: *1 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 10.255.0.2, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;192.168.99.101&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="服务伸缩"><a href="#服务伸缩" class="headerlink" title="服务伸缩"></a>服务伸缩</h3><p>我们可以使用 <code>docker service scale</code> 对一个服务运行的容器数量进行伸缩。</p>
<p>当业务处于高峰期时，我们需要扩展服务运行的容器数量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker service scale nginx=5</span><br></pre></td></tr></table></figure>

<p>当业务平稳时，我们需要减少服务运行的容器数量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker service scale nginx=2</span><br></pre></td></tr></table></figure>

<h3 id="删除服务"><a href="#删除服务" class="headerlink" title="删除服务"></a>删除服务</h3><p>使用 <code>docker service rm</code> 来从 <code>Swarm</code> 集群移除某个服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker service <span class="built_in">rm</span> nginx</span><br></pre></td></tr></table></figure>

<h2 id="在-Swarm-集群中使用-compose-文件"><a href="#在-Swarm-集群中使用-compose-文件" class="headerlink" title="在 Swarm 集群中使用 compose 文件"></a>在 Swarm 集群中使用 compose 文件</h2><p>正如之前使用 <code>docker-compose.yml</code> 来一次配置、启动多个容器，在 <code>Swarm</code> 集群中也可以使用 <code>compose</code> 文件 （<code>docker-compose.yml</code>） 来配置、启动多个服务。</p>
<p>上一节中，我们使用 <code>docker service create</code> 一次只能部署一个服务，使用 <code>docker-compose.yml</code> 我们可以一次启动多个关联的服务。</p>
<p>我们以在 <code>Swarm</code> 集群中部署 <code>WordPress</code> 为例进行说明。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">overlay</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">db:3306</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">overlay</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db-data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span> [<span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span>]</span><br><span class="line">  <span class="attr">visualizer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dockersamples/visualizer:stable</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">stop_grace_period:</span> <span class="string">1m30s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span> [<span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span>]</span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db-data:</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">overlay:</span></span><br></pre></td></tr></table></figure>

<p>在 <code>Swarm</code> 集群管理节点新建该文件，其中的 <code>visualizer</code> 服务提供一个可视化页面，我们可以从浏览器中很直观的查看集群中各个服务的运行节点。</p>
<p>在 <code>Swarm</code> 集群中使用 <code>docker-compose.yml</code> 我们用 <code>docker stack</code> 命令，下面我们对该命令进行详细讲解。</p>
<h3 id="部署服务-1"><a href="#部署服务-1" class="headerlink" title="部署服务"></a>部署服务</h3><p>部署服务使用 <code>docker stack deploy</code>，其中 <code>-c</code> 参数指定 compose 文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker stack deploy -c docker-compose.yml wordpress</span><br></pre></td></tr></table></figure>

<p>现在我们打开浏览器输入 <code>任一节点IP:8080</code> 即可看到各节点运行状态。如下图所示：</p>
<p><img src="/2022/docker_practice/wordpress.png" alt="img"></p>
<p>在浏览器新的标签页输入 <code>任一节点IP</code> 即可看到 <code>WordPress</code> 安装界面，安装完成之后，输入 <code>任一节点IP</code> 即可看到 <code>WordPress</code> 页面。</p>
<h3 id="查看服务-1"><a href="#查看服务-1" class="headerlink" title="查看服务"></a>查看服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker stack <span class="built_in">ls</span></span><br><span class="line">NAME                SERVICES</span><br><span class="line">wordpress           3</span><br></pre></td></tr></table></figure>

<h3 id="移除服务"><a href="#移除服务" class="headerlink" title="移除服务"></a>移除服务</h3><p>要移除服务，使用 <code>docker stack down</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker stack down wordpress</span><br><span class="line">Removing service wordpress_db</span><br><span class="line">Removing service wordpress_visualizer</span><br><span class="line">Removing service wordpress_wordpress</span><br><span class="line">Removing network wordpress_overlay</span><br><span class="line">Removing network wordpress_default</span><br></pre></td></tr></table></figure>

<p>该命令不会移除服务所使用的 <code>数据卷</code>，如果你想移除数据卷请使用 <code>docker volume rm</code></p>
<h2 id="在-Swarm-集群中管理敏感数据"><a href="#在-Swarm-集群中管理敏感数据" class="headerlink" title="在 Swarm 集群中管理敏感数据"></a>在 Swarm 集群中管理敏感数据</h2><p>在动态的、大规模的分布式集群上，管理和分发 <code>密码</code>、<code>证书</code> 等敏感信息是极其重要的工作。传统的密钥分发方式（如密钥放入镜像中，设置环境变量，volume 动态挂载等）都存在着潜在的巨大的安全风险。</p>
<p>Docker 目前已经提供了 <code>secrets</code> 管理功能，用户可以在 Swarm 集群中安全地管理密码、密钥证书等敏感数据，并允许在多个 Docker 容器实例之间共享访问指定的敏感数据。</p>
<blockquote>
<p>注意： <code>secret</code> 也可以在 <code>Docker Compose</code> 中使用。</p>
</blockquote>
<p>我们可以用 <code>docker secret</code> 命令来管理敏感信息。接下来我们在上面章节中创建好的 Swarm 集群中介绍该命令的使用。</p>
<p>这里我们以在 Swarm 集群中部署 <code>mysql</code> 和 <code>wordpress</code> 服务为例。</p>
<h3 id="创建-secret"><a href="#创建-secret" class="headerlink" title="创建 secret"></a>创建 secret</h3><p>我们使用 <code>docker secret create</code> 命令以管道符的形式创建 <code>secret</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl rand -<span class="built_in">base64</span> 20 | docker secret create mysql_password -</span><br><span class="line">$ openssl rand -<span class="built_in">base64</span> 20 | docker secret create mysql_root_password -</span><br></pre></td></tr></table></figure>

<h3 id="查看-secret"><a href="#查看-secret" class="headerlink" title="查看 secret"></a>查看 secret</h3><p>使用 <code>docker secret ls</code> 命令来查看 <code>secret</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker secret <span class="built_in">ls</span></span><br><span class="line">ID                          NAME                  CREATED             UPDATED</span><br><span class="line">l1vinzevzhj4goakjap5ya409   mysql_password        41 seconds ago      41 seconds ago</span><br><span class="line">yvsczlx9votfw3l0nz5rlidig   mysql_root_password   12 seconds ago      12 seconds ago</span><br></pre></td></tr></table></figure>

<h3 id="创建-MySQL-服务"><a href="#创建-MySQL-服务" class="headerlink" title="创建 MySQL 服务"></a>创建 MySQL 服务</h3><p>创建服务相关命令已经在前边章节进行了介绍，这里直接列出命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker network create -d overlay mysql_private</span><br><span class="line">$ docker service create \</span><br><span class="line">     --name mysql \</span><br><span class="line">     --replicas 1 \</span><br><span class="line">     --network mysql_private \</span><br><span class="line">     --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=mydata,destination=/var/lib/mysql \</span><br><span class="line">     --secret <span class="built_in">source</span>=mysql_root_password,target=mysql_root_password \</span><br><span class="line">     --secret <span class="built_in">source</span>=mysql_password,target=mysql_password \</span><br><span class="line">     -e MYSQL_ROOT_PASSWORD_FILE=<span class="string">&quot;/run/secrets/mysql_root_password&quot;</span> \</span><br><span class="line">     -e MYSQL_PASSWORD_FILE=<span class="string">&quot;/run/secrets/mysql_password&quot;</span> \</span><br><span class="line">     -e MYSQL_USER=<span class="string">&quot;wordpress&quot;</span> \</span><br><span class="line">     -e MYSQL_DATABASE=<span class="string">&quot;wordpress&quot;</span> \</span><br><span class="line">     mysql:latest</span><br></pre></td></tr></table></figure>

<p>如果你没有在 <code>target</code> 中显式的指定路径时，<code>secret</code> 默认通过 <code>tmpfs</code> 文件系统挂载到容器的 <code>/run/secrets</code> 目录中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker service create \</span><br><span class="line">     --name wordpress \</span><br><span class="line">     --replicas 1 \</span><br><span class="line">     --network mysql_private \</span><br><span class="line">     --publish target=30000,port=80 \</span><br><span class="line">     --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=wpdata,destination=/var/www/html \</span><br><span class="line">     --secret <span class="built_in">source</span>=mysql_password,target=wp_db_password,mode=0444 \</span><br><span class="line">     -e WORDPRESS_DB_USER=<span class="string">&quot;wordpress&quot;</span> \</span><br><span class="line">     -e WORDPRESS_DB_PASSWORD_FILE=<span class="string">&quot;/run/secrets/wp_db_password&quot;</span> \</span><br><span class="line">     -e WORDPRESS_DB_HOST=<span class="string">&quot;mysql:3306&quot;</span> \</span><br><span class="line">     -e WORDPRESS_DB_NAME=<span class="string">&quot;wordpress&quot;</span> \</span><br><span class="line">     wordpress:latest</span><br></pre></td></tr></table></figure>

<p>查看服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker service <span class="built_in">ls</span></span><br><span class="line">ID            NAME   MODE        REPLICAS  IMAGE</span><br><span class="line">wvnh0siktqr3  mysql      replicated  1/1       mysql:latest</span><br><span class="line">nzt5xzae4n62  wordpress  replicated  1/1       wordpress:latest</span><br></pre></td></tr></table></figure>

<p>现在浏览器访问 <code>IP:30000</code>，即可开始 <code>WordPress</code> 的安装与使用。</p>
<p>通过以上方法，我们没有像以前通过设置环境变量来设置 MySQL 密码， 而是采用 <code>docker secret</code> 来设置密码，防范了密码泄露的风险。</p>
<h2 id="在-Swarm-集群中管理配置数据"><a href="#在-Swarm-集群中管理配置数据" class="headerlink" title="在 Swarm 集群中管理配置数据"></a>在 Swarm 集群中管理配置数据</h2><p>在动态的、大规模的分布式集群上，管理和分发配置文件也是很重要的工作。传统的配置文件分发方式（如配置文件放入镜像中，设置环境变量，volume 动态挂载等）都降低了镜像的通用性。</p>
<p>在 Docker 17.06 以上版本中，Docker 新增了 <code>docker config</code> 子命令来管理集群中的配置信息，以后你无需将配置文件放入镜像或挂载到容器中就可实现对服务的配置。</p>
<blockquote>
<p>注意：<code>config</code> 仅能在 Swarm 集群中使用。</p>
</blockquote>
<p>这里我们以在 Swarm 集群中部署 <code>redis</code> 服务为例。</p>
<h3 id="创建-config"><a href="#创建-config" class="headerlink" title="创建 config"></a>创建 config</h3><p>新建 <code>redis.conf</code> 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">port 6380</span><br></pre></td></tr></table></figure>

<p>此项配置 Redis 监听 <code>6380</code> 端口</p>
<p>我们使用 <code>docker config create</code> 命令创建 <code>config</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker config create redis.conf redis.conf</span><br></pre></td></tr></table></figure>

<h3 id="查看-config"><a href="#查看-config" class="headerlink" title="查看 config"></a>查看 config</h3><p>使用 <code>docker config ls</code> 命令来查看 <code>config</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker config <span class="built_in">ls</span></span><br><span class="line">ID                          NAME                CREATED             UPDATED</span><br><span class="line">yod8fx8iiqtoo84jgwadp86yk   redis.conf          4 seconds ago       4 seconds ago</span><br></pre></td></tr></table></figure>

<h3 id="创建-redis-服务"><a href="#创建-redis-服务" class="headerlink" title="创建 redis 服务"></a>创建 redis 服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker service create \</span><br><span class="line">     --name redis \</span><br><span class="line">     <span class="comment"># --config source=redis.conf,target=/etc/redis.conf \</span></span><br><span class="line">     --config redis.conf \</span><br><span class="line">     -p 6379:6380 \</span><br><span class="line">     redis:latest \</span><br><span class="line">     redis-server /redis.conf</span><br></pre></td></tr></table></figure>

<p>如果你没有在 <code>target</code> 中显式的指定路径时，默认的 <code>redis.conf</code> 以 <code>tmpfs</code> 文件系统挂载到容器的 <code>/config.conf</code>。</p>
<p>经过测试，redis 可以正常使用。</p>
<p>以前我们通过监听主机目录来配置 Redis，就需要在集群的每个节点放置该文件，如果采用 <code>docker config</code> 来管理服务的配置信息，我们只需在集群中的管理节点创建 <code>config</code>，当部署服务时，集群会自动的将配置文件分发到运行服务的各个节点中，大大降低了配置信息的管理和分发难度。</p>
<h2 id="Swarm-mode-与滚动升级"><a href="#Swarm-mode-与滚动升级" class="headerlink" title="Swarm mode 与滚动升级"></a>Swarm mode 与滚动升级</h2><p>在 <a href="deploy.md">部署服务</a> 一节中我们使用 <code>nginx:1.13.7-alpine</code> 镜像部署了一个名为 <code>nginx</code> 的服务。</p>
<p>现在我们想要将 <code>NGINX</code> 版本升级到 <code>1.13.12</code>，那么在 Swarm mode 中如何升级服务呢？</p>
<p>你可能会想到，先停止原来的服务，再使用新镜像部署一个服务，不就完成服务的 “升级” 了吗。</p>
<p>这样做的弊端很明显，如果新部署的服务出现问题，原来的服务删除之后，很难恢复，那么在 Swarm mode 中到底该如何对服务进行滚动升级呢？</p>
<p>答案就是使用 <code>docker service update</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker service update \</span><br><span class="line">    --image nginx:1.13.12-alpine \</span><br><span class="line">    nginx</span><br></pre></td></tr></table></figure>

<p>以上命令使用 <code>--image</code> 选项更新了服务的镜像。当然我们也可以使用 <code>docker service update</code> 更新任意的配置。</p>
<p><code>--secret-add</code> 选项可以增加一个密钥</p>
<p><code>--secret-rm</code> 选项可以删除一个密钥</p>
<p>更多选项可以通过 <code>docker service update -h</code> 命令查看。</p>
<h3 id="服务回退"><a href="#服务回退" class="headerlink" title="服务回退"></a>服务回退</h3><p>现在假设我们发现 <code>nginx</code> 服务的镜像升级到 <code>nginx:1.13.12-alpine</code> 出现了一些问题，我们可以使用命令一键回退。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker service rollback nginx</span><br></pre></td></tr></table></figure>

<p>现在使用 <code>docker service ps</code> 命令查看 <code>nginx</code> 服务详情。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker service ps nginx</span><br><span class="line">ID                  NAME                IMAGE                  NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">rt677gop9d4x        nginx.1             nginx:1.13.7-alpine   VM-20-83-debian     Running             Running about a minute ago</span><br><span class="line">d9pw13v59d00         \_ nginx.1         nginx:1.13.12-alpine  VM-20-83-debian     Shutdown            Shutdown 2 minutes ago</span><br><span class="line">i7ynkbg6ybq5         \_ nginx.1         nginx:1.13.7-alpine   VM-20-83-debian     Shutdown            Shutdown 2 minutes ago</span><br></pre></td></tr></table></figure>

<p>结果的输出详细记录了服务的部署、滚动升级、回退的过程。</p>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>评估 Docker 的安全性时，主要考虑三个方面:</p>
<ul>
<li>由内核的命名空间和控制组机制提供的容器内在安全</li>
<li>Docker 程序（特别是服务端）本身的抗攻击性</li>
<li>内核安全性的加强机制对容器安全性的影响</li>
</ul>
<h2 id="命名空间（Namespaces）"><a href="#命名空间（Namespaces）" class="headerlink" title="命名空间（Namespaces）"></a>命名空间（Namespaces）</h2><p>Docker 容器和 LXC 容器很相似，所提供的安全特性也差不多。当用 <code>docker run</code> 启动一个容器时，在后台 Docker 为容器创建了一个独立的命名空间和控制组集合。</p>
<p><em>命名空间</em> 提供了最基础也是最直接的隔离，在容器中运行的进程不会被运行在主机上的进程和其它容器发现和作用。</p>
<p>每个容器都有自己独有的网络栈，意味着它们不能访问其他容器的 sockets 或接口。不过，如果主机系统上做了相应的设置，容器可以像跟主机交互一样的和其他容器交互。当指定公共端口或使用 links 来连接 2 个容器时，容器就可以相互通信了（可以根据配置来限制通信的策略）。</p>
<p>从网络架构的角度来看，所有的容器通过本地主机的网桥接口相互通信，就像物理机器通过物理交换机通信一样。</p>
<p>那么，内核中实现命名空间和私有网络的代码是否足够成熟？</p>
<p>内核命名空间从 2.6.15 版本（2008 年 7 月发布）之后被引入，数年间，这些机制的可靠性在诸多大型生产系统中被实践验证。</p>
<p>实际上，命名空间的想法和设计提出的时间要更早，最初是为了在内核中引入一种机制来实现 <a href="https://en.wikipedia.org/wiki/OpenVZ">OpenVZ</a> 的特性。<br>而 OpenVZ 项目早在 2005 年就发布了，其设计和实现都已经十分成熟。</p>
<h2 id="控制组（Control-groups）"><a href="#控制组（Control-groups）" class="headerlink" title="控制组（Control groups）"></a>控制组（Control groups）</h2><p>控制组是 Linux 容器机制的另外一个关键组件，负责实现资源的审计和限制。</p>
<p>它提供了很多有用的特性；以及确保各个容器可以公平地分享主机的内存、CPU、磁盘 IO 等资源；当然，更重要的是，控制组确保了当容器内的资源使用产生压力时不会连累主机系统。</p>
<p>尽管控制组不负责隔离容器之间相互访问、处理数据和进程，它在防止拒绝服务（DDOS）攻击方面是必不可少的。尤其是在多用户的平台（比如公有或私有的 PaaS）上，控制组十分重要。例如，当某些应用程序表现异常的时候，可以保证一致地正常运行和性能。</p>
<p>控制组机制始于 2006 年，内核从 2.6.24 版本开始被引入。</p>
<h2 id="Docker服务端的防护"><a href="#Docker服务端的防护" class="headerlink" title="Docker服务端的防护"></a>Docker服务端的防护</h2><p>运行一个容器或应用程序的核心是通过 Docker 服务端。Docker 服务的运行目前需要 root 权限，因此其安全性十分关键。</p>
<p>首先，确保只有可信的用户才可以访问 Docker 服务。Docker 允许用户在主机和容器间共享文件夹，同时不需要限制容器的访问权限，这就容易让容器突破资源限制。例如，恶意用户启动容器的时候将主机的根目录<code>/</code>映射到容器的 <code>/host</code> 目录中，那么容器理论上就可以对主机的文件系统进行任意修改了。这听起来很疯狂？但是事实上几乎所有虚拟化系统都允许类似的资源共享，而没法禁止用户共享主机根文件系统到虚拟机系统。</p>
<p>这将会造成很严重的安全后果。因此，当提供容器创建服务时（例如通过一个 web 服务器），要更加注意进行参数的安全检查，防止恶意的用户用特定参数来创建一些破坏性的容器。</p>
<p>为了加强对服务端的保护，Docker 的 REST API（客户端用来跟服务端通信）在 0.5.2 之后使用本地的 Unix 套接字机制替代了原先绑定在 127.0.0.1 上的 TCP 套接字，因为后者容易遭受跨站脚本攻击。现在用户使用 Unix 权限检查来加强套接字的访问安全。</p>
<p>用户仍可以利用 HTTP 提供 REST API 访问。建议使用安全机制，确保只有可信的网络或 VPN，或证书保护机制（例如受保护的 stunnel 和 ssl 认证）下的访问可以进行。此外，还可以使用 <a href="https://docs.docker.com/engine/security/https/"> HTTPS 和证书</a> 来加强保护。</p>
<p>最近改进的 Linux 命名空间机制将可以实现使用非 root 用户来运行全功能的容器。这将从根本上解决了容器和主机之间共享文件系统而引起的安全问题。</p>
<p>终极目标是改进 2 个重要的安全特性：</p>
<ul>
<li>将容器的 root 用户 <a href="https://docs.docker.com/engine/security/userns-remap/">映射到本地主机上的非 root 用户</a>，减轻容器和主机之间因权限提升而引起的安全问题；</li>
<li>允许 Docker 服务端在 <a href="https://docs.docker.com/engine/security/rootless/">非 root 权限(rootless 模式)</a> 下运行，利用安全可靠的子进程来代理执行需要特权权限的操作。这些子进程将只允许在限定范围内进行操作，例如仅仅负责虚拟网络设定或文件系统管理、配置操作等。</li>
</ul>
<p>最后，建议采用专用的服务器来运行 Docker 和相关的管理服务（例如管理服务比如 ssh 监控和进程监控、管理工具 nrpe、collectd 等）。其它的业务服务都放到容器中去运行。</p>
<h2 id="内核能力机制"><a href="#内核能力机制" class="headerlink" title="内核能力机制"></a>内核能力机制</h2><p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">能力机制（Capability）</a> 是 Linux 内核一个强大的特性，可以提供细粒度的权限访问控制。<br>Linux 内核自 2.2 版本起就支持能力机制，它将权限划分为更加细粒度的操作能力，既可以作用在进程上，也可以作用在文件上。</p>
<p>例如，一个 Web 服务进程只需要绑定一个低于 1024 的端口的权限，并不需要 root 权限。那么它只需要被授权 <code>net_bind_service</code> 能力即可。此外，还有很多其他的类似能力来避免进程获取 root 权限。</p>
<p>默认情况下，Docker 启动的容器被严格限制只允许使用内核的一部分能力。</p>
<p>使用能力机制对加强 Docker 容器的安全有很多好处。通常，在服务器上会运行一堆需要特权权限的进程，包括有 ssh、cron、syslogd、硬件管理工具模块（例如负载模块）、网络配置工具等等。容器跟这些进程是不同的，因为几乎所有的特权进程都由容器以外的支持系统来进行管理。</p>
<ul>
<li>ssh 访问被主机上ssh服务来管理；</li>
<li>cron 通常应该作为用户进程执行，权限交给使用它服务的应用来处理；</li>
<li>日志系统可由 Docker 或第三方服务管理；</li>
<li>硬件管理无关紧要，容器中也就无需执行 udevd 以及类似服务；</li>
<li>网络管理也都在主机上设置，除非特殊需求，容器不需要对网络进行配置。</li>
</ul>
<p>从上面的例子可以看出，大部分情况下，容器并不需要“真正的” root 权限，容器只需要少数的能力即可。为了加强安全，容器可以禁用一些没必要的权限。</p>
<ul>
<li>完全禁止任何 mount 操作；</li>
<li>禁止直接访问本地主机的套接字；</li>
<li>禁止访问一些文件系统的操作，比如创建新的设备、修改文件属性等；</li>
<li>禁止模块加载。</li>
</ul>
<p>这样，就算攻击者在容器中取得了 root 权限，也不能获得本地主机的较高权限，能进行的破坏也有限。</p>
<p>默认情况下，Docker采用 <a href="https://github.com/moby/moby/blob/master/oci/caps/defaults.go">白名单</a> 机制，禁用必需功能之外的其它权限。<br>当然，用户也可以根据自身需求来为 Docker 容器启用额外的权限。</p>
<h2 id="其它安全特性"><a href="#其它安全特性" class="headerlink" title="其它安全特性"></a>其它安全特性</h2><p>除了能力机制之外，还可以利用一些现有的安全机制来增强使用 Docker 的安全性，例如 TOMOYO, AppArmor, Seccomp, SELinux, GRSEC 等。</p>
<p>Docker 当前默认只启用了能力机制。用户可以采用多种方案来加强 Docker 主机的安全，例如：</p>
<ul>
<li>在内核中启用 GRSEC 和 PAX，这将增加很多编译和运行时的安全检查；通过地址随机化避免恶意探测等。并且，启用该特性不需要 Docker 进行任何配置。</li>
<li>使用一些有增强安全特性的容器模板，比如带 AppArmor 的模板和 Redhat 带 SELinux 策略的模板。这些模板提供了额外的安全特性。</li>
<li>用户可以自定义访问控制机制来定制安全策略。</li>
</ul>
<p>跟其它添加到 Docker 容器的第三方工具一样（比如网络拓扑和文件系统共享），有很多类似的机制，在不改变 Docker 内核情况下就可以加固现有的容器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来看，Docker 容器还是十分安全的，特别是在容器内不使用 root 权限来运行进程的话。</p>
<p>另外，用户可以使用现有工具，比如 <a href="https://docs.docker.com/engine/security/apparmor/">Apparmor</a>, <a href="https://docs.docker.com/engine/security/seccomp/">Seccomp</a>, SELinux, GRSEC 来增强安全性；甚至自己在内核中实现更复杂的安全机制。</p>
<h1 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h1><p>Docker 底层的核心技术包括 Linux 上的命名空间（Namespaces）、控制组（Control groups）、Union 文件系统（Union file systems）和容器格式（Container format）。</p>
<p>我们知道，传统的虚拟机通过在宿主主机中运行 hypervisor 来模拟一整套完整的硬件环境提供给虚拟机的操作系统。虚拟机系统看到的环境是可限制的，也是彼此隔离的。 这种直接的做法实现了对资源最完整的封装，但很多时候往往意味着系统资源的浪费。 例如，以宿主机和虚拟机系统都为 Linux 系统为例，虚拟机中运行的应用其实可以利用宿主机系统中的运行环境。</p>
<p>我们知道，在操作系统中，包括内核、文件系统、网络、PID、UID、IPC、内存、硬盘、CPU 等等，所有的资源都是应用进程直接共享的。 要想实现虚拟化，除了要实现对内存、CPU、网络IO、硬盘IO、存储空间等的限制外，还要实现文件系统、网络、PID、UID、IPC等等的相互隔离。 前者相对容易实现一些，后者则需要宿主机系统的深入支持。</p>
<p>随着 Linux 系统对于命名空间功能的完善实现，程序员已经可以实现上面的所有需求，让某些进程在彼此隔离的命名空间中运行。大家虽然都共用一个内核和某些运行时环境（例如一些系统命令和系统库），但是彼此却看不到，都以为系统中只有自己的存在。<strong>这种机制就是容器（Container），利用命名空间来做权限的隔离控制，利用 cgroups 来做资源分配。</strong></p>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>Docker 采用了 <code>C/S</code> 架构，包括客户端和服务端。Docker 守护进程 （<code>Daemon</code>）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。</p>
<p>客户端和服务端既可以运行在一个机器上，也可通过 <code>socket</code> 或者 <code>RESTful API</code> 来进行通信。</p>
<p>Docker 守护进程一般在宿主主机后台运行，等待接收来自客户端的消息。</p>
<p>Docker 客户端则为用户提供一系列可执行命令，用户用这些命令实现跟 Docker 守护进程交互。</p>
<h2 id="命名空间（Namespaces）-1"><a href="#命名空间（Namespaces）-1" class="headerlink" title="命名空间（Namespaces）"></a>命名空间（Namespaces）</h2><p>命名空间是 Linux 内核一个强大的特性。每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响。</p>
<h3 id="pid-命名空间"><a href="#pid-命名空间" class="headerlink" title="pid 命名空间"></a>pid 命名空间</h3><p>不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。所有的 LXC 进程在 Docker 中的父进程为 Docker 进程，每个 LXC 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。</p>
<h3 id="net-命名空间"><a href="#net-命名空间" class="headerlink" title="net 命名空间"></a>net 命名空间</h3><p>有了 pid 命名空间，每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备，IP 地址，路由表，<code>/proc/net</code> 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。</p>
<h3 id="ipc-命名空间"><a href="#ipc-命名空间" class="headerlink" title="ipc 命名空间"></a>ipc 命名空间</h3><p>容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication - IPC)， 包括信号量、消息队列和共享内存等。然而与 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。</p>
<h3 id="mnt-命名空间"><a href="#mnt-命名空间" class="headerlink" title="mnt 命名空间"></a>mnt 命名空间</h3><p>类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。与 chroot 不同，每个命名空间中的容器在 <code>/proc/mounts</code> 的信息只包含所在命名空间的 mount point。</p>
<h3 id="uts-命名空间"><a href="#uts-命名空间" class="headerlink" title="uts 命名空间"></a>uts 命名空间</h3><p>UTS(“UNIX Time-sharing System”) 命名空间允许每个容器拥有独立的 hostname 和 domain name， 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。</p>
<h3 id="user-命名空间"><a href="#user-命名空间" class="headerlink" title="user 命名空间"></a>user 命名空间</h3><p>每个容器可以有不同的用户和组 id， 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。</p>
<p>*注：更多关于 Linux 上命名空间的信息，请阅读 <a href="https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/">这篇文章</a>。</p>
<h2 id="控制组"><a href="#控制组" class="headerlink" title="控制组"></a>控制组</h2><p>控制组（<a href="https://en.wikipedia.org/wiki/Cgroups">cgroups</a>）是 Linux 内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。</p>
<p>控制组技术最早是由 Google 的程序员在 2006 年提出，Linux 内核自 2.6.24 开始支持。</p>
<p>控制组可以提供对容器的内存、CPU、磁盘 IO 等资源的限制和审计管理。</p>
<h2 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h2><p>联合文件系统（<a href="https://en.wikipedia.org/wiki/UnionFS">UnionFS</a>）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p>
<p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p>
<p>Docker 中使用的 AUFS（Advanced Multi-Layered Unification Filesystem）就是一种联合文件系统。 <code>AUFS</code> 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 <code>AUFS</code> 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p>
<p>Docker 目前支持的联合文件系统包括 <code>OverlayFS</code>, <code>AUFS</code>, <code>Btrfs</code>, <code>VFS</code>, <code>ZFS</code> 和 <code>Device Mapper</code>。</p>
<p>各 Linux 发行版 Docker 推荐使用的存储驱动如下表。</p>
<table>
<thead>
<tr>
<th align="left">Linux 发行版</th>
<th align="left">Docker 推荐使用的存储驱动</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Docker on Ubuntu</td>
<td align="left"><code>overlay2</code> (16.04 +)</td>
</tr>
<tr>
<td align="left">Docker on Debian</td>
<td align="left"><code>overlay2</code> (Debian Stretch), <code>aufs</code>, <code>devicemapper</code></td>
</tr>
<tr>
<td align="left">Docker on CentOS</td>
<td align="left"><code>overlay2</code></td>
</tr>
<tr>
<td align="left">Docker on Fedora</td>
<td align="left"><code>overlay2</code></td>
</tr>
</tbody></table>
<p>**在可能的情况下，<a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">推荐</a> 使用 <code>overlay2</code> 存储驱动，<code>overlay2</code> 是目前 Docker 默认的存储驱动，以前则是 <code>aufs</code>。**你可以通过配置来使用以上提到的其他类型的存储驱动。</p>
<h2 id="容器格式"><a href="#容器格式" class="headerlink" title="容器格式"></a>容器格式</h2><p><strong>最初，Docker 采用了 <code>LXC</code> 中的容器格式。从 0.7 版本以后开始去除 LXC，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc">runC</a> 和 <a href="https://github.com/containerd/containerd">containerd</a>。</strong></p>
<h2 id="Docker-网络实现"><a href="#Docker-网络实现" class="headerlink" title="Docker 网络实现"></a>Docker 网络实现</h2><p>Docker 的网络实现其实就是利用了 Linux 上的 <em>网络命名空间</em> 和 <em>虚拟网络设备</em>（特别是 veth pair）。</p>
<p>首先，要实现网络通信，机器需要至少一个网络接口（物理接口或虚拟接口）来收发数据包；此外，如果不同子网之间要进行通信，需要路由机制。</p>
<p>Docker 中的网络接口默认都是虚拟的接口。虚拟接口的优势之一是转发效率较高。<br>Linux 通过在内核中进行数据复制来实现虚拟接口之间的数据转发，发送接口的发送缓存中的数据包被直接复制到接收接口的接收缓存中。对于本地系统和容器内系统看来就像是一个正常的以太网卡，只是它不需要真正同外部网络设备通信，速度要快很多。</p>
<p>Docker 容器网络就利用了这项技术。它在本地主机和容器内分别创建一个虚拟接口，并让它们彼此连通（这样的一对接口叫做 <code>veth pair</code>）。</p>
<h3 id="创建网络参数"><a href="#创建网络参数" class="headerlink" title="创建网络参数"></a>创建网络参数</h3><p>Docker 创建一个容器的时候，会执行如下操作：</p>
<ul>
<li>创建一对虚拟接口，分别放到本地主机和新容器中；</li>
<li>本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 veth65f9；</li>
<li>容器一端放到新容器中，并修改名字作为 eth0，这个接口只在容器的命名空间可见；</li>
<li>从网桥可用地址段中获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 veth65f9。</li>
</ul>
<p>完成这些之后，容器就可以使用 eth0 虚拟网卡来连接其他容器和其他网络。</p>
<p>可以在 <code>docker run</code> 的时候通过 <code>--net</code> 参数来指定容器的网络配置，有4个可选值：</p>
<ul>
<li><code>--net=bridge</code> 这个是默认值，连接到默认的网桥。</li>
<li><code>--net=host</code> 告诉 Docker 不要将容器网络放到隔离的命名空间中，即不要容器化容器内的网络。此时容器使用本地主机的网络，它拥有完全的本地主机接口访问权限。容器进程可以跟主机其它 root 进程一样可以打开低范围的端口，可以访问本地网络服务比如 D-bus，还可以让容器做一些影响整个主机系统的事情，比如重启主机。因此使用这个选项的时候要非常小心。<strong>如果进一步的使用 <code>--privileged=true</code>，容器会被允许直接配置主机的网络堆栈。</strong></li>
<li><code>--net=container:NAME_or_ID</code> 让 Docker 将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享 IP 地址和端口等网络资源，两者进程可以直接通过 <code>lo</code> 环回接口通信。</li>
<li><code>--net=none</code> 让 Docker 将新容器放到隔离的网络栈中，但是不进行网络配置。之后，用户可以自己进行配置。</li>
</ul>
<h3 id="网络配置细节"><a href="#网络配置细节" class="headerlink" title="网络配置细节"></a>网络配置细节</h3><p>用户使用 <code>--net=none</code> 后，可以自行配置网络，让容器达到跟平常一样具有访问网络的权限。通过这个过程，可以了解 Docker 配置网络的细节。</p>
<p>首先，启动一个 <code>/bin/bash</code> 容器，指定 <code>--net=none</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -i -t --<span class="built_in">rm</span> --net=none base /bin/bash</span><br><span class="line">root@63f36fc01b5f:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>在本地主机查找容器的进程 id，并为它创建网络命名空间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> 63f36fc01b5f</span><br><span class="line">2778</span><br><span class="line">$ pid=2778</span><br><span class="line">$ sudo <span class="built_in">mkdir</span> -p /var/run/netns</span><br><span class="line">$ sudo <span class="built_in">ln</span> -s /proc/<span class="variable">$pid</span>/ns/net /var/run/netns/<span class="variable">$pid</span></span><br></pre></td></tr></table></figure>
<p>检查桥接网卡的 IP 和子网掩码信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip addr show docker0</span><br><span class="line">21: docker0: ...</span><br><span class="line">inet 172.17.42.1/16 scope global docker0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>创建一对 “veth pair” 接口 A 和 B，绑定 A 到网桥 <code>docker0</code>，并启用它</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ip <span class="built_in">link</span> add A <span class="built_in">type</span> veth peer name B</span><br><span class="line">$ sudo brctl addif docker0 A</span><br><span class="line">$ sudo ip <span class="built_in">link</span> <span class="built_in">set</span> A up</span><br></pre></td></tr></table></figure>
<p>将B放到容器的网络命名空间，命名为 eth0，启动它并配置一个可用 IP（桥接网段）和默认网关。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ip <span class="built_in">link</span> <span class="built_in">set</span> B netns <span class="variable">$pid</span></span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev B name eth0</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip addr add 172.17.42.99/16 dev eth0</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip route add default via 172.17.42.1</span><br></pre></td></tr></table></figure>
<p>以上，就是 Docker 配置网络的具体过程。</p>
<p>当容器结束后，Docker 会清空容器，容器内的 eth0 会随网络命名空间一起被清除，A 接口也被自动从 <code>docker0</code> 卸载。</p>
<p>此外，用户可以使用 <code>ip netns exec</code> 命令来在指定网络命名空间中进行配置，从而配置容器内的网络。</p>
<h1 id="Docker-Buildx"><a href="#Docker-Buildx" class="headerlink" title="Docker Buildx"></a>Docker Buildx</h1><p>Docker Buildx 是一个 docker CLI 插件，其扩展了 docker 命令，支持 Moby BuildKit 提供的功能。提供了与 docker build 相同的用户体验，并增加了许多新功能。</p>
<blockquote>
<p>该功能仅适用于 Docker v19.03+ 版本</p>
</blockquote>
<h2 id="使用-BuildKit-构建镜像"><a href="#使用-BuildKit-构建镜像" class="headerlink" title="使用 BuildKit 构建镜像"></a>使用 <code>BuildKit</code> 构建镜像</h2><p><strong>BuildKit</strong> 是下一代的镜像构建组件，在 <a href="https://github.com/moby/buildkit">https://github.com/moby/buildkit</a> 开源。</p>
<blockquote>
<p>注意：如果您的镜像构建使用的是云服务商提供的镜像构建服务（腾讯云容器服务、阿里云容器服务等），由于上述服务提供商的 Docker 版本低于 18.09，BuildKit 无法使用，将造成镜像构建失败。建议使用 BuildKit 构建镜像时使用一个新的 Dockerfile 文件（例如 Dockerfile.buildkit）</p>
</blockquote>
<p>目前，Docker Hub 自动构建已经支持 buildkit，具体请参考 <a href="https://github.com/docker-practice/docker-hub-buildx">https://github.com/docker-practice/docker-hub-buildx</a></p>
<h3 id="Dockerfile-新增指令详解"><a href="#Dockerfile-新增指令详解" class="headerlink" title="Dockerfile 新增指令详解"></a><code>Dockerfile</code> 新增指令详解</h3><p>启用 <code>BuildKit</code> 之后，我们可以使用下面几个新的 <code>Dockerfile</code> 指令来加快镜像构建。</p>
<h4 id="RUN-mount-type-cache"><a href="#RUN-mount-type-cache" class="headerlink" title="RUN --mount=type=cache"></a><code>RUN --mount=type=cache</code></h4><p>目前，几乎所有的程序都会使用依赖管理工具，例如 <code>Go</code> 中的 <code>go mod</code>、<code>Node.js</code> 中的 <code>npm</code> 等等，当我们构建一个镜像时，往往会重复的从互联网中获取依赖包，难以缓存，大大降低了镜像的构建效率。</p>
<p>例如一个前端工程需要用到 <code>npm</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:alpine as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json /app/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm i --registry=https://registry.npm.taobao.org \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; <span class="built_in">rm</span> -rf ~/.npm</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src /app/src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm run build</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /app/dist /app/dist</span></span><br></pre></td></tr></table></figure>

<p>使用多阶段构建，构建的镜像中只包含了目标文件夹 <code>dist</code>，但仍然存在一些问题，当 <code>package.json</code> 文件变动时，<code>RUN npm i &amp;&amp; rm -rf ~/.npm</code> 这一层会重新执行，变更多次后，生成了大量的中间层镜像。</p>
<p>为解决这个问题，进一步的我们可以设想一个类似 <strong>数据卷</strong> 的功能，在镜像构建时把 <code>node_modules</code> 文件夹挂载上去，在构建完成后，这个 <code>node_modules</code> 文件夹会自动卸载，实际的镜像中并不包含 <code>node_modules</code> 这个文件夹，这样我们就省去了每次获取依赖的时间，大大增加了镜像构建效率，同时也避免了生成了大量的中间层镜像。</p>
<p><code>BuildKit</code> 提供了 <code>RUN --mount=type=cache</code> 指令，可以实现上边的设想。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># syntax = docker/dockerfile:experimental</span></span><br><span class="line"><span class="keyword">FROM</span> node:alpine as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json /app/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/app/node_modules,<span class="built_in">id</span>=my_app_npm_module,sharing=locked \</span></span><br><span class="line"><span class="language-bash">    --mount=<span class="built_in">type</span>=cache,target=/root/.npm,<span class="built_in">id</span>=npm_cache \</span></span><br><span class="line"><span class="language-bash">        npm i --registry=https://registry.npm.taobao.org</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src /app/src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/app/node_modules,<span class="built_in">id</span>=my_app_npm_module,sharing=locked \</span></span><br><span class="line"><span class="language-bash"><span class="comment"># --mount=type=cache,target=/app/dist,id=my_app_dist,sharing=locked \</span></span></span><br><span class="line"><span class="language-bash">        npm run build</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:alpine</span><br><span class="line"><span class="comment"># COPY --from=builder /app/dist /app/dist</span></span><br><span class="line"><span class="comment"># 为了更直观的说明 from 和 source 指令，这里使用 RUN 指令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/tmp/dist,from=builder,<span class="built_in">source</span>=/app/dist \</span></span><br><span class="line"><span class="language-bash">    <span class="comment"># --mount=type=cache,target/tmp/dist,from=my_app_dist,sharing=locked \</span></span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> -p /app/dist &amp;&amp; <span class="built_in">cp</span> -r /tmp/dist/* /app/dist</span></span><br></pre></td></tr></table></figure>

<p><strong>由于 <code>BuildKit</code> 为实验特性，每个 <code>Dockerfile</code> 文件开头都必须加上如下指令</strong></p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="comment"># syntax = docker/dockerfile:experimental</span></span><br></pre></td></tr></table></figure>

<p>第一个 <code>RUN</code> 指令执行后，<code>id</code> 为 <code>my_app_npm_module</code> 的缓存文件夹挂载到了 <code>/app/node_modules</code> 文件夹中。多次执行也不会产生多个中间层镜像。</p>
<p>第二个 <code>RUN</code> 指令执行时需要用到 <code>node_modules</code> 文件夹，<code>node_modules</code> 已经挂载，命令也可以正确执行。</p>
<p>第三个 <code>RUN</code> 指令将上一阶段产生的文件复制到指定位置，<code>from</code> 指明缓存的来源，这里 <code>builder</code> 表示缓存来源于构建的第一阶段，<code>source</code> 指明缓存来源的文件夹。</p>
<p>上面的 <code>Dockerfile</code> 中 <code>--mount=type=cache,...</code> 中指令作用如下：</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td><code>id</code> 设置一个标志，以便区分缓存。</td>
</tr>
<tr>
<td><code>target</code> (必填项)</td>
<td>缓存的挂载目标文件夹。</td>
</tr>
<tr>
<td><code>ro</code>,<code>readonly</code></td>
<td>只读，缓存文件夹不能被写入。</td>
</tr>
<tr>
<td><code>sharing</code></td>
<td>有 <code>shared</code> <code>private</code> <code>locked</code> 值可供选择。<code>sharing</code> 设置当一个缓存被多次使用时的表现，由于 <code>BuildKit</code> 支持并行构建，当多个步骤使用同一缓存时（同一 <code>id</code>）会发生冲突。<code>shared</code> 表示多个步骤可以同时读写，<code>private</code> 表示当多个步骤使用同一缓存时，每个步骤使用不同的缓存，<code>locked</code> 表示当一个步骤完成释放缓存后，后一个步骤才能继续使用该缓存。</td>
</tr>
<tr>
<td><code>from</code></td>
<td>缓存来源（构建阶段），不填写时为空文件夹。</td>
</tr>
<tr>
<td><code>source</code></td>
<td>来源的文件夹路径。</td>
</tr>
</tbody></table>
<h4 id="RUN-mount-type-bind"><a href="#RUN-mount-type-bind" class="headerlink" title="RUN --mount=type=bind"></a><code>RUN --mount=type=bind</code></h4><p>该指令可以将一个镜像（或上一构建阶段）的文件挂载到指定位置。</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="comment"># syntax = docker/dockerfile:experimental</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=<span class="built_in">bind</span>,from=php:alpine,<span class="built_in">source</span>=/usr/local/bin/docker-php-entrypoint,target=/docker-php-entrypoint \</span></span><br><span class="line"><span class="language-bash">        <span class="built_in">cat</span> /docker-php-entrypoint</span></span><br></pre></td></tr></table></figure>

<h4 id="RUN-mount-type-tmpfs"><a href="#RUN-mount-type-tmpfs" class="headerlink" title="RUN --mount=type=tmpfs"></a><code>RUN --mount=type=tmpfs</code></h4><p>该指令可以将一个 <code>tmpfs</code> 文件系统挂载到指定位置。</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="comment"># syntax = docker/dockerfile:experimental</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=tmpfs,target=/temp \</span></span><br><span class="line"><span class="language-bash">        mount | grep /temp</span></span><br></pre></td></tr></table></figure>

<h4 id="RUN-mount-type-secret"><a href="#RUN-mount-type-secret" class="headerlink" title="RUN --mount=type=secret"></a><code>RUN --mount=type=secret</code></h4><p>该指令可以将一个文件(例如密钥)挂载到指定位置。</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="comment"># syntax = docker/dockerfile:experimental</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=secret,<span class="built_in">id</span>=aws,target=/root/.aws/credentials \</span></span><br><span class="line"><span class="language-bash">        <span class="built_in">cat</span> /root/.aws/credentials</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t <span class="built_in">test</span> --secret <span class="built_in">id</span>=aws,src=<span class="variable">$HOME</span>/.aws/credentials .</span><br></pre></td></tr></table></figure>

<h4 id="RUN-mount-type-ssh"><a href="#RUN-mount-type-ssh" class="headerlink" title="RUN --mount=type=ssh"></a><code>RUN --mount=type=ssh</code></h4><p>该指令可以挂载 <code>ssh</code> 密钥。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># syntax = docker/dockerfile:experimental</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache openssh-client</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p -m 0700 ~/.ssh &amp;&amp; ssh-keyscan gitlab.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=ssh ssh git@gitlab.com | <span class="built_in">tee</span> /hello</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> $(ssh-agent)</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br><span class="line">(Input your passphrase here)</span><br><span class="line">$ docker build -t <span class="built_in">test</span> --ssh default=<span class="variable">$SSH_AUTH_SOCK</span> .</span><br></pre></td></tr></table></figure>

<h3 id="docker-compose-build-使用-Buildkit"><a href="#docker-compose-build-使用-Buildkit" class="headerlink" title="docker-compose build 使用 Buildkit"></a>docker-compose build 使用 Buildkit</h3><p>设置 <code>COMPOSE_DOCKER_CLI_BUILD=1</code> 环境变量即可使用。</p>
<h3 id="官方文档-1"><a href="#官方文档-1" class="headerlink" title="官方文档"></a>官方文档</h3><ul>
<li><a href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md">https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md</a></li>
</ul>
<h2 id="使用-Buildx-构建镜像"><a href="#使用-Buildx-构建镜像" class="headerlink" title="使用 Buildx 构建镜像"></a>使用 Buildx 构建镜像</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>你可以直接使用 <code>docker buildx build</code> 命令构建镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker buildx build .</span><br><span class="line">[+] Building 8.4s (23/32)</span><br><span class="line"> =&gt; ...</span><br></pre></td></tr></table></figure>

<p>Buildx 使用 <a href="buildkit.md">BuildKit 引擎</a> 进行构建，支持许多新的功能，具体参考 <a href="buildkit.md">Buildkit</a> 一节。</p>
<h3 id="官方文档-2"><a href="#官方文档-2" class="headerlink" title="官方文档"></a>官方文档</h3><ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/buildx/">https://docs.docker.com/engine/reference/commandline/buildx/</a></li>
</ul>
<h2 id="使用-buildx-构建多种系统架构支持的-Docker-镜像"><a href="#使用-buildx-构建多种系统架构支持的-Docker-镜像" class="headerlink" title="使用 buildx 构建多种系统架构支持的 Docker 镜像"></a>使用 buildx 构建多种系统架构支持的 Docker 镜像</h2><p>在之前的版本中构建多种系统架构支持的 Docker 镜像，要想使用统一的名字必须使用 <a href="../image/manifest.md"><code>$ docker manifest</code></a> 命令。</p>
<p>在 Docker 19.03+ 版本中可以使用 <code>$ docker buildx build</code> 命令使用 <code>BuildKit</code> 构建镜像。该命令支持 <code>--platform</code> 参数可以同时构建支持多种系统架构的 Docker 镜像，大大简化了构建步骤。</p>
<h3 id="新建-builder-实例"><a href="#新建-builder-实例" class="headerlink" title="新建 builder 实例"></a>新建 <code>builder</code> 实例</h3><p>Docker for Linux 不支持构建 <code>arm</code> 架构镜像，我们可以运行一个新的容器让其支持该特性，Docker 桌面版无需进行此项设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --<span class="built_in">rm</span> --privileged tonistiigi/binfmt:latest --install all</span><br></pre></td></tr></table></figure>

<p>由于 Docker 默认的 <code>builder</code> 实例不支持同时指定多个 <code>--platform</code>，我们必须首先创建一个新的 <code>builder</code> 实例。同时由于国内拉取镜像较缓慢，我们可以使用配置了 <a href="https://github.com/moby/buildkit/blob/master/docs/buildkitd.toml.md">镜像加速地址</a>  的 <a href="https://github.com/docker-practice/buildx"><code>dockerpracticesig/buildkit:master</code></a> 镜像替换官方镜像。</p>
<blockquote>
<p>如果你有私有的镜像加速器，可以基于 <a href="https://github.com/docker-practice/buildx">https://github.com/docker-practice/buildx</a> 构建自己的 buildkit 镜像并使用它。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 适用于国内环境</span></span><br><span class="line">$ docker buildx create --use --name=mybuilder-cn --driver docker-container --driver-opt image=dockerpracticesig/buildkit:master</span><br><span class="line"><span class="comment"># 适用于腾讯云环境(腾讯云主机、coding.net 持续集成)</span></span><br><span class="line">$ docker buildx create --use --name=mybuilder-cn --driver docker-container --driver-opt image=dockerpracticesig/buildkit:master-tencent</span><br><span class="line"><span class="comment"># $ docker buildx create --name mybuilder --driver docker-container</span></span><br><span class="line">$ docker buildx use mybuilder</span><br></pre></td></tr></table></figure>

<h3 id="构建镜像-2"><a href="#构建镜像-2" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>新建 Dockerfile 文件。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> --platform=$TARGETPLATFORM alpine</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">uname</span> -a &gt; /os.txt</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">cat</span> /os.txt</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>$ docker buildx build</code> 命令构建镜像，注意将 <code>myusername</code> 替换为自己的 Docker Hub 用户名。</p>
<p><code>--push</code> 参数表示将构建好的镜像推送到 Docker 仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker buildx build --platform linux/arm,linux/arm64,linux/amd64 -t myusername/hello . --push</span><br><span class="line"><span class="comment"># 查看镜像信息</span></span><br><span class="line">$ docker buildx imagetools inspect myusername/hello</span><br></pre></td></tr></table></figure>

<p>在不同架构运行该镜像，可以得到该架构的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># arm</span></span><br><span class="line">$ docker run -it --<span class="built_in">rm</span> myusername/hello</span><br><span class="line">Linux buildkitsandbox 4.9.125-linuxkit <span class="comment">#1 SMP Fri Sep 7 08:20:28 UTC 2018 armv7l Linux</span></span><br><span class="line"><span class="comment"># arm64</span></span><br><span class="line">$ docker run -it --<span class="built_in">rm</span> myusername/hello</span><br><span class="line">Linux buildkitsandbox 4.9.125-linuxkit <span class="comment">#1 SMP Fri Sep 7 08:20:28 UTC 2018 aarch64 Linux</span></span><br><span class="line"><span class="comment"># amd64</span></span><br><span class="line">$ docker run -it --<span class="built_in">rm</span> myusername/hello</span><br><span class="line">Linux buildkitsandbox 4.9.125-linuxkit <span class="comment">#1 SMP Fri Sep 7 08:20:28 UTC 2018 x86_64 Linux</span></span><br></pre></td></tr></table></figure>

<h3 id="架构相关变量"><a href="#架构相关变量" class="headerlink" title="架构相关变量"></a>架构相关变量</h3><p><code>Dockerfile</code> 支持如下架构相关的变量</p>
<p><strong>TARGETPLATFORM</strong> </p>
<p>构建镜像的目标平台，例如 <code>linux/amd64</code>, <code>linux/arm/v7</code>, <code>windows/amd64</code>。</p>
<p><strong>TARGETOS</strong> </p>
<p><code>TARGETPLATFORM</code> 的 OS 类型，例如 <code>linux</code>, <code>windows</code></p>
<p><strong>TARGETARCH</strong> </p>
<p><code>TARGETPLATFORM</code> 的架构类型，例如 <code>amd64</code>, <code>arm</code></p>
<p><strong>TARGETVARIANT</strong></p>
<p><code>TARGETPLATFORM</code> 的变种，该变量可能为空，例如 <code>v7</code></p>
<p><strong>BUILDPLATFORM</strong></p>
<p>构建镜像主机平台，例如 <code>linux/amd64</code></p>
<p><strong>BUILDOS</strong> </p>
<p><code>BUILDPLATFORM</code> 的 OS 类型，例如 <code>linux</code></p>
<p><strong>BUILDARCH</strong> </p>
<p><code>BUILDPLATFORM</code> 的架构类型，例如 <code>amd64</code></p>
<p><strong>BUILDVARIANT</strong> </p>
<p><code>BUILDPLATFORM</code> 的变种，该变量可能为空，例如 <code>v7</code></p>
<h4 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h4><p>例如我们要构建支持 <code>linux/arm/v7</code> 和 <code>linux/amd64</code> 两种架构的镜像。假设已经生成了两个平台对应的二进制文件：</p>
<ul>
<li><code>bin/dist-linux-arm</code></li>
<li><code>bin/dist-linux-amd64</code></li>
</ul>
<p>那么 <code>Dockerfile</code> 可以这样书写：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="comment"># 使用变量必须申明</span></span><br><span class="line"><span class="keyword">ARG</span> TARGETOS</span><br><span class="line"><span class="keyword">ARG</span> TARGETARCH</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> bin/dist-<span class="variable">$&#123;TARGETOS&#125;</span>-<span class="variable">$&#123;TARGETARCH&#125;</span> /dist</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;dist&quot;</span>]</span></span><br></pre></td></tr></table></figure>



<h1 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h1><p><code>etcd</code> 是 <code>CoreOS</code> 团队发起的一个管理配置信息和服务发现（<code>Service Discovery</code>）的项目，在这一章里面，我们将基于 <code>etcd 3.x</code> 版本介绍该项目的目标，安装和使用，以及实现的技术。</p>
<h2 id="什么是-etcd"><a href="#什么是-etcd" class="headerlink" title="什么是 etcd"></a>什么是 etcd</h2><p><code>etcd</code> 是 <code>CoreOS</code> 团队于 2013 年 6 月发起的开源项目，它的目标是构建一个高可用的分布式键值（<code>key-value</code>）数据库，基于 <code>Go</code> 语言实现。我们知道，在分布式系统中，各种服务的配置信息的管理分享，服务的发现是一个很基本同时也是很重要的问题。<code>CoreOS</code> 项目就希望基于 <code>etcd</code> 来解决这一问题。</p>
<p><code>etcd</code> 目前在 <a href="https://github.com/etcd-io/etcd">github.com&#x2F;etcd-io&#x2F;etcd</a> 进行维护。</p>
<p>受到 <a href="https://zookeeper.apache.org/">Apache ZooKeeper</a> 项目和 <a href="https://github.com/ha/doozerd">doozer</a> 项目的启发，<code>etcd</code> 在设计的时候重点考虑了下面四个要素：</p>
<ul>
<li><p>简单：具有定义良好、面向用户的 <code>API</code> (<a href="https://github.com/grpc/grpc">gRPC</a>)</p>
</li>
<li><p>安全：支持 <code>HTTPS</code> 方式的访问</p>
</li>
<li><p>快速：支持并发 <code>10 k/s</code> 的写操作</p>
</li>
<li><p>可靠：支持分布式结构，基于 <code>Raft</code> 的一致性算法</p>
</li>
</ul>
<p><em>Apache ZooKeeper 是一套知名的分布式系统中进行同步和一致性管理的工具。</em></p>
<p><em>doozer 是一个一致性分布式数据库。</em></p>
<p><em><a href="https://raft.github.io/">Raft</a> 是一套通过选举主节点来实现分布式系统一致性的算法，相比于大名鼎鼎的 Paxos 算法，它的过程更容易被人理解，由 Stanford 大学的 Diego Ongaro 和 John Ousterhout 提出。更多细节可以参考 <a href="http://raftconsensus.github.io/">raftconsensus.github.io</a>。</em></p>
<p>一般情况下，用户使用 <code>etcd</code> 可以在多个节点上启动多个实例，并添加它们为一个集群。同一个集群中的 <code>etcd</code> 实例将会保持彼此信息的一致性。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>etcd</code> 基于 <code>Go</code> 语言实现，因此，用户可以从 <a href="https://github.com/etcd-io/etcd">项目主页</a> 下载源代码自行编译，也可以下载编译好的二进制文件，甚至直接使用制作好的 <code>Docker</code> 镜像文件来体验。</p>
<blockquote>
<p>注意：本章节内容基于 etcd <code>3.4.x</code> 版本</p>
</blockquote>
<h3 id="二进制文件方式下载"><a href="#二进制文件方式下载" class="headerlink" title="二进制文件方式下载"></a>二进制文件方式下载</h3><p>编译好的二进制文件都在 <a href="https://github.com/etcd-io/etcd/releases/">github.com&#x2F;etcd-io&#x2F;etcd&#x2F;releases</a> 页面，用户可以选择需要的版本，或通过下载工具下载。</p>
<p>例如，使用 <code>curl</code> 工具下载压缩包，并解压。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -L https://github.com/etcd-io/etcd/releases/download/v3.4.0/etcd-v3.4.0-linux-amd64.tar.gz -o etcd-v3.4.0-linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># 国内用户可以使用以下方式加快下载</span></span><br><span class="line">$ curl -L https://download.fastgit.org/etcd-io/etcd/releases/download/v3.4.0/etcd-v3.4.0-linux-amd64.tar.gz -o etcd-v3.4.0-linux-amd64.tar.gz</span><br><span class="line">$ tar xzvf etcd-v3.4.0-linux-amd64.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> etcd-v3.4.0-linux-amd64</span><br></pre></td></tr></table></figure>

<p>解压后，可以看到文件包括</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">Documentation README-etcdctl.md README.md READMEv2-etcdctl.md etcd etcdctl</span><br></pre></td></tr></table></figure>

<p>其中 <code>etcd</code> 是服务主文件，<code>etcdctl</code> 是提供给用户的命令客户端，其他文件是支持文档。</p>
<p>下面将 <code>etcd</code> <code>etcdctl</code> 文件放到系统可执行目录（例如 <code>/usr/local/bin/</code>）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">cp</span> etcd* /usr/local/bin/</span><br></pre></td></tr></table></figure>

<p>默认 <code>2379</code> 端口处理客户端的请求，<code>2380</code> 端口用于集群各成员间的通信。启动 <code>etcd</code> 显示类似如下的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ etcd</span><br><span class="line">...</span><br><span class="line">2017-12-03 11:18:34.411579 I | embed: listening <span class="keyword">for</span> peers on http://localhost:2380</span><br><span class="line">2017-12-03 11:18:34.411938 I | embed: listening <span class="keyword">for</span> client requests on localhost:2379</span><br></pre></td></tr></table></figure>

<p>此时，可以使用 <code>etcdctl</code> 命令进行测试，设置和获取键值 <code>testkey: &quot;hello world&quot;</code>，检查 <code>etcd</code> 服务是否启动成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ETCDCTL_API=3 etcdctl member list</span><br><span class="line">8e9e05c52164694d, started, default, http://localhost:2380, http://localhost:2379</span><br><span class="line">$ ETCDCTL_API=3 etcdctl put testkey <span class="string">&quot;hello world&quot;</span></span><br><span class="line">OK</span><br><span class="line">$ etcdctl get testkey</span><br><span class="line">testkey</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>说明 etcd 服务已经成功启动了。</p>
<h3 id="Docker-镜像方式运行"><a href="#Docker-镜像方式运行" class="headerlink" title="Docker 镜像方式运行"></a>Docker 镜像方式运行</h3><p>镜像名称为 <code>quay.io/coreos/etcd</code>，可以通过下面的命令启动 <code>etcd</code> 服务监听到 <code>2379</code> 和 <code>2380</code> 端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run \</span><br><span class="line">-p 2379:2379 \</span><br><span class="line">-p 2380:2380 \</span><br><span class="line">--mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/tmp/etcd-data.tmp,destination=/etcd-data \</span><br><span class="line">--name etcd-gcr-v3.4.0 \</span><br><span class="line">quay.io/coreos/etcd:v3.4.0 \</span><br><span class="line">/usr/local/bin/etcd \</span><br><span class="line">--name s1 \</span><br><span class="line">--data-dir /etcd-data \</span><br><span class="line">--listen-client-urls http://0.0.0.0:2379 \</span><br><span class="line">--advertise-client-urls http://0.0.0.0:2379 \</span><br><span class="line">--listen-peer-urls http://0.0.0.0:2380 \</span><br><span class="line">--initial-advertise-peer-urls http://0.0.0.0:2380 \</span><br><span class="line">--initial-cluster s1=http://0.0.0.0:2380 \</span><br><span class="line">--initial-cluster-token tkn \</span><br><span class="line">--initial-cluster-state new \</span><br><span class="line">--log-level info \</span><br><span class="line">--logger zap \</span><br><span class="line">--log-outputs stderr</span><br></pre></td></tr></table></figure>

<p>打开新的终端按照上一步的方法测试 <code>etcd</code> 是否成功启动。</p>
<h3 id="macOS-中运行"><a href="#macOS-中运行" class="headerlink" title="macOS 中运行"></a>macOS 中运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install etcd</span><br><span class="line">$ etcd</span><br><span class="line">$ etcdctl member list</span><br></pre></td></tr></table></figure>

<h2 id="etcd-集群"><a href="#etcd-集群" class="headerlink" title="etcd 集群"></a>etcd 集群</h2><p>下面我们使用 <a href="../compose/">Docker Compose</a> 模拟启动一个 3 节点的 <code>etcd</code> 集群。</p>
<p>编辑 <code>docker-compose.yml</code> 文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.6&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">node1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">quay.io/coreos/etcd:v3.4.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node1-data:/etcd-data</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2380</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">cluster_net:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">172.16</span><span class="number">.238</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ETCDCTL_API=3</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/bin/etcd</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--data-dir=/etcd-data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--name</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--initial-advertise-peer-urls</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://172.16.238.100:2380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--listen-peer-urls</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://0.0.0.0:2380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--advertise-client-urls</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://172.16.238.100:2379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--listen-client-urls</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://0.0.0.0:2379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--initial-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node1=http://172.16.238.100:2380,node2=http://172.16.238.101:2380,node3=http://172.16.238.102:2380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--initial-cluster-state</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--initial-cluster-token</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">docker-etcd</span></span><br><span class="line">  <span class="attr">node2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">quay.io/coreos/etcd:v3.4.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node2-data:/etcd-data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">cluster_net:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">172.16</span><span class="number">.238</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ETCDCTL_API=3</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2380</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/bin/etcd</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--data-dir=/etcd-data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--name</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--initial-advertise-peer-urls</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://172.16.238.101:2380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--listen-peer-urls</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://0.0.0.0:2380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--advertise-client-urls</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://172.16.238.101:2379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--listen-client-urls</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://0.0.0.0:2379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--initial-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node1=http://172.16.238.100:2380,node2=http://172.16.238.101:2380,node3=http://172.16.238.102:2380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--initial-cluster-state</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--initial-cluster-token</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">docker-etcd</span></span><br><span class="line">  <span class="attr">node3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">quay.io/coreos/etcd:v3.4.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node3-data:/etcd-data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">cluster_net:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">172.16</span><span class="number">.238</span><span class="number">.102</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ETCDCTL_API=3</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2380</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/bin/etcd</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--data-dir=/etcd-data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--name</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--initial-advertise-peer-urls</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://172.16.238.102:2380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--listen-peer-urls</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://0.0.0.0:2380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--advertise-client-urls</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://172.16.238.102:2379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--listen-client-urls</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://0.0.0.0:2379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--initial-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node1=http://172.16.238.100:2380,node2=http://172.16.238.101:2380,node3=http://172.16.238.102:2380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--initial-cluster-state</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--initial-cluster-token</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">docker-etcd</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">node1-data:</span></span><br><span class="line">  <span class="attr">node2-data:</span></span><br><span class="line">  <span class="attr">node3-data:</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">cluster_net:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">ipam:</span></span><br><span class="line">      <span class="attr">driver:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">      <span class="bullet">-</span></span><br><span class="line">        <span class="attr">subnet:</span> <span class="number">172.16</span><span class="number">.238</span><span class="number">.0</span><span class="string">/24</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>docker-compose up</code> 启动集群之后使用 <code>docker exec</code> 命令登录到任一节点测试 <code>etcd</code> 集群。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># etcdctl member list</span></span><br><span class="line">daf3fd52e3583ff, started, node3, http://172.16.238.102:2380, http://172.16.238.102:2379</span><br><span class="line">422a74f03b622fef, started, node1, http://172.16.238.100:2380, http://172.16.238.100:2379</span><br><span class="line">ed635d2a2dbef43d, started, node2, http://172.16.238.101:2380, http://172.16.238.101:2379</span><br></pre></td></tr></table></figure>

<h2 id="使用-etcdctl"><a href="#使用-etcdctl" class="headerlink" title="使用 etcdctl"></a>使用 etcdctl</h2><p><code>etcdctl</code> 是一个命令行客户端，它能提供一些简洁的命令，供用户直接跟 <code>etcd</code> 服务打交道，而无需基于 <code>HTTP API</code> 方式。这在某些情况下将很方便，例如用户对服务进行测试或者手动修改数据库内容。我们也推荐在刚接触 <code>etcd</code> 时通过 <code>etcdctl</code> 命令来熟悉相关的操作，这些操作跟 <code>HTTP API</code> 实际上是对应的。</p>
<p><code>etcd</code> 项目二进制发行包中已经包含了 <code>etcdctl</code> 工具，没有的话，可以从 <a href="https://github.com/etcd-io/etcd/releases">github.com&#x2F;etcd-io&#x2F;etcd&#x2F;releases</a> 下载。</p>
<p><code>etcdctl</code> 支持如下的命令，大体上分为数据库操作和非数据库操作两类，后面将分别进行解释。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAME:</span><br><span class="line">	etcdctl - A simple <span class="built_in">command</span> line client <span class="keyword">for</span> etcd3.</span><br><span class="line">USAGE:</span><br><span class="line">	etcdctl</span><br><span class="line">VERSION:</span><br><span class="line">	3.4.0</span><br><span class="line">API VERSION:</span><br><span class="line">	3.4</span><br><span class="line">COMMANDS:</span><br><span class="line">	get			Gets the key or a range of keys</span><br><span class="line">	put			Puts the given key into the store</span><br><span class="line">	del			Removes the specified key or range of keys [key, range_end)</span><br><span class="line">	txn			Txn processes all the requests <span class="keyword">in</span> one transaction</span><br><span class="line">	compaction		Compacts the event <span class="built_in">history</span> <span class="keyword">in</span> etcd</span><br><span class="line">	alarm disarm		Disarms all alarms</span><br><span class="line">	alarm list		Lists all alarms</span><br><span class="line">	defrag			Defragments the storage of the etcd members with given endpoints</span><br><span class="line">	endpoint health		Checks the healthiness of endpoints specified <span class="keyword">in</span> `--endpoints` flag</span><br><span class="line">	endpoint status		Prints out the status of endpoints specified <span class="keyword">in</span> `--endpoints` flag</span><br><span class="line">	watch			Watches events stream on keys or prefixes</span><br><span class="line">	version			Prints the version of etcdctl</span><br><span class="line">	lease grant		Creates leases</span><br><span class="line">	lease revoke		Revokes leases</span><br><span class="line">	lease timetolive	Get lease information</span><br><span class="line">	lease keep-alive	Keeps leases alive (renew)</span><br><span class="line">	member add		Adds a member into the cluster</span><br><span class="line">	member remove		Removes a member from the cluster</span><br><span class="line">	member update		Updates a member <span class="keyword">in</span> the cluster</span><br><span class="line">	member list		Lists all members <span class="keyword">in</span> the cluster</span><br><span class="line">	snapshot save		Stores an etcd node backend snapshot to a given file</span><br><span class="line">	snapshot restore	Restores an etcd member snapshot to an etcd directory</span><br><span class="line">	snapshot status		Gets backend snapshot status of a given file</span><br><span class="line">	make-mirror		Makes a mirror at the destination etcd cluster</span><br><span class="line">	migrate			Migrates keys <span class="keyword">in</span> a v2 store to a mvcc store</span><br><span class="line">	lock			Acquires a named lock</span><br><span class="line">	elect			Observes and participates <span class="keyword">in</span> leader election</span><br><span class="line">	auth <span class="built_in">enable</span>		Enables authentication</span><br><span class="line">	auth <span class="built_in">disable</span>		Disables authentication</span><br><span class="line">	user add		Adds a new user</span><br><span class="line">	user delete		Deletes a user</span><br><span class="line">	user get		Gets detailed information of a user</span><br><span class="line">	user list		Lists all <span class="built_in">users</span></span><br><span class="line">	user passwd		Changes password of user</span><br><span class="line">	user grant-role		Grants a role to a user</span><br><span class="line">	user revoke-role	Revokes a role from a user</span><br><span class="line">	role add		Adds a new role</span><br><span class="line">	role delete		Deletes a role</span><br><span class="line">	role get		Gets detailed information of a role</span><br><span class="line">	role list		Lists all roles</span><br><span class="line">	role grant-permission	Grants a key to a role</span><br><span class="line">	role revoke-permission	Revokes a key from a role</span><br><span class="line">	check perf		Check the performance of the etcd cluster</span><br><span class="line">	<span class="built_in">help</span>			Help about any <span class="built_in">command</span></span><br><span class="line">OPTIONS:</span><br><span class="line">      --cacert=<span class="string">&quot;&quot;</span>				verify certificates of TLS-enabled secure servers using this CA bundle</span><br><span class="line">      --cert=<span class="string">&quot;&quot;</span>					identify secure client using this TLS certificate file</span><br><span class="line">      --command-timeout=5s			<span class="built_in">timeout</span> <span class="keyword">for</span> short running <span class="built_in">command</span> (excluding dial <span class="built_in">timeout</span>)</span><br><span class="line">      --debug[=<span class="literal">false</span>]				<span class="built_in">enable</span> client-side debug logging</span><br><span class="line">      --dial-timeout=2s				dial <span class="built_in">timeout</span> <span class="keyword">for</span> client connections</span><br><span class="line">      --endpoints=[127.0.0.1:2379]		gRPC endpoints</span><br><span class="line">      --hex[=<span class="literal">false</span>]				<span class="built_in">print</span> byte strings as hex encoded strings</span><br><span class="line">      --insecure-skip-tls-verify[=<span class="literal">false</span>]	skip server certificate verification</span><br><span class="line">      --insecure-transport[=<span class="literal">true</span>]		<span class="built_in">disable</span> transport security <span class="keyword">for</span> client connections</span><br><span class="line">      --key=<span class="string">&quot;&quot;</span>					identify secure client using this TLS key file</span><br><span class="line">      --user=<span class="string">&quot;&quot;</span>					username[:password] <span class="keyword">for</span> authentication (prompt <span class="keyword">if</span> password is not supplied)</span><br><span class="line">  -w, --write-out=<span class="string">&quot;simple&quot;</span>			<span class="built_in">set</span> the output format (fields, json, protobuf, simple, table)</span><br></pre></td></tr></table></figure>

<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>数据库操作围绕对键值和目录的 CRUD （符合 REST 风格的一套操作：Create）完整生命周期的管理。</p>
<p>etcd 在键的组织上采用了层次化的空间结构（类似于文件系统中目录的概念），用户指定的键可以为单独的名字，如 <code>testkey</code>，此时实际上放在根目录 <code>/</code> 下面，也可以为指定目录结构，如 <code>cluster1/node2/testkey</code>，则将创建相应的目录结构。</p>
<blockquote>
<p>注：CRUD 即 Create, Read, Update, Delete，是符合 REST 风格的一套 API 操作。</p>
</blockquote>
<h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ etcdctl put /testdir/testkey <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>获取指定键的值。例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ etcdctl put testkey hello</span><br><span class="line">OK</span><br><span class="line">$ etcdctl get testkey</span><br><span class="line">testkey</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>支持的选项为</p>
<p><code>--sort</code>	对结果进行排序</p>
<p><code>--consistent</code> 将请求发给主节点，保证获取内容的一致性</p>
<h4 id="del"><a href="#del" class="headerlink" title="del"></a>del</h4><p>删除某个键值。例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ etcdctl del testkey</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="非数据库操作"><a href="#非数据库操作" class="headerlink" title="非数据库操作"></a>非数据库操作</h3><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>监测一个键值的变化，一旦键值发生更新，就会输出最新的值。</p>
<p>例如，用户更新 <code>testkey</code> 键值为 <code>Hello world</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ etcdctl watch testkey</span><br><span class="line">PUT</span><br><span class="line">testkey</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h4 id="member"><a href="#member" class="headerlink" title="member"></a>member</h4><p>通过 <code>list</code>、<code>add</code>、<code>update</code>、<code>remove</code> 命令列出、添加、更新、删除 etcd 实例到 etcd 集群中。</p>
<p>例如本地启动一个 <code>etcd</code> 服务实例后，可以用如下命令进行查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ etcdctl member list</span><br><span class="line">422a74f03b622fef, started, node1, http://172.16.238.100:2380, http://172.16.238.100:23</span><br></pre></td></tr></table></figure>

<h1 id="Fedora-CoreOS"><a href="#Fedora-CoreOS" class="headerlink" title="Fedora CoreOS"></a>Fedora CoreOS</h1><p>CoreOS 是一个专门为安全和大规模运行容器化工作负载而构建的新 Fedora 版本，它继承了 Fedora Atomic Host 和 CoreOS Container Linux 的优势。</p>
<p>CoreOS 的安装文件和运行依赖非常小，它提供了精简的 Linux 系统。它使用 Linux 容器在更高的抽象层来管理你的服务，而不是通过常规的包管理工具 yum 或 apt 来安装包。</p>
<p>同时，CoreOS 几乎可以运行在任何平台：VirtualBox Amazon EC2 QEMU&#x2F;KVM VMware Bare Metal 和 OpenStack 等 。</p>
<h2 id="Fedora-CoreOS-介绍"><a href="#Fedora-CoreOS-介绍" class="headerlink" title="Fedora CoreOS 介绍"></a>Fedora CoreOS 介绍</h2><p><a href="https://getfedora.org/coreos/">Fedora CoreOS</a> 是一个自动更新的，最小的，整体的，以容器为中心的操作系统，不仅适用于集群，而且可独立运行，并针对运行 Kubernetes 进行了优化。它旨在结合 CoreOS Container Linux 和 Fedora Atomic Host 的优点，将 Container Linux 中的 <a href="https://github.com/coreos/ignition">Ignition</a> 与 <a href="https://github.com/coreos/rpm-ostree">rpm-ostree</a> 和 Project Atomic 中的 SELinux 强化等技术相集成。其目标是提供最佳的容器主机，以安全，大规模地运行容器化的工作负载。</p>
<h3 id="FCOS-特性"><a href="#FCOS-特性" class="headerlink" title="FCOS 特性"></a>FCOS 特性</h3><h4 id="一个最小化操作系统"><a href="#一个最小化操作系统" class="headerlink" title="一个最小化操作系统"></a>一个最小化操作系统</h4><p>FCOS 被设计成一个基于容器的最小化的现代操作系统。它比现有的 Linux 安装平均节省 40% 的 RAM（大约 114M ）并允许从 PXE 或 iPXE 非常快速的启动。</p>
<h4 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h4><p>Ignition 是一种配置实用程序，可读取配置文件（JSON 格式）并根据该配置配置 FCOS 系统。可配置的组件包括存储，文件系统，systemd 和用户。</p>
<p>Ignition 在系统首次启动期间（在 initramfs 中）仅运行一次。由于 Ignition 在启动过程中的早期运行，因此它可以在用户空间开始启动之前重新对磁盘分区，格式化文件系统，创建用户并写入文件。当 systemd 启动时，systemd 服务已被写入磁盘，从而加快了启动时间。</p>
<h4 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h4><p>FCOS 使用 rpm-ostree 系统进行事务性升级。无需像 yum 升级那样升级单个软件包，而是 rpm-ostree 将 OS 升级作为一个原子单元进行。新的 OS 部署在升级期间进行，并在下次重新引导时生效。如果升级出现问题，则一次回滚和重新启动会使系统返回到先前的状态。确保了系统升级对群集容量的影响降到最小。</p>
<h4 id="容器工具"><a href="#容器工具" class="headerlink" title="容器工具"></a>容器工具</h4><p>对于诸如构建，复制和其他管理容器的任务，FCOS 用一组容器工具代替了 <strong>Docker CLI</strong>。<strong>podman CLI</strong> 工具支持许多容器运行时功能，例如运行，启动，停止，列出和删除容器和镜像。<strong>skopeo CLI</strong> 工具可以复制，认证和签名镜像。您还可以使用 <strong>crictl CLI</strong> 工具来处理 CRI-O 容器引擎中的容器和镜像。</p>
<h3 id="参考文档-1"><a href="#参考文档-1" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://docs.fedoraproject.org/en-US/fedora-coreos/">官方文档</a></li>
<li><a href="https://docs.openshift.com/container-platform/4.3/architecture/architecture-rhcos.html">openshift 官方文档</a></li>
</ul>
<h1 id="podman"><a href="#podman" class="headerlink" title="podman"></a>podman</h1><p><a href="https://github.com/containers/podman"><code>podman</code></a> 是一个无守护程序与 docker 命令兼容的下一代 Linux 容器工具。</p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum -y install podman</span><br></pre></td></tr></table></figure>

<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p><code>podman</code> 与 docker 命令完全兼容，只需将 <code>docker</code> 替换为 <code>podman</code> 即可，例如运行一个容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $ docker run -d -p 80:80 nginx:alpine</span></span><br><span class="line">$ podman run -d -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developers.redhat.com/blog/2019/02/21/podman-and-buildah-for-docker-users/">https://developers.redhat.com/blog/2019/02/21/podman-and-buildah-for-docker-users/</a></li>
</ul>
<h1 id="常见问题总结"><a href="#常见问题总结" class="headerlink" title="常见问题总结"></a>常见问题总结</h1><h2 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h2><h3 id="如何批量清理临时镜像文件？"><a href="#如何批量清理临时镜像文件？" class="headerlink" title="如何批量清理临时镜像文件？"></a>如何批量清理临时镜像文件？</h3><p>答：可以使用 <code>docker image prune</code> 命令。</p>
<h3 id="如何查看镜像支持的环境变量？"><a href="#如何查看镜像支持的环境变量？" class="headerlink" title="如何查看镜像支持的环境变量？"></a>如何查看镜像支持的环境变量？</h3><p>答：可以使用 <code>docker run IMAGE env</code> 命令。</p>
<h3 id="本地的镜像文件都存放在哪里？"><a href="#本地的镜像文件都存放在哪里？" class="headerlink" title="本地的镜像文件都存放在哪里？"></a>本地的镜像文件都存放在哪里？</h3><p>答：与 Docker 相关的本地资源默认存放在 <code>/var/lib/docker/</code> 目录下，以 <code>overlay2</code> 文件系统为例，其中 <code>containers</code> 目录存放容器信息，<code>image</code> 目录存放镜像信息，<code>overlay2</code> 目录下存放具体的镜像层文件。</p>
<h3 id="构建-Docker-镜像应该遵循哪些原则？"><a href="#构建-Docker-镜像应该遵循哪些原则？" class="headerlink" title="构建 Docker 镜像应该遵循哪些原则？"></a>构建 Docker 镜像应该遵循哪些原则？</h3><p>答：整体原则上，尽量保持镜像功能的明确和内容的精简，要点包括</p>
<ul>
<li><p>尽量选取满足需求但较小的基础系统镜像，例如大部分时候可以选择 <code>alpine</code> 镜像，仅有不足六兆大小；</p>
</li>
<li><p>清理编译生成文件、安装包的缓存等临时文件；</p>
</li>
<li><p>安装各个软件时候要指定准确的版本号，并避免引入不需要的依赖；</p>
</li>
<li><p>从安全角度考虑，应用要尽量使用系统的库和依赖；</p>
</li>
<li><p>如果安装应用时候需要配置一些特殊的环境变量，在安装后要还原不需要保持的变量值；</p>
</li>
<li><p>使用 Dockerfile 创建镜像时候要添加 .dockerignore 文件或使用干净的工作目录。</p>
</li>
</ul>
<p>更多内容请查看 <a href="../best_practices.md">Dockerfile 最佳实践</a></p>
<h3 id="碰到网络问题，无法-pull-镜像，命令行指定-http-proxy-无效？"><a href="#碰到网络问题，无法-pull-镜像，命令行指定-http-proxy-无效？" class="headerlink" title="碰到网络问题，无法 pull 镜像，命令行指定 http_proxy 无效？"></a>碰到网络问题，无法 pull 镜像，命令行指定 http_proxy 无效？</h3><p>答：在 Docker 配置文件中添加 <code>export http_proxy=&quot;http://&lt;PROXY_HOST&gt;:&lt;PROXY_PORT&gt;&quot;</code>，之后重启 Docker 服务即可。</p>
<h2 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h2><h3 id="容器退出后，通过-docker-container-ls-命令查看不到，数据会丢失么？"><a href="#容器退出后，通过-docker-container-ls-命令查看不到，数据会丢失么？" class="headerlink" title="容器退出后，通过 docker container ls 命令查看不到，数据会丢失么？"></a>容器退出后，通过 docker container ls 命令查看不到，数据会丢失么？</h3><p>答：容器退出后会处于终止（exited）状态，此时可以通过 <code>docker container ls -a</code> 查看。其中的数据也不会丢失，还可以通过 <code>docker start</code> 命令来启动它。只有删除掉容器才会清除所有数据。</p>
<h3 id="如何停止所有正在运行的容器？"><a href="#如何停止所有正在运行的容器？" class="headerlink" title="如何停止所有正在运行的容器？"></a>如何停止所有正在运行的容器？</h3><p>答：可以使用 <code>docker stop $(docker container ls -q)</code> 命令。</p>
<h3 id="如何批量清理已经停止的容器？"><a href="#如何批量清理已经停止的容器？" class="headerlink" title="如何批量清理已经停止的容器？"></a>如何批量清理已经停止的容器？</h3><p>答：可以使用 <code>docker container prune</code> 命令。</p>
<h3 id="如何获取某个容器的-PID-信息？"><a href="#如何获取某个容器的-PID-信息？" class="headerlink" title="如何获取某个容器的 PID 信息？"></a>如何获取某个容器的 PID 信息？</h3><p>答：可以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span> &lt;CONTAINER ID or NAME&gt;</span><br></pre></td></tr></table></figure>

<h3 id="如何获取某个容器的-IP-地址？"><a href="#如何获取某个容器的-IP-地址？" class="headerlink" title="如何获取某个容器的 IP 地址？"></a>如何获取某个容器的 IP 地址？</h3><p>答：可以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;</span> &lt;CONTAINER ID or NAME&gt;</span><br></pre></td></tr></table></figure>

<h3 id="如何给容器指定一个固定-IP-地址，而不是每次重启容器-IP-地址都会变？"><a href="#如何给容器指定一个固定-IP-地址，而不是每次重启容器-IP-地址都会变？" class="headerlink" title="如何给容器指定一个固定 IP 地址，而不是每次重启容器 IP 地址都会变？"></a>如何给容器指定一个固定 IP 地址，而不是每次重启容器 IP 地址都会变？</h3><p>答：使用以下命令启动容器可以使容器 IP 固定不变</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker network create -d bridge --subnet 172.25.0.0/16 my-net</span><br><span class="line">$ docker run --network=my-net --ip=172.25.3.3 -itd --name=my-container busybox</span><br></pre></td></tr></table></figure>

<h3 id="如何临时退出一个正在交互的容器的终端，而不终止它？"><a href="#如何临时退出一个正在交互的容器的终端，而不终止它？" class="headerlink" title="如何临时退出一个正在交互的容器的终端，而不终止它？"></a>如何临时退出一个正在交互的容器的终端，而不终止它？</h3><p>答：按 <code>Ctrl-p Ctrl-q</code>。如果按 <code>Ctrl-c</code> 往往会让容器内应用进程终止，进而会终止容器。</p>
<h3 id="使用-docker-port-命令映射容器的端口时，系统报错“Error-No-public-port-‘80’-published-for-xxx”？"><a href="#使用-docker-port-命令映射容器的端口时，系统报错“Error-No-public-port-‘80’-published-for-xxx”？" class="headerlink" title="使用 docker port 命令映射容器的端口时，系统报错“Error: No public port ‘80’ published for xxx”？"></a>使用 <code>docker port</code> 命令映射容器的端口时，系统报错“Error: No public port ‘80’ published for xxx”？</h3><p>答：</p>
<ul>
<li><p>创建镜像时 <code>Dockerfile</code> 要通过 <code>EXPOSE</code> 指定正确的开放端口；</p>
</li>
<li><p>容器启动时指定 <code>PublishAllPort = true</code>。</p>
</li>
</ul>
<h3 id="可以在一个容器中同时运行多个应用进程么？"><a href="#可以在一个容器中同时运行多个应用进程么？" class="headerlink" title="可以在一个容器中同时运行多个应用进程么？"></a>可以在一个容器中同时运行多个应用进程么？</h3><p>答：一般并不推荐在同一个容器内运行多个应用进程。如果有类似需求，可以通过一些额外的进程管理机制，比如 <code>supervisord</code> 来管理所运行的进程。可以参考 <a href="https://docs.docker.com/config/containers/multi-service_container/">https://docs.docker.com/config/containers/multi-service_container/</a> 。</p>
<h3 id="如何控制容器占用系统资源（CPU、内存）的份额？"><a href="#如何控制容器占用系统资源（CPU、内存）的份额？" class="headerlink" title="如何控制容器占用系统资源（CPU、内存）的份额？"></a>如何控制容器占用系统资源（CPU、内存）的份额？</h3><p>答：在使用 <code>docker create</code> 命令创建容器或使用 <code>docker run</code> 创建并启动容器的时候，可以使用 <code>-c|--cpu-shares[=0]</code> 参数来调整容器使用 CPU 的权重；使用 <code>-m|--memory[=MEMORY]</code> 参数来调整容器使用内存的大小。</p>
<h2 id="仓库相关"><a href="#仓库相关" class="headerlink" title="仓库相关"></a>仓库相关</h2><h3 id="仓库（Repository）、注册服务器（Registry）、注册索引（Index）-有何关系？"><a href="#仓库（Repository）、注册服务器（Registry）、注册索引（Index）-有何关系？" class="headerlink" title="仓库（Repository）、注册服务器（Registry）、注册索引（Index） 有何关系？"></a>仓库（Repository）、注册服务器（Registry）、注册索引（Index） 有何关系？</h3><p>首先，仓库是存放一组关联镜像的集合，比如同一个应用的不同版本的镜像。</p>
<p>注册服务器是存放实际的镜像文件的地方。注册索引则负责维护用户的账号、权限、搜索、标签等的管理。因此，注册服务器利用注册索引来实现认证等管理。</p>
<h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><h3 id="Docker-的配置文件放在哪里，如何修改配置？"><a href="#Docker-的配置文件放在哪里，如何修改配置？" class="headerlink" title="Docker 的配置文件放在哪里，如何修改配置？"></a>Docker 的配置文件放在哪里，如何修改配置？</h3><p>答：使用 <code>systemd</code> 的系统（如 Ubuntu 16.04、Centos 等）的配置文件在 <code>/etc/docker/daemon.json</code>。</p>
<h3 id="如何更改-Docker-的默认存储位置？"><a href="#如何更改-Docker-的默认存储位置？" class="headerlink" title="如何更改 Docker 的默认存储位置？"></a>如何更改 Docker 的默认存储位置？</h3><p>答：Docker 的默认存储位置是 <code>/var/lib/docker</code>，如果希望将 Docker 的本地文件存储到其他分区，可以使用 Linux 软连接的方式来完成，或者在启动 daemon 时通过 <code>-g</code> 参数指定，或者修改配置文件 <code>/etc/docker/daemon.json</code> 的 “data-root” 项 。可以使用 <code>docker system info | grep &quot;Root Dir&quot;</code> 查看当前使用的存储位置。</p>
<p>例如，如下操作将默认存储位置迁移到 &#x2F;storage&#x2F;docker。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@s26 ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem                    Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/VolGroup-lv_root   50G  5.3G   42G  12% /</span><br><span class="line">tmpfs                          48G  228K   48G   1% /dev/shm</span><br><span class="line">/dev/sda1                     485M   40M  420M   9% /boot</span><br><span class="line">/dev/mapper/VolGroup-lv_home  222G  188M  210G   1% /home</span><br><span class="line">/dev/sdb2                     2.7T  323G  2.3T  13% /storage</span><br><span class="line">[root@s26 ~]<span class="comment"># service docker stop</span></span><br><span class="line">[root@s26 ~]<span class="comment"># cd /var/lib/</span></span><br><span class="line">[root@s26 lib]<span class="comment"># mv docker /storage/</span></span><br><span class="line">[root@s26 lib]<span class="comment"># ln -s /storage/docker/ docker</span></span><br><span class="line">[root@s26 lib]<span class="comment"># ls -la docker</span></span><br><span class="line">lrwxrwxrwx. 1 root root 15 11月 17 13:43 docker -&gt; /storage/docker</span><br><span class="line">[root@s26 lib]<span class="comment"># service docker start</span></span><br></pre></td></tr></table></figure>

<h3 id="使用内存和-swap-限制启动容器时候报警告：”WARNING-Your-kernel-does-not-support-cgroup-swap-limit-WARNING-Your-kernel-does-not-support-swap-limit-capabilities-Limitation-discarded-”？"><a href="#使用内存和-swap-限制启动容器时候报警告：”WARNING-Your-kernel-does-not-support-cgroup-swap-limit-WARNING-Your-kernel-does-not-support-swap-limit-capabilities-Limitation-discarded-”？" class="headerlink" title="使用内存和 swap 限制启动容器时候报警告：”WARNING: Your kernel does not support cgroup swap limit. WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.”？"></a>使用内存和 swap 限制启动容器时候报警告：”WARNING: Your kernel does not support cgroup swap limit. WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.”？</h3><p>答：这是因为系统默认没有开启对内存和 swap 使用的统计功能，引入该功能会带来性能的下降。要开启该功能，可以采取如下操作：</p>
<ul>
<li><p>编辑 <code>/etc/default/grub</code> 文件（Ubuntu 系统为例），配置 <code>GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1&quot;</code></p>
</li>
<li><p>更新 grub：<code>$ sudo update-grub</code></p>
</li>
<li><p>重启系统，即可。</p>
</li>
</ul>
<h2 id="Docker-与虚拟化"><a href="#Docker-与虚拟化" class="headerlink" title="Docker 与虚拟化"></a>Docker 与虚拟化</h2><h3 id="Docker-与-LXC（Linux-Container）有何不同？"><a href="#Docker-与-LXC（Linux-Container）有何不同？" class="headerlink" title="Docker 与 LXC（Linux Container）有何不同？"></a>Docker 与 LXC（Linux Container）有何不同？</h3><p>答：LXC 利用 Linux 上相关技术实现了容器。Docker 则在如下的几个方面进行了改进：</p>
<ul>
<li>移植性：通过抽象容器配置，容器可以实现从一个平台移植到另一个平台；</li>
<li>镜像系统：基于 OverlayFS 的镜像系统为容器的分发带来了很多的便利，同时共同的镜像层只需要存储一份，实现高效率的存储；</li>
<li>版本管理：类似于Git的版本管理理念，用户可以更方便的创建、管理镜像文件；</li>
<li>仓库系统：仓库系统大大降低了镜像的分发和管理的成本；</li>
<li>周边工具：各种现有工具（配置管理、云平台）对 Docker 的支持，以及基于 Docker的 PaaS、CI 等系统，让 Docker 的应用更加方便和多样化。</li>
</ul>
<h3 id="Docker-与-Vagrant-有何不同？"><a href="#Docker-与-Vagrant-有何不同？" class="headerlink" title="Docker 与 Vagrant 有何不同？"></a>Docker 与 Vagrant 有何不同？</h3><p>答：两者的定位完全不同。</p>
<ul>
<li><p>Vagrant 类似 Boot2Docker（一款运行 Docker 的最小内核），是一套虚拟机的管理环境。Vagrant 可以在多种系统上和虚拟机软件中运行，可以在 Windows，Mac 等非 Linux 平台上为 Docker 提供支持，自身具有较好的包装性和移植性。</p>
</li>
<li><p>原生的 Docker 自身只能运行在 Linux 平台上，但启动和运行的性能都比虚拟机要快，往往更适合快速开发和部署应用的场景。</p>
</li>
</ul>
<p>简单说：Vagrant 适合用来管理虚拟机，而 Docker 适合用来管理应用环境。</p>
<h3 id="开发环境中-Docker-和-Vagrant-该如何选择？"><a href="#开发环境中-Docker-和-Vagrant-该如何选择？" class="headerlink" title="开发环境中 Docker 和 Vagrant 该如何选择？"></a>开发环境中 Docker 和 Vagrant 该如何选择？</h3><p>答：Docker 不是虚拟机，而是进程隔离，对于资源的消耗很少，但是目前需要 Linux 环境支持。Vagrant 是虚拟机上做的封装，虚拟机本身会消耗资源。</p>
<p>如果本地使用的 Linux 环境，推荐都使用 Docker。</p>
<p>如果本地使用的是 macOS 或者 Windows 环境，那就需要开虚拟机，单一开发环境下 Vagrant 更简单；多环境开发下推荐在 Vagrant 里面再使用 Docker 进行环境隔离。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="Docker-能在非-Linux-平台（比如-Windows-或-macOS-）上运行么？"><a href="#Docker-能在非-Linux-平台（比如-Windows-或-macOS-）上运行么？" class="headerlink" title="Docker 能在非 Linux 平台（比如 Windows 或 macOS ）上运行么？"></a>Docker 能在非 Linux 平台（比如 Windows 或 macOS ）上运行么？</h3><p>答：完全可以。安装方法请查看 <a href="../../install/">安装 Docker</a> 一节</p>
<h3 id="如何将一台宿主主机的-Docker-环境迁移到另外一台宿主主机？"><a href="#如何将一台宿主主机的-Docker-环境迁移到另外一台宿主主机？" class="headerlink" title="如何将一台宿主主机的 Docker 环境迁移到另外一台宿主主机？"></a>如何将一台宿主主机的 Docker 环境迁移到另外一台宿主主机？</h3><p>答：停止 Docker 服务。将整个 Docker 存储文件夹复制到另外一台宿主主机，然后调整另外一台宿主主机的配置即可。</p>
<h3 id="如何进入-Docker-容器的网络命名空间？"><a href="#如何进入-Docker-容器的网络命名空间？" class="headerlink" title="如何进入 Docker 容器的网络命名空间？"></a>如何进入 Docker 容器的网络命名空间？</h3><p>答：Docker 在创建容器后，删除了宿主主机上 <code>/var/run/netns</code> 目录中的相关的网络命名空间文件。因此，在宿主主机上是无法看到或访问容器的网络命名空间的。</p>
<p>用户可以通过如下方法来手动恢复它。</p>
<p>首先，使用下面的命令查看容器进程信息，比如这里的 1234。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker inspect --format=<span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125; &#x27;</span> <span class="variable">$container_id</span></span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>接下来，在 <code>/proc</code> 目录下，把对应的网络命名空间文件链接到 <code>/var/run/netns</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">ln</span> -s /proc/1234/ns/net /var/run/netns/</span><br></pre></td></tr></table></figure>

<p>然后，在宿主主机上就可以看到容器的网络命名空间信息。例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ip netns show</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>此时，用户可以通过正常的系统命令来查看或操作容器的命名空间了。例如修改容器的 IP 地址信息为 <code>172.17.0.100/16</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ip netns <span class="built_in">exec</span> 1234 ifconfig eth0 172.17.0.100/16</span><br></pre></td></tr></table></figure>

<h3 id="如何获取容器绑定到本地那个-veth-接口上？"><a href="#如何获取容器绑定到本地那个-veth-接口上？" class="headerlink" title="如何获取容器绑定到本地那个 veth 接口上？"></a>如何获取容器绑定到本地那个 veth 接口上？</h3><p>答：Docker 容器启动后，会通过 veth 接口对连接到本地网桥，veth 接口命名跟容器命名毫无关系，十分难以找到对应关系。</p>
<p>最简单的一种方式是通过查看接口的索引号，在容器中执行 <code>ip a</code> 命令，查看到本地接口最前面的接口索引号，如 <code>205</code>，将此值加上 1，即 <code>206</code>，然后在本地主机执行 <code>ip a</code> 命令，查找接口索引号为 <code>206</code> 的接口，两者即为连接的 veth 接口对。</p>
<h1 id="Docker-命令查询"><a href="#Docker-命令查询" class="headerlink" title="Docker 命令查询"></a>Docker 命令查询</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>Docker 命令有两大类，客户端命令和服务端命令。前者是主要的操作接口，后者用来启动 Docker Daemon。</p>
<ul>
<li><p>客户端命令：基本命令格式为 <code>docker [OPTIONS] COMMAND [arg...]</code>；</p>
</li>
<li><p>服务端命令：基本命令格式为 <code>dockerd [OPTIONS]</code>。</p>
</li>
</ul>
<p>可以通过 <code>man docker</code> 或 <code>docker help</code> 来查看这些命令。</p>
<p>接下来的小节对这两个命令进行介绍。</p>
<h2 id="客户端命令-docker"><a href="#客户端命令-docker" class="headerlink" title="客户端命令(docker)"></a>客户端命令(docker)</h2><h3 id="客户端命令选项"><a href="#客户端命令选项" class="headerlink" title="客户端命令选项"></a>客户端命令选项</h3><ul>
<li><code>--config=&quot;&quot;</code>：指定客户端配置文件，默认为 <code>~/.docker</code>；</li>
<li><code>-D=true|false</code>：是否使用 debug 模式。默认不开启；</li>
<li><code>-H, --host=[]</code>：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字 <code>unix:///path/to/socket</code>，文件句柄 <code>fd://socketfd</code> 或 tcp 套接字 <code>tcp://[host[:port]]</code>，默认为 <code>unix:///var/run/docker.sock</code>；</li>
<li><code>-l, --log-level=&quot;debug|info|warn|error|fatal&quot;</code>：指定日志输出级别；</li>
<li><code>--tls=true|false</code>：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；</li>
<li><code>--tlscacert=/.docker/ca.pem</code>：TLS CA 签名的可信证书文件路径；</li>
<li><code>--tlscert=/.docker/cert.pem</code>：TLS 可信证书文件路径；</li>
<li><code>--tlscert=/.docker/key.pem</code>：TLS 密钥文件路径；</li>
<li><code>--tlsverify=true|false</code>：启用 TLS 校验，默认为否。</li>
</ul>
<h3 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h3><p>可以通过 <code>docker COMMAND --help</code> 来查看这些命令的具体用法。</p>
<ul>
<li><code>attach</code>：依附到一个正在运行的容器中；</li>
<li><code>build</code>：从一个 Dockerfile 创建一个镜像；</li>
<li><code>commit</code>：从一个容器的修改中创建一个新的镜像；</li>
<li><code>cp</code>：在容器和本地宿主系统之间复制文件中；</li>
<li><code>create</code>：创建一个新容器，但并不运行它；</li>
<li><code>diff</code>：检查一个容器内文件系统的修改，包括修改和增加；</li>
<li><code>events</code>：从服务端获取实时的事件；</li>
<li><code>exec</code>：在运行的容器内执行命令；</li>
<li><code>export</code>：导出容器内容为一个 <code>tar</code> 包；</li>
<li><code>history</code>：显示一个镜像的历史信息；</li>
<li><code>images</code>：列出存在的镜像；</li>
<li><code>import</code>：导入一个文件（典型为 <code>tar</code> 包）路径或目录来创建一个本地镜像；</li>
<li><code>info</code>：显示一些相关的系统信息；</li>
<li><code>inspect</code>：显示一个容器的具体配置信息；</li>
<li><code>kill</code>：关闭一个运行中的容器 (包括进程和所有相关资源)；</li>
<li><code>load</code>：从一个 tar 包中加载一个镜像；</li>
<li><code>login</code>：注册或登录到一个 Docker 的仓库服务器；</li>
<li><code>logout</code>：从 Docker 的仓库服务器登出；</li>
<li><code>logs</code>：获取容器的 log 信息；</li>
<li><code>network</code>：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；</li>
<li><code>node</code>：管理 swarm 集群中的节点，包括查看、更新、删除、提升&#x2F;取消管理节点等；</li>
<li><code>pause</code>：暂停一个容器中的所有进程；</li>
<li><code>port</code>：查找一个 nat 到一个私有网口的公共口；</li>
<li><code>ps</code>：列出主机上的容器；</li>
<li><code>pull</code>：从一个Docker的仓库服务器下拉一个镜像或仓库；</li>
<li><code>push</code>：将一个镜像或者仓库推送到一个 Docker 的注册服务器；</li>
<li><code>rename</code>：重命名一个容器；</li>
<li><code>restart</code>：重启一个运行中的容器；</li>
<li><code>rm</code>：删除给定的若干个容器；</li>
<li><code>rmi</code>：删除给定的若干个镜像；</li>
<li><code>run</code>：创建一个新容器，并在其中运行给定命令；</li>
<li><code>save</code>：保存一个镜像为 tar 包文件；</li>
<li><code>search</code>：在 Docker index 中搜索一个镜像；</li>
<li><code>service</code>：管理 Docker 所启动的应用服务，包括创建、更新、删除等；</li>
<li><code>start</code>：启动一个容器；</li>
<li><code>stats</code>：输出（一个或多个）容器的资源使用统计信息；</li>
<li><code>stop</code>：终止一个运行中的容器；</li>
<li><code>swarm</code>：管理 Docker swarm 集群，包括创建、加入、退出、更新等；</li>
<li><code>tag</code>：为一个镜像打标签；</li>
<li><code>top</code>：查看一个容器中的正在运行的进程信息；</li>
<li><code>unpause</code>：将一个容器内所有的进程从暂停状态中恢复；</li>
<li><code>update</code>：更新指定的若干容器的配置信息；</li>
<li><code>version</code>：输出 Docker 的版本信息；</li>
<li><code>volume</code>：管理 Docker volume，包括查看、创建、删除等；</li>
<li><code>wait</code>：阻塞直到一个容器终止，然后输出它的退出符。</li>
</ul>
<h3 id="一张图总结-Docker-的命令"><a href="#一张图总结-Docker-的命令" class="headerlink" title="一张图总结 Docker 的命令"></a>一张图总结 Docker 的命令</h3><p><img src="/2022/docker_practice/cmd_logic.png" alt="Docker 命令总结"></p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/cli/">官方文档</a></li>
</ul>
<h2 id="服务端命令-dockerd"><a href="#服务端命令-dockerd" class="headerlink" title="服务端命令(dockerd)"></a>服务端命令(dockerd)</h2><h3 id="dockerd-命令选项"><a href="#dockerd-命令选项" class="headerlink" title="dockerd 命令选项"></a>dockerd 命令选项</h3><ul>
<li><code>--api-cors-header=&quot;&quot;</code>：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 “*”；</li>
<li><code>--authorization-plugin=&quot;&quot;</code>：载入认证的插件；</li>
<li><code>-b=&quot;&quot;</code>：将容器挂载到一个已存在的网桥上。指定为 <code>none</code> 时则禁用容器的网络，与 <code>--bip</code> 选项互斥；</li>
<li><code>--bip=&quot;&quot;</code>：让动态创建的 <code>docker0</code> 网桥采用给定的 CIDR 地址; 与 <code>-b</code> 选项互斥；</li>
<li><code>--cgroup-parent=&quot;&quot;</code>：指定 cgroup 的父组，默认 fs cgroup 驱动为 <code>/docker</code>，systemd cgroup 驱动为 <code>system.slice</code>；</li>
<li><code>--cluster-store=&quot;&quot;</code>：构成集群（如 <code>Swarm</code>）时，集群键值数据库服务地址；</li>
<li><code>--cluster-advertise=&quot;&quot;</code>：构成集群时，自身的被访问地址，可以为 <code>host:port</code> 或 <code>interface:port</code>；</li>
<li><code>--cluster-store-opt=&quot;&quot;</code>：构成集群时，键值数据库的配置选项；</li>
<li><code>--config-file=&quot;/etc/docker/daemon.json&quot;</code>：daemon 配置文件路径；</li>
<li><code>--containerd=&quot;&quot;</code>：containerd 文件的路径；</li>
<li><code>-D, --debug=true|false</code>：是否使用 Debug 模式。缺省为 false；</li>
<li><code>--default-gateway=&quot;&quot;</code>：容器的 IPv4 网关地址，必须在网桥的子网段内；</li>
<li><code>--default-gateway-v6=&quot;&quot;</code>：容器的 IPv6 网关地址；</li>
<li><code>--default-ulimit=[]</code>：默认的 ulimit 值；</li>
<li><code>--disable-legacy-registry=true|false</code>：是否允许访问旧版本的镜像仓库服务器；</li>
<li><code>--dns=&quot;&quot;</code>：指定容器使用的 DNS 服务器地址；</li>
<li><code>--dns-opt=&quot;&quot;</code>：DNS 选项；</li>
<li><code>--dns-search=[]</code>：DNS 搜索域；</li>
<li><code>--exec-opt=[]</code>：运行时的执行选项；</li>
<li><code>--exec-root=&quot;&quot;</code>：容器执行状态文件的根路径，默认为 <code>/var/run/docker</code>；</li>
<li><code>--fixed-cidr=&quot;&quot;</code>：限定分配 IPv4 地址范围；</li>
<li><code>--fixed-cidr-v6=&quot;&quot;</code>：限定分配 IPv6 地址范围；</li>
<li><code>-G, --group=&quot;&quot;</code>：分配给 unix 套接字的组，默认为 <code>docker</code>；</li>
<li><code>-g, --graph=&quot;&quot;</code>：Docker 运行时的根路径，默认为 <code>/var/lib/docker</code>；</li>
<li><code>-H, --host=[]</code>：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字 <code>unix:///path/to/socket</code>，文件句柄 <code>fd://socketfd</code> 或 tcp 套接字 <code>tcp://[host[:port]]</code>，默认为 <code>unix:///var/run/docker.sock</code>；</li>
<li><code>--icc=true|false</code>：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。</li>
<li><code>--insecure-registry=[]</code>：允许访问给定的非安全仓库服务；</li>
<li><code>--ip=&quot;&quot;</code>：绑定容器端口时候的默认 IP 地址。缺省为 <code>0.0.0.0</code>；</li>
<li><code>--ip-forward=true|false</code>：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；</li>
<li><code>--ip-masq=true|false</code>：是否进行地址伪装，用于容器访问外部网络，默认开启；</li>
<li><code>--iptables=true|false</code>：是否允许 Docker 添加 iptables 规则。缺省为 true；</li>
<li><code>--ipv6=true|false</code>：是否启用 IPv6 支持，默认关闭；</li>
<li><code>-l, --log-level=&quot;debug|info|warn|error|fatal&quot;</code>：指定日志输出级别；</li>
<li><code>--label=&quot;[]&quot;</code>：添加指定的键值对标注；</li>
<li><code>--log-driver=&quot;json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none&quot;</code>：指定日志后端驱动，默认为 <code>json-file</code>；</li>
<li><code>--log-opt=[]</code>：日志后端的选项；</li>
<li><code>--mtu=VALUE</code>：指定容器网络的 <code>mtu</code>；</li>
<li><code>-p=&quot;&quot;</code>：指定 daemon 的 PID 文件路径。缺省为 <code>/var/run/docker.pid</code>；</li>
<li><code>--raw-logs</code>：输出原始，未加色彩的日志信息；</li>
<li><code>--registry-mirror=&lt;scheme&gt;://&lt;host&gt;</code>：指定 <code>docker pull</code> 时使用的注册服务器镜像地址；</li>
<li><code>-s, --storage-driver=&quot;&quot;</code>：指定使用给定的存储后端；</li>
<li><code>--selinux-enabled=true|false</code>：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；</li>
<li><code>--storage-opt=[]</code>：驱动后端选项；</li>
<li><code>--tls=true|false</code>：是否对 Docker daemon 启用 TLS 安全机制，默认为否；</li>
<li><code>--tlscacert=/.docker/ca.pem</code>：TLS CA 签名的可信证书文件路径；</li>
<li><code>--tlscert=/.docker/cert.pem</code>：TLS 可信证书文件路径；</li>
<li><code>--tlscert=/.docker/key.pem</code>：TLS 密钥文件路径；</li>
<li><code>--tlsverify=true|false</code>：启用 TLS 校验，默认为否；</li>
<li><code>--userland-proxy=true|false</code>：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；</li>
<li><code>--userns-remap=default|uid:gid|user:group|user|uid</code>：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。</li>
</ul>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/dockerd/">官方文档</a></li>
</ul>
<h1 id="Dockerfile-最佳实践"><a href="#Dockerfile-最佳实践" class="headerlink" title="Dockerfile 最佳实践"></a>Dockerfile 最佳实践</h1><p>本附录是笔者对 Docker 官方文档中 <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Best practices for writing Dockerfiles</a> 的理解与翻译。</p>
<h2 id="一般性的指南和建议"><a href="#一般性的指南和建议" class="headerlink" title="一般性的指南和建议"></a>一般性的指南和建议</h2><h3 id="容器应该是短暂的"><a href="#容器应该是短暂的" class="headerlink" title="容器应该是短暂的"></a>容器应该是短暂的</h3><p>通过 <code>Dockerfile</code> 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。</p>
<h3 id="使用-dockerignore-文件"><a href="#使用-dockerignore-文件" class="headerlink" title="使用 .dockerignore 文件"></a>使用 <code>.dockerignore</code> 文件</h3><p>使用 <code>Dockerfile</code> 构建镜像时最好是将 <code>Dockerfile</code> 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 <code>.dockerignore</code> 文件来指定要忽略的文件和目录。<code>.dockerignore</code> 文件的排除模式语法和 Git 的 <code>.gitignore</code> 文件相似。</p>
<h3 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h3><p>在 <code>Docker 17.05</code> 以上版本中，你可以使用 <a href="../image/multistage-builds.md">多阶段构建</a> 来减少所构建镜像的大小。</p>
<h3 id="避免安装不必要的包"><a href="#避免安装不必要的包" class="headerlink" title="避免安装不必要的包"></a>避免安装不必要的包</h3><p>为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。</p>
<h3 id="一个容器只运行一个进程"><a href="#一个容器只运行一个进程" class="headerlink" title="一个容器只运行一个进程"></a>一个容器只运行一个进程</h3><p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web应用、数据库、缓存。</p>
<p>如果容器互相依赖，你可以使用 <a href="../network/linking.md">Docker 自定义网络</a> 来把这些容器连接起来。</p>
<h3 id="镜像层数尽可能少"><a href="#镜像层数尽可能少" class="headerlink" title="镜像层数尽可能少"></a>镜像层数尽可能少</h3><p>你需要在 <code>Dockerfile</code> 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p>
<h3 id="将多行参数排序"><a href="#将多行参数排序" class="headerlink" title="将多行参数排序"></a>将多行参数排序</h3><p>将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 <code>PRs</code> 阅读和审查。建议在反斜杠符号 <code>\</code> 之前添加一个空格，以增加可读性。</p>
<p>下面是来自 <code>buildpack-deps</code> 镜像的例子：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">  bzr \</span></span><br><span class="line"><span class="language-bash">  cvs \</span></span><br><span class="line"><span class="language-bash">  git \</span></span><br><span class="line"><span class="language-bash">  mercurial \</span></span><br><span class="line"><span class="language-bash">  subversion</span></span><br></pre></td></tr></table></figure>

<h3 id="构建缓存"><a href="#构建缓存" class="headerlink" title="构建缓存"></a>构建缓存</h3><p>在镜像的构建过程中，Docker 会遍历 <code>Dockerfile</code> 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 <code>docker build</code> 命令中使用 <code>--no-cache=true</code> 选项。</p>
<p>但是，如果你想在构建的过程中使用缓存，你得明白什么时候会，什么时候不会找到匹配的镜像，遵循的基本规则如下：</p>
<ul>
<li>从一个基础镜像开始（<code>FROM</code> 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。</li>
<li>在大多数情况下，只需要简单地对比 <code>Dockerfile</code> 中的指令和子镜像。然而，有些指令需要更多的检查和解释。</li>
<li>对于 <code>ADD</code> 和 <code>COPY</code> 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。</li>
<li>除了 <code>ADD</code> 和 <code>COPY</code> 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 <code>RUN apt-get -y update</code> 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。</li>
</ul>
<p>一旦缓存失效，所有后续的 <code>Dockerfile</code> 指令都将产生新的镜像，缓存不会被使用。</p>
<h2 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h2><p>下面针对 <code>Dockerfile</code> 中各种指令的最佳编写方式给出建议。</p>
<h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用 <a href="https://hub.docker.com/_/alpine/">Alpine</a> 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。</p>
<h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 <code>LABEL</code> 开头加上一个或多个标签对。下面的示例展示了各种不同的可能格式。<code>#</code> 开头的行是注释内容。</p>
<blockquote>
<p>注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set one or more individual labels</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> vendor=<span class="string">&quot;ACME Incorporated&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.version.is-production=<span class="string">&quot;&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>一个镜像可以包含多个标签，但建议将多个标签放入到一个 <code>LABEL</code> 指令中。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set multiple labels at once, using line-continuation characters to break long lines</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> vendor=ACME\ Incorporated \</span></span><br><span class="line"><span class="language-bash">      com.example.is-beta= \</span></span><br><span class="line"><span class="language-bash">      com.example.is-production=<span class="string">&quot;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>关于标签可以接受的键值对，参考 <a href="https://docs.docker.com/config/labels-custom-metadata/">Understanding object labels</a>。关于查询标签信息，参考 <a href="https://docs.docker.com/config/labels-custom-metadata/">Managing labels on objects</a>。</p>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>为了保持 <code>Dockerfile</code> 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 <code>RUN</code> 指令用反斜杠 <code>\</code> 分割成多行。</p>
<h4 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h4><p><code>RUN</code> 指令最常见的用法是安装包用的 <code>apt-get</code>。因为 <code>RUN apt-get</code> 指令会安装包，所以有几个问题需要注意。</p>
<p>不要使用 <code>RUN apt-get upgrade</code> 或 <code>dist-upgrade</code>，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 <code>foo</code>，需要升级，使用 <code>apt-get install -y foo</code> 就行，该指令会自动升级 <code>foo</code> 包。</p>
<p>永远将 <code>RUN apt-get update</code> 和 <code>apt-get install</code> 组合成一条 <code>RUN</code> 声明，例如：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">        package-bar \</span></span><br><span class="line"><span class="language-bash">        package-baz \</span></span><br><span class="line"><span class="language-bash">        package-foo</span></span><br></pre></td></tr></table></figure>

<p>将 <code>apt-get update</code> 放在一条单独的 <code>RUN</code> 声明中会导致缓存问题以及后续的 <code>apt-get install</code> 失败。比如，假设你有一个 <code>Dockerfile</code> 文件：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y curl</span></span><br></pre></td></tr></table></figure>

<p>构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 <code>apt-get install</code> 添加了一个包：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y curl nginx</span></span><br></pre></td></tr></table></figure>

<p>Docker 发现修改后的 <code>RUN apt-get update</code> 指令和之前的完全一样。所以，<code>apt-get update</code> 不会执行，而是使用之前的缓存镜像。因为 <code>apt-get update</code> 没有运行，后面的 <code>apt-get install</code> 可能安装的是过时的 <code>curl</code> 和 <code>nginx</code> 版本。</p>
<p>使用 <code>RUN apt-get update &amp;&amp; apt-get install -y</code> 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 <code>cache busting</code>。你也可以显示指定一个包的版本号来达到 <code>cache-busting</code>，这就是所谓的固定版本，例如：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    package-bar \</span></span><br><span class="line"><span class="language-bash">    package-baz \</span></span><br><span class="line"><span class="language-bash">    package-foo=1.3.*</span></span><br></pre></td></tr></table></figure>

<p>固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。</p>
<p>下面是一个 <code>RUN</code> 指令的示例模板，展示了所有关于 <code>apt-get</code> 的建议。</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    aufs-tools \</span></span><br><span class="line"><span class="language-bash">    automake \</span></span><br><span class="line"><span class="language-bash">    build-essential \</span></span><br><span class="line"><span class="language-bash">    curl \</span></span><br><span class="line"><span class="language-bash">    dpkg-sig \</span></span><br><span class="line"><span class="language-bash">    libcap-dev \</span></span><br><span class="line"><span class="language-bash">    libsqlite3-dev \</span></span><br><span class="line"><span class="language-bash">    mercurial \</span></span><br><span class="line"><span class="language-bash">    reprepro \</span></span><br><span class="line"><span class="language-bash">    ruby1.9.1 \</span></span><br><span class="line"><span class="language-bash">    ruby1.9.1-dev \</span></span><br><span class="line"><span class="language-bash">    s3cmd=1.1.* \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>s3cmd</code> 指令指定了一个版本号 <code>1.1.*</code>。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 <code>apt-get udpate</code> 缓存失效并确保安装的是新版本。</p>
<p>另外，清理掉 apt 缓存 <code>var/lib/apt/lists</code> 可以减小镜像大小。因为 <code>RUN</code> 指令的开头为 <code>apt-get udpate</code>，包缓存总是会在 <code>apt-get install</code> 之前刷新。</p>
<blockquote>
<p>注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。</p>
</blockquote>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>CMD</code> 指令用于执行目标镜像中包含的软件，可以包含参数。<code>CMD</code> 大多数情况下都应该以 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...]</code> 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 <code>Apache</code>)，你可能会执行类似于 <code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code> 形式的命令。我们建议任何服务镜像都使用这种形式的命令。</p>
<p>多数情况下，<code>CMD</code> 都需要一个交互式的 <code>shell</code> (bash, Python, perl 等)，例如 <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]</code>，或者 <code>CMD [&quot;PHP&quot;, &quot;-a&quot;]</code>。使用这种形式意味着，当你执行类似 <code>docker run -it python</code> 时，你会进入一个准备好的 <code>shell</code> 中。<code>CMD</code> 应该在极少的情况下才能以 <code>CMD [&quot;param&quot;, &quot;param&quot;]</code> 的形式与 <code>ENTRYPOINT</code> 协同使用，除非你和你的镜像使用者都对 <code>ENTRYPOINT</code> 的工作方式十分熟悉。</p>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><code>EXPOSE</code> 指令用于指定容器将要监听的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 <code>Apache</code> web 服务的镜像应该使用 <code>EXPOSE 80</code>，而提供 <code>MongoDB</code> 服务的镜像使用 <code>EXPOSE 27017</code>。</p>
<p>对于外部访问，用户可以在执行 <code>docker run</code> 时使用一个标志来指示如何将指定的端口映射到所选择的端口。</p>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>为了方便新程序运行，你可以使用 <code>ENV</code> 来为容器中安装的程序更新 <code>PATH</code> 环境变量。例如使用 <code>ENV PATH /usr/local/nginx/bin:$PATH</code> 来确保 <code>CMD [&quot;nginx&quot;]</code> 能正确运行。</p>
<p><code>ENV</code> 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 <code>PGDATA</code>。</p>
<p>最后，<code>ENV</code> 也能用于设置常见的版本号，比如下面的示例：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> PG_MAJOR <span class="number">9.3</span></span><br><span class="line"><span class="keyword">ENV</span> PG_VERSION <span class="number">9.3</span>.<span class="number">4</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SL http://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span></span><br><span class="line"><span class="keyword">ENV</span> PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>类似于程序中的常量，这种方法可以让你只需改变 <code>ENV</code> 指令来自动的改变容器中的软件版本。</p>
<h3 id="ADD-和-COPY"><a href="#ADD-和-COPY" class="headerlink" title="ADD 和 COPY"></a>ADD 和 COPY</h3><p>虽然 <code>ADD</code> 和 <code>COPY</code> 功能类似，但一般优先使用 <code>COPY</code>。因为它比 <code>ADD</code> 更透明。<code>COPY</code> 只支持简单将本地文件拷贝到容器中，而 <code>ADD</code> 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，<code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</p>
<p>如果你的 <code>Dockerfile</code> 有多个步骤需要使用上下文中不同的文件。单独 <code>COPY</code> 每个文件，而不是一次性的 <code>COPY</code> 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt /tmp/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --requirement /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /tmp/</span></span><br></pre></td></tr></table></figure>

<p>如果将 <code>COPY . /tmp/</code> 放置在 <code>RUN</code> 指令之前，只要 <code>.</code> 目录中任何一个文件变化，都会导致后续指令的缓存失效。</p>
<p>为了让镜像尽量小，最好不要使用 <code>ADD</code> 指令从远程 URL 获取包，而是使用 <code>curl</code> 和 <code>wget</code>。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> http://example.com/big.tar.xz /usr/src/things/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure>

<p>而是应该使用下面这种方法：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/things \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; curl -SL http://example.com/big.tar.xz \</span></span><br><span class="line"><span class="language-bash">    | tar -xJC /usr/src/things \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure>

<p>上面使用的管道操作，所以没有中间文件需要删除。</p>
<p>对于其他不需要 <code>ADD</code> 的自动提取功能的文件或目录，你应该使用 <code>COPY</code>。</p>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p><code>ENTRYPOINT</code> 的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用 <code>CMD</code> 提供默认选项）。</p>
<p>例如，下面的示例镜像提供了命令行工具 <code>s3cmd</code>:</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;s3cmd&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--help&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>现在直接运行该镜像创建的容器会显示命令帮助：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run s3cmd</span><br></pre></td></tr></table></figure>

<p>或者提供正确的参数来执行某个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run s3cmd <span class="built_in">ls</span> s3://mybucket</span><br></pre></td></tr></table></figure>

<p>这样镜像名可以当成命令行的参考。</p>
<p><code>ENTRYPOINT</code> 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。</p>
<p>例如，<code>Postgres</code> 官方镜像使用下面的脚本作为 <code>ENTRYPOINT</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;postgres&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">chown</span> -R postgres <span class="string">&quot;<span class="variable">$PGDATA</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="subst">$(ls -A <span class="string">&quot;<span class="variable">$PGDATA</span>&quot;</span>)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">exec</span> gosu postgres <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p>
</blockquote>
<p>该辅助脚本被拷贝到容器，并在容器启动时通过 <code>ENTRYPOINT</code> 执行：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-entrypoint.sh /</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/docker-entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>该脚本可以让用户用几种不同的方式和 <code>Postgres</code> 交互。</p>
<p>你可以很简单地启动 <code>Postgres</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run postgres</span><br></pre></td></tr></table></figure>

<p>也可以执行 <code>Postgres</code> 并传递参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run postgres postgres --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>最后，你还可以启动另外一个完全不同的工具，比如 <code>Bash</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --<span class="built_in">rm</span> -it postgres bash</span><br></pre></td></tr></table></figure>

<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><code>VOLUME</code> 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 <code>VOLUME</code> 来管理镜像中的可变部分和用户可以改变的部分。</p>
<h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>如果某个服务不需要特权执行，建议使用 <code>USER</code> 指令切换到非 root 用户。先在 <code>Dockerfile</code> 中使用类似 <code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> 的指令创建用户和用户组。</p>
<blockquote>
<p>注意：在镜像中，用户和用户组每次被分配的 UID&#x2F;GID 都是不确定的，下次重新构建镜像时被分配到的 UID&#x2F;GID 可能会不一样。如果要依赖确定的 UID&#x2F;GID，你应该显式的指定一个 UID&#x2F;GID。</p>
</blockquote>
<p>你应该避免使用 <code>sudo</code>，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 <code>sudo</code> 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 <a href="https://github.com/tianon/gosu">gosu</a>。</p>
<p>最后，为了减少层数和复杂度，避免频繁地使用 <code>USER</code> 来回切换用户。</p>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>为了清晰性和可靠性，你应该总是在 <code>WORKDIR</code> 中使用绝对路径。另外，你应该使用 <code>WORKDIR</code> 来替代类似于 <code>RUN cd ... &amp;&amp; do-something</code> 的指令，后者难以阅读、排错和维护。</p>
<h2 id="官方镜像示例"><a href="#官方镜像示例" class="headerlink" title="官方镜像示例"></a>官方镜像示例</h2><p>这些官方镜像的 Dockerfile 都是参考典范：<a href="https://github.com/docker-library/docs">https://github.com/docker-library/docs</a></p>
<h1 id="如何调试-Docker"><a href="#如何调试-Docker" class="headerlink" title="如何调试 Docker"></a>如何调试 Docker</h1><h2 id="开启-Debug-模式"><a href="#开启-Debug-模式" class="headerlink" title="开启 Debug 模式"></a>开启 Debug 模式</h2><p>在 dockerd 配置文件 daemon.json（默认位于 &#x2F;etc&#x2F;docker&#x2F;）中添加</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;debug&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启守护进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">kill</span> -SIGHUP $(pidof dockerd)</span><br></pre></td></tr></table></figure>

<p>此时 dockerd 会在日志中输入更多信息供分析。</p>
<h2 id="检查内核日志"><a href="#检查内核日志" class="headerlink" title="检查内核日志"></a>检查内核日志</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dmesg |grep dockerd</span><br><span class="line">$ sudo dmesg |grep runc</span><br></pre></td></tr></table></figure>

<h2 id="Docker-不响应时处理"><a href="#Docker-不响应时处理" class="headerlink" title="Docker 不响应时处理"></a>Docker 不响应时处理</h2><p>可以杀死 dockerd 进程查看其堆栈调用情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">kill</span> -SIGUSR1 $(pidof dockerd)</span><br></pre></td></tr></table></figure>

<h2 id="重置-Docker-本地数据"><a href="#重置-Docker-本地数据" class="headerlink" title="重置 Docker 本地数据"></a>重置 Docker 本地数据</h2><p><em>注意，本操作会移除所有的 Docker 本地数据，包括镜像和容器等。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">rm</span> -rf /var/lib/docker</span><br></pre></td></tr></table></figure>

<h1 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h1><h2 id="官方网站"><a href="#官方网站" class="headerlink" title="官方网站"></a>官方网站</h2><ul>
<li>Docker 官方主页：<a href="https://www.docker.com/">https://www.docker.com</a></li>
<li>Docker 官方博客：<a href="https://www.docker.com/blog/">https://www.docker.com/blog/</a></li>
<li>Docker 官方文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></li>
<li>Docker Hub：<a href="https://hub.docker.com/">https://hub.docker.com</a></li>
<li>Docker 的源代码仓库：<a href="https://github.com/moby/moby">https://github.com/moby/moby</a></li>
<li>Docker 路线图 <a href="https://github.com/docker/roadmap/projects">https://github.com/docker/roadmap/projects</a></li>
<li>Docker 发布版本历史：<a href="https://docs.docker.com/release-notes/">https://docs.docker.com/release-notes/</a></li>
<li>Docker 常见问题：<a href="https://docs.docker.com/engine/faq/">https://docs.docker.com/engine/faq/</a></li>
<li>Docker 远端应用 API：<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a></li>
</ul>
<h2 id="实践参考"><a href="#实践参考" class="headerlink" title="实践参考"></a>实践参考</h2><ul>
<li>Dockerfile 参考：<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></li>
<li>Dockerfile 最佳实践：<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/</a></li>
</ul>
<h2 id="技术交流"><a href="#技术交流" class="headerlink" title="技术交流"></a>技术交流</h2><ul>
<li>Docker 邮件列表： <a href="https://groups.google.com/forum/#!forum/docker-user">https://groups.google.com/forum/#!forum/docker-user</a></li>
<li>Docker 的 IRC 频道：<a href="https://chat.freenode.net/#docker">https://chat.freenode.net#docker</a></li>
<li>Docker 的 Twitter 主页：<a href="https://twitter.com/docker">https://twitter.com/docker</a></li>
</ul>
<h2 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h2><ul>
<li>Docker 的 StackOverflow 问答主页：<a href="https://stackoverflow.com/search?q=docker">https://stackoverflow.com/search?q=docker</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>CNCF</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx小记</title>
    <url>/2022/some_pieces_of_nginx/</url>
    <content><![CDATA[<h1 id="nginx及其衍生版本"><a href="#nginx及其衍生版本" class="headerlink" title="nginx及其衍生版本"></a>nginx及其衍生版本</h1><ul>
<li>nginx开源版：<a href="http://nginx.org/">http://nginx.org</a></li>
<li>nginx plus 商业版: <a href="https://www.nginx.com/">https://www.nginx.com</a></li>
<li>openresty: <a href="http://openresty.org/">http://openresty.org</a></li>
<li>tengine: <a href="http://tengine.taobao.org/">http://tengine.taobao.org</a></li>
</ul>
<h1 id="nginx默认目录结构"><a href="#nginx默认目录结构" class="headerlink" title="nginx默认目录结构"></a>nginx默认目录结构</h1><ul>
<li><code>logs/</code>：日志目录；</li>
<li><code>conf/</code>：配置文件目录；</li>
<li><code>html/</code>：静态资源目录；</li>
<li><code>sbin/</code>：存放nginx可执行文件；</li>
</ul>
<h1 id="nginx基础配置"><a href="#nginx基础配置" class="headerlink" title="nginx基础配置"></a>nginx基础配置</h1><h2 id="nginx最小配置"><a href="#nginx最小配置" class="headerlink" title="nginx最小配置"></a>nginx最小配置</h2><ul>
<li><code>worker_processes</code> worker 进程数，根据CPU核心数进行配置；</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>通过配置<code>server_name</code>可以同时在一台服务器部署多个虚拟主机。通过<code>server_name</code>区分不同虚拟主机，甚至可以做到不同web站点服务共享相同端口。</p>
<p><code>server_name</code>支持多种匹配模式：</p>
<ul>
<li>完整匹配（精确匹配）；</li>
<li>通配符匹配：如，<code>*.baidu.com</code>，<code>*.baidu.*</code>等；</li>
<li>正则匹配；</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 虚拟主机1</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    		<span class="comment"># 通过配置server_name 可以同时在一台服务器部署多个虚拟主机；</span></span><br><span class="line">        <span class="comment"># 通过server_name区分不同虚拟主机，甚至可以做到不同web站点服务共享相同端口；</span></span><br><span class="line">        <span class="comment"># 注意 vhost1和vhost2都是用80端口！</span></span><br><span class="line">        <span class="attribute">server_name</span>  vhost1;  </span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/www/vhost1/html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/www/vhost1/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 虚拟主机2</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="comment"># 通过server_name区分不同虚拟主机，甚至可以做到不同web站点服务共享相同端口；</span></span><br><span class="line">        <span class="comment"># 注意 vhost1和vhost2都是用80端口！</span></span><br><span class="line">        <span class="attribute">server_name</span>  vhost2;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/www/vhost2/html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/www/vhost2/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><code>proxy_pass</code>参数配置</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 虚拟主机1</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  vhost1;  </span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 配置反向代理</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://www.baidu.com;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/www/vhost1/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 定义服务器集群，集群名为httpds</span></span><br><span class="line">    <span class="section">upstream</span> httpds &#123;</span><br><span class="line">      <span class="attribute">server</span> <span class="number">172.17.0.2:80</span>;</span><br><span class="line">      <span class="attribute">server</span> <span class="number">172.17.0.3:80</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 虚拟主机1</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  vhost1;  </span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 配置反向代理</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://httpds;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/www/vhost1/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  ngx:</span><br><span class="line">    image: nginx:1.21.6</span><br><span class="line">    container_name: ngx</span><br><span class="line">    ports:</span><br><span class="line">      - 80:80</span><br><span class="line">    volumes:</span><br><span class="line">      - ./www:/usr/share/nginx/www:ro</span><br><span class="line">      - ./nginx.conf:/etc/nginx/nginx.conf:ro</span><br><span class="line">      - ./logs:/var/log/nginx:rw</span><br><span class="line">    depends_on:</span><br><span class="line">      - ng1</span><br><span class="line">      - ng2</span><br><span class="line">      - ng3</span><br><span class="line">    networks:</span><br><span class="line">      - ngx_net</span><br><span class="line">  ng1:</span><br><span class="line">    image: nginx:1.21.6</span><br><span class="line">    container_name: ng1</span><br><span class="line">    ports:</span><br><span class="line">       - 8001:80</span><br><span class="line">    volumes:</span><br><span class="line">       - ./www/ng1/html:/usr/share/nginx/html:ro</span><br><span class="line">    networks:</span><br><span class="line">      - ngx_net</span><br><span class="line">  ng2:</span><br><span class="line">    image: nginx:1.21.6</span><br><span class="line">    container_name: ng2</span><br><span class="line">    ports:</span><br><span class="line">      - 8002:80</span><br><span class="line">    volumes:</span><br><span class="line">       - ./www/ng2/html:/usr/share/nginx/html:ro</span><br><span class="line">    networks:</span><br><span class="line">      - ngx_net</span><br><span class="line">  ng3:</span><br><span class="line">    image: nginx:1.21.6</span><br><span class="line">    container_name: ng3</span><br><span class="line">    ports:</span><br><span class="line">      - 8003:80</span><br><span class="line">    volumes:</span><br><span class="line">      - ./www/ng3/html:/usr/share/nginx/html:ro</span><br><span class="line">    networks:</span><br><span class="line">      - ngx_net</span><br><span class="line">networks:</span><br><span class="line">  ngx_net:</span><br></pre></td></tr></table></figure>

<p>weight设置权重：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 定义服务器集群，集群名为httpds</span></span><br><span class="line">    <span class="section">upstream</span> httpds &#123;</span><br><span class="line">      <span class="comment"># weight设置权重</span></span><br><span class="line">      <span class="attribute">server</span> ng1:<span class="number">80</span> weight=<span class="number">7</span>;</span><br><span class="line">      <span class="attribute">server</span> ng2:<span class="number">80</span> weight=<span class="number">2</span>;</span><br><span class="line">      <span class="attribute">server</span> ng3:<span class="number">80</span> weight=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 虚拟主机1</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;  </span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 配置反向代理</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://httpds;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/www/vhost1/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>down参数指定服务器不参与负载，backup参数代表默认不启用，其他服务器down了才启用：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 定义服务器集群，集群名为httpds</span></span><br><span class="line">    <span class="section">upstream</span> httpds &#123;</span><br><span class="line">      <span class="comment"># weight设置权重</span></span><br><span class="line">      <span class="attribute">server</span> ng1:<span class="number">80</span> weight=<span class="number">7</span>;</span><br><span class="line">      <span class="attribute">server</span> ng2:<span class="number">80</span> weight=<span class="number">2</span>;</span><br><span class="line">      <span class="attribute">server</span> ng3:<span class="number">80</span> weight=<span class="number">1</span> backup;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 虚拟主机1</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;  </span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 配置反向代理</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://httpds;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/www/vhost1/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 定义服务器集群，集群名为httpds</span></span><br><span class="line">    <span class="section">upstream</span> httpds &#123;</span><br><span class="line">      <span class="comment"># weight设置权重</span></span><br><span class="line">      <span class="attribute">server</span> ng1:<span class="number">80</span> weight=<span class="number">7</span>;</span><br><span class="line">      <span class="attribute">server</span> ng2:<span class="number">80</span> weight=<span class="number">2</span>;</span><br><span class="line">      <span class="attribute">server</span> ng3:<span class="number">80</span> weight=<span class="number">1</span> backup;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 虚拟主机1</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;  </span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 配置反向代理</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://httpds;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="section">location</span> /img &#123;</span><br><span class="line">					<span class="attribute">root</span> html;</span><br><span class="line">           <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    		<span class="section">location</span> /js &#123;</span><br><span class="line">					<span class="attribute">root</span> html;</span><br><span class="line">           <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    		<span class="section">location</span> /css &#123;</span><br><span class="line">					<span class="attribute">root</span> html;</span><br><span class="line">           <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/www/vhost1/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="location-正则参数"><a href="#location-正则参数" class="headerlink" title="location 正则参数"></a>location 正则参数</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 定义服务器集群，集群名为httpds</span></span><br><span class="line">    <span class="section">upstream</span> httpds &#123;</span><br><span class="line">      <span class="comment"># weight设置权重</span></span><br><span class="line">      <span class="attribute">server</span> ng1:<span class="number">80</span> weight=<span class="number">7</span>;</span><br><span class="line">      <span class="attribute">server</span> ng2:<span class="number">80</span> weight=<span class="number">2</span>;</span><br><span class="line">      <span class="attribute">server</span> ng3:<span class="number">80</span> weight=<span class="number">1</span> backup;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 虚拟主机1</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;  </span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 配置反向代理</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://httpds;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    		<span class="comment"># A regular expression is preceded with the tilde (~) for case-sensitive matching,</span></span><br><span class="line">        <span class="comment"># or the tilde-asterisk (~*) for case-insensitive matching. </span></span><br><span class="line">        <span class="section">location</span> ~*/(img|js|css) &#123;</span><br><span class="line">					<span class="attribute">root</span> html;</span><br><span class="line">           <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/www/vhost1/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="URL-rewrite"><a href="#URL-rewrite" class="headerlink" title="URL rewrite"></a>URL rewrite</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 定义服务器集群，集群名为httpds</span></span><br><span class="line">    <span class="section">upstream</span> httpds &#123;</span><br><span class="line">      <span class="comment"># weight设置权重</span></span><br><span class="line">      <span class="attribute">server</span> ng1:<span class="number">80</span> weight=<span class="number">7</span>;</span><br><span class="line">      <span class="attribute">server</span> ng2:<span class="number">80</span> weight=<span class="number">2</span>;</span><br><span class="line">      <span class="attribute">server</span> ng3:<span class="number">80</span> weight=<span class="number">1</span> backup;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 虚拟主机1</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;  </span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 将/2.html 重写为 /index.jsp?pageNum=2</span></span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/2.html$</span> /index.jsp?pageNum=<span class="number">2</span> <span class="literal">break</span>;</span><br><span class="line">            <span class="comment"># 配置反向代理</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://httpds;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    		<span class="comment"># A regular expression is preceded with the tilde (~) for case-sensitive matching,</span></span><br><span class="line">        <span class="comment"># or the tilde-asterisk (~*) for case-insensitive matching. </span></span><br><span class="line">        <span class="section">location</span> ~*/(img|js|css) &#123;</span><br><span class="line">					<span class="attribute">root</span> html;</span><br><span class="line">           <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/www/vhost1/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Python tkinter 布局管理</title>
    <url>/2022/tkinter_geometry_manager/</url>
    <content><![CDATA[<p>本文讲述如何使用 tkinter 的布局管理 (被称作 layout managers 或 geometry managers)。tkinter 有三种布局管理方式：</p>
<ul>
<li>pack</li>
<li>place</li>
<li>grid</li>
</ul>
<blockquote>
<p>注意，这三种布局管理在同一个 master window 里一定不该被混用！</p>
</blockquote>
<p>布局管理有以下功能：</p>
<ul>
<li>在屏幕上排列控件，包括确定组件的大小和位置</li>
<li>注册窗口控件到底层窗口系统</li>
<li>管理控件在屏幕上的显示</li>
</ul>
<p>虽然控件自己也可以指定大小和对齐方式等信息， 但最终的控件大小及位置还是由布局管理决定的。</p>
<span id="more"></span>

<h1 id="Pack-布局管理器"><a href="#Pack-布局管理器" class="headerlink" title="Pack 布局管理器"></a>Pack 布局管理器</h1><p>Pack布局管理器按行或列打包控件。您可以使用fill，expand和side等选项来控制此布局管理器。</p>
<p>管理器处理在同一master widget中打包的所有窗口小部件。打包算法很简单，但有点不太好用文字描述;想象一块弹性材料，中间有一个非常小的矩形孔。对于每个窗口控件，按照打包的顺序，布局管理器使孔足够大以容纳窗口控件，然后将其放置在给定的内边缘（默认为上边缘）。然后它重复所有小部件的过程。最后，当所有窗口小部件都被打包到孔中时，管理器计算所有窗口小部件的边界框，使master widget足够大以容纳所有窗口小部件，并将它们全部移动到主窗口。</p>
<p>pack 是三种布局管理器中最容易使用的。我们可以用pack方法声明控件之间的相对位置，而不必精确地指定控件在屏幕上的位置。pack 布局管理器会自动处理好控件的这些细节。虽然pack更容易使用，但相较于place和grid，这种布局管理器的灵活性也受到限制。对于简单的应用程序，pack肯定是首选。以下几种情况比较适合使用pack布局管理器：</p>
<ul>
<li>将控件放在frame（或任何其他容器控件）中，并让它填充整个frame</li>
<li>从上到下逐个放置一些控件</li>
<li>并排放置一些控件</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    root = tk.Tk()</span><br><span class="line">    </span><br><span class="line">    tk.Label(root, text=<span class="string">&quot;Red Sun&quot;</span>, bg=<span class="string">&quot;red&quot;</span>, fg=<span class="string">&quot;white&quot;</span>).pack()</span><br><span class="line">    tk.Label(root, text=<span class="string">&quot;Green Grass&quot;</span>, bg=<span class="string">&quot;green&quot;</span>, fg=<span class="string">&quot;black&quot;</span>).pack()</span><br><span class="line">    tk.Label(root, text=<span class="string">&quot;Blue Sky&quot;</span>, bg=<span class="string">&quot;blue&quot;</span>, fg=<span class="string">&quot;white&quot;</span>).pack()</span><br><span class="line"></span><br><span class="line">    root.mainloop()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/tkinter_geometry_manager/20170114201534466.png" alt="img"></p>
<p>如果需要创建更复杂的布局，通常需要使用额外的Frame控件对控件进行分组。您也可以使用grid布局管理器。</p>
<h2 id="fill-选项：控制填充"><a href="#fill-选项：控制填充" class="headerlink" title="fill 选项：控制填充"></a>fill 选项：控制填充</h2><p>在上面那个例子里, 我们简单的将三个 Label 控件 pack 到父控件<code>root</code>上，没有使用任何属性。 因此，pack必须决定以哪种方式来排列这些 Label 控件。可以看到，pack默认使用<code>pack(side=tkinter.TOP)</code>方式进行布局，即从上到下依次放置，并水平居中。 同时，我们也发现 pack 默认会将 Label 控件的大小设置为文本的大小。如果你想让这些控件和其父控件一样宽, 可以使用<code>fill=tkinter.X</code>属性，使其水平横向填充父控件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"></span><br><span class="line">root = tk.Tk()</span><br><span class="line">w1 = tk.Label(root, text=<span class="string">&quot;Red Sun&quot;</span>, bg=<span class="string">&quot;red&quot;</span>, fg=<span class="string">&quot;white&quot;</span>)</span><br><span class="line">w1.pack(fill=tk.X)</span><br><span class="line">w2 = tk.Label(root, text=<span class="string">&quot;Green Grass&quot;</span>, bg=<span class="string">&quot;green&quot;</span>, fg=<span class="string">&quot;black&quot;</span>)</span><br><span class="line">w2.pack(fill=tk.X)</span><br><span class="line">w3 = tk.Label(root, text=<span class="string">&quot;Blue Sky&quot;</span>, bg=<span class="string">&quot;blue&quot;</span>, fg=<span class="string">&quot;white&quot;</span>)</span><br><span class="line">w3.pack(fill=tk.X)</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>



<p><img src="/2022/tkinter_geometry_manager/20170114202405976.png" alt="img"></p>
<h2 id="padding-选项：控件边距"><a href="#padding-选项：控件边距" class="headerlink" title="padding 选项：控件边距"></a>padding 选项：控件边距</h2><p>Pack 可以在四个方面控制控件边距: 内边距, 外边距, 水平边距, 垂直边距:</p>
<p><strong>padx</strong> - 设置水平方向的外边距</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Tkinter <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = Label(root, text=<span class="string">&quot;Red Sun&quot;</span>, bg=<span class="string">&quot;red&quot;</span>, fg=<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w.pack(fill=X,padx=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = Label(root, text=<span class="string">&quot;Green Grass&quot;</span>, bg=<span class="string">&quot;green&quot;</span>, fg=<span class="string">&quot;black&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w.pack(fill=X,padx=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = Label(root, text=<span class="string">&quot;Blue Sky&quot;</span>, bg=<span class="string">&quot;blue&quot;</span>, fg=<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w.pack(fill=X,padx=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mainloop()</span><br></pre></td></tr></table></figure>



<p><img src="/2022/tkinter_geometry_manager/20170114202920393.png" alt="img"></p>
<p><strong>pady</strong> - 设置竖直方向的外边距</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Tkinter <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = Label(root, text=<span class="string">&quot;Red Sun&quot;</span>, bg=<span class="string">&quot;red&quot;</span>, fg=<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w.pack(fill=X,pady=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = Label(root, text=<span class="string">&quot;Green Grass&quot;</span>, bg=<span class="string">&quot;green&quot;</span>, fg=<span class="string">&quot;black&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w.pack(fill=X,pady=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = Label(root, text=<span class="string">&quot;Blue Sky&quot;</span>, bg=<span class="string">&quot;blue&quot;</span>, fg=<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w.pack(fill=X,pady=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mainloop()</span><br></pre></td></tr></table></figure>



<p><img src="/2022/tkinter_geometry_manager/20170114203036003.png" alt="img"></p>
<p><strong>ipadx</strong> - 设置水平方向的内边距</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Tkinter <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = Label(root, text=<span class="string">&quot;Red Sun&quot;</span>, bg=<span class="string">&quot;red&quot;</span>, fg=<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w.pack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = Label(root, text=<span class="string">&quot;Green Grass&quot;</span>, bg=<span class="string">&quot;green&quot;</span>, fg=<span class="string">&quot;black&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w.pack(ipadx=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = Label(root, text=<span class="string">&quot;Blue Sky&quot;</span>, bg=<span class="string">&quot;blue&quot;</span>, fg=<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w.pack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mainloop()</span><br></pre></td></tr></table></figure>



<p><img src="/2022/tkinter_geometry_manager/20170114203323832.png" alt="img"></p>
<p><strong>ipady</strong> - 设置竖直方向的内边距</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Tkinter <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = Label(root, text=<span class="string">&quot;Red Sun&quot;</span>, bg=<span class="string">&quot;red&quot;</span>, fg=<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w.pack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = Label(root, text=<span class="string">&quot;Green Grass&quot;</span>, bg=<span class="string">&quot;green&quot;</span>, fg=<span class="string">&quot;black&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w.pack(ipadx=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = Label(root, text=<span class="string">&quot;Blue Sky&quot;</span>, bg=<span class="string">&quot;blue&quot;</span>, fg=<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w.pack(ipady=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mainloop()</span><br></pre></td></tr></table></figure>



<p><img src="/2022/tkinter_geometry_manager/20170114203423489.png" alt="img"></p>
<p>上述四个属性的默认值都是 0.</p>
<h2 id="side选项：顺次放置控件"><a href="#side选项：顺次放置控件" class="headerlink" title="side选项：顺次放置控件"></a>side选项：顺次放置控件</h2><p>我们把上面那几个 Label 从左到右放在一排:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Tkinter <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line">w = Label(root, text=<span class="string">&quot;red&quot;</span>, bg=<span class="string">&quot;red&quot;</span>, fg=<span class="string">&quot;white&quot;</span>)</span><br><span class="line">w.pack(padx=<span class="number">5</span>, pady=<span class="number">10</span>, side=LEFT)</span><br><span class="line">w = Label(root, text=<span class="string">&quot;green&quot;</span>, bg=<span class="string">&quot;green&quot;</span>, fg=<span class="string">&quot;black&quot;</span>)</span><br><span class="line">w.pack(padx=<span class="number">5</span>, pady=<span class="number">20</span>, side=LEFT)</span><br><span class="line">w = Label(root, text=<span class="string">&quot;blue&quot;</span>, bg=<span class="string">&quot;blue&quot;</span>, fg=<span class="string">&quot;white&quot;</span>)</span><br><span class="line">w.pack(padx=<span class="number">5</span>, pady=<span class="number">20</span>, side=LEFT)</span><br><span class="line"></span><br><span class="line">mainloop()</span><br></pre></td></tr></table></figure>



<p><img src="/2022/tkinter_geometry_manager/20170114203536054.png" alt="img"></p>
<p>如果把上述 side 属性的值都改为 RIGHT, 那么上面 Label 控件的排列顺序就反过来了:</p>
<p><img src="/2022/tkinter_geometry_manager/20170114204013789.png" alt="img"></p>
<h1 id="Place-布局管理"><a href="#Place-布局管理" class="headerlink" title="Place 布局管理"></a>Place 布局管理</h1><p>Place 布局管理可以显式的指定控件的绝对位置或相对于其他控件的位置. 要使用 Place 布局, 调用相应控件的 place() 方法就可以了. 所有 tkinter 的标准控件都可以调用 place()</p>
<p> 方法.</p>
<p>下面是一个使用 Place 布局的例子: 为 Label 控件设置随机的背景色, 然后计算各个 Label 的背景色的亮度(灰度值), 如果其亮度小于 120, 则将其前景色(文字颜色, fg属性)设置为白色, 否则设为黑色. 这样做是为了避免使背景色和前景色过于接近而导致文字不易阅读.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Tkinter <span class="keyword">as</span> tk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = tk.Tk()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># width x height + x_offset + y_offset:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root.geometry(<span class="string">&quot;170x200+30+30&quot;</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">languages = [<span class="string">&#x27;Python&#x27;</span>,<span class="string">&#x27;Perl&#x27;</span>,<span class="string">&#x27;C++&#x27;</span>,<span class="string">&#x27;Java&#x27;</span>,<span class="string">&#x27;Tcl/Tk&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">labels = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ct = [random.randrange(<span class="number">256</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   brightness = <span class="built_in">int</span>(<span class="built_in">round</span>(<span class="number">0.299</span>*ct[<span class="number">0</span>] + <span class="number">0.587</span>*ct[<span class="number">1</span>] + <span class="number">0.114</span>*ct[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ct_hex = <span class="string">&quot;%02x%02x%02x&quot;</span> % <span class="built_in">tuple</span>(ct)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   bg_colour = <span class="string">&#x27;#&#x27;</span> + <span class="string">&quot;&quot;</span>.join(ct_hex)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   l = tk.Label(root, </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                text=languages[i], </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                fg=<span class="string">&#x27;White&#x27;</span> <span class="keyword">if</span> brightness &lt; <span class="number">120</span> <span class="keyword">else</span> <span class="string">&#x27;Black&#x27;</span>,bg=bg_colour)</span><br><span class="line">   l.place(x = <span class="number">20</span>, y = <span class="number">30</span> + i*<span class="number">30</span>, width=<span class="number">120</span>, height=<span class="number">25</span>)</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>



<p><img src="/2022/tkinter_geometry_manager/20170114205223623.png" alt="img"></p>
<h1 id="Grid-布局管理"><a href="#Grid-布局管理" class="headerlink" title="Grid 布局管理"></a>Grid 布局管理</h1><p>Pack 作为首选的布局管理方式, 其运作方式并不是特别易于理解. 已经由 Pack 布局完成的设计也很难做出改变. Grid 布局在1996年作为另一种可供选择的布局方式被引入. Grid 布局方式易学易用, 但似乎大家还是习惯用 Pack.</p>
<p>Grid 在很多场景下是最好用的布局方式. 相比而言, Pack 布局在控制细节方面有些力不从心. Place 布局虽然可以完全控制控件位置, 但这也导致使用 Place 会比其他两种布局方式更加复杂.</p>
<p>Grid 把控件位置作为一个二维表结构来维护, 即按照行列的方式排列控件: 控件位置由其所在的行号和列号决定. 行号相同而列号不同的几个控件会被彼此上下排列; 列号相同而行号不同的几个控件会被彼此左右排列.</p>
<p>使用 Grid 布局的过程就是为各个控件指定行号和列号的过程. 不需要为每个格子指定大小, Grid 布局会自动设置一个合适的大小.</p>
<p>下面还是举个栗子吧:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Tkinter <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">colours = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>,<span class="string">&#x27;white&#x27;</span>,<span class="string">&#x27;yellow&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line">r = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> colours:</span><br><span class="line">    Label(text=c, relief=RIDGE,width=<span class="number">15</span>).grid(row=r,column=<span class="number">0</span>)</span><br><span class="line">    Entry(bg=c, relief=SUNKEN,width=<span class="number">10</span>).grid(row=r,column=<span class="number">1</span>)</span><br><span class="line">    r = r + <span class="number">1</span></span><br><span class="line">mainloop()</span><br></pre></td></tr></table></figure>



<p><img src="/2022/tkinter_geometry_manager/20170114210830212.png" alt="img"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>tkinter</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>tkinter 一例</title>
    <url>/2022/tkinter_input_in_entry_widget%EF%BC%8Coutput_in_text_widget_in_real_time/</url>
    <content><![CDATA[<p>entry输入命令，text实时获得命令输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">import</span> tkinter.ttk <span class="keyword">as</span> ttk</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span>(tk.Frame):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,master=<span class="literal">None</span></span>):</span><br><span class="line">		<span class="built_in">super</span>().__init__(master)</span><br><span class="line">		self.pack(fill=tk.BOTH)</span><br><span class="line">		self.create_widgets()</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line">		content = self.entry.get()</span><br><span class="line">		<span class="keyword">if</span> content:</span><br><span class="line">			cmd = shlex.split(content)</span><br><span class="line">			result = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding=<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line">			<span class="comment"># 实时获取子进程输出的每一行内容</span></span><br><span class="line">			<span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">iter</span>(result.stdout.readline, <span class="string">&#x27;&#x27;</span>):</span><br><span class="line">				<span class="comment"># 将子进程输出的每一行写入text文本框</span></span><br><span class="line">				self.text.insert(tk.END, line)</span><br><span class="line">				<span class="comment"># 立即重绘Text内容</span></span><br><span class="line">				self.text.update()</span><br><span class="line">			</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">create_widgets</span>(<span class="params">self</span>):</span><br><span class="line">		self.entry = ttk.Entry(self)</span><br><span class="line">		self.entry.grid(row=<span class="number">0</span>, column=<span class="number">0</span>, sticky=tk.W+tk.E)</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		self.label_split = ttk.Label(self)</span><br><span class="line">		self.label_split.grid(row=<span class="number">0</span>, column=<span class="number">1</span>)</span><br><span class="line">		</span><br><span class="line">		self.button = ttk.Button(self, text=<span class="string">&quot;确定&quot;</span>, width=<span class="number">10</span>, command=self.test)</span><br><span class="line">		self.button.grid(row=<span class="number">0</span>, column=<span class="number">2</span>, sticky=tk.E)</span><br><span class="line">		</span><br><span class="line">		self.label_split = ttk.Label(self)</span><br><span class="line">		self.label_split.grid(row=<span class="number">1</span>, column=<span class="number">0</span>, sticky=tk.W+tk.E)</span><br><span class="line">		</span><br><span class="line">		self.scrollbar = ttk.Scrollbar(self)</span><br><span class="line">		self.text = tk.Text(self, yscrollcommand=self.scrollbar.<span class="built_in">set</span>)</span><br><span class="line">		<span class="comment"># 渲染以上2个组件</span></span><br><span class="line">		self.text.grid(row=<span class="number">2</span>, column=<span class="number">0</span>, sticky=tk.W+tk.E+tk.N+tk.S)</span><br><span class="line">		self.scrollbar.grid(row=<span class="number">2</span>, column=<span class="number">1</span>,sticky=tk.N+tk.S)</span><br><span class="line">		self.scrollbar.config(command=self.text.yview)</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">	root = tk.Tk()</span><br><span class="line">	root.title = <span class="string">&quot;Test&quot;</span></span><br><span class="line">	</span><br><span class="line">	app = App(master=root)</span><br><span class="line">	app.mainloop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>tkinter</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 http-proxy-middleware 创建 npm 代理</title>
    <url>/2022/using-http-proxy-middleware-as-npm-proxy/</url>
    <content><![CDATA[<p>在上一篇中，我们使用 <a href="https://github.com/snail007/goproxy/releases">goproxy</a> 创建 HTTP 代理，供内网中服务器使用 npm 下载并安装第三方外部依赖。其实，借助 <code>http-proxy-middleware</code> 包，我们也可以使用 Node.js 来创建 HTTP 代理。</p>
<p><strong>环境</strong></p>
<ul>
<li>开发计算机：<ul>
<li>Windows 10</li>
<li>可以访问服务器，也可访问互联网</li>
<li>IP: 192.168.200.1</li>
</ul>
</li>
<li>服务器：<ul>
<li>CentOS 8 </li>
<li>仅可访问开发主机，无法直接访问互联网</li>
<li>IP: 192.168.200.129</li>
</ul>
</li>
</ul>
<span id="more"></span>


<p><strong>安装依赖</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i express http-proxy-middleware</span><br></pre></td></tr></table></figure>

<p><strong>代码实现</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// proxy.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include dependencies</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy middleware options</span></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">import(&#x27;http-proxy-middleware/dist/types&#x27;).Options</span>&#125; */</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">target</span>: <span class="string">&#x27;https://registry.npmmirror.com&#x27;</span>, <span class="comment">// target host with the same base path</span></span><br><span class="line"><span class="comment">//   changeOrigin: true, // needed for virtual hosted sites</span></span><br><span class="line">  <span class="attr">logger</span>: <span class="variable language_">console</span>,</span><br><span class="line">  <span class="attr">secure</span>: <span class="literal">false</span>, <span class="comment">// don&#x27;t verify the SSL certs</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create the proxy</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">createProxyMiddleware</span>(options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mount `exampleProxy` in web server</span></span><br><span class="line">app.<span class="title function_">use</span>(proxy);</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">33080</span>);</span><br></pre></td></tr></table></figure>

<p><strong>服务器配置</strong></p>
<p>在服务器上启用全局http代理。注意，以下为临时启用，直接设置<code>http_proxy</code>和<code>https_proxy</code>环境变量。如果需要重启后依然生效，则需要将其写入配置文件。</p>
<blockquote>
<p>注意：这里 <code>http_proxy</code> 和 <code>https_proxy</code> 都是指向 <code>http://</code> 而不是 <code>https://</code> 。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://192.168.200.1:33080</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://192.168.200.1:33080</span><br></pre></td></tr></table></figure>

<p>配置 NPM 代理，将 <code>proxy</code> 和 <code>https-proxy</code> 同时指向 <code>http://192.168.200.1:33080</code>。</p>
<blockquote>
<p>注意：这里 <code>proxy</code> 和 <code>https-proxy</code> 都是指向 <code>http://</code> 而不是 <code>https://</code> 。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> proxy http://192.168.200.1:33080</span><br><span class="line">npm config <span class="built_in">set</span> https-proxy http://192.168.200.1:33080</span><br></pre></td></tr></table></figure>

<p><strong>修改 npm registry</strong></p>
<p><strong>注意，由于我们的实现没有使用HTTPS，需要修改 npm registry 为<code>http://</code>。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry http://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<p>在开发用的电脑上运行我们实现的代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node proxy.js</span><br></pre></td></tr></table></figure>

<p>在服务器上使用 npm 安装外部依赖包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i npm -g</span><br><span class="line"></span><br><span class="line">changed 14 packages <span class="keyword">in</span> 3s</span><br><span class="line"></span><br><span class="line">11 packages are looking <span class="keyword">for</span> funding</span><br><span class="line">  run `npm fund` <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i nrm -g</span><br><span class="line">npm WARN deprecated har-validator@5.1.5: this library is no longer supported</span><br><span class="line">npm WARN deprecated uuid@3.4.0: Please upgrade  to version 7 or higher.  Older versions may use Math.random() <span class="keyword">in</span> certain circumstances, <span class="built_in">which</span> is known to be problematic.  See https://v8.dev/blog/math-random <span class="keyword">for</span> details.</span><br><span class="line">npm WARN deprecated request@2.88.2: request has been deprecated, see https://github.com/request/request/issues/3142</span><br><span class="line"></span><br><span class="line">changed 73 packages <span class="keyword">in</span> 6s</span><br><span class="line"></span><br><span class="line">11 packages are looking <span class="keyword">for</span> funding</span><br><span class="line">  run `npm fund` <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure>

<p>可以看到，内网服务器同样可以通过我们实现的 HTTP 代理使用 npm 安装第三方外部依赖了。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>Node.js</tag>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 goproxy 为处于内网环境的开发服务器提供 npm 代理</title>
    <url>/2022/using_goproxy_as_npm_proxy/</url>
    <content><![CDATA[<p>通常，企业内部使用的 Web 应用，其服务器通常无法直接与外网通信，导致没法直接在服务器上使用 npm 或 yarn 等工具安装第三方外部依赖。而开发使用的电脑通常是可以访问互联网的，那么，就可以在开发电脑上使用 goproxy 创建一个 http 代理，通过这个 http 代理临时为服务器提供外网访问，以便可以使用 npm 或 yarn 安装第三方外部依赖。</p>
<p><strong>环境</strong></p>
<ul>
<li>开发计算机：<ul>
<li>Windows 10</li>
<li>可以访问服务器，也可访问互联网</li>
<li>IP: 192.168.200.1</li>
</ul>
</li>
<li>服务器：<ul>
<li>CentOS 8 </li>
<li>仅可访问开发主机，无法直接访问互联网</li>
<li>IP: 192.168.200.129</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p><strong>具体操作</strong></p>
<p>第1步：在开发计算机上使用 <a href="https://github.com/snail007/goproxy/releases">goproxy</a> 创建 http 代理。</p>
<blockquote>
<p><code>--max-conns-rate</code> 参数控制每秒客户端的最大连接数, 默认20, 0为不限制。有时候 npm 包依赖太多，并发会超过默认的20；超过限制后，goproxy 会杀掉超过的会话，导致 npm 包安装失败。</p>
</blockquote>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">.\proxy.exe http -t tcp -p &quot;:<span class="number">33080</span>&quot; --max-conns-rate <span class="number">0</span> --forever</span><br></pre></td></tr></table></figure>

<p>第2步：在服务器上启用全局http代理。注意，以下为临时启用，直接设置<code>http_proxy</code>和<code>https_proxy</code>环境变量。如果需要重启后依然生效，则需要将其写入配置文件。</p>
<blockquote>
<p>注意：这里 <code>http_proxy</code> 和 <code>https_proxy</code> 都是指向 <code>http://</code> 而不是 <code>https://</code> 。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://192.168.200.1:33080</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://192.168.200.1:33080</span><br></pre></td></tr></table></figure>



<p>第3步：配置 NPM 代理，将 <code>proxy</code> 和 <code>https-proxy</code> 同时指向 <code>http://192.168.200.1:33080</code>。</p>
<blockquote>
<p>注意：这里 <code>proxy</code> 和 <code>https-proxy</code> 都是指向 <code>http://</code> 而不是 <code>https://</code> 。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> proxy http://192.168.200.1:33080</span><br><span class="line">npm config <span class="built_in">set</span> https-proxy http://192.168.200.1:33080</span><br></pre></td></tr></table></figure>

<p>第4步：修改 NPM 源（非必需）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<p>使用 npm 安装 <code>nrm</code> ，测试 http 代理是否可用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i nrm -g</span><br><span class="line">npm WARN deprecated har-validator@5.1.5: this library is no longer supported</span><br><span class="line">npm WARN deprecated uuid@3.4.0: Please upgrade  to version 7 or higher.  Older versions may use Math.random() <span class="keyword">in</span> certain circumstances, <span class="built_in">which</span> is known to be problematic.  See https://v8.dev/blog/math-random <span class="keyword">for</span> details.</span><br><span class="line">npm WARN deprecated request@2.88.2: request has been deprecated, see https://github.com/request/request/issues/3142</span><br><span class="line"></span><br><span class="line">added 58 packages <span class="keyword">in</span> 4s</span><br><span class="line"></span><br><span class="line">11 packages are looking <span class="keyword">for</span> funding</span><br><span class="line">  run `npm fund` <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure>
<p>可以看到处于内网的服务器已经成功安装了 <code>nrm</code> 包。同时，开发计算机的控制台也输出了来自服务器的相关 log ： </p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function"> E:\<span class="title">proxy</span>-<span class="title">windows</span>-<span class="title">amd64</span>&gt;.\<span class="title">proxy.exe</span> <span class="title">http</span> -<span class="title">t</span> <span class="title">tcp</span> -<span class="title">p</span> &quot;:33080&quot; --<span class="title">max</span>-<span class="title">conns</span>-<span class="title">rate</span> 0 --<span class="title">forever</span></span></span><br><span class="line"><span class="function">2022/06/09 22:49:12.715429 <span class="title">INFO</span> <span class="title">worker</span> <span class="title">E</span>:\<span class="title">Downloads</span>\<span class="title">Chrome</span>\<span class="title">proxy</span>-<span class="title">windows</span>-<span class="title">amd64</span>\<span class="title">proxy.exe</span> [<span class="title">PID</span>] 88516 <span class="title">running</span>...</span></span><br><span class="line"><span class="function">2022/06/09 22:49:12.821243 <span class="title">INFO</span> <span class="title">tcp</span> <span class="title">http</span>(<span class="title">s</span>) <span class="title">proxy</span> <span class="title">on</span> [::]:33080</span></span><br><span class="line"><span class="function">2022/06/09 22:49:19.266803 <span class="title">INFO</span> <span class="title">CONNECT:registry</span>.<span class="title">npmmirror.com</span>:443</span></span><br><span class="line"><span class="function">2022/06/09 22:49:19.266803 <span class="title">INFO</span> <span class="title">use</span> <span class="title">parent</span> : <span class="title">false</span>, <span class="title">registry.npmmirror.com</span>:443</span></span><br><span class="line"><span class="function">2022/06/09 22:49:19.291648 <span class="title">INFO</span> <span class="title">conn</span> 192.168.200.129:55892 - 39.130.171.71:443 <span class="title">connected</span> [<span class="title">registry.npmmirror.com</span>:443]</span></span><br><span class="line"><span class="function">2022/06/09 22:49:19.576069 <span class="title">INFO</span> <span class="title">conn</span> 192.168.200.129:55892 - 39.130.171.71:443 <span class="title">released</span> [<span class="title">registry.npmmirror.com</span>:443]</span></span><br><span class="line"><span class="function">2022/06/09 22:49:19.641743 <span class="title">INFO</span> <span class="title">CONNECT:registry</span>.<span class="title">npmmirror.com</span>:443</span></span><br><span class="line"><span class="function">2022/06/09 22:49:19.641743 <span class="title">INFO</span> <span class="title">use</span> <span class="title">parent</span> : <span class="title">false</span>, <span class="title">registry.npmmirror.com</span>:443</span></span><br><span class="line"><span class="function">2022/06/09 22:49:19.664109 <span class="title">INFO</span> <span class="title">conn</span> 192.168.200.129:55894 - 39.130.171.71:443 <span class="title">connected</span> [<span class="title">registry.npmmirror.com</span>:443]</span></span><br><span class="line"><span class="function">2022/06/09 22:49:19.939819 <span class="title">INFO</span> <span class="title">conn</span> 192.168.200.129:55894 - 39.130.171.71:443 <span class="title">released</span> [<span class="title">registry.npmmirror.com</span>:443]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>Node.js</tag>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title>从《A Tour of Go》到《Effective Go》</title>
    <url>/2022/from_A-Tour-of-Go_to_Effective-Go/</url>
    <content><![CDATA[<blockquote>
<p>本文是Golang的学习笔记，内容涵盖 <a href="https://go.dev/tour/">A Tour of Go</a> 官方文档 <a href="https://go.dev/doc/effective_go">Effective Go</a> 以及 <a href="https://go-zh.org/doc/effective_go.html">翻译</a></p>
</blockquote>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Go 是一门全新的语言。尽管它从既有的语言中借鉴了许多理念，但其与众不同的特性， 使得使用Go编程在本质上就不同于其它语言。将现有的C++或Java程序直译为Go 程序并不能令人满意——毕竟Java程序是用Java编写的，而不是Go。 另一方面，若从Go的角度去分析问题，你就能编写出同样可行但大不相同的程序。 换句话说，要想将Go程序写得好，就必须理解其特性和风格。了解命名、格式化、 程序结构等既定规则也同样重要，这样你编写的程序才能更容易被其他程序员所理解。</p>
<span id="more"></span>



<h1 id="代码的组织"><a href="#代码的组织" class="headerlink" title="代码的组织"></a>代码的组织</h1><h2 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h2><p><code>go</code> 工具为公共代码仓库中维护的开源代码而设计。 无论你会不会公布代码，该模型设置工作环境的方法都是相同的。</p>
<p>Go 代码必须放在<strong>工作空间</strong>内。它其实就是一个目录，其中包含3个子目录：</p>
<ul>
<li><code>src</code> 目录包含 Go 的源文件，它们被组织成包（每个目录都对应一个包），</li>
<li><code>pkg</code> 目录包含包对象，</li>
<li><code>bin</code> 目录包含可执行命令。</li>
</ul>
<p><code>go</code> 工具用于构建源码包，并将其生成的二进制文件安装到 <code>pkg</code> 和 <code>bin</code> 目录中。</p>
<p><code>src</code> 子目录通常包会含多种版本控制的代码仓库（例如Git或Mercurial）， 以此来跟踪一个或多个源码包的开发。</p>
<p>以下例子展现了实践中工作空间的概念：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/</span><br><span class="line">	streak                         <span class="comment"># 可执行命令</span></span><br><span class="line">	todo                           <span class="comment"># 可执行命令</span></span><br><span class="line">pkg/</span><br><span class="line">	linux_amd64/</span><br><span class="line">		code.google.com/p/goauth2/</span><br><span class="line">			oauth.a                <span class="comment"># 包对象</span></span><br><span class="line">		github.com/nf/todo/</span><br><span class="line">			task.a                 <span class="comment"># 包对象</span></span><br><span class="line">src/</span><br><span class="line">	code.google.com/p/goauth2/</span><br><span class="line">		.hg/                       <span class="comment"># mercurial 代码库元数据</span></span><br><span class="line">		oauth/</span><br><span class="line">			oauth.go               <span class="comment"># 包源码</span></span><br><span class="line">			oauth_test.go          <span class="comment"># 测试源码</span></span><br><span class="line">	github.com/nf/</span><br><span class="line">		streak/</span><br><span class="line">		.git/                      <span class="comment"># git 代码库元数据</span></span><br><span class="line">			oauth.go               <span class="comment"># 命令源码</span></span><br><span class="line">			streak.go              <span class="comment"># 命令源码</span></span><br><span class="line">		todo/</span><br><span class="line">		.git/                      <span class="comment"># git 代码库元数据</span></span><br><span class="line">			task/</span><br><span class="line">				task.go            <span class="comment"># 包源码</span></span><br><span class="line">			todo.go                <span class="comment"># 命令源码</span></span><br></pre></td></tr></table></figure>

<p>此工作空间包含三个代码库（<code>goauth2</code>、<code>streak</code> 和 <code>todo</code>），两个命令（<code>streak</code> 和 <code>todo</code>） 以及两个库（<code>oauth</code> 和 <code>task</code>）。</p>
<p>命令和库从不同的源码包编译而来。<a href="https://go-zh.org/doc/code.html#%E5%8C%85%E5%90%8D">稍后</a>我们会对讨论它的特性。</p>
<h2 id="GOPATH-环境变量"><a href="#GOPATH-环境变量" class="headerlink" title="GOPATH 环境变量"></a><code>GOPATH</code> 环境变量</h2><p><code>GOPATH</code> 环境变量指定了你的工作空间位置。它或许是你在开发Go代码时， 唯一需要设置的环境变量。</p>
<p>首先创建一个工作空间目录，并设置相应的 <code>GOPATH</code>。你的工作空间可以放在任何地方， 在此文档中我们使用 <code>$HOME/work</code>。注意，它<strong>绝对不能</strong>和你的Go安装目录相同。 （另一种常见的设置是 <code>GOPATH=$HOME</code>。）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> <span class="variable">$HOME</span>/work</span><br><span class="line">$ <span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/work</span><br></pre></td></tr></table></figure>

<p>作为约定，请将此工作空间的 <code>bin</code> 子目录添加到你的 <code>PATH</code> 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOPATH</span>/bin</span><br></pre></td></tr></table></figure>

<p>To learn more about setting up the <code>GOPATH</code> environment variable, please see <a href="https://go-zh.org/cmd/go/#hdr-GOPATH_environment_variable"><code>go help gopath</code></a></p>
<h2 id="包路径"><a href="#包路径" class="headerlink" title="包路径"></a>包路径</h2><p>标准库中的包有给定的短路径，比如 <code>&quot;fmt&quot;</code> 和 <code>&quot;net/http&quot;</code>。 对于你自己的包，你必须选择一个基本路径，来保证它不会与将来添加到标准库， 或其它扩展库中的包相冲突。</p>
<p>如果你将你的代码放到了某处的源码库，那就应当使用该源码库的根目录作为你的基本路径。 例如，若你在 <a href="https://github.com/">GitHub</a> 上有账户 <code>github.com/user</code> 那么它就应该是你的基本路径。</p>
<p>注意，在你能构建这些代码之前，无需将其公布到远程代码库上。只是若你某天会发布它， 这会是个好习惯。在实践中，你可以选择任何路径名，只要它对于标准库和更大的Go生态系统来说， 是唯一的就行。</p>
<p>我们将使用 <code>github.com/user</code> 作为基本路径。在你的工作空间里创建一个目录， 我们将源码存放到其中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p <span class="variable">$GOPATH</span>/src/github.com/user</span><br></pre></td></tr></table></figure>

<h2 id="你的第一个程序"><a href="#你的第一个程序" class="headerlink" title="你的第一个程序"></a>你的第一个程序</h2><p>要编译并运行简单的程序，首先要选择包路径（我们在这里使用 <code>github.com/user/hello</code>），并在你的工作空间内创建相应的包目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> <span class="variable">$GOPATH</span>/src/github.com/user/hello</span><br></pre></td></tr></table></figure>

<p>接着，在该目录中创建名为 <code>hello.go</code> 的文件，其内容为以下Go代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hello, world.\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你可以用 <code>go</code> 工具构建并安装此程序了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install github.com/user/hello</span><br></pre></td></tr></table></figure>

<p>注意，你可以在系统的任何地方运行此命令。<code>go</code> 工具会根据 <code>GOPATH</code> 指定的工作空间，在 <code>github.com/user/hello</code> 包内查找源码。</p>
<p>若在从包目录中运行 <code>go install</code>，也可以省略包路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/user/hello</span><br><span class="line">$ go install</span><br></pre></td></tr></table></figure>

<p>此命令会构建 <code>hello</code> 命令，产生一个可执行的二进制文件。 接着它会将该二进制文件作为 <code>hello</code>（在 Windows 下则为 <code>hello.exe</code>）安装到工作空间的 <code>bin</code> 目录中。 在我们的例子中为 <code>$GOPATH/bin/hello</code>，具体一点就是 <code>$HOME/go/bin/hello</code>。</p>
<p><code>go</code> 工具只有在发生错误时才会打印输出，因此若这些命令没有产生输出， 就表明执行成功了。</p>
<p>现在，你可以在命令行下输入它的完整路径来运行它了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="variable">$GOPATH</span>/bin/hello</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure>

<p>若你已经将 <code>$GOPATH/bin</code> 添加到 <code>PATH</code> 中了，只需输入该二进制文件名即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hello</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure>

<p>若你使用源码控制系统，那现在就该初始化仓库，添加文件并提交你的第一次更改了。 再次强调，这一步是可选的：你无需使用源码控制来编写Go代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/user/hello</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/user/work/src/github.com/user/hello/.git/</span><br><span class="line">$ git add hello.go</span><br><span class="line">$ git commit -m <span class="string">&quot;initial commit&quot;</span></span><br><span class="line">[master (root-commit) 0b4507d] initial commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">  create mode 100644 hello.go</span><br></pre></td></tr></table></figure>

<p>将代码推送到远程仓库就留作读者的练习了。</p>
<h2 id="你的第一个库"><a href="#你的第一个库" class="headerlink" title="你的第一个库"></a>你的第一个库</h2><p>让我们编写一个库，并让 <code>hello</code> 程序来使用它。</p>
<p>同样，第一步还是选择包路径（我们将使用 <code>github.com/user/stringutil</code>） 并创建包目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> <span class="variable">$GOPATH</span>/src/github.com/user/stringutil</span><br></pre></td></tr></table></figure>

<p>接着，在该目录中创建名为 <code>reverse.go</code> 的文件，内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stringutil 包含有用于处理字符串的工具函数。</span></span><br><span class="line"><span class="keyword">package</span> stringutil</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse 将其实参字符串以符文为单位左右反转。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	r := []<span class="type">rune</span>(s)</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		r[i], r[j] = r[j], r[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在用 <code>go build</code> 命令来测试该包的编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build github.com/user/stringutil</span><br></pre></td></tr></table></figure>

<p>当然，若你在该包的源码目录中，只需执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build</span><br></pre></td></tr></table></figure>

<p>即可。这不会产生输出文件。想要输出的话，必须使用 <code>go install</code> 命令，它会将包的对象放到工作空间的 <code>pkg</code> 目录中。</p>
<p>确认 <code>stringutil</code> 包构建完毕后，修改原来的 <code>hello.go</code> 文件（它位于 <code>$GOPATH/src/github.com/user/hello</code>）去使用它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/user/stringutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(stringutil.Reverse(<span class="string">&quot;!oG ,olleH&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是安装包还是二进制文件，<code>go</code> 工具都会安装它所依赖的任何东西。 因此当我们通过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install github.com/user/hello</span><br></pre></td></tr></table></figure>

<p>来安装 <code>hello</code> 程序时，<code>stringutil</code> 包也会被自动安装。</p>
<p>运行此程序的新版本，你应该能看到一条新的，反向的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hello</span><br><span class="line">Hello, Go!</span><br></pre></td></tr></table></figure>

<p>做完上面这些步骤后，你的工作空间应该是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/</span><br><span class="line">	hello                 <span class="comment"># 可执行命令</span></span><br><span class="line">pkg/</span><br><span class="line">	linux_amd64/          <span class="comment"># 这里会反映出你的操作系统和架构</span></span><br><span class="line">		github.com/user/</span><br><span class="line">			stringutil.a  <span class="comment"># 包对象</span></span><br><span class="line">src/</span><br><span class="line">	github.com/user/</span><br><span class="line">		hello/</span><br><span class="line">			hello.go      <span class="comment"># 命令源码</span></span><br><span class="line">		stringutil/</span><br><span class="line">			reverse.go       <span class="comment"># 包源码</span></span><br></pre></td></tr></table></figure>

<p>注意 <code>go install</code> 会将 <code>stringutil.a</code> 对象放到 <code>pkg/linux_amd64</code> 目录中，它会反映出其源码目录。 这就是在此之后调用 <code>go</code> 工具，能找到包对象并避免不必要的重新编译的原因。 <code>linux_amd64</code> 这部分能帮助跨平台编译，并反映出你的操作系统和架构。</p>
<p>Go的可执行命令是静态链接的；在运行Go程序时，包对象无需存在。</p>
<h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><p>Go源文件中的第一个语句必须是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 名称</span><br></pre></td></tr></table></figure>

<p>这里的 <strong><code>名称</code></strong> 即为导入该包时使用的默认名称。 （一个包中的所有文件都必须使用相同的 <strong><code>名称</code></strong>。）</p>
<p>Go的约定是包名为导入路径的最后一个元素：作为 <code>crypto/rot13</code> 导入的包应命名为 <code>rot13</code>。</p>
<p>可执行命令必须使用 <code>package main</code>。</p>
<p>链接成单个二进制文件的所有包，其包名无需是唯一的，只有导入路径（它们的完整文件名） 才是唯一的。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>Go拥有一个轻量级的测试框架，它由 <code>go test</code> 命令和 <code>testing</code> 包构成。</p>
<p>你可以通过创建一个名字以 <code>_test.go</code> 结尾的，包含名为 <code>TestXXX</code> 且签名为 <code>func (t *testing.T)</code> 函数的文件来编写测试。 测试框架会运行每一个这样的函数；若该函数调用了像 <code>t.Error</code> 或 <code>t.Fail</code> 这样表示失败的函数，此测试即表示失败。</p>
<p>我们可通过创建文件 <code>$GOPATH/src/github.com/user/stringutil/reverse_test.go</code> 来为 <code>stringutil</code> 添加测试，其内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stringutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverse</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		in, want <span class="type">string</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;<span class="string">&quot;Hello, world&quot;</span>, <span class="string">&quot;dlrow ,olleH&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Hello, 世界&quot;</span>, <span class="string">&quot;界世 ,olleH&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">		got := Reverse(c.in)</span><br><span class="line">		<span class="keyword">if</span> got != c.want &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;Reverse(%q) == %q, want %q&quot;</span>, c.in, got, c.want)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着使用 <code>go test</code> 运行该测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> github.com/user/stringutil</span><br><span class="line">ok  	github.com/user/stringutil 0.165s</span><br></pre></td></tr></table></figure>

<p>同样，若你在包目录下运行 <code>go</code> 工具，也可以忽略包路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">ok  	github.com/user/stringutil 0.165s</span><br></pre></td></tr></table></figure>

<p>更多详情可运行 <code>go help test</code> 或从 <a href="https://go-zh.org/pkg/testing/">testing 包文档</a> 中查看。</p>
<h1 id="远程包"><a href="#远程包" class="headerlink" title="远程包"></a>远程包</h1><p>像Git或Mercurial这样的版本控制系统，可根据导入路径的描述来获取包源代码。<code>go</code> 工具可通过此特性来从远程代码库自动获取包。例如，本文档中描述的例子也可存放到Google Code上的Mercurial仓库 <code>code.google.com/p/go.example</code> 中，若你在包的导入路径中包含了代码仓库的URL，<code>go get</code> 就会自动地获取、 构建并安装它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go get github.com/golang/example/hello</span><br><span class="line">$ <span class="variable">$GOPATH</span>/bin/hello</span><br><span class="line">Hello, Go examples!</span><br></pre></td></tr></table></figure>

<p>若指定的包不在工作空间中，<code>go get</code> 就会将会将它放到 <code>GOPATH</code> 指定的第一个工作空间内。（若该包已存在，<code>go get</code> 就会跳过远程获取， 其行为与 <code>go install</code> 相同）</p>
<p>在执行完上面的<code>go get</code> 命令后，工作空间的目录树看起来应该是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/</span><br><span class="line">	hello                 <span class="comment"># 可执行命令</span></span><br><span class="line">pkg/</span><br><span class="line">	linux_amd64/</span><br><span class="line">		code.google.com/p/go.example/</span><br><span class="line">			stringutil.a     <span class="comment"># 包对象</span></span><br><span class="line">		github.com/user/</span><br><span class="line">			stringutil.a     <span class="comment"># 包对象</span></span><br><span class="line">src/</span><br><span class="line">	code.google.com/p/go.example/</span><br><span class="line">		hello/</span><br><span class="line">			hello.go      <span class="comment"># 命令源码</span></span><br><span class="line">		stringutil/</span><br><span class="line">			reverse.go       <span class="comment"># 包源码</span></span><br><span class="line">			reverse_test.go  <span class="comment"># 测试源码</span></span><br><span class="line">	github.com/user/</span><br><span class="line">		hello/</span><br><span class="line">			hello.go      <span class="comment"># 命令源码</span></span><br><span class="line">		stringutil/</span><br><span class="line">			reverse.go       <span class="comment"># 包源码</span></span><br><span class="line">			reverse_test.go  <span class="comment"># 测试源码</span></span><br></pre></td></tr></table></figure>

<p><code>hello</code> 命令及其依赖的 <code>stringutil</code> 包都托管在Google Code上的同一代码库中。<code>hello.go</code> 文件使用了同样的导入路径约定， 因此 <code>go get</code> 命令也能够定位并安装其依赖包。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/golang/example/stringutil&quot;</span></span><br></pre></td></tr></table></figure>

<p>遵循此约定可让他人以最简单的方式使用你的Go包。 <a href="http://code.google.com/p/go-wiki/wiki/Projects">Go维基</a> 与 <a href="http://godoc.org/">godoc.org</a> 提供了外部Go项目的列表。</p>
<p>通过 <code>go</code> 工具使用远程代码库的更多详情，见 <code>go help remote</code>。</p>
<h1 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h1><p>格式化问题总是充满了争议，但却始终没有形成统一的定论。虽说人们可以适应不同的编码风格， 但抛弃这种适应过程岂不更好？若所有人都遵循相同的编码风格，在这类问题上浪费的时间将会更少。 问题就在于如何实现这种设想，而无需冗长的语言风格规范。</p>
<p>在Go中我们另辟蹊径，让机器来处理大部分的格式化问题。<code>gofmt</code> 程序（也可用 <code>go fmt</code>，它以包为处理对象而非源文件）将Go程序按照标准风格缩进、 对齐，保留注释并在需要时重新格式化。若你想知道如何处理一些新的代码布局，请尝试运行 <code>gofmt</code>；若结果仍不尽人意，请重新组织你的程序（或提交有关 <code>gofmt</code> 的Bug），而不必为此纠结。</p>
<p>举例来说，你无需花时间将结构体中的字段注释对齐，<code>gofmt</code> 将为你代劳。 假如有以下声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span> <span class="comment">// 对象名</span></span><br><span class="line">	value <span class="type">int</span> <span class="comment">// 对象值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gofmt</code> 会将它按列对齐为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	name    <span class="type">string</span> <span class="comment">// 对象名</span></span><br><span class="line">	value   <span class="type">int</span>    <span class="comment">// 对象值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准包中所有的Go代码都已经用 <code>gofmt</code> 格式化过了。</p>
<p>还有一些关于格式化的细节，它们非常简短：</p>
<ul>
<li><p>缩进</p>
<p>我们使用制表符（tab）缩进，<code>gofmt</code> 默认也使用它。在你认为确实有必要时再使用空格。</p>
</li>
<li><p>行的长度</p>
<p>Go对行的长度没有限制，别担心打孔纸不够长。如果一行实在太长，也可进行折行并插入适当的tab缩进。</p>
</li>
<li><p>括号</p>
<p>比起C和Java，Go所需的括号更少：控制结构（<code>if</code>、<code>for</code> 和 <code>switch</code>）在语法上并不需要圆括号。此外，操作符优先级处理变得更加简洁，因此<code>x&lt;&lt;8 + y&lt;&lt;16 </code>正表述了空格符所传达的含义。</p>
</li>
</ul>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>Go语言支持C风格的块注释 <code>/* */</code> 和C++风格的行注释 <code>//</code>。 行注释更为常用，而块注释则主要用作包的注释，当然也可在禁用一大段代码时使用。</p>
<p><code>godoc</code> 既是一个程序，又是一个Web服务器，它对Go的源码进行处理，并提取包中的文档内容。 出现在顶级声明之前，且与该声明之间没有空行的注释，将与该声明一起被提取出来，作为该条目的说明文档。 这些注释的类型和风格决定了 <code>godoc</code> 生成的文档质量。</p>
<p>每个包都应包含一段<strong>包注释</strong>，即放置在包子句前的一个块注释。对于包含多个文件的包， 包注释只需出现在其中的任一文件中即可。包注释应在整体上对该包进行介绍，并提供包的相关信息。 它将出现在 <code>godoc</code> 页面中的最上面，并为紧随其后的内容建立详细的文档。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	regexp 包为正则表达式实现了一个简单的库。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	该库接受的正则表达式语法为：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	正则表达式:</span></span><br><span class="line"><span class="comment">		串联 &#123; &#x27;|&#x27; 串联 &#125;</span></span><br><span class="line"><span class="comment">	串联:</span></span><br><span class="line"><span class="comment">		&#123; 闭包 &#125;</span></span><br><span class="line"><span class="comment">	闭包:</span></span><br><span class="line"><span class="comment">		条目 [ &#x27;*&#x27; | &#x27;+&#x27; | &#x27;?&#x27; ]</span></span><br><span class="line"><span class="comment">	条目:</span></span><br><span class="line"><span class="comment">		&#x27;^&#x27;</span></span><br><span class="line"><span class="comment">		&#x27;$&#x27;</span></span><br><span class="line"><span class="comment">		&#x27;.&#x27;</span></span><br><span class="line"><span class="comment">		字符</span></span><br><span class="line"><span class="comment">		&#x27;[&#x27; [ &#x27;^&#x27; ] 字符遍历 &#x27;]&#x27;</span></span><br><span class="line"><span class="comment">		&#x27;(&#x27; 正则表达式 &#x27;)&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> regexp</span><br></pre></td></tr></table></figure>

<p>若某个包比较简单，包注释同样可以简洁些。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path 包实现了一些常用的工具，以便于操作用反斜杠分隔的路径.</span></span><br></pre></td></tr></table></figure>

<p>注释无需进行额外的格式化，如用星号来突出等。生成的输出甚至可能无法以等宽字体显示， 因此不要依赖于空格对齐，<code>godoc</code> 会像 <code>gofmt</code> 那样处理好这一切。 注释是不会被解析的纯文本，因此像HTML或其它类似于 <code>_这样_</code> 的东西将按照 <strong>原样</strong> 输出，因此不应使用它们。<code>godoc</code> 所做的调整， 就是将已缩进的文本以等宽字体显示，来适应对应的程序片段。 <a href="http://golang.org/pkg/fmt/"><code>fmt</code> 包</a>的注释就用了这种不错的效果。</p>
<p><code>godoc</code> 是否会重新格式化注释取决于上下文，因此必须确保它们看起来清晰易辨： 使用正确的拼写、标点和语句结构以及折叠长行等。</p>
<p>在包中，任何顶级声明前面的注释都将作为该声明的<strong>文档注释</strong>。 在程序中，每个可导出（首字母大写）的名称都应该有文档注释。</p>
<p>文档注释最好是完整的句子，这样它才能适应各种自动化的展示。 第一句应当以被声明的东西开头，并且是单句的摘要。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compile 用于解析正则表达式并返回，如果成功，则 Regexp 对象就可用于匹配所针对的文本。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(str <span class="type">string</span>)</span></span> (regexp *Regexp, err <span class="type">error</span>) &#123;</span><br></pre></td></tr></table></figure>

<p>若注释总是以名称开头，<code>godoc</code> 的输出就能通过 <code>grep</code> 变得更加有用。假如你记不住“Compile”这个名称，而又在找正则表达式的解析函数， 那就可以运行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ godoc regexp | grep parse</span><br></pre></td></tr></table></figure>

<p>若包中的所有文档注释都以“此函数…”开头，<code>grep</code> 就无法帮你记住此名称。 但由于每个包的文档注释都以其名称开头，你就能看到这样的内容，它能显示你正在寻找的词语。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ godoc regexp | grep parse</span><br><span class="line">	Compile parses a regular expression and returns, <span class="keyword">if</span> successful, a Regexp</span><br><span class="line">	parsed. It simplifies safe initialization of global variables holding</span><br><span class="line">	cannot be parsed. It simplifies safe initialization of global variables</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>Go的声明语法允许成组声明。单个文档注释应介绍一组相关的常量或变量。 由于是整体声明，这种注释往往较为笼统。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表达式解析失败后返回错误代码。</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ErrInternal      = errors.New(<span class="string">&quot;regexp: internal error&quot;</span>)</span><br><span class="line">	ErrUnmatchedLpar = errors.New(<span class="string">&quot;regexp: unmatched &#x27;(&#x27;&quot;</span>)</span><br><span class="line">	ErrUnmatchedRpar = errors.New(<span class="string">&quot;regexp: unmatched &#x27;)&#x27;&quot;</span>)</span><br><span class="line">	...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>即便是对于私有名称，也可通过成组声明来表明各项间的关系，例如某一组由互斥体保护的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	countLock   sync.Mutex</span><br><span class="line">	inputCount  <span class="type">uint32</span></span><br><span class="line">	outputCount <span class="type">uint32</span></span><br><span class="line">	errorCount  <span class="type">uint32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><p>正如命名在其它语言中的地位，它在 Go 中同样重要。有时它们甚至会影响语义： 例如，某个名称在包外是否可见，就取决于其首个字符是否为大写字母。 因此有必要花点时间来讨论Go程序中的命名约定。</p>
<h2 id="包名-1"><a href="#包名-1" class="headerlink" title="包名"></a>包名</h2><p>当一个包被导入后，包名就会成了内容的访问器。在</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;bytes&quot;</span></span><br></pre></td></tr></table></figure>

<p>之后，被导入的包就能通过 <code>bytes.Buffer</code> 来引用了。 若所有人都以相同的名称来引用其内容将大有裨益， 这也就意味着包应当有个恰当的名称：其名称应该简洁明了而易于理解。按照惯例， 包应当以小写的单个单词来命名，且不应使用下划线或驼峰记法。<code>err</code> 的命名就是出于简短考虑的，因为任何使用该包的人都会键入该名称。 不必担心<strong>引用次序</strong>的冲突。包名就是导入时所需的唯一默认名称， 它并不需要在所有源码中保持唯一，即便在少数发生冲突的情况下， 也可为导入的包选择一个别名来局部使用。 无论如何，通过文件名来判定使用的包，都是不会产生混淆的。</p>
<p>另一个约定就是包名应为其源码目录的基本名称。在 <code>src/pkg/encoding/base64</code> 中的包应作为 <code>&quot;encoding/base64&quot;</code> 导入，其包名应为 <code>base64</code>， 而非 <code>encoding_base64</code> 或 <code>encodingBase64</code>。</p>
<p>包的导入者可通过包名来引用其内容，因此包中的可导出名称可以此来避免冲突。 （请勿使用 <code>import .</code> 记法，它可以简化必须在被测试包外运行的测试， 除此之外应尽量避免使用。）例如，<code>bufio</code> 包中的缓存读取器类型叫做 <code>Reader</code> 而非 <code>BufReader</code>，因为用户将它看做 <code>bufio.Reader</code>，这是个清楚而简洁的名称。 此外，由于被导入的项总是通过它们的包名来确定，因此 <code>bufio.Reader</code> 不会与 <code>io.Reader</code> 发生冲突。同样，用于创建 <code>ring.Ring</code> 的新实例的函数（这就是Go中的<strong>构造函数</strong>）一般会称之为 <code>NewRing</code>，但由于 <code>Ring</code> 是该包所导出的唯一类型，且该包也叫 <code>ring</code>，因此它可以只叫做 <code>New</code>，它跟在包的后面，就像 <code>ring.New</code>。使用包结构可以帮助你选择好的名称。</p>
<p>另一个简短的例子是 <code>once.Do</code>，<code>once.Do(setup)</code> 表述足够清晰， 使用 <code>once.DoOrWaitUntilDone(setup)</code> 完全就是画蛇添足。 长命名并不会使其更具可读性。一份有用的说明文档通常比额外的长名更有价值。</p>
<h2 id="获取器"><a href="#获取器" class="headerlink" title="获取器"></a>获取器</h2><p>Go并不对获取器（getter）和设置器（setter）提供自动支持。 你应当自己提供获取器和设置器，通常很值得这样做，但若要将 <code>Get</code> 放到获取器的名字中，既不符合习惯，也没有必要。若你有个名为 <code>owner</code> （小写，未导出）的字段，其获取器应当名为 <code>Owner</code>（大写，可导出）而非 <code>GetOwner</code>。大写字母即为可导出的这种规定为区分方法和字段提供了便利。 若要提供设置器方法，<code>SetOwner</code> 是个不错的选择。两个命名看起来都很合理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">owner := obj.Owner()</span><br><span class="line"><span class="keyword">if</span> owner != user &#123;</span><br><span class="line">	obj.SetOwner(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口名"><a href="#接口名" class="headerlink" title="接口名"></a>接口名</h2><p>按照约定，只包含一个方法的接口应当以该方法的名称加上-er后缀来命名，如 <code>Reader</code>、<code>Writer</code>、 <code>Formatter</code>、<code>CloseNotifier</code> 等。</p>
<p>诸如此类的命名有很多，遵循它们及其代表的函数名会让事情变得简单。 <code>Read</code>、<code>Write</code>、<code>Close</code>、<code>Flush</code>、 <code>String</code> 等都具有典型的签名和意义。为避免冲突，请不要用这些名称为你的方法命名， 除非你明确知道它们的签名和意义相同。反之，若你的类型实现了的方法， 与一个众所周知的类型的方法拥有相同的含义，那就使用相同的命名。 请将字符串转换方法命名为 <code>String</code> 而非 <code>ToString</code>。</p>
<h2 id="驼峰记法"><a href="#驼峰记法" class="headerlink" title="驼峰记法"></a>驼峰记法</h2><p>最后，Go中约定使用驼峰记法 <code>MixedCaps</code> 或 <code>mixedCaps</code>。</p>
<h1 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h1><p>和C一样，Go的正式语法使用分号来结束语句；和C不同的是，这些分号并不在源码中出现。 取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此因此源码中基本就不用分号了。</p>
<p>规则是这样的：若在新行前的最后一个标记为标识符（包括 <code>int</code> 和 <code>float64</code> 这类的单词）、数值或字符串常量之类的基本字面或以下标记之一</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span> <span class="keyword">continue</span> <span class="keyword">fallthrough</span> <span class="keyword">return</span> ++ -- ) &#125;</span><br></pre></td></tr></table></figure>

<p>则词法分析将始终在该标记后面插入分号。这点可以概括为： “如果新行前的标记为语句的末尾，则插入分号”。</p>
<p>分号也可在闭括号之前直接省略，因此像</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; dst &lt;- &lt;-src &#125; &#125;()</span><br></pre></td></tr></table></figure>

<p>这样的语句无需分号。通常Go程序只在诸如 <code>for</code> 循环子句这样的地方使用分号， 以此来将初始化器、条件及增量元素分开。如果你在一行中写多个语句，也需要用分号隔开。</p>
<p>警告：无论如何，你都不应将一个控制结构（<code>if</code>、<code>for</code>、<code>switch</code> 或 <code>select</code>）的左大括号放在下一行。如果这样做，就会在大括号前面插入一个分号，这可能引起不需要的效果。 你应该这样写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> i &lt; f() &#123;</span><br><span class="line">	g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而不是这样</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> i &lt; f()  <span class="comment">// 错！</span></span><br><span class="line">&#123;           <span class="comment">// 错！</span></span><br><span class="line">	g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h1><p>Go中的结构控制与C有许多相似之处，但其不同之处才是独到之处。 Go不再使用 <code>do</code> 或 <code>while</code> 循环，只有一个更通用的 <code>for</code>；<code>switch</code> 要更灵活一点；<code>if</code> 和 <code>switch</code> 像 <code>for</code>一样可接受可选的初始化语句； 此外，还有一个包含类型选择和多路通信复用器的新控制结构：<code>select</code>。 其语法也有些许不同：没有圆括号，而其主体必须始终使用大括号括住。</p>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p>在Go中，一个简单的 <code>if</code> 语句看起来像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强制的大括号促使你将简单的 <code>if</code> 语句分成多行。特别是在主体中包含 <code>return</code> 或 <code>break</code> 等控制语句时，这种编码风格的好处一比便知。</p>
<p>由于 <code>if</code> 和 <code>switch</code> 可接受初始化语句， 因此用它们来设置局部变量十分常见。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := file.Chmod(<span class="number">0664</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Print(err)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Go的库中，你会发现若 <code>if</code> 语句不会执行到下一条语句时，亦即其执行体 以 <code>break</code>、<code>continue</code>、<code>goto</code> 或 <code>return</code> 结束时，不必要的 <code>else</code> 会被省略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">codeUsing(f)</span><br></pre></td></tr></table></figure>

<p>下例是一种常见的情况，代码必须防范一系列的错误条件。若控制流成功继续， 则说明程序已排除错误。由于出错时将以<code>return</code> 结束， 之后的代码也就无需 <code>else</code> 了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">d, err := f.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	f.Close()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">codeUsing(f, d)</span><br></pre></td></tr></table></figure>

<h2 id="重新声明与再次赋值"><a href="#重新声明与再次赋值" class="headerlink" title="重新声明与再次赋值"></a>重新声明与再次赋值</h2><p>题外话：上一节中最后一个示例展示了短声明 <code>:=</code> 如何使用。 调用了 <code>os.Open</code> 的声明为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br></pre></td></tr></table></figure>

<p>该语句声明了两个变量 <code>f</code> 和 <code>err</code>。在几行之后，又通过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">d, err := f.Stat()</span><br></pre></td></tr></table></figure>

<p>调用了 <code>f.Stat</code>。它看起来似乎是声明了 <code>d</code> 和 <code>err</code>。 注意，尽管两个语句中都出现了 <code>err</code>，但这种重复仍然是合法的：<code>err</code> 在第一条语句中被声明，但在第二条语句中只是被<strong>再次赋值</strong>罢了。也就是说，调用 <code>f.Stat</code> 使用的是前面已经声明的 <code>err</code>，它只是被重新赋值了而已。</p>
<p>在满足下列条件时，已被声明的变量 <code>v</code> 可出现在<code>:=</code> 声明中：</p>
<ul>
<li>本次声明与已声明的 <code>v</code> 处于同一作用域中（若 <code>v</code> 已在外层作用域中声明过，则此次声明会创建一个新的变量§），</li>
<li>在初始化中与其类型相应的值才能赋予 <code>v</code>，且</li>
<li>在此次声明中至少另有一个变量是新声明的。</li>
</ul>
<p>这个特性简直就是纯粹的实用主义体现，它使得我们可以很方面地只使用一个 <code>err</code> 值，例如，在一个相当长的 <code>if-else</code> 语句链中， 你会发现它用得很频繁。</p>
<p>§值得一提的是，即便Go中的函数形参和返回值在词法上处于大括号之外， 但它们的作用域和该函数体仍然相同。</p>
<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>Go的 <code>for</code> 循环类似于C，但却不尽相同。它统一了 <code>for</code> 和 <code>while</code>，不再有 <code>do-while</code> 了。它有三种形式，但只有一种需要分号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如同C的for循环</span></span><br><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如同C的while循环</span></span><br><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如同C的for(;;)循环</span></span><br><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>简短声明能让我们更容易在循环中声明下标变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若你想遍历数组、切片、字符串或者映射，或从信道中读取消息， <code>range</code> 子句能够帮你轻松实现循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">	newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若你只需要该遍历中的第一个项（键或下标），去掉第二个就行了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m &#123;</span><br><span class="line">	<span class="keyword">if</span> key.expired() &#123;</span><br><span class="line">		<span class="built_in">delete</span>(m, key)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若你只需要该遍历中的第二个项（值），请使用<strong>空白标识符</strong>，即下划线来丢弃第一个值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> array &#123;</span><br><span class="line">	sum += value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空白标识符还有多种用法，它会在<a href="https://go-zh.org/doc/effective_go.html#%E7%A9%BA%E7%99%BD">后面的小节</a>中描述。</p>
<p>对于字符串，<code>range</code> 能够提供更多便利。它能通过解析UTF-8， 将每个独立的Unicode码点分离出来。错误的编码将占用一个字节，并以符文U+FFFD来代替。 （名称“符文”和内建类型 <code>rune</code> 是Go对单个Unicode码点的成称谓。 详情见<a href="http://golang.org/ref/spec#%E7%AC%A6%E6%96%87%E5%AD%97%E9%9D%A2">语言规范</a>）。循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pos, char := <span class="keyword">range</span> <span class="string">&quot;日本\x80語&quot;</span> &#123; <span class="comment">// \x80 是个非法的UTF-8编码</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符 %#U 始于字节位置 %d\n&quot;</span>, char, pos)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将打印</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">字符 U+<span class="number">65E5</span> <span class="string">&#x27;日&#x27;</span> 始于字节位置 <span class="number">0</span></span><br><span class="line">字符 U+<span class="number">672</span>C <span class="string">&#x27;本&#x27;</span> 始于字节位置 <span class="number">3</span></span><br><span class="line">字符 U+FFFD <span class="string">&#x27;�&#x27;</span> 始于字节位置 <span class="number">6</span></span><br><span class="line">字符 U+<span class="number">8</span>A9E <span class="string">&#x27;語&#x27;</span> 始于字节位置 <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>最后，Go没有逗号操作符，而 <code>++</code> 和 <code>--</code> 为语句而非表达式。 因此，若你想要在 <code>for</code> 中使用多个变量，应采用平行赋值的方式 （因为它会拒绝 <code>++</code> 和 <code>--</code>）.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反转 a</span></span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">	a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>Go的 <code>switch</code> 比C的更通用。其表达式无需为常量或整数，<code>case</code> 语句会自上而下逐一进行求值直到匹配为止。若 <code>switch</code> 后面没有表达式，它将匹配 <code>true</code>，因此，我们可以将 <code>if-else-if-else</code> 链写成一个 <code>switch</code>，这也更符合Go的风格。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unhex</span><span class="params">(c <span class="type">byte</span>)</span></span> <span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch</code> 并不会自动下溯，但 <code>case</code> 可通过逗号分隔来列举相同的处理条件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldEscape</span><span class="params">(c <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> c &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管它们在Go中的用法和其它类C语言差不多，但 <code>break</code> 语句可以使 <code>switch</code> 提前终止。不仅是 <code>switch</code>， 有时候也必须打破层层的循环。在Go中，我们只需将标签放置到循环外，然后 “蹦”到那里即可。下面的例子展示了二者的用法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Loop:</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="built_in">len</span>(src); n += size &#123;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> src[n] &lt; sizeOne:</span><br><span class="line">			<span class="keyword">if</span> validateOnly &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			size = <span class="number">1</span></span><br><span class="line">			update(src[n])</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> src[n] &lt; sizeTwo:</span><br><span class="line">			<span class="keyword">if</span> n+<span class="number">1</span> &gt;= <span class="built_in">len</span>(src) &#123;</span><br><span class="line">				err = errShortInput</span><br><span class="line">				<span class="keyword">break</span> Loop</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> validateOnly &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			size = <span class="number">2</span></span><br><span class="line">			update(src[n] + src[n+<span class="number">1</span>]&lt;&lt;shift)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>当然，<code>continue</code> 语句也能接受一个可选的标签，不过它只能在循环中使用。</p>
<p>作为这一节的结束，此程序通过使用两个 <code>switch</code> 语句对字节数组进行比较：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compare 按字典顺序比较两个字节切片并返回一个整数。</span></span><br><span class="line"><span class="comment">// 若 a == b，则结果为零；若 a &lt; b；则结果为 -1；若 a &gt; b，则结果为 +1。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compare</span><span class="params">(a, b []<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a) &amp;&amp; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> a[i] &gt; b[i]:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">		<span class="keyword">case</span> a[i] &lt; b[i]:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="built_in">len</span>(a) &gt; <span class="built_in">len</span>(b):</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> <span class="built_in">len</span>(a) &lt; <span class="built_in">len</span>(b):</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h2><p><code>switch</code> 也可用于判断接口变量的动态类型。如 <strong>类型选择</strong> 通过圆括号中的关键字 <code>type</code> 使用类型断言语法。若 <code>switch</code> 在表达式中声明了一个变量，那么该变量的每个子句中都将有该变量对应的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Printf(<span class="string">&quot;unexpected type %T&quot;</span>, t)       <span class="comment">// %T 输出 t 是什么类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">	fmt.Printf(<span class="string">&quot;boolean %t\n&quot;</span>, t)             <span class="comment">// t 是 bool 类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">	fmt.Printf(<span class="string">&quot;integer %d\n&quot;</span>, t)             <span class="comment">// t 是 int 类型</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">bool</span>:</span><br><span class="line">	fmt.Printf(<span class="string">&quot;pointer to boolean %t\n&quot;</span>, *t) <span class="comment">// t 是 *bool 类型</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">int</span>:</span><br><span class="line">	fmt.Printf(<span class="string">&quot;pointer to integer %d\n&quot;</span>, *t) <span class="comment">// t 是 *int 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="多返回值-Multiple-return-values"><a href="#多返回值-Multiple-return-values" class="headerlink" title="多返回值 (Multiple return values)"></a>多返回值 (<a href="https://go.dev/doc/effective_go#multiple-returns">Multiple return values</a>)</h2><p>Go与众不同的特性之一就是函数和方法可返回多个值。这种形式可以改善C中一些笨拙的习惯： 将错误值返回（例如用 <code>-1</code> 表示 <code>EOF</code>）和修改通过地址传入的实参。</p>
<p>在C中，写入操作发生的错误会用一个负数标记，而错误码会隐藏在某个不确定的位置。 而在Go中，<code>Write</code> 会返回写入的字节数<strong>以及</strong>一个错误： “是的，您写入了一些字节，但并未全部写入，因为设备已满”。 在 <code>os</code> 包中，<code>File.Write</code> 的签名为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>正如文档所述，它返回写入的字节数，并在<code>n != len(b)</code> 时返回一个非 <code>nil</code> 的 <code>error</code> 错误值。 这是一种常见的编码风格，更多示例见错误处理一节。</p>
<p>我们可以采用一种简单的方法。来避免为模拟引用参数而传入指针。 以下简单的函数可从字节数组中的特定位置获取其值，并返回该数值和下一个位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextInt</span><span class="params">(b []<span class="type">byte</span>, i <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(b) &amp;&amp; !isDigit(b[i]); i++ &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	x := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(b) &amp;&amp; isDigit(b[i]); i++ &#123;</span><br><span class="line">		x = x*<span class="number">10</span> + <span class="type">int</span>(b[i]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x, i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以像下面这样，通过它扫描输入的切片 <code>b</code> 来获取数字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); &#123;</span><br><span class="line">	x, i = nextInt(b, i)</span><br><span class="line">	fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可命名结果形参-Named-result-parameters"><a href="#可命名结果形参-Named-result-parameters" class="headerlink" title="可命名结果形参 (Named result parameters)"></a>可命名结果形参 (<a href="https://go.dev/doc/effective_go#named-results">Named result parameters</a>)</h2><p>Go函数的返回值或结果“形参”可被命名，并作为常规变量使用，就像传入的形参一样。 命名后，一旦该函数开始执行，它们就会被初始化为与其类型相应的零值； 若该函数执行了一条不带实参的 <code>return</code> 语句，则结果形参的当前值将被返回。</p>
<p>此名称不是强制性的，但它们能使代码更加简短清晰：它们就是文档。若我们命名了 <code>nextInt</code> 的结果，那么它返回的 <code>int</code> 就值如其意了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextInt</span><span class="params">(b []<span class="type">byte</span>, pos <span class="type">int</span>)</span></span> (value, nextPos <span class="type">int</span>) &#123;</span><br></pre></td></tr></table></figure>

<p>由于被命名的结果已经初始化，且已经关联至无参数的返回，它们就能让代码简单而清晰。 下面的 <code>io.ReadFull</code> 就是个很好的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="type">byte</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(buf) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nr <span class="type">int</span></span><br><span class="line">		nr, err = r.Read(buf)</span><br><span class="line">		n += nr</span><br><span class="line">		buf = buf[nr:]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a><a href="https://go.dev/doc/effective_go#defer">Defer</a></h2><p>Go的 <code>defer</code> 语句用于预设一个函数调用（即<strong>推迟执行</strong>函数）， 该函数会在执行 <code>defer</code> 的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是解锁互斥和关闭文件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Contents 将文件的内容作为字符串返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contents</span><span class="params">(filename <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	f, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()  <span class="comment">// f.Close 会在我们结束后运行。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result []<span class="type">byte</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := f.Read(buf[<span class="number">0</span>:])</span><br><span class="line">		result = <span class="built_in">append</span>(result, buf[<span class="number">0</span>:n]...) <span class="comment">// append 将在后面讨论。</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err  <span class="comment">// 我们在这里返回后，f 就会被关闭。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(result), <span class="literal">nil</span> <span class="comment">// 我们在这里返回后，f 就会被关闭。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推迟诸如 <code>Close</code> 之类的函数调用有两点好处：第一， 它能确保你不会忘记关闭文件。如果你以后又为该函数添加了新的返回路径时， 这种情况往往就会发生。第二，它意味着“关闭”离“打开”很近， 这总比将它放在函数结尾处要清晰明了。</p>
<p>被推迟函数的实参（如果该函数为方法则还包括接收者）在<strong>推迟</strong>执行时就会求值， 而不是在<strong>调用</strong>执行时才求值。这样不仅无需担心变量值在函数执行时被改变， 同时还意味着单个已推迟的调用可推迟多个函数的执行。下面是个简单的例子。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被推迟的函数按照后进先出（LIFO）的顺序执行，因此以上代码在函数返回时会打印 <code>4 3 2 1 0</code>。一个更具实际意义的例子是通过一种简单的方法， 用程序来跟踪函数的执行。我们可以编写一对简单的跟踪例程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="type">string</span>)</span></span>   &#123; fmt.Println(<span class="string">&quot;entering:&quot;</span>, s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">untrace</span><span class="params">(s <span class="type">string</span>)</span></span> &#123; fmt.Println(<span class="string">&quot;leaving:&quot;</span>, s) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像这样使用它们：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	trace(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> untrace(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	<span class="comment">// 做一些事情....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以充分利用这个特点，即被推迟函数的实参在 <code>defer</code> 执行时才会被求值。 跟踪例程可针对反跟踪例程设置实参。以下例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;entering:&quot;</span>, s)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;leaving:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> un(trace(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;in a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> un(trace(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;in b&quot;</span>)</span><br><span class="line">	a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会打印</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">entering: b</span><br><span class="line">in b</span><br><span class="line">entering: a</span><br><span class="line">in a</span><br><span class="line">leaving: a</span><br><span class="line">leaving: b</span><br></pre></td></tr></table></figure>

<p>对于习惯其它语言中块级资源管理的程序员，<code>defer</code> 似乎有点怪异， 但它最有趣而强大的应用恰恰来自于其基于函数而非块的特点。在 <code>panic</code> 和 <code>recover</code> 这两节中，我们将看到关于它可能性的其它例子。</p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="零值-The-zero-value"><a href="#零值-The-zero-value" class="headerlink" title="零值 (The zero value)"></a>零值 (<a href="https://go.dev/ref/spec#The_zero_value">The zero value</a>)</h2><p>When storage is allocated for a <a href="https://go.dev/ref/spec#Variables">variable</a>, either through a declaration or a call of <code>new</code>, or when a new value is created, either through a composite literal or a call of <code>make</code>, and no explicit initialization is provided, the variable or value is given a default value. Each element of such a variable or value is set to the <em>zero value</em> for its type: <code>false</code> for booleans, <code>0</code> for numeric types, <code>&quot;&quot;</code> for strings, and <code>nil</code> for pointers, functions, interfaces, slices, channels, and maps. This initialization is done recursively, so for instance each element of an array of structs will have its fields zeroed if no value is specified.</p>
<p>当通过声明或 new 调用为变量分配存储空间时，或通过复合文字或 make 调用创建新值时，且未提供显式初始化，则变量或值会被给定一个默认值。变量或值的每个元素都被设置为其类型的零值：对于布尔值，其零值是<code>false</code>；对于数值类型，其零值是<code>0</code>；对于字符串，其零值是<code>&quot;&quot;</code>；对于指针、函数、接口、切片、信道 (channels)和映射，其零值是<code>nil</code>。初始化操作是递归完成的。例如，如果没有指定，则结构体数组的每个元素都被置为其字段的零值。</p>
<p>以下两种声明是等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>例如，下面<code>i1</code>虽然声明时未赋值，但自动被赋零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i1 <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i2 <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">fmt.Println(i1 == i2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>又或者下面这个结构体T，通过调用<code>new</code>声明变量t：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123; i <span class="type">int</span>; f <span class="type">float64</span>; next *T &#125;</span><br><span class="line">t := <span class="built_in">new</span>(T)</span><br></pre></td></tr></table></figure>

<p>这个结构体变量<code>t</code>的成员字段零值如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.i == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">t.f == <span class="number">0.0</span> <span class="comment">// true</span></span><br><span class="line">t.next == <span class="literal">nil</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>直接声明结构体T的变量<code>t</code>也是同样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">fmt.Println(t.i == <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">fmt.Println(t.f == <span class="number">0.0</span>) <span class="comment">// true</span></span><br><span class="line">fmt.Println(t.next == <span class="literal">nil</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="new-分配"><a href="#new-分配" class="headerlink" title="new 分配"></a><code>new</code> 分配</h2><p> <code>new</code>是个用来分配内存的内建函数， 但与其它语言中的同名函数不同，它不会<strong>初始化</strong>内存，只会将内存<strong>置零</strong>。 也就是说，<code>new(T)</code> 会为类型为 <code>T</code> 的新项分配已置零的内存空间， 并返回它的地址，也就是一个类型为 <code>*T</code> 的值。用Go的术语来说，它返回一个指针， 该指针指向新分配的，类型为 <code>T</code> 的零值。</p>
<p>Since the memory returned by <code>new</code> is zeroed, it’s helpful to arrange when designing your data structures that the zero value of each type can be used without further initialization. This means a user of the data structure can create one with <code>new</code> and get right to work. For example, the documentation for <code>bytes.Buffer</code> states that “the zero value for <code>Buffer</code> is an empty buffer ready to use.” Similarly, <code>sync.Mutex</code> does not have an explicit constructor or <code>Init</code> method. Instead, the zero value for a <code>sync.Mutex</code> is defined to be an unlocked mutex.</p>
<p>既然 <code>new</code> 返回的内存已置零，那么每种类型的零值不必进一步初始化就可以使用了。这在设计数据结构时是非常有用的。这意味着该数据结构的使用者只需用 <code>new</code> 创建一个新的对象就能正常工作。例如，<code>bytes.Buffer</code> 的文档中提到“零值的 <code>Buffer</code> 就是已准备就绪的缓冲区。” 同样，<code>sync.Mutex</code> 并没有显式的构造函数或 <code>Init</code> 方法， 而是零值的 <code>sync.Mutex</code> 就已经被定义为已解锁的互斥锁了。</p>
<p>The zero-value-is-useful property works transitively. Consider this type declaration.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncedBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock    sync.Mutex</span><br><span class="line">	buffer  bytes.Buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Values of type <code>SyncedBuffer</code> are also ready to use immediately upon allocation or just declaration. In the next snippet, both <code>p</code> and <code>v</code> will work correctly without further arrangement.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(SyncedBuffer)  <span class="comment">// type *SyncedBuffer</span></span><br><span class="line"><span class="keyword">var</span> v SyncedBuffer      <span class="comment">// type  SyncedBuffer</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数与复合字面量-Constructors-and-composite-literals"><a href="#构造函数与复合字面量-Constructors-and-composite-literals" class="headerlink" title="构造函数与复合字面量 (Constructors and composite literals)"></a>构造函数与复合字面量 (<a href="https://go.dev/doc/effective_go#constructors_and_composite_literals">Constructors and composite literals</a>)</h2><p>有时零值还不够好，这时就需要一个初始化构造函数，如来自 <code>os</code> 包中的这段代码所示。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="type">int</span>, name <span class="type">string</span>)</span></span> *File &#123;</span><br><span class="line">	<span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	f := <span class="built_in">new</span>(File)</span><br><span class="line">	f.fd = fd</span><br><span class="line">	f.name = name</span><br><span class="line">	f.dirinfo = <span class="literal">nil</span></span><br><span class="line">	f.nepipe = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里显得代码过于冗长。我们可通过<strong>复合字面量</strong>来简化它， 该表达式在每次求值时都会创建新的实例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="type">int</span>, name <span class="type">string</span>)</span></span> *File &#123;</span><br><span class="line">	<span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当获取一个复合字面的地址时，都将为一个新的实例分配内存， 因此我们可以将上面的最后两行代码合并：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>复合字面的字段必须按顺序全部列出。但如果以 <strong>字段</strong><code>:</code><strong>值</strong> 对的形式明确地标出元素，初始化字段时就可以按任何顺序出现，未给出的字段值将赋予零值。 因此，我们可以用如下形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;File&#123;fd: fd, name: name&#125;</span><br></pre></td></tr></table></figure>

<p>As a limiting case, if a composite literal contains no fields at all, it creates a zero value for the type. The expressions <code>new(File)</code> and <code>&amp;File&#123;&#125;</code> are equivalent.</p>
<p>作为一种极端情况，若复合字面不包括任何字段，它将创建该类型的零值。表达式 <code>new(File)</code> 和 <code>&amp;File&#123;&#125;</code> 是等价的。</p>
<h2 id="make-分配"><a href="#make-分配" class="headerlink" title="make 分配"></a><code>make</code> 分配</h2><p>内建函数 <code>make(T, args)</code> 的目的不同于 <code>new(T)</code>。它只用于创建切片、映射和信道 (Channel)，并返回类型为 <code>T</code>（而非 <code>*T</code>）的一个<strong>已初始化</strong> （而非<strong>置零</strong>）的值。出现这种用差异的原因在于，这三种类型本质上为引用数据类型，它们在使用前必须初始化。 例如，切片是一个具有三项内容的描述符，包含一个指向（数组内部）数据的指针、长度以及容量， 在这三项被初始化之前，该切片为 <code>nil</code>。对于切片、映射和信道，<code>make</code> 用于初始化其内部的数据结构并准备好将要使用的值。例如，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>会分配一个具有100个 <code>int</code> 的数组空间，接着创建一个长度为10， 容量为100并指向该数组中前10个元素的切片结构。（生成切片时，其容量可以省略，更多信息见切片一节。） 与此相反，<code>new([]int)</code> 会返回一个指向新分配的，已置零的切片结构， 即一个指向 <code>nil</code> 切片值的指针。</p>
<p>下面的例子阐明了 <code>new</code> 和 <code>make</code> 之间的区别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *[]<span class="type">int</span> = <span class="built_in">new</span>([]<span class="type">int</span>)       <span class="comment">// 分配切片结构；*p == nil；几乎没什么用</span></span><br><span class="line"><span class="keyword">var</span> v  []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">100</span>) <span class="comment">// 切片 v 现在引用了一个具有 100 个 int 元素的新数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没必要的复杂：</span></span><br><span class="line"><span class="keyword">var</span> p *[]<span class="type">int</span> = <span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line">*p = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 习惯用法：</span></span><br><span class="line">v := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>请记住，<code>make</code> 只适用于映射、切片和信道且不返回指针。若要获得明确的指针， 请使用 <code>new</code> 分配内存。</p>
<h2 id="new和make的区别"><a href="#new和make的区别" class="headerlink" title="new和make的区别"></a>new和make的区别</h2><p><code>new</code> 的特点：</p>
<ul>
<li>分配内存空间</li>
<li>对变量和值置零值</li>
<li>返回指针</li>
<li><code>new(Type)</code> 等价于 <code>&amp;File&#123;Type&#125;</code></li>
</ul>
<p><code>make</code> 的特点：</p>
<ul>
<li>只用于创建切片、映射和信道 (Channel)</li>
<li>对变量和值初始化</li>
<li>返回值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line">fmt.Println(a)        <span class="comment">// []</span></span><br><span class="line">fmt.Println(a == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">b := <span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line">fmt.Println(b)         <span class="comment">// &amp;[]</span></span><br><span class="line">fmt.Println(b == <span class="literal">nil</span>)  <span class="comment">// false</span></span><br><span class="line">fmt.Println(*b == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(c)        <span class="comment">// [0 0 0]</span></span><br><span class="line">fmt.Println(c == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %T %T&quot;</span>, a, b, c) <span class="comment">// []int *[]int []int</span></span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p>
<p>表达式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>会将变量 <code>a</code> 声明为拥有 10 个整数的数组。</p>
<p>这是一个数组字面量 (literal)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>]<span class="type">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在详细规划内存布局时，数组是非常有用的，有时还能避免过多的内存分配， 但它们主要用作切片的构件。</p>
<p>以下为数组在Go和C中的主要区别。在Go中，</p>
<ul>
<li>数组是值。将一个数组赋予另一个数组会复制其所有元素。</li>
<li>特别地，若将某个数组传入某个函数，它将接收到该数组的一份<strong>副本</strong>而非指针。</li>
<li>数组的大小是其类型的一部分，因此数组不能改变大小。类型 <code>[10]int</code> 和 <code>[20]int</code> 是不同的。</li>
</ul>
<p>The value property can be useful but also expensive; if you want C-like behavior and efficiency, you can pass a pointer to the array.</p>
<p>数组为值的属性很有用，但代价高昂；若你想要C那样的行为和效率，你可以传递一个指向该数组的指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a *[3]<span class="type">float64</span>)</span></span> (sum <span class="type">float64</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> *a &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array := [...]<span class="type">float64</span>&#123;<span class="number">7.0</span>, <span class="number">8.5</span>, <span class="number">9.1</span>&#125;</span><br><span class="line">x := Sum(&amp;array)  <span class="comment">// 注意显式的取址操作</span></span><br></pre></td></tr></table></figure>

<p>但这并不是Go的习惯用法。使用切片，而不是数组。</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>每个数组的大小都是固定的。切片通过对数组进行封装，为数据序列提供了更通用、强大而方便的接口。 除了矩阵变换这类需要明确维度的情况外，Go中的大部分数组编程都是通过切片来完成的。</p>
<p>类型 <code>[]T</code> 表示一个元素类型为 <code>T</code> 的切片。</p>
<p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[low : high]</span><br></pre></td></tr></table></figure>

<p>它会选择一个半开区间，包括第一个元素，但排除最后一个元素。</p>
<p>以下表达式创建了一个切片，它包含 <code>a</code> 中下标从 1 到 3 的元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>切片保存了对底层数组的引用，若你将某个切片赋予另一个切片，它们会引用同一个数组。 更改切片的元素会修改其底层数组中对应的元素。与它共享底层数组的切片都会观测到这些修改。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">names := [<span class="number">4</span>]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Paul&quot;</span>,</span><br><span class="line">    <span class="string">&quot;George&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Ringo&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(names) <span class="comment">// [John Paul George Ringo]</span></span><br><span class="line"></span><br><span class="line">a := names[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">b := names[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(a, b) <span class="comment">// [John Paul] [Paul George]</span></span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = <span class="string">&quot;XXX&quot;</span></span><br><span class="line">fmt.Println(a, b) <span class="comment">// [John XXX] [XXX George]</span></span><br><span class="line">fmt.Println(names) <span class="comment">// [John XXX George Ringo]</span></span><br></pre></td></tr></table></figure>

<h3 id="切片的零值"><a href="#切片的零值" class="headerlink" title="切片的零值"></a>切片的零值</h3><p>切片的零值是 <code>nil</code>。<code>nil</code> 切片的长度和容量为 0 且没有底层数组。</p>
<h3 id="切片字面量-Slice-Literals"><a href="#切片字面量-Slice-Literals" class="headerlink" title="切片字面量 (Slice Literals)"></a>切片字面量 (Slice Literals)</h3><p>切片字面量类似于没有长度的数组文法。下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[]<span class="type">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用-make-创建切片"><a href="#用-make-创建切片" class="headerlink" title="用 make 创建切片"></a>用 make 创建切片</h3><p>切片可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p>
<p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)  <span class="comment">// len(a)=5</span></span><br></pre></td></tr></table></figure>

<p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line"></span><br><span class="line">b = b[:<span class="built_in">cap</span>(b)] <span class="comment">// len(b)=5, cap(b)=5</span></span><br><span class="line">b = b[<span class="number">1</span>:]      <span class="comment">// len(b)=4, cap(b)=4</span></span><br></pre></td></tr></table></figure>

<h3 id="切片的默认上下界"><a href="#切片的默认上下界" class="headerlink" title="切片的默认上下界"></a>切片的默认上下界</h3><p>切片下界的默认值为 <code>0</code>，上界则是该切片的长度。</p>
<p>对于数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>来说，以下切片是等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">a[:<span class="number">10</span>]</span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line">a[:]</span><br></pre></td></tr></table></figure>

<h3 id="切片作为函数参数"><a href="#切片作为函数参数" class="headerlink" title="切片作为函数参数"></a>切片作为函数参数</h3><p>若某个函数将一个切片作为参数传入，则它对该切片元素的修改对调用者而言同样可见， 这可以理解为传递了底层数组的指针。因此，<code>Read</code> 函数可接受一个切片实参 而非一个指针和一个计数；切片的长度决定了可读取数据的上限。以下为 <code>os</code> 包中 <code>File</code> 类型的 <code>Read</code> 方法签名:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span></span> Read(buf []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>该方法返回读取的字节数和一个错误值（若有的话）。若要从更大的缓冲区 <code>buf</code> 中读取前32个字节，只需对其进行<strong>切片</strong>即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n, err := f.Read(buf[<span class="number">0</span>:<span class="number">32</span>])</span><br></pre></td></tr></table></figure>

<p>这种切片的方法常用且高效。</p>
<h3 id="切片的长度与容量"><a href="#切片的长度与容量" class="headerlink" title="切片的长度与容量"></a>切片的长度与容量</h3><p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。切片的<strong>长度</strong>就是它所包含的元素个数。切片的<strong>容量</strong>是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p>
<p>切片 <code>s</code> 的长度和容量可通过内建函数 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</p>
<p>你可以通过重新切片来扩展一个切片，给它提供足够的容量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s) <span class="comment">// len=6 cap=6 [2 3 5 7 11 13]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取切片使其长度为 0</span></span><br><span class="line">s = s[:<span class="number">0</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s) <span class="comment">// len=0 cap=6 []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展其长度</span></span><br><span class="line">s = s[:<span class="number">4</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s) <span class="comment">// len=4 cap=6 [2 3 5 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 舍弃前两个值</span></span><br><span class="line">s = s[<span class="number">2</span>:]</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s) <span class="comment">// len=2 cap=4 [5 7]</span></span><br></pre></td></tr></table></figure>

<p>只要切片不超出底层数组的限制，它的长度就是可变的，只需将它赋给其自身的切片即可。  以下是将数据追加到切片的函数。若数据超出其容量，则会重新分配该切片。返回值即为所得的切片。 该函数中所使用的 <code>len</code> 和 <code>cap</code> 在应用于 <code>nil</code> 切片时是合法的，它会返回0.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Append</span><span class="params">(slice, data []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	l := <span class="built_in">len</span>(slice)</span><br><span class="line">	<span class="keyword">if</span> l + <span class="built_in">len</span>(data) &gt; <span class="built_in">cap</span>(slice) &#123;  <span class="comment">// 重新分配</span></span><br><span class="line">		<span class="comment">// 为了未来的增长，分配双倍。</span></span><br><span class="line">		newSlice := <span class="built_in">make</span>([]<span class="type">byte</span>, (l+<span class="built_in">len</span>(data))*<span class="number">2</span>)</span><br><span class="line">		<span class="comment">// copy 函数是预声明的，且可用于任何切片类型。</span></span><br><span class="line">		<span class="built_in">copy</span>(newSlice, slice)</span><br><span class="line">		slice = newSlice</span><br><span class="line">	&#125;</span><br><span class="line">	slice = slice[<span class="number">0</span>:l+<span class="built_in">len</span>(data)]</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> data &#123;</span><br><span class="line">		slice[l+i] = c</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终我们必须返回切片，因为尽管 <code>Append</code> 可修改 <code>slice</code> 的元素，但切片自身（其运行时数据结构包含指针、长度和容量）是通过值传递的。</p>
<p>为切片追加新的元素是种常用的操作，因此有专门的内建函数 <code>append</code>：</p>
<ul>
<li><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该切片的末尾。</li>
<li><code>append</code> 的结果是一个包含原切片所有元素加上新添加元素的切片。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(s []T, vs ...T)</span></span> []T</span><br></pre></td></tr></table></figure>

<p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</p>
<h2 id="二维切片"><a href="#二维切片" class="headerlink" title="二维切片"></a>二维切片</h2><p>Go的数组和切片都是一维的。要创建等价的二维数组或切片，就必须定义一个数组的数组， 或切片的切片，就像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Transform [<span class="number">3</span>][<span class="number">3</span>]<span class="type">float64</span>  <span class="comment">// 一个 3x3 的数组，其实是包含多个数组的一个数组。</span></span><br><span class="line"><span class="keyword">type</span> LinesOfText [][]<span class="type">byte</span>     <span class="comment">// 包含多个字节切片的一个切片。</span></span><br></pre></td></tr></table></figure>

<p>由于切片长度是可变的，因此其内部可能拥有多个不同长度的切片。在我们的 <code>LinesOfText</code> 例子中，这是种常见的情况：每行都有其自己的长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">text := LinesOfText&#123;</span><br><span class="line">	[]<span class="type">byte</span>(<span class="string">&quot;Now is the time&quot;</span>),</span><br><span class="line">	[]<span class="type">byte</span>(<span class="string">&quot;for all good gophers&quot;</span>),</span><br><span class="line">	[]<span class="type">byte</span>(<span class="string">&quot;to bring some fun to the party.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时必须分配一个二维数组，例如在处理像素的扫描行时，这种情况就会发生。 我们有两种方式来达到这个目的。一种就是独立地分配每一个切片；而另一种就是只分配一个数组， 将各个切片都指向它。采用哪种方式取决于你的应用。若切片会增长或收缩， 就应该通过独立分配来避免覆盖下一行；若不会，用单次分配来构造对象会更加高效。 以下是这两种方法的大概代码，仅供参考。首先是一次一行的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配顶层切片。</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="type">uint8</span>, YSize) <span class="comment">// 每 y 个单元一行。</span></span><br><span class="line"><span class="comment">// 遍历行，为每一行都分配切片</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">	picture[i] = <span class="built_in">make</span>([]<span class="type">uint8</span>, XSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在是一次分配，对行进行切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配顶层切片，和前面一样。</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="type">uint8</span>, YSize) <span class="comment">// 每 y 个单元一行。</span></span><br><span class="line"><span class="comment">// 分配一个大的切片来保存所有像素</span></span><br><span class="line">pixels := <span class="built_in">make</span>([]<span class="type">uint8</span>, XSize*YSize) <span class="comment">// 拥有类型 []uint8，尽管图片是 [][]uint8.</span></span><br><span class="line"><span class="comment">// 遍历行，从剩余像素切片的前面切出每行来。</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">	picture[i], pixels = pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射是方便而强大的内建数据结构，它可以关联不同类型的值。其键可以是任何相等性操作符支持的类型， 如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构以及数组。 切片不能用作映射键，因为它们的相等性是未定义。与切片一样，映射也是引用类型。 若将映射传入函数中，并更改了该映射的内容，则此修改对调用者同样可见。</p>
<p>映射的零值为 <code>nil</code> 。<code>nil</code> 映射既没有键，也不能添加键。</p>
<p><code>make</code> 函数可以返回给定类型的映射，并将其初始化。</p>
<p>映射可使用一般的复合字面语法进行构建，其键-值对使用逗号分隔，因此可在初始化时很容易构建它们。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeZone = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">	<span class="string">&quot;UTC&quot;</span>:  <span class="number">0</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">&quot;EST&quot;</span>: <span class="number">-5</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">&quot;CST&quot;</span>: <span class="number">-6</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">&quot;MST&quot;</span>: <span class="number">-7</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">&quot;PST&quot;</span>: <span class="number">-8</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>赋值和获取映射值的语法类似于数组，不同的是映射的索引不必为整数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">offset := timeZone[<span class="string">&quot;EST&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>若试图通过映射中不存在的键来取值，就会返回与该映射中项的类型对应的零值。 例如，若某个映射包含整数，当查找一个不存在的键时会返回 <code>0</code>。 </p>
<p>可以通过一个值类型为 <code>bool</code> 的映射来实现<strong>集合</strong>。将该映射中的项置为 <code>true</code> 可将该值放入集合中，此后通过简单的索引操作即可判断是否存在。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">attended := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>&#123;</span><br><span class="line">	<span class="string">&quot;Ann&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="string">&quot;Joe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> attended[person] &#123; <span class="comment">// 若某人不在此映射中，则为 false</span></span><br><span class="line">	fmt.Println(person, <span class="string">&quot;正在开会&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时你需要区分某项是不存在还是其值为零值。如对于一个值本应为零的 <code>&quot;UTC&quot;</code> 条目，也可能是由于不存在该项而得到零值。你可以使用多重赋值的形式来分辨这种情况。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> seconds <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">seconds, ok = timeZone[tz]</span><br></pre></td></tr></table></figure>

<p>显然，我们可称之为“逗号 ok”惯用法。在下面的例子中，若 <code>tz</code> 存在， <code>seconds</code> 就会被赋予适当的值，且 <code>ok</code> 会被置为 <code>true</code>； 若不存在，<code>seconds</code> 则会被置为零，而 <code>ok</code> 会被置为 <code>false</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">offset</span><span class="params">(tz <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> seconds, ok := timeZone[tz]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> seconds</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">&quot;unknown time zone:&quot;</span>, tz)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若仅需判断映射中是否存在某项而不关心实际的值，可使用<a href="https://go-zh.org/doc/effective_go.html#%E7%A9%BA%E7%99%BD">空白标识符</a> （<code>_</code>）来代替该值的一般变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, present := timeZone[tz]</span><br></pre></td></tr></table></figure>

<p>要删除映射中的某项，可使用内建函数 <code>delete</code>，它以映射及要被删除的键为实参。 即便对应的键不在该映射中，此操作也是安全的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(timeZone, <span class="string">&quot;PDT&quot;</span>)  <span class="comment">// 现在用标准时间</span></span><br></pre></td></tr></table></figure>

<p>映射的值可以是结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line">	<span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;</span><br><span class="line">		<span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;Google&quot;</span>: Vertex&#123;</span><br><span class="line">		<span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若顶级类型只是一个类型名，你可以在字面量的元素中省略它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line">	<span class="string">&quot;Bell Labs&quot;</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">	<span class="string">&quot;Google&quot;</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p>Go采用的格式化打印风格和C的 <code>printf</code> 族类似，但却更加丰富而通用。 这些函数位于 <code>fmt</code> 包中，且函数名首字母均为大写：如 <code>fmt.Printf</code>、<code>fmt.Fprintf</code>，<code>fmt.Sprintf</code> 等。 字符串函数（<code>Sprintf</code> 等）会返回一个字符串，而非填充给定的缓冲区。</p>
<p>你无需提供一个格式字符串。每个 <code>Printf</code>、<code>Fprintf</code> 和 <code>Sprintf</code> 都分别对应另外的函数，如 <code>Print</code> 与 <code>Println</code>。 这些函数并不接受格式字符串，而是为每个实参生成一种默认格式。<code>Println</code> 系列的函数还会在实参中插入空格，并在输出时追加一个换行符，而 <code>Print</code> 版本仅在操作数两侧都没有字符串时才添加空白。以下示例中各行产生的输出都是一样的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;Hello %d\n&quot;</span>, <span class="number">23</span>)</span><br><span class="line">fmt.Fprint(os.Stdout, <span class="string">&quot;Hello &quot;</span>, <span class="number">23</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello&quot;</span>, <span class="number">23</span>)</span><br><span class="line">fmt.Println(fmt.Sprint(<span class="string">&quot;Hello &quot;</span>, <span class="number">23</span>))</span><br></pre></td></tr></table></figure>

<p><code>fmt.Fprint</code> 一类的格式化打印函数可接受任何实现了 <code>io.Writer</code> 接口的对象作为第一个实参；变量<code>os.Stdout</code> 与 <code>os.Stderr</code> 都是人们熟知的例子。</p>
<p>从这里开始，就与C有些不同了。首先，像 <code>%d</code> 这样的数值格式并不接受表示符号或大小的标记， 打印例程会根据实参的类型来决定这些属性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">uint64</span> = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %x; %d %x\n&quot;</span>, x, x, <span class="type">int64</span>(x), <span class="type">int64</span>(x))</span><br></pre></td></tr></table></figure>

<p>将打印</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">18446744073709551615</span> ffffffffffffffff; <span class="number">-1</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>若你只想要默认的转换，如使用十进制的整数，你可以使用通用的格式 <code>%v</code>（对应“值”）；其结果与 <code>Print</code> 和 <code>Println</code> 的输出完全相同。此外，这种格式还能打印<strong>任意</strong>值，甚至包括数组、结构体和映射。 以下是打印上一节中定义的时区映射的语句。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, timeZone)  <span class="comment">// 或只用 fmt.Println(timeZone)</span></span><br></pre></td></tr></table></figure>

<p>这会输出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[CST:<span class="number">-21600</span> PST:<span class="number">-28800</span> EST:<span class="number">-18000</span> UTC:<span class="number">0</span> MST:<span class="number">-25200</span>]</span><br></pre></td></tr></table></figure>

<p>当然，映射中的键可能按任意顺序输出。当打印结构体时，改进的格式 <code>%+v</code> 会为结构体的每个字段添上字段名，而另一种格式 <code>%#v</code> 将完全按照Go的语法打印值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">	b <span class="type">float64</span></span><br><span class="line">	c <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">t := &amp;T&#123; <span class="number">7</span>, <span class="number">-2.35</span>, <span class="string">&quot;abc\tdef&quot;</span> &#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, timeZone)</span><br></pre></td></tr></table></figure>

<p>将打印</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&amp;&#123;<span class="number">7</span> <span class="number">-2.35</span> abc   def&#125;</span><br><span class="line">&amp;&#123;a:<span class="number">7</span> b:<span class="number">-2.35</span> c:abc     def&#125;</span><br><span class="line">&amp;main.T&#123;a:<span class="number">7</span>, b:<span class="number">-2.35</span>, c:<span class="string">&quot;abc\tdef&quot;</span>&#125;</span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>] <span class="type">int</span>&#123;<span class="string">&quot;CST&quot;</span>:<span class="number">-21600</span>, <span class="string">&quot;PST&quot;</span>:<span class="number">-28800</span>, <span class="string">&quot;EST&quot;</span>:<span class="number">-18000</span>, <span class="string">&quot;UTC&quot;</span>:<span class="number">0</span>, <span class="string">&quot;MST&quot;</span>:<span class="number">-25200</span>&#125;</span><br></pre></td></tr></table></figure>

<p>（请注意其中的&amp;符号）当遇到 <code>string</code> 或 <code>[]byte</code> 值时， 可使用 <code>%q</code> 产生带引号的字符串；而格式 <code>%#q</code> 会尽可能使用反引号。 （<code>%q</code> 格式也可用于整数和符文，它会产生一个带单引号的符文常量。） 此外，<code>%x</code> 还可用于字符串、字节数组以及整数，并生成一个很长的十六进制字符串， 而带空格的格式（<code>% x</code>）还会在字节之间插入空格。</p>
<p>另一种实用的格式是 <code>%T</code>，它会打印某个值的<strong>类型</strong>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, timeZone)</span><br></pre></td></tr></table></figure>

<p>会打印</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="type">string</span>] <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>若你想控制自定义类型的默认格式，只需为该类型定义一个具有 <code>String() string</code> 签名的方法。对于我们简单的类型 <code>T</code>，可进行如下操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d/%g/%q&quot;</span>, t.a, t.b, t.c)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, t)</span><br></pre></td></tr></table></figure>

<p>会打印出如下格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>/<span class="number">-2.35</span>/<span class="string">&quot;abc\tdef&quot;</span></span><br></pre></td></tr></table></figure>

<p>（如果你需要像指向 <code>T</code> 的指针那样打印类型 <code>T</code> 的<strong>值</strong>， <code>String</code> 的接收者就必须是值类型的；上面的例子中接收者是一个指针， 因为这对结构来说更高效而通用。更多详情见<a href="https://go-zh.org/doc/effective_go.html#%E6%8C%87%E9%92%88vs%E5%80%BC">指针vs.值接收者</a>一节.）</p>
<p>我们的 <code>String</code> 方法也可调用 <code>Sprintf</code>， 因为打印例程可以完全重入并按这种方式封装。不过要理解这种方式，还有一个重要的细节： 请勿通过调用 <code>Sprintf</code> 来构造 <code>String</code> 方法，因为它会无限递归你的 <code>String</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyString)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;MyString=%s&quot;</span>, m) <span class="comment">// 错误：会无限递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要解决这个问题也很简单：将该实参转换为基本的字符串类型，它没有这个方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyString)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;MyString=%s&quot;</span>, <span class="type">string</span>(m)) <span class="comment">// 可以：注意转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<a href="https://go-zh.org/doc/effective_go.html#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>一节中，我们将看到避免这种递归的另一种技术。</p>
<p>另一种打印技术就是将打印例程的实参直接传入另一个这样的例程。<code>Printf</code> 的签名为其最后的实参使用了 <code>...interface&#123;&#125;</code> 类型，这样格式的后面就能出现任意数量，任意类型的形参了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br></pre></td></tr></table></figure>

<p>在 <code>Printf</code> 函数中，<code>v</code> 看起来更像是 <code>[]interface&#123;&#125;</code> 类型的变量，但如果将它传递到另一个变参函数中，它就像是常规实参列表了。 以下是我们之前用过的 <code>log.Println</code> 的实现。它直接将其实参传递给 <code>fmt.Sprintln</code> 进行实际的格式化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Println 通过 fmt.Println 的方式将日志打印到标准记录器。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	std.Output(<span class="number">2</span>, fmt.Sprintln(v...))  <span class="comment">// Output 接受形参 (int, string)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该 <code>Sprintln</code> 嵌套调用中，我们将 <code>...</code> 写在 <code>v</code> 之后来告诉编译器将 <code>v</code> 视作一个实参列表，否则它会将 <code>v</code> 当做单一的切片实参来传递。</p>
<p>还有很多关于打印知识点没有提及。详情请参阅 <code>godoc</code> 对 <code>fmt</code> 包的说明文档。</p>
<p>顺便一提，<code>...</code> 形参可指定具体的类型，例如从整数列表中选出最小值的函数 <code>min</code>，其形参可为 <code>...int</code> 类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Min</span><span class="params">(a ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	min := <span class="type">int</span>(^<span class="type">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>)  <span class="comment">// 最大的 int</span></span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="keyword">if</span> i &lt; min &#123;</span><br><span class="line">			min = i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h2><p>现在我们要对内建函数 <code>append</code> 的设计进行补充说明。大致来说,<code>append</code> 函数的签名像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []T, 元素 ...T)</span></span> []T</span><br></pre></td></tr></table></figure>

<p>其中的 <em>T</em> 为任意给定类型的占位符。实际上，你无法在Go中编写一个类型 <code>T</code> 由调用者决定的函数。这也就是为何 <code>append</code> 为内建函数的原因：它需要编译器的支持。</p>
<p><code>append</code> 会在切片末尾追加元素并返回结果。我们必须返回结果， 原因与我们手写的 <code>Append</code> 一样，即底层数组可能会被改变。以下简单的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>

<p>将打印 <code>[1 2 3 4 5 6]</code>。因此 <code>append</code> 有点像 <code>Printf</code> 那样，可接受任意数量的实参。</p>
<p>但如果我们要像 <code>Append</code> 那样将一个切片追加到另一个切片中呢？ 很简单：在调用的地方使用 <code>...</code>，就像我们在上面调用 <code>Output</code> 那样。以下代码片段的输出与上一个相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">y := []<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, y...)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>

<p>如果没有 <code>...</code>，它就会由于类型错误而无法编译，因为 <code>y</code> 不是 <code>int</code> 类型的。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>尽管从表面上看，Go 的初始化过程与 C 或 C++ 并没有太大不同，但它确实更为强大。 在初始化过程中，不仅可以构建复杂的结构，还能正确处理不同包对象间的初始化顺序。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>Go 中的常量就是不变量。它们在编译时创建，即便它们可能是函数中定义的局部变量。 常量只能是数字、字符（符文）、字符串或布尔值。由于编译时的限制， 定义它们的表达式必须也是可被编译器求值的常量表达式。例如 <code>1&lt;&lt;3</code> 就是一个常量表达式，而 <code>math.Sin(math.Pi/4)</code> 则不是，因为对 <code>math.Sin</code> 的函数调用在运行时才会发生。</p>
<p>在 Go 中，枚举常量使用枚举器 <code>iota</code> 创建。由于 <code>iota</code> 可为表达式的一部分，而表达式可以被隐式地重复，这样也就更容易构建复杂的值的集合了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteSize <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 通过赋予空白标识符来忽略第一个值</span></span><br><span class="line">    _           = <span class="literal">iota</span> <span class="comment">// ignore first value by assigning to blank identifier</span></span><br><span class="line">    KB ByteSize = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    MB</span><br><span class="line">    GB</span><br><span class="line">    TB</span><br><span class="line">    PB</span><br><span class="line">    EB</span><br><span class="line">    ZB</span><br><span class="line">    YB</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>由于可将 <code>String</code> 之类的方法附加在用户定义的类型上， 因此它就为打印时自动格式化任意值提供了可能性，即便是作为一个通用类型的一部分。 尽管你常常会看到这种技术应用于结构体，但它对于像 <code>ByteSize</code> 之类的浮点数标量等类型也是有用的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b ByteSize)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> b &gt;= YB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fYB&quot;</span>, b/YB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= ZB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fZB&quot;</span>, b/ZB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= EB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fEB&quot;</span>, b/EB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= PB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fPB&quot;</span>, b/PB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= TB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fTB&quot;</span>, b/TB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= GB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fGB&quot;</span>, b/GB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= MB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fMB&quot;</span>, b/MB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= KB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fKB&quot;</span>, b/KB)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fB&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表达式 <code>YB</code> 会打印出 <code>1.00YB</code>，而 <code>ByteSize(1e13)</code> 则会打印出 <code>9.09</code>。</p>
<p>在这里用 <code>Sprintf</code> 实现 <code>ByteSize</code> 的 <code>String</code> 方法很安全（不会无限递归），这倒不是因为类型转换，而是它以 <code>%f</code> 调用了 <code>Sprintf</code>，它并不是一种字符串格式：<code>Sprintf</code> 只会在它需要字符串时才调用 <code>String</code> 方法，而 <code>%f</code> 需要一个浮点数值。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量的初始化与常量类似，但其初始值也可以是在运行时才被计算的一般表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	home   = os.Getenv(<span class="string">&quot;HOME&quot;</span>)</span><br><span class="line">	user   = os.Getenv(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">	gopath = os.Getenv(<span class="string">&quot;GOPATH&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a><code>init</code> 函数</h2><p>最后，每个源文件都可以通过定义自己的无参数 <code>init</code> 函数来设置一些必要的状态。 （其实每个文件都可以拥有多个 <code>init</code> 函数。）而它的结束就意味着初始化结束： 只有该包中的所有变量声明都通过它们的初始化器求值后 <code>init</code> 才会被调用， 而那些 <code>init</code> 只有在所有已导入的包都被初始化后才会被求值。</p>
<p>除了那些不能被表示成声明的初始化外，<code>init</code> 函数还常被用在程序真正开始执行前，检验或校正程序的状态。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;$USER not set&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> home == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		home = <span class="string">&quot;/home/&quot;</span> + user</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gopath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		gopath = home + <span class="string">&quot;/go&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// gopath 可通过命令行中的 --gopath 标记覆盖掉。</span></span><br><span class="line">	flag.StringVar(&amp;gopath, <span class="string">&quot;gopath&quot;</span>, gopath, <span class="string">&quot;override default GOPATH&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="详解-Go-语言中的-init-函数"><a href="#详解-Go-语言中的-init-函数" class="headerlink" title="详解 Go 语言中的 init () 函数"></a><a href="https://learnku.com/go/t/47178">详解 Go 语言中的 init () 函数</a></h3><blockquote>
<p>原文作者：Summer<br>转自链接：<a href="https://learnku.com/go/t/47178">https://learnku.com/go/t/47178</a><br>原文地址：<a href="https://developpaper.com/detailed-explanation-of-init-function-in-go-language/">https://developpaper.com/detailed-explan...</a><br>译文地址：<a href="https://learnku.com/go/t/47178">https://learnku.com/go/t/47178</a><br>版权声明：著作权归作者所有。商业转载请联系作者获得授权，非商业转载请保留以上作者信息和原文链接。</p>
</blockquote>
<p>初始化每个包后，会自动执行 init（）函数，并且执行优先级高于主函数的执行优先级。init 函数通常用于：</p>
<ul>
<li>变量初始化</li>
<li>检查 &#x2F; 修复状态</li>
<li>注册器</li>
<li>运行计算</li>
</ul>
<p><strong>包初始化</strong></p>
<p>为了使用导入的程序包，必须首先对其进行初始化。初始化始终在单个线程中执行，并且以程序包依赖关系的顺序执行。这由 Golang 的运行时系统控制，如下图所示：</p>
<ul>
<li>初始化导入的包（递归导入）</li>
<li>计算并为块中声明的变量分配初始值</li>
<li>在包中执行初始化函数</li>
</ul>
<p><img src="/2022/from_A-Tour-of-Go_to_Effective-Go/ejLR69f443.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">var</span> _ <span class="type">int64</span>=s()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;init function ---&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">s</span><span class="params">()</span></span> <span class="type">int64</span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;function s() ---&gt;&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;main ---&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">function s() —&gt;</span><br><span class="line">init function —&gt;</span><br><span class="line">main —&gt;</span><br></pre></td></tr></table></figure>

<p>即使程序包被多次导入，初始化也只需要一次。</p>
<p><strong>特性</strong></p>
<p><code>init</code> 函数不需要传入参数，也不需要返回任何值。与 <code>main</code> 相比，<code>init</code> 没有声明，因此无法引用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  init()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译上述函数 <code>undefined：init</code> 时发生错误。</p>
<p>每个源文件可以包含一个以上的 <code>init</code> 函数，请记住，写在每个源文件中的 “行进方式” 只能包含一个 <code>init</code> 函数，这有点不同，因此进行下一个验证。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;init 1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;init2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行结果:</span></span><br><span class="line"><span class="comment">init1</span></span><br><span class="line"><span class="comment">init2</span></span><br><span class="line"><span class="comment">main </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从上面的示例中，您可以看到每个源文件可以包含多个 <code>init</code> 函数。</p>
<p>初始化函数的一个常见示例是设置初始表达式的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> precomputed=[<span class="number">20</span>]<span class="type">float64</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current <span class="type">float64</span>=<span class="number">1</span></span><br><span class="line">  precomputed[<span class="number">0</span>]=current</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(precomputed);i++&#123;</span><br><span class="line">    precomputed[i]=precomputed[i<span class="number">-1</span>]*<span class="number">1.2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为不可能在上面的代码 (这是一条语句) 中将 for 循环用作预先计算的值，所以可以使用 <code>init</code> 函数来解决此问题。</p>
<p><strong>Go 套件汇入规则的副作用</strong></p>
<p>Go 非常严格，不允许引用未使用的软件包。但是有时您引用包只是为了调用 <code>init</code> 函数进行一些初始化。空标识符 (即下划线) 的目的是解决此问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;image/png&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Go 没有类。不过你可以为结构体类型定义方法。</p>
<p>方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</p>
<p>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p>
<p>在此例中，<code>Abs</code> 方法拥有一个名为 <code>v</code>，类型为 <code>Vertex</code> 的接收者。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>方法即函数</strong></p>
<p>记住：方法只是个带接收者参数的函数。</p>
<p>现在这个 <code>Abs</code> 的写法就是个正常的函数，功能并没有什么变化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以为非结构体类型声明方法。</p>
<p>在此例中，我们看到了一个带 <code>Abs</code> 方法的数值类型 <code>MyFloat</code>。</p>
<p>你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 <code>int</code> 之类的内建类型）的接收者声明方法。</p>
<p>（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := MyFloat(-math.Sqrt2)</span><br><span class="line">	fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h2><p>你可以为指针接收者声明 <strong>方法</strong> 。</p>
<p>这意味着对于某类型 <code>T</code>，接收者的类型可以用 <code>*T</code> 的文法。（此外，<code>T</code> 不能是像 <code>*int</code> 这样的指针。）</p>
<p>例如，这里为 <code>*Vertex</code> 定义了 <code>Scale</code> 方法。</p>
<p><strong>指针接收者的方法可以修改接收者指向的值（就像 <code>Scale</code> 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。</strong></p>
<p>若使用值接收者，那么 <code>Scale</code> 方法会对原始 <code>Vertex</code> 值的副本进行操作。（对于函数的其它参数也是如此。）<code>Scale</code> 方法必须用指针接受者来更改 <code>main</code> 函数中声明的 <code>Vertex</code> 的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	v.Scale(<span class="number">10</span>)</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们要把 <code>Abs</code> 和 <code>Scale</code> 方法重写为函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span><span class="params">(v Vertex, f <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	Scale(v, <span class="number">10</span>)</span><br><span class="line">	fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h2><p>比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">ScaleFunc(v, <span class="number">5</span>)  <span class="comment">// 编译错误！</span></span><br><span class="line">ScaleFunc(&amp;v, <span class="number">5</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>而以指针为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">v.Scale(<span class="number">5</span>)  <span class="comment">// OK</span></span><br><span class="line">p := &amp;v</span><br><span class="line">p.Scale(<span class="number">10</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。 <strong>也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code>。</strong></p>
<p>同样的事情也发生在相反的方向。</p>
<p>接受一个值作为参数的函数必须接受一个指定类型的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">fmt.Println(AbsFunc(v))  <span class="comment">// OK</span></span><br><span class="line">fmt.Println(AbsFunc(&amp;v)) <span class="comment">// 编译错误！</span></span><br></pre></td></tr></table></figure>

<p>而以值为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">fmt.Println(v.Abs()) <span class="comment">// OK</span></span><br><span class="line">p := &amp;v</span><br><span class="line">fmt.Println(p.Abs()) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p><strong>这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code>。</strong></p>
<h2 id="选择值或指针作为接收者"><a href="#选择值或指针作为接收者" class="headerlink" title="选择值或指针作为接收者"></a>选择值或指针作为接收者</h2><p>使用指针接收者的原因有二：</p>
<ul>
<li>方法能够修改其接收者指向的值。</li>
<li>这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</li>
</ul>
<p>在本例中，<code>Scale</code> 和 <code>Abs</code> 接收者的类型为 <code>*Vertex</code>，即便 <code>Abs</code> 并不需要修改其接收者。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Before scaling: %+v, Abs: %v\n&quot;</span>, v, v.Abs())</span><br><span class="line">	v.Scale(<span class="number">5</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;After scaling: %+v, Abs: %v\n&quot;</span>, v, v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。</p>
<h2 id="指针-vs-值"><a href="#指针-vs-值" class="headerlink" title="指针 vs. 值"></a>指针 vs. 值</h2><p>正如 <code>ByteSize</code> 那样，我们可以为任何已命名的类型（除了指针或接口）定义方法； 接收者可不必为结构体。</p>
<p>在之前讨论切片时，我们编写了一个 <code>Append</code> 函数。 我们也可将其定义为切片的方法。为此，我们首先要声明一个已命名的类型来绑定该方法， 然后使该方法的接收者成为该类型的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteSlice []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(slice ByteSlice)</span></span> Append(data []<span class="type">byte</span>) []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="comment">// 主体和前面相同。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们仍然需要该方法返回更新后的切片。为了消除这种不便，我们可通过重新定义该方法， 将一个指向 <code>ByteSlice</code> 的<strong>指针</strong>作为该方法的接收者， 这样该方法就能重写调用者提供的切片了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ByteSlice)</span></span> Append(data []<span class="type">byte</span>) &#123;</span><br><span class="line">	slice := *p</span><br><span class="line">	<span class="comment">// 主体和前面相同，但没有 return。</span></span><br><span class="line">	*p = slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若我们将函数修改为与标准 <code>Write</code> 类似的方法，就像这样，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ByteSlice)</span></span> Write(data []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	slice := *p</span><br><span class="line">	<span class="comment">// 依旧和前面相同。</span></span><br><span class="line">	*p = slice</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(data), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么类型 <code>*ByteSlice</code> 就满足了标准的 <code>io.Writer</code> 接口，这将非常实用。 例如，我们可以通过打印将内容写入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b ByteSlice</span><br><span class="line">fmt.Fprintf(&amp;b, <span class="string">&quot;This hour has %d days\n&quot;</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>我们将 <code>ByteSlice</code> 的地址传入，因为只有 <code>*ByteSlice</code> 才满足 <code>io.Writer</code>。以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用。</p>
<p>之所以会有这条规则是因为指针方法可以修改接收者；通过值调用它们会导致方法接收到该值的副本， 因此任何修改都将被丢弃，因此该语言不允许这种错误。不过有个方便的例外：<strong>若该值是可寻址的， 那么该语言就会自动插入取址操作符来对付一般的通过值调用的指针方法。在我们的例子中，变量 <code>b</code> 是可寻址的，因此我们只需通过 <code>b.Write</code> 来调用它的 <code>Write</code> 方法，编译器会将它重写为 <code>(&amp;b).Write</code>。</strong></p>
<p>顺便一提，在字节切片上使用 <code>Write</code> 的想法已被 <code>bytes.Buffer</code> 所实现。</p>
<h1 id="接口与其它类型"><a href="#接口与其它类型" class="headerlink" title="接口与其它类型"></a>接口与其它类型</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Go中的接口为指定对象的行为提供了一种方法：如果某样东西可以完成<strong>这个</strong>， 那么它就可以用在<strong>这里</strong>。我们已经见过许多简单的示例了；通过实现 <code>String</code> 方法，我们可以自定义打印函数，而通过 <code>Write</code> 方法，<code>Fprintf</code> 则能对任何对象产生输出。在Go代码中， 仅包含一两种方法的接口很常见，且其名称通常来自于实现它的方法， 如 <code>io.Writer</code> 就是实现了 <code>Write</code> 的一类对象。</p>
<p>每种类型都能实现多个接口。例如一个实现了 <code>sort.Interface</code> 接口的集合就可通过 <code>sort</code> 包中的例程进行排序。该接口包括 <code>Len()</code>、<code>Less(i, j int) bool</code> 以及 <code>Swap(i, j int)</code>，另外，该集合仍然可以有一个自定义的格式化器。 以下特意构建的例子 <code>Sequence</code> 就同时满足这两种情况。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sequence []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods required by sort.Interface.</span></span><br><span class="line"><span class="comment">// sort.Interface 所需的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s[i] &lt; s[j]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method for printing - sorts the elements before printing.</span></span><br><span class="line"><span class="comment">// 用于打印的方法 - 在打印前对元素进行排序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    sort.Sort(s)</span><br><span class="line">    str := <span class="string">&quot;[&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i, elem := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            str += <span class="string">&quot; &quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        str += fmt.Sprint(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str + <span class="string">&quot;]&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	seq := Sequence&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(seq) <span class="comment">// [1 2 3 4 7 8 9 10]</span></span><br><span class="line">    </span><br><span class="line">    seq = []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(seq) <span class="comment">// [7 8 2 1 3 10 9 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><code>Sequence</code> 的 <code>String</code> 方法重新实现了 <code>Sprint</code> 为切片实现的功能。若我们在调用 <code>Sprint</code> 之前将 <code>Sequence</code> 转换为纯粹的 <code>[]int</code>，就能共享 <code>[]int</code> 已实现的功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	sort.Sort(s)</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprint([]<span class="type">int</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	seq := Sequence&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(seq) <span class="comment">// [1 2 3 4 7 8 9 10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是通过类型转换技术，在 <code>String</code> 方法中安全调用 <code>Sprintf</code> 的另个一例子。若我们忽略类型名的话，这两种类型（<code>Sequence</code>和 <code>[]int</code>）其实是相同的，因此在二者之间进行转换是合法的。 转换过程并不会创建新值，它只是值暂让现有的时看起来有个新类型而已。 （还有些合法转换则会创建新值，如从整数转换为浮点数等。）</p>
<p>在Go程序中，为访问不同的方法集而进行类型转换的情况非常常见。 例如，我们可使用现有的 <code>sort.IntSlice</code> 类型来简化整个示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Sequence []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于打印的方法 - 在打印前对元素进行排序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	sort.IntSlice(s).Sort() <span class="comment">// 将 s 的类型转换为 sort.IntSlice 类型，然后调用 sort.IntSlice 的 Sort 方法 </span></span><br><span class="line">	<span class="keyword">return</span> fmt.Sprint([]<span class="type">int</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，不必让 <code>Sequence</code> 实现多个接口（排序和打印）， 我们可通过将数据条目转换为多种类型（<code>Sequence</code>、<code>sort.IntSlice</code> 和 <code>[]int</code>）来使用相应的功能，每次转换都完成一部分工作。 这在实践中虽然有些不同寻常，但往往却很有效。</p>
<h2 id="接口转换与类型断言"><a href="#接口转换与类型断言" class="headerlink" title="接口转换与类型断言"></a>接口转换与类型断言</h2><p><a href="https://go-zh.org/doc/effective_go.html#%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9">类型选择</a> 是类型转换的一种形式：它接受一个接口，在 switch 语句中根据其判断选择对应的 case 语句， 并在某种意义上将其转换为该种类型。以下代码为 <code>fmt.Printf</code> 通过类型选择将值转换为字符串的简化版。若它已经为字符串，我们需要该接口中实际的字符串值； 若它有 <code>String</code> 方法，我们则需要调用该方法所得的结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 调用者提供的值。</span></span><br><span class="line"><span class="keyword">switch</span> str := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">case</span> Stringer:</span><br><span class="line">	<span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种情况获取具体的值，第二种将该接口转换为另一个接口。这种方式对于混合类型来说非常完美。</p>
<p>若我们只关心一种类型呢？若我们知道该值拥有一个 <code>string</code> 而想要提取它呢？ 只需一种情况的类型选择就行，但它需要<strong>类型断言</strong>。类型断言接受一个接口值， 并从中提取指定的明确类型的值。其语法借鉴自类型选择开头的子句，但它需要一个明确的类型， 而非 <code>type</code> 关键字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value.(typeName)</span><br></pre></td></tr></table></figure>

<p>而其结果则是拥有静态类型 <code>typeName</code> 的新值。该类型必须为该接口所拥有的具体类型， 或者该值可转换成的第二种接口类型。要提取我们知道在该值中的字符串，可以这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := value.(<span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<p>但若它所转换的值中不包含字符串，该程序就会以运行时错误崩溃。为避免这种情况， 需使用<code>逗号, ok</code>惯用测试它能安全地判断该值是否为字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str, ok := value.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串值为 %q\n&quot;</span>, str)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;该值非字符串\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若类型断言失败，<code>str</code> 将继续存在且为字符串类型，但它将拥有零值，即空字符串。</p>
<p>作为对能力 (capability) 的说明，这里有个 <code>if-else</code> 语句，它等价于本节开头的类型选择 switch 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> str, ok := value.(<span class="type">string</span>); ok &#123;</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> str, ok := value.(Stringer); ok &#123;</span><br><span class="line">	<span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h2><p>若某种现有的类型仅实现了一个接口，且除此之外并无可导出的方法，则该类型本身就无需导出。 仅导出该接口能让我们更专注于其行为而非实现，其它属性不同的实现则能镜像该原始类型的行为。 这也能够避免为每个通用接口的实例重复编写文档。</p>
<p>在这种情况下，构造函数应当返回一个接口值而非实现的类型。例如在 <code>hash</code> 库中，<code>crc32.NewIEEE</code> 和 <code>adler32.New</code> 都返回接口类型 <code>hash.Hash32</code>。要在Go程序中用 Adler-32 算法替代 CRC-32， 只需修改构造函数调用即可，其余代码则不受算法改变的影响。</p>
<p>同样的方式能将 <code>crypto</code> 包中多种联系在一起的流密码算法与块密码算法分开。 <code>crypto/cipher</code> 包中的 <code>Block</code> 接口指定了块密码算法的行为， 它为单独的数据块提供加密。接着，和 <code>bufio</code> 包类似，任何实现了该接口的密码包都能被用于构造以 <code>Stream</code> 为接口表示的流密码，而无需知道块加密的细节。</p>
<p><code>crypto/cipher</code> 接口看其来就像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">interface</span> &#123;</span><br><span class="line">	BlockSize() <span class="type">int</span></span><br><span class="line">	Encrypt(src, dst []<span class="type">byte</span>)</span><br><span class="line">	Decrypt(src, dst []<span class="type">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stream <span class="keyword">interface</span> &#123;</span><br><span class="line">	XORKeyStream(dst, src []<span class="type">byte</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是计数器模式 CTR 流的定义，它将块加密改为流加密，注意块加密的细节已被抽象化了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewCTR 返回一个 Stream，其加密/解密使用计数器模式中给定的 Block 进行。</span></span><br><span class="line"><span class="comment">// iv 的长度必须与 Block 的块大小相同。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCTR</span><span class="params">(block Block, iv []<span class="type">byte</span>)</span></span> Stream</span><br></pre></td></tr></table></figure>

<p><code>NewCTR</code> 的应用并不仅限于特定的加密算法和数据源，它适用于任何对 <code>Block</code> 接口和 <code>Stream</code> 的实现。因为它们返回接口值， 所以用其它加密模式来代替CTR只需做局部的更改。构造函数的调用过程必须被修改， 但由于其周围的代码只能将它看做 <code>Stream</code>，因此它们不会注意到其中的区别。</p>
<h2 id="接口和方法"><a href="#接口和方法" class="headerlink" title="接口和方法"></a>接口和方法</h2><p>由于几乎任何类型都能添加方法，因此几乎任何类型都能满足一个接口。一个很直观的例子就是 <code>http</code> 包中定义的 <code>Handler</code> 接口。任何实现了 <code>Handler</code> 的对象都能够处理HTTP请求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ResponseWriter</code> 接口提供了对方法的访问，这些方法需要响应客户端的请求。 由于这些方法包含了标准的 <code>Write</code> 方法，因此 <code>http.ResponseWriter</code> 可用于任何 <code>io.Writer</code> 适用的场景。<code>Request</code> 结构体包含已解析的客户端请求。</p>
<p>为简单起见，我们假设所有的HTTP请求都是GET方法，而忽略POST方法， 这种简化不会影响处理程序的建立方式。这里有个短小却完整的处理程序实现， 它用于记录某个页面被访问的次数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的计数器服务。</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">	n <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctr *Counter)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	ctr.n++</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;counter = %d\n&quot;</span>, ctr.n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（紧跟我们的主题，注意 <code>Fprintf</code> 如何能输出到 <code>http.ResponseWriter</code>。） 作为参考，这里演示了如何将这样一个服务器添加到URL树的一个节点上。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line">...</span><br><span class="line">ctr := <span class="built_in">new</span>(Counter)</span><br><span class="line">http.Handle(<span class="string">&quot;/counter&quot;</span>, ctr)</span><br></pre></td></tr></table></figure>

<p>但 <code>Counter</code> 不必是结构体，一个整数就够了。 An integer is all that’s needed. （接收者必须为指针，增量操作对于调用者才可见。）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的计数器服务。</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctr *Counter)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	*ctr++</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;counter = %d\n&quot;</span>, *ctr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当页面被访问时，怎样通知你的程序去更新一些内部状态呢？为Web页面绑定个信道吧。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次浏览该信道都会发送一个提醒。</span></span><br><span class="line"><span class="comment">// （可能需要带缓冲的信道。）</span></span><br><span class="line"><span class="keyword">type</span> Chan <span class="keyword">chan</span> *http.Request</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch Chan)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	ch &lt;- req</span><br><span class="line">	fmt.Fprint(w, <span class="string">&quot;notification sent&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，假设我们需要输出调用服务器二进制程序时使用的实参 <code>/args</code>。 很简单，写个打印实参的函数就行了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArgServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们如何将它转换为HTTP服务器呢？我们可以将 <code>ArgServer</code> 实现为某种可忽略值的方法，不过还有种更简单的方法。 既然我们可以为除指针和接口以外的任何类型定义方法，同样也能为一个函数写一个方法。 <code>http</code> 包包含以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HandlerFunc 类型是一个适配器，它允许将普通函数用做HTTP处理程序。</span></span><br><span class="line"><span class="comment">// 若 f 是个具有适当签名的函数，HandlerFunc(f) 就是个调用 f 的处理程序对象。</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(c, req).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, req *Request) &#123;</span><br><span class="line">	f(w, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HandlerFunc</code> 是个具有 <code>ServeHTTP</code> 方法的类型， 因此该类型的值就能处理HTTP请求。我们来看看该方法的实现：接收者是一个函数 <code>f</code>，而该方法调用 <code>f</code>。这看起来很奇怪，但不必大惊小怪， 区别在于接收者变成了一个信道，而方法通过该信道发送消息。</p>
<p>为了将 <code>ArgServer</code> 实现成HTTP服务器，首先我们得让它拥有合适的签名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实参服务器。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArgServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintln(w, os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ArgServer</code> 和 <code>HandlerFunc</code> 现在拥有了相同的签名， 因此我们可将其转换为这种类型以访问它的方法，就像我们将 <code>Sequence</code> 转换为 <code>IntSlice</code> 以访问 <code>IntSlice.Sort</code> 那样。 建立代码非常简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.Handle(<span class="string">&quot;/args&quot;</span>, http.HandlerFunc(ArgServer))</span><br></pre></td></tr></table></figure>

<p>当有人访问 <code>/args</code> 页面时，安装到该页面的处理程序就有了值 <code>ArgServer</code> 和类型 <code>HandlerFunc</code>。 HTTP服务器会以 <code>ArgServer</code> 为接收者，调用该类型的 <code>ServeHTTP</code> 方法，它会反过来调用 <code>ArgServer</code>（通过 <code>f(c, req)</code>），接着实参就会被显示出来。</p>
<p>在本节中，我们通过一个结构体，一个整数，一个信道和一个函数，建立了一个HTTP服务器， 这一切都是因为接口只是方法的集和，而几乎任何类型都能定义方法。</p>
<h1 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符"></a>空白标识符</h1><p>我们在 <a href="https://go-zh.org/doc/effective_go.html#for"><code>for-range</code> 循环</a>和<a href="https://go-zh.org/doc/effective_go.html#%E6%98%A0%E5%B0%84">映射</a>中提过几次空白标识符。 空白标识符可被赋予或声明为任何类型的任何值，而其值会被无害地丢弃。它有点像Unix中的 <code>/dev/null</code> 文件：它表示只写的值，在需要变量但不需要实际值的地方用作占位符。 我们在前面已经见过它的用法了。</p>
<h2 id="多重赋值中的空白标识符"><a href="#多重赋值中的空白标识符" class="headerlink" title="多重赋值中的空白标识符"></a>多重赋值中的空白标识符</h2><p><code>for range</code> 循环中对空表标识符的用法是一种具体情况，更一般的情况即为多重赋值。</p>
<p>若某次赋值需要匹配多个左值，但其中某个变量不会被程序使用， 那么用空白标识符来代替该变量可避免创建无用的变量，并能清楚地表明该值将被丢弃。 例如，当调用某个函数时，它会返回一个值和一个错误，但只有错误很重要， 那么可使用空白标识符来丢弃无关的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := os.Stat(path); os.IsNotExist(err) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s does not exist\n&quot;</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你偶尔会看见为忽略错误而丢弃错误值的代码，这是种糟糕的实践。请务必检查错误返回， 它们会提供错误的理由。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 烂代码！若路径不存在，它就会崩溃。</span></span><br><span class="line">fi, _ := os.Stat(path)</span><br><span class="line"><span class="keyword">if</span> fi.IsDir() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s is a directory\n&quot;</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="未使用的导入和变量"><a href="#未使用的导入和变量" class="headerlink" title="未使用的导入和变量"></a>未使用的导入和变量</h2><p>若导入某个包或声明某个变量而不使用它就会产生错误。未使用的包会让程序膨胀并拖慢编译速度， 而已初始化但未使用的变量不仅会浪费计算能力，还有可能暗藏着更大的Bug。 然而在程序开发过程中，经常会产生未使用的导入和变量。虽然以后会用到它们， 但为了完成编译又不得不删除它们才行，这很让人烦恼。空白标识符就能提供一个工作空间。</p>
<p>这个写了一半的程序有两个未使用的导入（<code>fmt</code> 和 <code>io</code>）以及一个未使用的变量（<code>fd</code>），因此它不能编译， 但若到目前为止代码还是正确的，我们还是很乐意看到它们的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fd, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> use fd.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要让编译器停止关于未使用导入的抱怨，需要空白标识符来引用已导入包中的符号。 同样，将未使用的变量 <code>fd</code> 赋予空白标识符也能关闭未使用变量错误。 该程序的以下版本可以编译。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = fmt.Printf <span class="comment">// For debugging; delete when done. // 用于调试，结束时删除。</span></span><br><span class="line"><span class="keyword">var</span> _ io.Reader    <span class="comment">// For debugging; delete when done. // 用于调试，结束时删除。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fd, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> use fd.</span></span><br><span class="line">    _ = fd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照惯例，我们应在导入并加以注释后，再使全局声明导入错误静默，这样可以让它们更易找到， 并作为以后清理它的提醒。</p>
<h2 id="为副作用而导入"><a href="#为副作用而导入" class="headerlink" title="为副作用而导入"></a>为副作用而导入</h2><p>像前例中 <code>fmt</code> 或 <code>io</code> 这种未使用的导入总应在最后被使用或移除： 空白赋值会将代码标识为工作正在进行中。但有时导入某个包只是为了其副作用， 而没有任何明确的使用。例如，在 <code>net/http/pprof</code> 包的 <code>init</code> 函数中记录了HTTP处理程序的调试信息。它有个可导出的API， 但大部分客户端只需要该处理程序的记录和通过网页访问数据。只为了其副作用来导入该包， 只需将包重命名为空白标识符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br></pre></td></tr></table></figure>

<p>这种导入格式能明确表示该包是为其副作用而导入的，因为没有其它使用该包的可能： 在此文件中，它没有名字。（若它有名字而我们没有使用，编译器就会拒绝该程序。）</p>
<h2 id="接口检查"><a href="#接口检查" class="headerlink" title="接口检查"></a>接口检查</h2><p>就像我们在前面<a href="https://go-zh.org/doc/effective_go.html#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E5%9E%8B">接口</a>中讨论的那样， 一个类型无需显式地声明它实现了某个接口。取而代之，该类型只要实现了某个接口的方法， 其实就实现了该接口。在实践中，大部分接口转换都是静态的，因此会在编译时检测。 例如，将一个 <code>*os.File</code> 传入一个预期的 <code>io.Reader</code> 函数将不会被编译， 除非 <code>*os.File</code> 实现了 <code>io.Reader</code> 接口。</p>
<p>尽管有些接口检查会在运行时进行。<code>encoding/json</code> 包中就有个实例它定义了一个 <code>Marshaler</code> 接口。当JSON编码器接收到一个实现了该接口的值，那么该编码器就会调用该值的编组方法， 将其转换为JSON，而非进行标准的类型转换。 编码器在运行时通过<a href="https://go-zh.org/doc/effective_go.html#%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2">类型断言</a>检查其属性，就像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m, ok := val.(json.Marshaler)</span><br></pre></td></tr></table></figure>

<p>若只需要判断某个类型是否是实现了某个接口，而不需要实际使用接口本身 （可能是错误检查部分），就使用空白标识符来忽略类型断言的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := val.(json.Marshaler); ok &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value %v of type %T implements json.Marshaler\n&quot;</span>, val, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要确保某个包中实现的类型一定满足该接口时，就会遇到这种情况。 若某个类型（例如 <code>json.RawMessage</code>） 需要一种定制的JSON表现时，它应当实现 <code>json.Marshaler</code>， 不过现在没有静态转换可以让编译器去自动验证它。若该类型通过忽略转换失败来满足该接口， 那么JSON编码器仍可工作，但它却不会使用定制的实现。为确保其实现正确， 可在该包中用空白标识符声明一个全局变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ json.Marshaler = (*RawMessage)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>在此声明中，我们调用了一个 <code>*RawMessage</code> 转换并将其赋予了 <code>Marshaler</code>，以此来要求 <code>*RawMessage</code> 实现 <code>Marshaler</code>，这时其属性就会在编译时被检测。 若 <code>json.Marshaler</code> 接口被更改，此包将无法通过编译， 而我们则会注意到它需要更新。</p>
<p>在这种结构中出现空白标识符，即表示该声明的存在只是为了类型检查。 不过请不要为满足接口就将它用于任何类型。作为约定， 仅当代码中不存在静态类型转换时才能这种声明，毕竟这是种罕见的情况。</p>
<h1 id="内嵌"><a href="#内嵌" class="headerlink" title="内嵌"></a>内嵌</h1><p>Go并不提供典型的、类型驱动的子类化概念，但通过将类型<strong>内嵌</strong>到结构体或接口中， 它就能“借鉴”部分实现。</p>
<p>接口内嵌非常简单。我们之前提到过 <code>io.Reader</code> 和 <code>io.Writer</code> 接口，这里是它们的定义。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>io</code> 包也导出了一些其它接口，以此来阐明对象所需实现的方法。 例如 <code>io.ReadWriter</code> 就是个包含 <code>Read</code> 和 <code>Write</code> 的接口。我们可以通过显式地列出这两个方法来指明 <code>io.ReadWriter</code>， 但通过将这两个接口内嵌到新的接口中显然更容易且更具启发性，就像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReadWriter 接口结合了 Reader 和 Writer 接口。</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如它看起来那样：<code>ReadWriter</code> 能够做任何 <code>Reader</code> <strong>和</strong> <code>Writer</code> 可以做到的事情，它是内嵌接口的联合体 （它们必须是不相交的方法集）。<strong>只有接口能被嵌入到接口中。</strong></p>
<p>同样的基本想法可以应用在结构体中，但其意义更加深远。<code>bufio</code> 包中有 <code>bufio.Reader</code> 和 <code>bufio.Writer</code> 这两个结构体类型， 它们每一个都实现了与 <code>io</code> 包中相同意义的接口。此外，<code>bufio</code> 还通过结合 <code>reader/writer</code> 并将其内嵌到结构体中，实现了带缓冲的 <code>reader/writer</code>：它列出了结构体中的类型，但并未给予它们字段名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReadWriter 存储了指向 Reader 和 Writer 的指针。</span></span><br><span class="line"><span class="comment">// 它实现了 io.ReadWriter。</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	*Reader  <span class="comment">// *bufio.Reader</span></span><br><span class="line">	*Writer  <span class="comment">// *bufio.Writer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内嵌的元素为指向结构体的指针，当然它们在使用前必须被初始化为指向有效结构体的指针。 <code>ReadWriter</code> 结构体可通过如下方式定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	reader *Reader</span><br><span class="line">	writer *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但为了提升该字段的方法并满足 <code>io</code> 接口，我们同样需要提供转发的方法， 就像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *ReadWriter)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> rw.reader.Read(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<strong>通过直接内嵌结构体，我们就能避免如此繁琐。 内嵌类型的方法可以直接引用，这意味着 <code>bufio.ReadWriter</code> 不仅包括 <code>bufio.Reader</code> 和 <code>bufio.Writer</code> 的方法，它还同时满足下列三个接口： <code>io.Reader</code>、<code>io.Writer</code> 以及 <code>io.ReadWriter</code>。</strong></p>
<p>还有种区分内嵌与子类的重要手段。**当内嵌一个类型时，该类型的方法会成为外部类型的方法， 但当它们被调用时，该方法的接收者是内部类型，而非外部的。**在我们的例子中，当 <code>bufio.ReadWriter</code> 的 <code>Read</code> 方法被调用时， 它与之前写的转发方法具有同样的效果；接收者是 <code>ReadWriter</code> 的 <code>reader</code> 字段，而非 <code>ReadWriter</code> 本身。</p>
<p><strong>内嵌同样可以提供便利。这个例子展示了一个内嵌字段和一个常规的命名字段。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">	Command <span class="type">string</span></span><br><span class="line">	*log.Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Job</code> 类型现在有了 <code>Log</code>、<code>Logf</code> 和 <code>*log.Logger</code> 的其它方法。我们当然可以为 <code>Logger</code> 提供一个字段名，但完全不必这么做。现在，一旦初始化后，我们就能记录 <code>Job</code> 了：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">job.Log(<span class="string">&quot;starting now...&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>go 1.19.1 没有 <code>Log</code>、<code>Logf</code>方法，但 <code>job</code> 依然有了 <code>log.Logger</code>的其他方法，如：<code>Println</code>、<code>Print</code>、<code>Fatal</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下结果运行于 go 1.19.1</span></span><br><span class="line"></span><br><span class="line">job := &amp;Job&#123;<span class="string">&quot;cmd&quot;</span>, log.New(os.Stderr, <span class="string">&quot;Job: &quot;</span>, log.Ldate)&#125;</span><br><span class="line">fmt.Println(job.Command) <span class="comment">// cmd</span></span><br><span class="line">job.Println(<span class="string">&quot;starting now...&quot;</span>) <span class="comment">// Job: 2022/09/14 starting now...</span></span><br></pre></td></tr></table></figure></blockquote>
<p><code>Logger</code> 是 <code>Job</code> 结构体的常规字段， 因此我们可在 <code>Job</code> 的构造函数中，通过一般的方式来初始化它，就像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewJob</span><span class="params">(command <span class="type">string</span>, logger *log.Logger)</span></span> *Job &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Job&#123;command, logger&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或通过复合字面：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">job := &amp;Job&#123;command, log.New(os.Stderr, <span class="string">&quot;Job: &quot;</span>, log.Ldate)&#125;</span><br></pre></td></tr></table></figure>

<p>若我们需要直接引用内嵌字段，可以忽略包限定名，直接将该字段的类型名作为字段名， 就像我们在 <code>ReaderWriter</code> 结构体的 <code>Read</code> 方法中做的那样。 若我们需要访问 <code>Job</code> 类型的变量 <code>job</code> 的 <code>*log.Logger</code>， 可以直接写作 <code>job.Logger</code>。若我们想精炼 <code>Logger</code> 的方法时， 这会非常有用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(job *Job)</span></span> Logf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	job.Logger.Logf(<span class="string">&quot;%q: %s&quot;</span>, job.Command, fmt.Sprintf(format, args...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内嵌类型会引入命名冲突的问题，但解决规则却很简单。首先，字段或方法 <code>X</code> 会隐藏该类型中更深层嵌套的其它项 <code>X</code>。若 <code>log.Logger</code> 包含一个名为 <code>Command</code> 的字段或方法，<code>Job</code> 的 <code>Command</code> 字段会覆盖它。</strong></p>
<p><strong>其次，若相同的嵌套层级上出现同名冲突，通常会产生一个错误。若 <code>Job</code> 结构体中包含名为 <code>Logger</code> 的字段或方法，再将 <code>log.Logger</code> 内嵌到其中的话就会产生错误。然而，若重名永远不会在该类型定义之外的程序中使用，那就不会出错。 这种限定能够在外部嵌套类型发生修改时提供某种保护。 因此，就算添加的字段与另一个子类型中的字段相冲突，只要这两个相同的字段永远不会被使用就没问题。</strong></p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="通过通信共享内存"><a href="#通过通信共享内存" class="headerlink" title="通过通信共享内存"></a>通过通信共享内存</h2><p>并发编程是个很大的论题。但限于篇幅，这里仅讨论一些Go特有的东西。</p>
<p>在并发编程中，为实现对共享变量的正确访问需要精确的控制，这在多数环境下都很困难。 Go语言另辟蹊径，它将共享的值通过信道传递，实际上，多个独立执行的线程从不会主动共享。 在任意给定的时间点，只有一个Go程能够访问该值。数据竞争从设计上就被杜绝了。 为了提倡这种思考方式，我们将它简化为一句口号：</p>
<blockquote>
<p>不要通过共享内存来通信，而应通过通信来共享内存。</p>
</blockquote>
<p>这种方法意义深远。例如，引用计数通过为整数变量添加互斥锁来很好地实现。 但作为一种高级方法，通过信道来控制访问能够让你写出更简洁，正确的程序。</p>
<p>我们可以从典型的单线程运行在单CPU之上的情形来审视这种模型。它无需提供同步原语。 现在考虑另一种情况，它也无需同步。现在让它们俩进行通信。若将通信过程看做同步着， 那就完全不需要其它同步了。例如，Unix管道就与这种模型完美契合。 尽管Go的并发处理方式来源于Hoare的通信顺序处理（CSP）， 它依然可以看做是类型安全的Unix管道的实现。</p>
<h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p>我们称之为**Go程（Goroutines）**是因为现有的术语—线程、协程、进程等等—无法准确传达它的含义。 <strong>Go程</strong>具有简单的模型：它是与其它Go程并发运行在同一地址空间的函数。它是轻量级的， 所有消耗几乎就只有栈空间的分配。而且栈最开始是非常小的，所以它们很廉价， 仅在需要时才会随着堆空间的分配（和释放）而变化。</p>
<p>Go程在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待I&#x2F;O， 那么其它的线程就会运行。Go程的设计隐藏了线程创建和管理的诸多复杂性。</p>
<p><strong>在函数或方法前添加 <code>go</code> 关键字能够在新的Go程中调用它。当调用完成后， 该Go程也会安静地退出。（效果有点像Unix Shell中的 <code>&amp;</code> 符号，它能让命令在后台运行。）</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> list.Sort()  <span class="comment">// 并发运行 list.Sort，无需等它结束。</span></span><br></pre></td></tr></table></figure>

<p>函数字面在Go程调用中非常有用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Announce</span><span class="params">(message <span class="type">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(delay)</span><br><span class="line">		fmt.Println(message)</span><br><span class="line">	&#125;()  <span class="comment">// 注意括号 - 必须调用该函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Go中，函数字面都是闭包：其实现在保证了函数内引用变量的生命周期与函数的活动时间相同。</p>
<p>这些函数没什么实用性，因为它们没有实现完成时的信号处理。因此，我们需要信道。</p>
<h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>信道与映射一样，也需要通过 <code>make</code> 来分配内存。其结果值充当了对底层数据结构的引用。 若提供了一个可选的整数形参，它就会为该信道设置缓冲区大小。默认值是零，表示不带缓冲的或同步的信道。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ci := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)            <span class="comment">// 整数类型的无缓冲信道</span></span><br><span class="line">cj := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>)         <span class="comment">// 整数类型的无缓冲信道</span></span><br><span class="line">cs := <span class="built_in">make</span>(<span class="keyword">chan</span> *os.File, <span class="number">100</span>)  <span class="comment">// 指向文件指针的带缓冲信道</span></span><br></pre></td></tr></table></figure>

<p>无缓冲信道在通信时会同步交换数据，它能确保（两个Go程的）计算处于确定状态。</p>
<p>信道有很多惯用法，我们从这里开始了解。在上一节中，我们在后台启动了排序操作。 信道使得启动的Go程等待排序完成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)  <span class="comment">// 分配一个信道</span></span><br><span class="line"><span class="comment">// 在Go程中启动排序。当它完成后，在信道上发送信号。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	list.Sort()</span><br><span class="line">	c &lt;- <span class="number">1</span>  <span class="comment">// 发送信号，什么值无所谓。</span></span><br><span class="line">&#125;()</span><br><span class="line">doSomethingForAWhile()</span><br><span class="line">&lt;-c   <span class="comment">// 等待排序结束，丢弃发来的值。</span></span><br></pre></td></tr></table></figure>

<p>接收者在收到数据前会一直阻塞。若信道是不带缓冲的，那么在接收者收到值前， 发送者会一直阻塞；若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞； 若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。</p>
<p>A buffered channel can be used like a semaphore, for instance to limit throughput. In this example, incoming requests are passed to <code>handle</code>, which sends a value into the channel, processes the request, and then receives a value from the channel to ready the “semaphore” for the next consumer. The capacity of the channel buffer limits the number of simultaneous calls to <code>process</code>.</p>
<p>带缓冲的信道可被用作信号量，例如限制吞吐量。在此例中，进入的请求会被传递给 <code>handle</code>，它从信道中接收值，处理请求后将值发回该信道中，以便让该 “信号量”准备迎接下一次请求。信道缓冲区的容量决定了同时调用 <code>process</code> 的数量上限，因此我们在初始化时首先要填充至它的容量上限。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sem = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, MaxOutstanding)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">	sem &lt;- <span class="number">1</span> <span class="comment">// 等待活动队列清空。</span></span><br><span class="line">	process(r)  <span class="comment">// 可能需要很长时间。</span></span><br><span class="line">	&lt;-sem    <span class="comment">// 完成；使下一个请求可以运行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		req := &lt;-queue</span><br><span class="line">		<span class="keyword">go</span> handle(req)  <span class="comment">// 无需等待 handle 结束。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Once <code>MaxOutstanding</code> handlers are executing <code>process</code>, any more will block trying to send into the filled channel buffer, until one of the existing handlers finishes and receives from the buffer.</p>
<p>一旦有 <code>MaxOutstanding</code> 个处理程序正在执行 <code>process</code>，任何试图向缓冲区已满的信道发送更多消息的操作都将被阻塞，直到有一个处理程序（handler）完成并从缓冲区接收。</p>
<p>由于数据同步发生在信道的接收端（也就是说发送<strong>发生在</strong>&gt;接受<strong>之前</strong>，参见 <a href="https://go-zh.org/ref/mem">Go内存模型</a>），因此信号必须在信道的接收端获取，而非发送端。</p>
<p>然而，它却有个设计问题：尽管只有 <code>MaxOutstanding</code> 个Go程能同时运行，但 <code>Serve</code> 还是为每个进入的请求都创建了新的Go程。其结果就是，若请求来得很快， 该程序就会无限地消耗资源。为了弥补这种不足，我们可以通过修改 <code>Serve</code> 来限制创建Go程，这是个明显的解决方案，但要当心我们修复后出现的Bug。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		sem &lt;- <span class="number">1</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			process(req) <span class="comment">// 这儿有Bug，见下方解释。</span></span><br><span class="line">			&lt;-sem</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bug出现在Go的 <code>for</code> 循环中，该循环变量在每次迭代时会被重用，因此 <code>req</code> 变量会在所有的Go程间共享，这不是我们想要的。我们需要确保 <code>req</code> 对于每个Go程来说都是唯一的。</p>
<p>有一种方法能够做到，就是将 <code>req</code> 的值作为实参传入到该Go程的闭包中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		sem &lt;- <span class="number">1</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(req *Request)</span></span> &#123;</span><br><span class="line">			process(req)</span><br><span class="line">			&lt;-sem</span><br><span class="line">		&#125;(req)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较前后两个版本，观察该闭包声明和运行中的差别。 </p>
<p>另一种解决方案就是以相同的名字创建新的变量，如例中所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		req := req <span class="comment">// 为该Go程创建 req 的新实例。</span></span><br><span class="line">		sem &lt;- <span class="number">1</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			process(req)</span><br><span class="line">			&lt;-sem</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的写法看起来有点奇怪</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">req := req</span><br></pre></td></tr></table></figure>

<p>但在Go中这样做是合法且惯用的。你用相同的名字获得了该变量的一个新的版本， 以此来局部地刻意屏蔽循环变量，使它对每个Go程保持唯一。</p>
<p>回到编写服务器的一般问题上来。另一种管理资源的好方法就是启动固定数量的 <code>handle</code> Go程，一起从请求信道中读取数据。Go程的数量限制了同时调用 <code>process</code> 的数量。<code>Serve</code> 同样会接收一个通知退出的信道， 在启动所有Go程后，它将阻塞并暂停从信道中接收消息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> r := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		process(r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(clientRequests <span class="keyword">chan</span> *Request, quit <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 启动处理程序</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; MaxOutstanding; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> handle(clientRequests)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-quit  <span class="comment">// 等待通知退出。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信道的-range-和-close"><a href="#信道的-range-和-close" class="headerlink" title="信道的 range 和 close"></a>信道的 range 和 close</h2><p>发送者可通过 <code>close</code> 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure>

<p>之后 <code>ok</code> 会被设置为 <code>false</code>。</p>
<p>循环 <code>for i := range c</code> 会不断从信道接收值，直到它被关闭。</p>
<p><em>注意：</em> 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p>
<p><em>还要注意：</em> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code> 循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		c &lt;- x</span><br><span class="line">		x, y = y, x+y</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h2><p><code>select</code> 语句使一个 Go 程可以等待多个通信操作。</p>
<p><code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> c &lt;- x:</span><br><span class="line">			x, y = y, x+y</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Println(&lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">		quit &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="默认选择"><a href="#默认选择" class="headerlink" title="默认选择"></a>默认选择</h3><p>当 <code>select</code> 中的其它分支都没有准备好时，<code>default</code> 分支就会执行。</p>
<p>为了在尝试发送或者接收时不发生阻塞，可使用 <code>default</code> 分支：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// 使用 i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 从 c 中接收会阻塞时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tick := time.Tick(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">	boom := time.After(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-tick:</span><br><span class="line">			fmt.Println(<span class="string">&quot;tick.&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> &lt;-boom:</span><br><span class="line">			fmt.Println(<span class="string">&quot;BOOM!&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;    .&quot;</span>)</span><br><span class="line">			time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="信道中的信道"><a href="#信道中的信道" class="headerlink" title="信道中的信道"></a>信道中的信道</h2><p>Go最重要的特性就是信道是一等值 （ first-class value），它可以被分配并像其它值到处传递。 这种特性通常被用来实现安全、并行的多路分解。</p>
<p>在上一节的例子中，<code>handle</code> 是个非常理想化的请求处理程序， 但我们并未定义它所处理的请求类型。若该类型包含一个可用于回复的信道， 那么每一个客户端都能为其回应提供自己的路径。以下为 <code>Request</code> 类型的大概定义。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	args        []<span class="type">int</span></span><br><span class="line">	f           <span class="function"><span class="keyword">func</span><span class="params">([]<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">	resultChan  <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端提供了一个函数及其实参，此外在请求对象中还有个接收应答的信道。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="type">int</span>)</span></span> (s <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		s += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request := &amp;Request&#123;[]<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, sum, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)&#125;</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">clientRequests &lt;- request</span><br><span class="line"><span class="comment">// 等待回应</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;answer: %d\n&quot;</span>, &lt;-request.resultChan)</span><br></pre></td></tr></table></figure>

<p>在服务器端, 只需要修改处理函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		req.resultChan &lt;- req.f(req.args)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使其实际可用还有很多工作要做，这些代码仅能实现一个速率有限、并行、非阻塞RPC系统的 框架，而且它并不包含互斥锁。</p>
<h2 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h2><p>这些设计的另一个应用是在多CPU核心上实现并行计算。如果计算过程能够被分为几块 可独立执行的过程，它就可以在每块计算结束时向信道发送信号，从而实现并行处理。</p>
<p>让我们看看这个理想化的例子。我们在对一系列向量项进行极耗资源的操作， 而每个项的值计算是完全独立的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vector []<span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将此操应用至 v[i], v[i+1] ... 直到 v[n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vector)</span></span> DoSome(i, n <span class="type">int</span>, u Vector, c <span class="keyword">chan</span> <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> ; i &lt; n; i++ &#123;</span><br><span class="line">		v[i] += u.Op(v[i])</span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- <span class="number">1</span>    <span class="comment">// 发信号表示这一块计算完成。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在循环中启动了独立的处理块，每个CPU将执行一个处理。 它们有可能以乱序的形式完成并结束，但这没有关系； 我们只需在所有Go程开始后接收，并统计信道中的完成信号即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NCPU = <span class="number">4</span>  <span class="comment">// CPU核心数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vector)</span></span> DoAll(u Vector) &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, NCPU)  <span class="comment">// 缓冲区是可选的，但明显用上更好</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NCPU; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> v.DoSome(i*<span class="built_in">len</span>(v)/NCPU, (i+<span class="number">1</span>)*<span class="built_in">len</span>(v)/NCPU, u, c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 排空信道。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NCPU; i++ &#123;</span><br><span class="line">		&lt;-c    <span class="comment">// 等待任务完成</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 一切完成。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rather than create a constant value for numCPU, we can ask the runtime what value is appropriate. The function <code>runtime.NumCPU</code> returns the number of hardware CPU cores in the machine, so we could write</p>
<p>我们可以询问 runtime 什么值是合适的，而不是创建一个常量值 <code>numCPU</code> 。 <code>runtime.NumCPU</code> 函数返回机器中硬件 CPU 内核的数量，所以我们可以这样写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numCPU = runtime.NumCPU()</span><br></pre></td></tr></table></figure>

<p>There is also a function <code>runtime.GOMAXPROCS</code>, which reports (or sets) the user-specified number of cores that a Go program can have running simultaneously. It defaults to the value of <code>runtime.NumCPU</code> but can be overridden by setting the similarly named shell environment variable or by calling the function with a positive number. Calling it with zero just queries the value. Therefore if we want to honor the user’s resource request, we should write</p>
<p>函数 <a href="https://go.dev/pkg/runtime#GOMAXPROCS"><code>runtime.GOMAXPROCS</code></a> 可以报告（或设置）Go程序可以同时运行的、用户指定的核心数。其值默认为 <code>runtime.NumCPU</code> 的值，但可以被重新覆盖；如，通过设置类似的命名Shell环境变量，或者调用 <code>runtime.GOMAXPROCS</code> 函数并传递一个正数作为参数。以 <code>0</code> 作为参数调用 <code>runtime.GOMAXPROCS</code> 仅仅是查询该值。因此，如果我们想尊重用户的资源请求，我们应该这样写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numCPU = runtime.GOMAXPROCS(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>注意不要混淆并发和并行的概念：并发是用可独立执行的组件构造程序的方法， 而并行则是为了效率在多CPU上平行地进行计算。尽管Go的并发特性能够让某些问题更易构造成并行计算， 但Go仍然是种并发而非并行的语言，且Go的模型并不适合所有的并行问题。 关于其中区别的讨论，见 <a href="http://blog.golang.org/2013/01/concurrency-is-not-parallelism.html">此博文</a>。</p>
<h2 id="Leaky-Buffer"><a href="#Leaky-Buffer" class="headerlink" title="Leaky Buffer"></a>Leaky Buffer</h2><p>并发编程的工具甚至能很容易地表达非并发的思想。这里有个提取自RPC包的例子。 客户端Go程从某些来源，可能是网络中循环接收数据。为避免分配和释放缓冲区， 它保存了一个空闲链表，使用一个带缓冲信道表示。若信道为空，就会分配新的缓冲区。 一旦消息缓冲区就绪，它将通过 <code>serverChan</code> 被发送到服务器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> freeList = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> serverChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">client</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> b *Buffer</span><br><span class="line">		<span class="comment">// 若缓冲区可用就用它，不可用就分配个新的。</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> b = &lt;-freeList:</span><br><span class="line">			<span class="comment">// 获取一个，不做别的。</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 非空闲，因此分配一个新的。</span></span><br><span class="line">			b = <span class="built_in">new</span>(Buffer)</span><br><span class="line">		&#125;</span><br><span class="line">		load(b)              <span class="comment">// 从网络中读取下一条消息。</span></span><br><span class="line">		serverChan &lt;- b   <span class="comment">// 发送至服务器。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器从客户端循环接收每个消息，处理它们，并将缓冲区返回给空闲列表。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		b := &lt;-serverChan    <span class="comment">// 等待工作。</span></span><br><span class="line">		process(b)</span><br><span class="line">		<span class="comment">// 若缓冲区有空间就重用它。</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> freeList &lt;- b:</span><br><span class="line">			<span class="comment">// 将缓冲区b放到freeList中，不做别的。</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 空闲列表已满，保持就好。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The client attempts to retrieve a buffer from <code>freeList</code>; if none is available, it allocates a fresh one. The server’s send to <code>freeList</code> puts <code>b</code> back on the free list unless the list is full, in which case the buffer is dropped on the floor to be reclaimed by the garbage collector. (The <code>default</code> clauses in the <code>select</code> statements execute when no other case is ready, meaning that the <code>selects</code> never block.) This implementation builds a leaky bucket free list in just a few lines, relying on the buffered channel and the garbage collector for bookkeeping.</p>
<p>客户端试图从 <code>freeList</code> 中获取缓冲区；若没有缓冲区可用， 它就将分配一个新的。服务器将 <code>b</code> 放回空闲列表 <code>freeList</code> 中直到列表已满，此时缓冲区将被丢弃，并被垃圾回收器回收。（<code>select</code> 语句中的 <code>default</code> 子句在没有条件符合时执行，这也就意味着 <code>selects</code> 永远不会被阻塞。）依靠带缓冲的信道和垃圾回收器的记录， 我们仅用短短几行代码就构建了一个漏桶 （leaky bucket）空闲列表。</p>
<h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><p>我们已经看到信道非常适合在各个 Go 程间进行通信。</p>
<p>但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p>
<p>这里涉及的概念叫做 <em>互斥（mutual exclusion）</em> ，我们通常使用 <em>互斥锁（Mutex）</em> 这一数据结构来提供这种机制。</p>
<p>Go 标准库中提供了 <a href="https://go-zh.org/pkg/sync/#Mutex"><code>sync.Mutex</code></a> 互斥锁类型及其两个方法：</p>
<ul>
<li><code>Lock</code></li>
<li><code>Unlock</code></li>
</ul>
<p>我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用 <code>Unlock</code> 方法来保证一段代码的互斥执行。参见 <code>Inc</code> 方法。</p>
<p>我们也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。参见 <code>Value</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter 的并发使用是安全的。</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">	v   <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">	mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 增加给定 key 的计数器的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Inc(key <span class="type">string</span>) &#123;</span><br><span class="line">	c.mux.Lock()</span><br><span class="line">	<span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line">	c.v[key]++</span><br><span class="line">	c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 返回给定 key 的计数器的当前值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Value(key <span class="type">string</span>) <span class="type">int</span> &#123;</span><br><span class="line">	c.mux.Lock()</span><br><span class="line">	<span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line">	<span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line">	<span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> c.Inc(<span class="string">&quot;somekey&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(c.Value(<span class="string">&quot;somekey&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><p>A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.</p>
<p>A WaitGroup must not be copied after first use.</p>
<p>In the terminology of the Go memory model, a call to Done “synchronizes before” the return of any Wait call that it unblocks.</p>
<p>在 Go 内存模型的术语中，对 Done 的调用在它解除阻塞的任何 Wait 调用返回之前是同步的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	c &lt;- <span class="number">0</span></span><br><span class="line">	list := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> list &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			tmp := &lt;-c</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%v + %v = %v\n&quot;</span>, tmp, n, tmp+n)</span><br><span class="line">			c &lt;- tmp + n</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次运行，可以发现执行过程并不是同步的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line"><span class="number">3</span> + <span class="number">4</span> = <span class="number">7</span></span><br><span class="line"><span class="number">7</span> + <span class="number">5</span> = <span class="number">12</span></span><br><span class="line"><span class="number">12</span> + <span class="number">3</span> = <span class="number">15</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>库例程 （Library routines）通常需要向调用者返回某种类型的错误提示。之前提到过，Go语言的多值返回特性， 使得它在返回常规的值时，还能轻松地返回详细的错误描述。按照约定，错误的类型通常为 <code>error</code>，这是一个内建的简单接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>库的编写者通过更丰富的底层模型可以轻松实现这个接口，这样不仅能看见错误， 还能提供一些上下文。例如，<code>os.Open</code> 可返回一个 <code>os.PathError</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PathError 记录一个错误以及产生该错误的路径和操作。</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Op <span class="type">string</span>    <span class="comment">// &quot;open&quot;、&quot;unlink&quot; 等等。</span></span><br><span class="line">	Path <span class="type">string</span>  <span class="comment">// 相关联的文件。</span></span><br><span class="line">	Err <span class="type">error</span>    <span class="comment">// 由系统调用返回。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.Op + <span class="string">&quot; &quot;</span> + e.Path + <span class="string">&quot;: &quot;</span> + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PathError</code>的 <code>Error</code> 会生成如下错误信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">open /etc/passwx: no such file or directory</span><br></pre></td></tr></table></figure>

<p>这种错误包含了出错的文件名、操作和触发的操作系统错误，即便在产生该错误的调用 和输出的错误信息相距甚远时，它也会非常有用，这比苍白的“不存在该文件或目录”更具说明性。</p>
<p>错误字符串应尽可能地指明它们的来源，例如产生该错误的包名前缀。例如在 <code>image</code> 包中，由于未知格式导致解码错误的字符串为“image: unknown format”。</p>
<p>若调用者关心错误的完整细节，可使用类型选择或者类型断言来查看特定错误，并抽取其细节。 对于 <code>PathErrors</code>，它应该还包含检查内部的 <code>Err</code> 字段以进行可能的错误恢复。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> try := <span class="number">0</span>; try &lt; <span class="number">2</span>; try++ &#123;</span><br><span class="line">	file, err = os.Create(filename)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC &#123;</span><br><span class="line">		deleteTempFiles()  <span class="comment">// 恢复一些空间。</span></span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的第二条 <code>if</code> 是另一种<a href="https://go-zh.org/doc/effective_go.html#%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2">类型断言</a>。若它失败， <code>ok</code> 将为 <code>false</code>，而 <code>e</code> 则为<code>nil</code>. 若它成功，<code>ok</code> 将为 <code>true</code>，这意味着该错误属于 <code>*os.PathError</code> 类型，而 <code>e</code> 能够检测关于该错误的更多信息。</p>
<h2 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h2><p>向调用者报告错误的一般方式就是将 <code>error</code> 作为额外的值返回。 标准的 <code>Read</code> 方法就是个众所周知的实例，它返回一个字节计数和一个 <code>error</code>。但如果错误是不可恢复的呢？有时程序就是不能继续运行。</p>
<p>为此，我们提供了内建的 <code>panic</code> 函数，它会产生一个运行时错误并终止程序 （但请继续看下一节）。该函数接受一个任意类型的实参（一般为字符串），并在程序终止时打印。 它还能表明发生了意料之外的事情，比如从无限循环中退出了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用牛顿法计算立方根的一个玩具实现。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CubeRoot</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	z := x/<span class="number">3</span>   <span class="comment">// 任意初始值</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1e6</span>; i++ &#123;</span><br><span class="line">		prevz := z</span><br><span class="line">		z -= (z*z*z-x) / (<span class="number">3</span>*z*z)</span><br><span class="line">		<span class="keyword">if</span> veryClose(z, prevz) &#123;</span><br><span class="line">			<span class="keyword">return</span> z</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 一百万次迭代并未收敛，事情出错了。</span></span><br><span class="line">	<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;CubeRoot(%g) did not converge&quot;</span>, x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这仅仅是个示例，实际的库函数应避免 <code>panic</code>。若问题可以被屏蔽或解决， 最好就是让程序继续运行而不是终止整个程序。一个可能的反例就是初始化： 若某个库真的不能让自己工作，且有足够理由产生Panic，那就由它去吧。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = os.Getenv(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;no value for $USER&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Recover"><a href="#Recover" class="headerlink" title="Recover"></a>Recover</h2><p>当 <code>panic</code> 被调用后（包括不明确的运行时错误，例如切片检索越界或类型断言失败）， 程序将立刻终止当前函数的执行，并开始回溯Go程的栈，运行任何被推迟的函数。 若回溯到达Go程栈的顶端，程序就会终止。不过我们可以用内建的 <code>recover</code> 函数来重新取回Go程的控制权限并使其恢复正常执行。</p>
<p>调用 <code>recover</code> 将停止回溯过程，并返回传入 <code>panic</code> 的实参。 由于在回溯时只有被推迟函数中的代码在运行，因此 <code>recover</code> 只能在被推迟的函数中才有效。</p>
<p><code>recover</code> 的一个应用就是在服务器中终止失败的Go程而无需杀死其它正在执行的Go程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(workChan &lt;-<span class="keyword">chan</span> *Work)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> work := <span class="keyword">range</span> workChan &#123;</span><br><span class="line">		<span class="keyword">go</span> safelyDo(work)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safelyDo</span><span class="params">(work *Work)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;work failed:&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	do(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此例中，若 <code>do(work)</code> 触发了Panic，其结果就会被记录， 而该Go程会被干净利落地结束，不会干扰到其它Go程。我们无需在推迟的闭包中做任何事情， <code>recover</code> 会处理好这一切。</p>
<p>由于直接从被推迟函数中调用 <code>recover</code> 时不会返回 <code>nil</code>， 因此被推迟的代码能够调用本身使用了 <code>panic</code> 和 <code>recover</code> 的库函数而不会失败。例如在 <code>safelyDo</code> 中，被推迟的函数可能在调用 <code>recover</code> 前先调用记录函数，而该记录函数应当不受Panic状态的代码的影响。</p>
<p>通过恰当地使用恢复模式，<code>do</code> 函数（及其调用的任何代码）可通过调用 <code>panic</code> 来避免更坏的结果。我们可以利用这种思想来简化复杂软件中的错误处理。 让我们看看 <code>regexp</code> 包的理想化版本，它会以局部的错误类型调用 <code>panic</code> 来报告解析错误。以下是一个 <code>error</code> 类型的 <code>Error</code> 方法和一个 <code>Compile</code> 函数的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Error 是解析错误的类型，它满足 error 接口。</span></span><br><span class="line"><span class="keyword">type</span> Error <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Error)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error 是 *Regexp 的方法，它通过用一个 Error 触发Panic来报告解析错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(regexp *Regexp)</span></span> <span class="type">error</span>(err <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="built_in">panic</span>(Error(err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile 返回该正则表达式解析后的表示。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(str <span class="type">string</span>)</span></span> (regexp *Regexp, err <span class="type">error</span>) &#123;</span><br><span class="line">	regexp = <span class="built_in">new</span>(Regexp)</span><br><span class="line">	<span class="comment">// doParse will panic if there is a parse error.</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">			regexp = <span class="literal">nil</span>    <span class="comment">// 清理返回值。</span></span><br><span class="line">			err = e.(Error) <span class="comment">// 若它不是解析错误，将重新触发Panic。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> regexp.doParse(str), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若 <code>doParse</code> 触发了Panic，恢复块会将返回值设为 <code>nil</code> —被推迟的函数能够修改已命名的返回值。在 <code>err</code> 的赋值过程中， 我们将通过断言它是否拥有局部类型 <code>Error</code> 来检查它。若它没有， 类型断言将会失败，此时会产生运行时错误，并继续栈的回溯，仿佛一切从未中断过一样。 该检查意味着若发生了一些像索引越界之类的意外，那么即便我们使用了 <code>panic</code> 和 <code>recover</code> 来处理解析错误，代码仍然会失败。</p>
<p>通过适当的错误处理，<code>error</code> 方法（由于它是个绑定到具体类型的方法， 因此即便它与内建的 <code>error</code> 类型名字相同也没有关系） 能让报告解析错误变得更容易，而无需手动处理回溯的解析栈：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pos == <span class="number">0</span> &#123;</span><br><span class="line">	re.<span class="type">error</span>(<span class="string">&quot;&#x27;*&#x27; illegal at start of expression&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管这种模式很有用，但它应当仅在包内使用。<code>Parse</code> 会将其内部的 <code>panic</code> 调用转为 <code>error</code> 值，它并不会向调用者暴露出 <code>panic</code>。这是个值得遵守的良好规则。</p>
<p>顺便一提，这种重新触发Panic的惯用法会在产生实际错误时改变Panic的值。 然而，不管是原始的还是新的错误都会在崩溃报告中显示，因此问题的根源仍然是可见的。 这种简单的重新触发Panic的模型已经够用了，毕竟他只是一次崩溃。 但若你只想显示原始的值，也可以多写一点代码来过滤掉不需要的问题，然后用原始值再次触发Panic。 这里就将这个练习留给读者了。</p>
<h1 id="一个Web服务器"><a href="#一个Web服务器" class="headerlink" title="一个Web服务器"></a>一个Web服务器</h1><p>让我们以一个完整的Go程序作为结束吧，一个Web服务器。该程序其实只是个Web服务器的重用。 Google在<a href="http://chart.apis.google.com/">http://chart.apis.google.com</a> 上提供了一个将表单数据自动转换为图表的服务。不过，该服务很难交互， 因为你需要将数据作为查询放到URL中。此程序为一种数据格式提供了更好的的接口： 给定一小段文本，它将调用图表服务器来生成二维码（QR码），这是一种编码文本的点格矩阵。 该图像可被你的手机摄像头捕获，并解释为一个字符串，比如URL， 这样就免去了你在狭小的手机键盘上键入URL的麻烦。</p>
<p>以下为完整的程序，随后有一段解释。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;html/template&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addr = flag.String(<span class="string">&quot;addr&quot;</span>, <span class="string">&quot;:1718&quot;</span>, <span class="string">&quot;http service address&quot;</span>) <span class="comment">// Q=17, R=18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> templ = template.Must(template.New(<span class="string">&quot;qr&quot;</span>).Parse(templateStr))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    http.Handle(<span class="string">&quot;/&quot;</span>, http.HandlerFunc(QR))</span><br><span class="line">    err := http.ListenAndServe(*addr, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;ListenAndServe:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QR</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    templ.Execute(w, req.FormValue(<span class="string">&quot;s&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> templateStr = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">&lt;title&gt;QR Link Generator&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;if .&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;img src=&quot;http://chart.apis.google.com/chart?chs=300x300&amp;cht=qr&amp;choe=UTF-8&amp;chl=&#123;&#123;.&#125;&#125;&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;.&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;form action=&quot;/&quot; name=f method=&quot;GET&quot;&gt;&lt;input maxLength=1024 size=70</span></span><br><span class="line"><span class="string">name=s value=&quot;&quot; title=&quot;Text to QR Encode&quot;&gt;&lt;input type=submit</span></span><br><span class="line"><span class="string">value=&quot;Show QR&quot; name=qr&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p><code>main</code> 之前的代码应该比较容易理解。我们通过一个标志为服务器设置了默认端口。 模板变量 <code>templ</code> 正是有趣的地方。它构建的HTML模版将会被服务器执行并显示在页面中。 稍后我们将详细讨论。</p>
<p><code>main</code> 函数解析了参数标志并使用我们讨论过的机制将 <code>QR</code> 函数绑定到服务器的根路径。然后调用 <code>http.ListenAndServe</code> 启动服务器；它将在服务器运行时处于阻塞状态。</p>
<p><code>QR</code> 仅接受包含表单数据的请求，并为表单值 <code>s</code> 中的数据执行模板。</p>
<p>模板包 <code>html/template</code> 非常强大；该程序只是浅尝辄止。 本质上，它通过在运行时将数据项中提取的元素（在这里是表单值）传给 <code>templ.Execute</code> 执行因而重写了HTML文本。 在模板文本（<code>templateStr</code>）中，双大括号界定的文本表示模板的动作。 从 <code>&#123;&#123;if .&#125;&#125;</code> 到 <code>&#123;&#123;end&#125;&#125;</code> 的代码段仅在当前数据项（这里是点 <code>.</code>）的值非空时才会执行。 也就是说，当字符串为空时，此部分模板段会被忽略。</p>
<p>其中两段 <code>&#123;&#123;.&#125;&#125;</code> 表示要将数据显示在模板中 （即将查询字符串显示在Web页面上）。HTML模板包将自动对文本进行转义， 因此文本的显示是安全的。</p>
<p>余下的模板字符串只是页面加载时将要显示的HTML。如果这段解释你无法理解，请参考 <a href="https://go-zh.org/pkg/html/template/">文档</a> 获得更多有关模板包的解释。</p>
<p>你终于如愿以偿了：以几行代码实现的，包含一些数据驱动的HTML文本的Web服务器。 Go语言强大到能让很多事情以短小精悍的方式解决。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Standard Library by Example</title>
    <url>/2023/Go-Standard-Library-by-Example/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="io-基本I-O接口"><a href="#io-基本I-O接口" class="headerlink" title="io 基本I&#x2F;O接口"></a><code>io</code> 基本I&#x2F;O接口</h1><p><code>io</code> 包为 I&#x2F;O 原语提供了基本的接口。它主要包装了这些原语的已有实现。</p>
<p>由于这些被接口包装的I&#x2F;O原语是由不同的低级操作实现，因此，在另有声明之前不该假定它们的并发执行是安全的。</p>
<p>在 <code>io</code> 包中最重要的是两个接口：<code>Reader</code> 和 <code>Writer</code> 接口。</p>
<h2 id="Reader-接口"><a href="#Reader-接口" class="headerlink" title="Reader 接口"></a><code>Reader</code> 接口</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Reader</code>接口封装了基本的 <code>Read</code> 方法。</p>
<p><code>Read</code> 将 <code>len(p)</code> 个字节读取到 <code>p</code> 中。它返回读取的字节数 <code>n（0 &lt;= n &lt;= len(p)）</code> 以及任何遇到的错误。即使 <code>Read</code> 返回的 <code>n &lt; len(p)</code>，它也会在调用过程中占用 <code>len(p)</code> 个字节作为暂存空间。若可读取的数据不到 <code>len(p)</code> 个字节，<code>Read</code> 会返回可用数据，而不是等待更多数据。</p>
<p>当 <code>Read</code> 在成功读取 <code>n &gt; 0</code> 个字节后遇到一个错误或 EOF (end-of-file)，它会返回读取的字节数。它可能会同时在本次的调用中返回一个non-nil错误,或在下一次的调用中返回这个错误（且 n 为 0）。 一般情况下, Reader会返回一个非0字节数n, 若 <code>n = len(p)</code> 个字节从输入源的结尾处由 Read 返回，<code>Read</code> 可能返回 <code>err == EOF</code> 或者 <code>err == nil</code>。并且之后的 <code>Read()</code> 都应该返回 (n:0, err:EOF)。</p>
<p>调用者在考虑错误之前应当首先处理返回的数据。这样做可以正确地处理在读取一些字节后产生的 I&#x2F;O 错误，同时允许EOF的出现。</p>
<p><code>ReadFrom</code> 函数将 <code>io.Reader</code> 作为参数，也就是说，<code>ReadFrom</code> 可以从任意的地方读取数据，只要来源实现了 <code>io.Reader</code> 接口。比如，我们可以从标准输入、文件、字符串等读取数据，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFrom</span><span class="params">(reader io.Reader, num <span class="type">int</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    p := <span class="built_in">make</span>([]<span class="type">byte</span>, num)</span><br><span class="line">    n, err := reader.Read(p)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p[:n], <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从标准输入读取</span></span><br><span class="line">data, err = ReadFrom(os.Stdin, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从普通文件读取，其中 file 是 os.File 的实例</span></span><br><span class="line">data, err = ReadFrom(file, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串读取</span></span><br><span class="line">data, err = ReadFrom(strings.NewReader(<span class="string">&quot;from string&quot;</span>), <span class="number">12</span>)</span><br></pre></td></tr></table></figure>


<h3 id="func-LimitReader-r-Reader-n-int64-Reader"><a href="#func-LimitReader-r-Reader-n-int64-Reader" class="headerlink" title="func LimitReader(r Reader, n int64) Reader"></a>func LimitReader(r Reader, n int64) Reader</h3><h3 id="func-MultiReader-readers-…Reader-Reader"><a href="#func-MultiReader-readers-…Reader-Reader" class="headerlink" title="func MultiReader(readers …Reader) Reader"></a>func MultiReader(readers …Reader) Reader</h3><h3 id="func-TeeReader-r-Reader-w-Writer-Reader"><a href="#func-TeeReader-r-Reader-w-Writer-Reader" class="headerlink" title="func TeeReader(r Reader, w Writer) Reader"></a>func TeeReader(r Reader, w Writer) Reader</h3><h2 id="ByteReader-接口"><a href="#ByteReader-接口" class="headerlink" title="ByteReader 接口"></a><code>ByteReader</code> 接口</h2><h2 id="type-ByteScanner"><a href="#type-ByteScanner" class="headerlink" title="type ByteScanner"></a>type ByteScanner</h2><h2 id="type-ByteWriter"><a href="#type-ByteWriter" class="headerlink" title="type ByteWriter"></a>type ByteWriter</h2><h2 id="type-Closer"><a href="#type-Closer" class="headerlink" title="type Closer"></a>type Closer</h2><h2 id="type-LimitedReader"><a href="#type-LimitedReader" class="headerlink" title="type LimitedReader"></a>type LimitedReader</h2><h3 id="func-l-LimitedReader-Read-p-byte-n-int-err-error"><a href="#func-l-LimitedReader-Read-p-byte-n-int-err-error" class="headerlink" title="func (l *LimitedReader) Read(p []byte) (n int, err error)"></a>func (l *LimitedReader) Read(p []byte) (n int, err error)</h3><h2 id="type-OffsetWriter"><a href="#type-OffsetWriter" class="headerlink" title="type OffsetWriter"></a>type OffsetWriter</h2><h3 id="func-NewOffsetWriter-w-WriterAt-off-int64-OffsetWriter"><a href="#func-NewOffsetWriter-w-WriterAt-off-int64-OffsetWriter" class="headerlink" title="func NewOffsetWriter(w WriterAt, off int64) *OffsetWriter"></a>func NewOffsetWriter(w WriterAt, off int64) *OffsetWriter</h3><h3 id="func-o-OffsetWriter-Seek-offset-int64-whence-int-int64-error"><a href="#func-o-OffsetWriter-Seek-offset-int64-whence-int-int64-error" class="headerlink" title="func (o *OffsetWriter) Seek(offset int64, whence int) (int64, error)"></a>func (o *OffsetWriter) Seek(offset int64, whence int) (int64, error)</h3><h3 id="func-o-OffsetWriter-Write-p-byte-n-int-err-error"><a href="#func-o-OffsetWriter-Write-p-byte-n-int-err-error" class="headerlink" title="func (o *OffsetWriter) Write(p []byte) (n int, err error)"></a>func (o *OffsetWriter) Write(p []byte) (n int, err error)</h3><h3 id="func-o-OffsetWriter-WriteAt-p-byte-off-int64-n-int-err-error"><a href="#func-o-OffsetWriter-WriteAt-p-byte-off-int64-n-int-err-error" class="headerlink" title="func (o *OffsetWriter) WriteAt(p []byte, off int64) (n int, err error)"></a>func (o *OffsetWriter) WriteAt(p []byte, off int64) (n int, err error)</h3><h2 id="type-PipeReader"><a href="#type-PipeReader" class="headerlink" title="type PipeReader"></a>type PipeReader</h2><h3 id="func-r-PipeReader-Close-error"><a href="#func-r-PipeReader-Close-error" class="headerlink" title="func (r *PipeReader) Close() error"></a>func (r *PipeReader) Close() error</h3><h3 id="func-r-PipeReader-CloseWithError-err-error-error"><a href="#func-r-PipeReader-CloseWithError-err-error-error" class="headerlink" title="func (r *PipeReader) CloseWithError(err error) error"></a>func (r *PipeReader) CloseWithError(err error) error</h3><h3 id="func-r-PipeReader-Read-data-byte-n-int-err-error"><a href="#func-r-PipeReader-Read-data-byte-n-int-err-error" class="headerlink" title="func (r *PipeReader) Read(data []byte) (n int, err error)"></a>func (r *PipeReader) Read(data []byte) (n int, err error)</h3><h2 id="type-PipeWriter"><a href="#type-PipeWriter" class="headerlink" title="type PipeWriter"></a>type PipeWriter</h2><h3 id="func-w-PipeWriter-Close-error"><a href="#func-w-PipeWriter-Close-error" class="headerlink" title="func (w *PipeWriter) Close() error"></a>func (w *PipeWriter) Close() error</h3><h3 id="func-w-PipeWriter-CloseWithError-err-error-error"><a href="#func-w-PipeWriter-CloseWithError-err-error-error" class="headerlink" title="func (w *PipeWriter) CloseWithError(err error) error"></a>func (w *PipeWriter) CloseWithError(err error) error</h3><h3 id="func-w-PipeWriter-Write-data-byte-n-int-err-error"><a href="#func-w-PipeWriter-Write-data-byte-n-int-err-error" class="headerlink" title="func (w *PipeWriter) Write(data []byte) (n int, err error)"></a>func (w *PipeWriter) Write(data []byte) (n int, err error)</h3><h2 id="type-ReadCloser"><a href="#type-ReadCloser" class="headerlink" title="type ReadCloser"></a>type ReadCloser</h2><h3 id="func-NopCloser-r-Reader-ReadCloser"><a href="#func-NopCloser-r-Reader-ReadCloser" class="headerlink" title="func NopCloser(r Reader) ReadCloser"></a>func NopCloser(r Reader) ReadCloser</h3><h2 id="type-ReadSeekCloser"><a href="#type-ReadSeekCloser" class="headerlink" title="type ReadSeekCloser"></a>type ReadSeekCloser</h2><h2 id="type-ReadSeeker"><a href="#type-ReadSeeker" class="headerlink" title="type ReadSeeker"></a>type ReadSeeker</h2><h2 id="type-ReadWriteCloser"><a href="#type-ReadWriteCloser" class="headerlink" title="type ReadWriteCloser"></a>type ReadWriteCloser</h2><h2 id="type-ReadWriteSeeker"><a href="#type-ReadWriteSeeker" class="headerlink" title="type ReadWriteSeeker"></a>type ReadWriteSeeker</h2><h2 id="type-ReadWriter"><a href="#type-ReadWriter" class="headerlink" title="type ReadWriter"></a>type ReadWriter</h2><h2 id="type-Reader"><a href="#type-Reader" class="headerlink" title="type Reader"></a>type Reader</h2><h2 id="type-ReaderAt"><a href="#type-ReaderAt" class="headerlink" title="type ReaderAt"></a>type ReaderAt</h2><h2 id="type-ReaderFrom"><a href="#type-ReaderFrom" class="headerlink" title="type ReaderFrom"></a>type ReaderFrom</h2><h2 id="type-RuneReader"><a href="#type-RuneReader" class="headerlink" title="type RuneReader"></a>type RuneReader</h2><h2 id="type-RuneScanner"><a href="#type-RuneScanner" class="headerlink" title="type RuneScanner"></a>type RuneScanner</h2><h2 id="type-SectionReader"><a href="#type-SectionReader" class="headerlink" title="type SectionReader"></a>type SectionReader</h2><h3 id="func-NewSectionReader-r-ReaderAt-off-int64-n-int64-SectionReader"><a href="#func-NewSectionReader-r-ReaderAt-off-int64-n-int64-SectionReader" class="headerlink" title="func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader"></a>func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader</h3><h3 id="func-s-SectionReader-Read-p-byte-n-int-err-error"><a href="#func-s-SectionReader-Read-p-byte-n-int-err-error" class="headerlink" title="func (s *SectionReader) Read(p []byte) (n int, err error)"></a>func (s *SectionReader) Read(p []byte) (n int, err error)</h3><h3 id="func-s-SectionReader-ReadAt-p-byte-off-int64-n-int-err-error"><a href="#func-s-SectionReader-ReadAt-p-byte-off-int64-n-int-err-error" class="headerlink" title="func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)"></a>func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)</h3><h3 id="func-s-SectionReader-Seek-offset-int64-whence-int-int64-error"><a href="#func-s-SectionReader-Seek-offset-int64-whence-int-int64-error" class="headerlink" title="func (s *SectionReader) Seek(offset int64, whence int) (int64, error)"></a>func (s *SectionReader) Seek(offset int64, whence int) (int64, error)</h3><h3 id="func-s-SectionReader-Size-int64"><a href="#func-s-SectionReader-Size-int64" class="headerlink" title="func (s *SectionReader) Size() int64"></a>func (s *SectionReader) Size() int64</h3><h2 id="type-Seeker"><a href="#type-Seeker" class="headerlink" title="type Seeker"></a>type Seeker</h2><h2 id="type-StringWriter"><a href="#type-StringWriter" class="headerlink" title="type StringWriter"></a>type StringWriter</h2><h2 id="type-WriteCloser"><a href="#type-WriteCloser" class="headerlink" title="type WriteCloser"></a>type WriteCloser</h2><h2 id="type-WriteSeeker"><a href="#type-WriteSeeker" class="headerlink" title="type WriteSeeker"></a>type WriteSeeker</h2><h2 id="type-Writer"><a href="#type-Writer" class="headerlink" title="type Writer"></a>type Writer</h2><h3 id="func-MultiWriter-writers-…Writer-Writer"><a href="#func-MultiWriter-writers-…Writer-Writer" class="headerlink" title="func MultiWriter(writers …Writer) Writer"></a>func MultiWriter(writers …Writer) Writer</h3><h2 id="type-WriterAt"><a href="#type-WriterAt" class="headerlink" title="type WriterAt"></a>type WriterAt</h2><h2 id="type-WriterTo"><a href="#type-WriterTo" class="headerlink" title="type WriterTo"></a>type WriterTo</h2>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>How does Windows decide whether your computer has limited or full Internet access</title>
    <url>/2023/How-does-Windows-decide-whether-your-computer-has-limited-or-full-Internet-access/</url>
    <content><![CDATA[<blockquote>
<p>reference <a href="https://devblogs.microsoft.com/oldnewthing/20221115-00/?p=107399">How does Windows decide whether your computer has limited or full Internet<br>  access?</a></p>
</blockquote>
<p>Windows lets you know when your computer’s Internet connection is limited or absent entirely. What is this sorcery?</p>
<p>Windows attempts to download a file from a dedicated Web server. Depending on which version of Windows, it’s <a href="http://www.msftncsi.com/ncsi.txt">http://www.msftncsi.com/ncsi.txt</a> or <a href="http://www.msftconnecttest.com/connecttest.txt">http://www.msftconnecttest.com/connecttest.txt</a>. If the download is successful and contains the correct contents, then Windows concludes that you have full Internet access.</p>
<p>If something goes wrong, Windows will report either limited or no Internet access, depending on what exactly went wrong.</p>
<p>You can <a href="https://docs.microsoft.com/en-us/troubleshoot/windows-client/networking/internet-explorer-edge-open-connect-corporate-public-network">read more details on docs.microsoft.com</a>.</p>
<p>Linux distros do something similar… e.g. on a current Fedora version, it’s <a href="http://fedoraproject.org/static/hotspot.txt">http://fedoraproject.org/static/hotspot.txt</a>.</p>
<p>Note that as with the Windows version, the protocol is HTTP, not HTTPS – because captive portals completely break TLS, but plaintext HTTP will result in a clean redirect to the portal, allowing the network service to detect the presence of the portal and to bring up a browser window to let the user authenticate.</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>更新 Rocket.Chat</title>
    <url>/2023/Updating-Rocket-Chat/</url>
    <content><![CDATA[<p>本文将对使用Docker Compose部署的Rocket.Chat<a href="https://github.com/filefi/RocketChatDeployment">项目</a>进行升级。</p>
<p>根据官网文档，官方不建议跨大版本升级。理想状态下，甚至不应该跨越2个小版本进行升级。</p>
<details class="note default"><summary><p><a href="https://docs.rocket.chat/deploy/updating-rocket.chat">官方文档</a>原文</p>
</summary>
<ul>
<li><p>For a successful update, you must not skip any major version. That is, say you want to move from version 1.x.x to say 4.x.x, you need to traverse chronologically 1.x.x -&gt; 2.x.x -&gt; 3.x.x -&gt; 4.x.x. Ideally, it’s even better to make more granular steps, and not skip more than two minor versions at a time.</p>
</li>
<li><p>Upgrading to v5 requires you to be on at least 4.x.</p>
</li>
</ul>

</details>

<span id="more"></span>

<h1 id="更新使用Docker部署的-Rocket-Chat"><a href="#更新使用Docker部署的-Rocket-Chat" class="headerlink" title="更新使用Docker部署的 Rocket.Chat"></a>更新使用Docker部署的 Rocket.Chat</h1><h2 id="更新到最新版Rocket-Chat"><a href="#更新到最新版Rocket-Chat" class="headerlink" title="更新到最新版Rocket.Chat"></a>更新到最新版Rocket.Chat</h2><p>拉取最新版的Docker镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull registry.rocket.chat/rocketchat/rocket.chat:latest</span><br></pre></td></tr></table></figure>

<p>停止并删除当前运行中的容器，然后重新运行新容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose stop rocketchat</span><br><span class="line">docker compose rm rocketchat</span><br><span class="line">docker compose up -d rocketchat</span><br></pre></td></tr></table></figure>

<h2 id="更新到指定版本Rocket-Chat"><a href="#更新到指定版本Rocket-Chat" class="headerlink" title="更新到指定版本Rocket.Chat"></a>更新到指定版本Rocket.Chat</h2><p>拉取指定版本的Docker镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull registry.rocket.chat/rocketchat/rocket.chat:latest</span><br></pre></td></tr></table></figure>

<p>要更新到指定版本的Rocket.Chat，需要修改部署目录中的<code>.env</code>配置文件，或者<code>compose.yml</code>文件：</p>
<ul>
<li>修改部署目录中的<code>.env</code>配置文件，将<code>RELEASE</code>变量的值修改为预期的Rocket.Chat版本号：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RELEASE=&lt;desired version&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果未使用<code>.env</code>配置文件，则可以直接修改<code>compose.yml</code>文件中<code>rocketchat</code>服务的<code>image</code>值所对应的Docker镜像tag改为预期的特定版本号：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">  rocketchat:</span><br><span class="line">    image:registry.rocket.chat/rocketchat/rocket.chat:&lt;desired version&gt;</span><br></pre></td></tr></table></figure>

<p>停止并删除当前运行中的容器，然后重新运行新容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose stop rocketchat</span><br><span class="line">docker compose rm rocketchat</span><br><span class="line">docker compose up -d rocketchat</span><br></pre></td></tr></table></figure>

<h2 id="更新到指定版本的MongoDB"><a href="#更新到指定版本的MongoDB" class="headerlink" title="更新到指定版本的MongoDB"></a>更新到指定版本的MongoDB</h2><p>更新MongoDB前应提前对数据库进行备份，以便更新失败后回退。</p>
<h3 id="使用mongodump备份MongoDB"><a href="#使用mongodump备份MongoDB" class="headerlink" title="使用mongodump备份MongoDB"></a>使用<code>mongodump</code>备份MongoDB</h3><blockquote>
<ul>
<li><code>mongodump</code> allows you to create backups from standalone, replica sets or sharded cluster deployments.</li>
<li>As from MongoDB server 4.4, you are required to install the mongodump utility separately. Read more at the MongoDB Database tools docs <a href="https://www.mongodb.com/docs/database-tools/mongodump">https://www.mongodb.com/docs/database-tools/mongodump</a></li>
</ul>
</blockquote>
<p>使用<code>mongodump</code>命令备份远程MongoDB实例，将命令的参数修改为<code>compose.yml</code>中的对应值：</p>
<p><code>mongodump --uri=&quot;mongodb://&lt;host URL/IP&gt;:&lt;Port&gt;&quot; [additional options]</code></p>
<h3 id="使用mongorestore还原MongoDB"><a href="#使用mongorestore还原MongoDB" class="headerlink" title="使用mongorestore还原MongoDB"></a>使用<code>mongorestore</code>还原MongoDB</h3><blockquote>
<ul>
<li>Make sure you drop first any existing rocketchat schema in your database with same name as the one you are restoring.</li>
<li><code>mongorestore</code> allows you to load data from either a binary database dump created by mongodump or the standard input into MongoDB instance.</li>
<li>As from MongoDB server 4.4, you are required to install the mongorestore utility separately. Read more at the MongoDB Database tools docs <a href="https://www.mongodb.com/docs/database-tools/mongorestore/">https://www.mongodb.com/docs/database-tools/mongorestore/</a></li>
</ul>
</blockquote>
<p>根据部署目录中的<code>.env</code>配置文件和<code>compose.yml</code>设置相应的命令行参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongorestore --uri=&quot;mongodb://&lt;host URL/IP&gt;:&lt;Port&gt;&quot; /dump</span><br></pre></td></tr></table></figure>

<h3 id="更新MongoDB"><a href="#更新MongoDB" class="headerlink" title="更新MongoDB"></a>更新MongoDB</h3><p>MongoDB不允许跨大版本更新，必须按大版本逐个更新。假设当前RocketChat所使用的MongoDB版本为4.4，现在要将MongoDB更新到6.0，则需要先将4.4更新到5.0，然后再从5.0更新到6.0。</p>
<details class="note info"><summary><p>前提条件</p>
</summary>
<p>The 4.4 replica set must have <code>featureCompatibilityVersion</code> set to <code>&quot;4.4&quot;</code>. </p>
<p>To ensure that all members of the replica set have <code>featureCompatibilityVersion</code> set to <code>&quot;4.4&quot;</code>, connect to each replica set member and check the <code>featureCompatibilityVersion</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="title function_">adminCommand</span>( &#123; <span class="attr">getParameter</span>: <span class="number">1</span>, <span class="attr">featureCompatibilityVersion</span>: <span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure>
<p>All members should return a result that includes <code>&quot;featureCompatibilityVersion&quot; : { &quot;version&quot; : &quot;4.4&quot; }</code>.</p>
<p>To set or update <code>featureCompatibilityVersion</code>, run the following command on the primary. A majority of the data-bearing members must be available:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="title function_">adminCommand</span>( &#123; <span class="attr">setFeatureCompatibilityVersion</span>: <span class="string">&quot;4.4&quot;</span> &#125; )</span><br></pre></td></tr></table></figure>

<p>The 5.0 replica set must have <code>featureCompatibilityVersion</code> set to <code>&quot;5.0&quot;</code>.</p>
<p>To ensure that all members of the replica set have <code>featureCompatibilityVersion</code> set to <code>&quot;5.0&quot;</code>, connect to each replica set member and check the <code>featureCompatibilityVersion</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="title function_">adminCommand</span>( &#123; <span class="attr">getParameter</span>: <span class="number">1</span>, <span class="attr">featureCompatibilityVersion</span>: <span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure>

<p>All members should return a result that includes <code>&quot;featureCompatibilityVersion&quot; : { &quot;version&quot; : &quot;5.0&quot; }</code>.</p>
<p>To set or update featureCompatibilityVersion, run the following command on the primary. A majority of the data-bearing members must be available:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="title function_">adminCommand</span>( &#123; <span class="attr">setFeatureCompatibilityVersion</span>: <span class="string">&quot;5.0&quot;</span> &#125; )</span><br></pre></td></tr></table></figure>

</details>



<p>以下操作将MongoDB 4.4 升级到 5.0，再从 5.0 更新到 6.0。具体步骤：</p>
<ol>
<li>拉取或加载指定版本的MongoDB镜像。要想将MongoDB 4.4 更新到 6.0，必须先更新到5.0，再从 5.0 更新到 6.0。所以我们需要首先拉取或加载 MongoDB 5.0 和 6.0 的Docker 镜像：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull bitnami/mongodb:5.0</span><br><span class="line">docker pull bitnami/mongodb:6.0</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>进入容器<code>mongodb</code> shell：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it mongodb bash</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入MongoDB shell：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>检查当前MongoDB的<code>featureCompatibilityVersion</code>值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="title function_">adminCommand</span>( &#123; <span class="attr">getParameter</span>: <span class="number">1</span>, <span class="attr">featureCompatibilityVersion</span>: <span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>如果输出结果不为<code>&quot;featureCompatibilityVersion&quot; : &#123; &quot;version&quot; : &quot;4.4&quot; &#125;</code>，则手动设置其值为<code>4.4</code>：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="title function_">adminCommand</span>( &#123; <span class="attr">setFeatureCompatibilityVersion</span>: <span class="string">&quot;4.4&quot;</span> &#125; )</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>修改部署目录中的<code>.env</code>配置文件的MongoDB版本变量（本文所使用的<code>compose.yml</code>部署文件中对应MongoDB版本的变量为<code>MONGODB_VERSION</code>）:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MONGODB_VERSION=5.0</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>停止并删除当前运行<code>mongodb</code>容器，然后重新运行新容器：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose stop mongodb</span><br><span class="line">docker compose rm mongodb</span><br><span class="line">docker compose up -d mongodb</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>检验是否更新成功；</li>
<li>继续。检查当前MongoDB的<code>featureCompatibilityVersion</code>值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="title function_">adminCommand</span>( &#123; <span class="attr">getParameter</span>: <span class="number">1</span>, <span class="attr">featureCompatibilityVersion</span>: <span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>如果输出结果不为<code>&quot;featureCompatibilityVersion&quot; : &#123; &quot;version&quot; : &quot;5.0&quot; &#125;</code>，则手动设置其值为<code>5.0</code>：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="title function_">adminCommand</span>( &#123; <span class="attr">setFeatureCompatibilityVersion</span>: <span class="string">&quot;5.0&quot;</span> &#125; )</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>修改部署目录中的<code>.env</code>配置文件的MongoDB版本变量（本文所使用的<code>compose.yml</code>部署文件中对应MongoDB版本的变量为<code>MONGODB_VERSION</code>）:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MONGODB_VERSION=6.0</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>停止并删除当前运行<code>mongodb</code>容器，然后重新运行新容器：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose stop mongodb</span><br><span class="line">docker compose rm mongodb</span><br><span class="line">docker compose up -d mongodb</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>检查是否更新成功。</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://docs.rocket.chat/deploy/updating-rocket.chat">https://docs.rocket.chat/deploy/updating-rocket.chat</a><br><a href="https://docs.rocket.chat/deploy/prepare-for-your-deployment/rapid-deployment-methods/docker-and-docker-compose">https://docs.rocket.chat/deploy/prepare-for-your-deployment/rapid-deployment-methods/docker-and-docker-compose</a><br><a href="https://docs.rocket.chat/deploy/rocket.chat-environment-configuration/mongodb-configuration/mongodb-backup-and-restore">https://docs.rocket.chat/deploy/rocket.chat-environment-configuration/mongodb-configuration/mongodb-backup-and-restore</a><br><a href="https://www.mongodb.com/docs/manual/release-notes/5.0-upgrade-replica-set/">https://www.mongodb.com/docs/manual/release-notes/5.0-upgrade-replica-set/</a><br><a href="https://www.mongodb.com/docs/manual/release-notes/6.0-upgrade-replica-set/">https://www.mongodb.com/docs/manual/release-notes/6.0-upgrade-replica-set/</a><br><a href="https://www.mongodb.com/docs/manual/tutorial/manage-mongodb-processes/#force-replica-set-shutdown">https://www.mongodb.com/docs/manual/tutorial/manage-mongodb-processes/#force-replica-set-shutdown</a><br><a href="https://www.mongodb.com/compatibility/deploying-a-mongodb-cluster-with-docker">https://www.mongodb.com/compatibility/deploying-a-mongodb-cluster-with-docker</a><br><a href="https://www.mongodb.com/docs/database-tools/mongodump/">https://www.mongodb.com/docs/database-tools/mongodump/</a><br><a href="https://www.mongodb.com/docs/database-tools/mongorestore/">https://www.mongodb.com/docs/database-tools/mongorestore/</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>RocketChat</tag>
        <tag>MongoDB</tag>
        <tag>Docker Compose</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning Scrapy</title>
    <url>/2023/learning-scrapy/</url>
    <content><![CDATA[<h1 id="Scrapy基本抓取流程UR²IM"><a href="#Scrapy基本抓取流程UR²IM" class="headerlink" title="Scrapy基本抓取流程UR²IM"></a>Scrapy基本抓取流程UR²IM</h1><p>一切始于URL，发起Request，由Response检索抽取需要的数据（可能包含更多URL），将数据填充于Item中，方便pipelines对Item进行二次加工（校验、清洗、存储等）。由Response获取更多URL，继续对URL发起抓取流程。</p>
<p><img src="/2023/learning-scrapy/webwxgetmsgimg.jpg" alt="img"></p>
<span id="more"></span>

<h1 id="Scrapy项目基本步骤"><a href="#Scrapy项目基本步骤" class="headerlink" title="Scrapy项目基本步骤"></a>Scrapy项目基本步骤</h1><h2 id="安装-Scrapy"><a href="#安装-Scrapy" class="headerlink" title="安装 Scrapy"></a>安装 Scrapy</h2><p><code>pip</code>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python -m pip install Scrapy</span><br></pre></td></tr></table></figure>

<p><code>conda</code>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ conda install -c conda-forge scrapy</span><br></pre></td></tr></table></figure>

<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a><a href="https://docs.scrapy.org/en/latest/intro/tutorial.html#creating-a-project">创建项目</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ scrapy startproject [项目名]</span><br></pre></td></tr></table></figure>

<p>以项目名为<code>tutorial</code>为例，新创建的项目目录包含以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tutorial/</span><br><span class="line">    scrapy.cfg            # deploy configuration file</span><br><span class="line"></span><br><span class="line">    tutorial/             # project&#x27;s Python module, you&#x27;ll import your code from here</span><br><span class="line">        __init__.py</span><br><span class="line"></span><br><span class="line">        items.py          # project items definition file</span><br><span class="line"></span><br><span class="line">        middlewares.py    # project middlewares file</span><br><span class="line"></span><br><span class="line">        pipelines.py      # project pipelines file</span><br><span class="line"></span><br><span class="line">        settings.py       # project settings file</span><br><span class="line"></span><br><span class="line">        spiders/          # a directory where you&#x27;ll later put your spiders</span><br><span class="line">            __init__.py</span><br><span class="line">            spider.py     # 爬虫文件，用户在其中定义Spider类的子类，Scrapy据此来进行web爬取</span><br></pre></td></tr></table></figure>

<h2 id="创建spider文件"><a href="#创建spider文件" class="headerlink" title="创建spider文件"></a>创建spider文件</h2><p>项目目录中的<code>spiders</code>目录用以存放spiders文件。Scrapy提供了命令行工具，可根据指定模板自动生成spider文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ scrapy.exe genspider -h</span><br><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line">  scrapy genspider [options] &lt;name&gt; &lt;domain&gt;</span><br><span class="line"></span><br><span class="line">Generate new spider using pre-defined templates</span><br><span class="line"></span><br><span class="line">Options</span><br><span class="line">=======</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -l, --list            List available templates</span><br><span class="line">  -e, --edit            Edit spider after creating it</span><br><span class="line">  -d TEMPLATE, --dump TEMPLATE</span><br><span class="line">                        Dump template to standard output</span><br><span class="line">  -t TEMPLATE, --template TEMPLATE</span><br><span class="line">                        Uses a custom template.</span><br><span class="line">  --force               If the spider already exists, overwrite it with the template</span><br><span class="line"></span><br><span class="line">Global Options</span><br><span class="line">--------------</span><br><span class="line">  --logfile FILE        log file. if omitted stderr will be used</span><br><span class="line">  -L LEVEL, --loglevel LEVEL</span><br><span class="line">                        log level (default: DEBUG)</span><br><span class="line">  --nolog               disable logging completely</span><br><span class="line">  --profile FILE        write python cProfile stats to FILE</span><br><span class="line">  --pidfile FILE        write process ID to FILE</span><br><span class="line">  -s NAME=VALUE, --set NAME=VALUE</span><br><span class="line">                        set/override setting (may be repeated)</span><br><span class="line">  --pdb                 enable pdb on failure</span><br></pre></td></tr></table></figure>

<p>如果不指定模板，则默认为<code>basic</code>，查看可用的模板：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ scrapy genspider -l</span><br><span class="line">Available templates:</span><br><span class="line">  basic</span><br><span class="line">  crawl</span><br><span class="line">  csvfeed</span><br><span class="line">  xmlfeed</span><br></pre></td></tr></table></figure>

<p>基于<code>basic</code>模板（默认）创建spider文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapy.exe genspider -t basic myspider example.com</span><br></pre></td></tr></table></figure>

<p>基于<code>crawl</code>模板创建spider文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scrapy.exe genspider -t crawl myspider example.com</span><br></pre></td></tr></table></figure>

<h2 id="定义Spider类"><a href="#定义Spider类" class="headerlink" title="定义Spider类"></a><a href="https://docs.scrapy.org/en/latest/intro/tutorial.html#our-first-spider">定义Spider类</a></h2><p>创建完spider文件，用户必须在spider文件中创建 <a href="https://docs.scrapy.org/en/latest/topics/spiders.html#scrapy.Spider"><code>Spider</code></a>类的子类，并在其中定义初始的请求，同时定义如何解析响应并从中抽取数据。Scrapy 会根据用户自定义的<code>Spider</code>类来进行Web爬取。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// quotes_spider.py</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuotesSpider</span>(scrapy.Spider):</span><br><span class="line">    <span class="comment"># name属性用以识别Spider。同一项目中，不同Spider的name必须唯一。</span></span><br><span class="line">    name = <span class="string">&quot;quotes&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果初始URL是静态的，则可以使用start_url属性替换start_requests方法。</span></span><br><span class="line">    <span class="comment"># start_urls = (&#x27;https://www.example.com/index.html&#x27;,)</span></span><br><span class="line">    <span class="comment"># start_urls = [&#x27;https://www.example.com/index.html&#x27;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果需要动态生成初始URL，则需定义start_requests方法。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">        urls = [</span><br><span class="line">            <span class="string">&quot;https://quotes.toscrape.com/page/1/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://quotes.toscrape.com/page/2/&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url=url, callback=self.parse)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        page = response.url.split(<span class="string">&quot;/&quot;</span>)[-<span class="number">2</span>]</span><br><span class="line">        filename = <span class="string">f&quot;quotes-<span class="subst">&#123;page&#125;</span>.html&quot;</span></span><br><span class="line">        Path(filename).write_bytes(response.body)</span><br><span class="line">        self.log(<span class="string">f&quot;Saved file <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.scrapy.org/en/latest/topics/spiders.html#scrapy.Spider"><code>scrapy.Spider</code></a>的子类包含如下属性和方法：</p>
<ul>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/spiders.html#scrapy.Spider.name"><code>name</code></a>: name属性用以识别Spider。同一项目中，不同Spider的name必须唯一。</p>
</li>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/spiders.html#scrapy.Spider.start_requests"><code>start_requests()</code></a>: must return an iterable of Requests (you can return a list of requests or write a generator function) which the Spider will begin to crawl from. Subsequent requests will be generated successively from these initial requests. 如果需要动态生成初始URL，则需定义<code>start_requests</code>方法。</p>
</li>
<li><p><a href="https://docs.scrapy.org/en/latest/intro/tutorial.html#a-shortcut-to-the-start-requests-method"><code>start_urls</code></a>包含初始URL字符串的序列（tuple或list）。如果初始URL是静态的，则可以使用<code>start_url</code>属性替换<code>start_requests</code>方法。</p>
</li>
<li><p><a href="https://docs.scrapy.org/en/latest/topics/spiders.html#scrapy.Spider.parse"><code>parse()</code></a>: a method that will be called to handle the response downloaded for each of the requests made. The response parameter is an instance of <a href="https://docs.scrapy.org/en/latest/topics/request-response.html#scrapy.http.TextResponse"><code>TextResponse</code></a> that holds the page content and has further helpful methods to handle it.</p>
<p>The <a href="https://docs.scrapy.org/en/latest/topics/spiders.html#scrapy.Spider.parse"><code>parse()</code></a> method usually parses the response, extracting the scraped data as dicts and also finding new URLs to follow and creating new requests (<code>Request</code>) from them.</p>
</li>
</ul>
<h2 id="运行spider"><a href="#运行spider" class="headerlink" title="运行spider"></a><a href="https://docs.scrapy.org/en/latest/intro/tutorial.html#how-to-run-our-spider">运行spider</a></h2><h3 id="scrapy-shell-——-在交互式shell中编写代码"><a href="#scrapy-shell-——-在交互式shell中编写代码" class="headerlink" title="scrapy shell —— 在交互式shell中编写代码"></a><code>scrapy shell</code> —— 在交互式shell中编写代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ scrapy shell -h</span><br><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line">  scrapy shell [url|file]</span><br><span class="line"></span><br><span class="line">Interactive console for scraping the given url or file. Use ./file.html syntax or full path for local file.</span><br><span class="line"></span><br><span class="line">Options</span><br><span class="line">=======</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -c CODE               evaluate the code in the shell, print the result and exit</span><br><span class="line">  --spider SPIDER       use this spider</span><br><span class="line">  --no-redirect         do not handle HTTP 3xx status codes and print response as-is</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="scrapy-parse-——验证Spider-parse方法的结果"><a href="#scrapy-parse-——验证Spider-parse方法的结果" class="headerlink" title="scrapy parse ——验证Spider parse方法的结果"></a><code>scrapy parse</code> ——验证Spider <code>parse</code>方法的结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ scrapy parse -h</span><br><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line">  scrapy parse [options] &lt;url&gt;</span><br><span class="line"></span><br><span class="line">Parse URL (using its spider) and print the results</span><br><span class="line"></span><br><span class="line">Options</span><br><span class="line">=======</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -a NAME=VALUE         set spider argument (may be repeated)</span><br><span class="line">  -o FILE, --output FILE</span><br><span class="line">                        append scraped items to the end of FILE (use - for stdout), to define format set a colon at the end of the output URI (i.e. -o FILE:FORMAT)    </span><br><span class="line">  -O FILE, --overwrite-output FILE</span><br><span class="line">                        dump scraped items into FILE, overwriting any existing file, to define format set a colon at the end of the output URI (i.e. -O FILE:FORMAT)   </span><br><span class="line">  -t FORMAT, --output-format FORMAT</span><br><span class="line">                        format to use for dumping items</span><br><span class="line">  --spider SPIDER       use this spider without looking for one</span><br><span class="line">  --pipelines           process items through pipelines</span><br><span class="line">  --nolinks             don&#x27;t show links to follow (extracted requests)</span><br><span class="line">  --noitems             don&#x27;t show scraped items</span><br><span class="line">  --nocolour            avoid using pygments to colorize the output</span><br><span class="line">  -r, --rules           use CrawlSpider rules to discover the callback</span><br><span class="line">  -c CALLBACK, --callback CALLBACK</span><br><span class="line">                        use this callback for parsing, instead looking for a callback</span><br><span class="line">  -m META, --meta META  inject extra meta into the Request, it must be a valid raw json string</span><br><span class="line">  --cbkwargs CBKWARGS   inject extra callback kwargs into the Request, it must be a valid raw json string</span><br><span class="line">  -d DEPTH, --depth DEPTH</span><br><span class="line">                        maximum depth for parsing requests [default: 1]</span><br><span class="line">  -v, --verbose         print each depth level one by one</span><br></pre></td></tr></table></figure>



<h3 id="scrapy-runspider-——运行给定spider文件中定义的Spider"><a href="#scrapy-runspider-——运行给定spider文件中定义的Spider" class="headerlink" title="scrapy runspider ——运行给定spider文件中定义的Spider"></a><code>scrapy runspider</code> ——运行给定spider文件中定义的Spider</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ scrapy runspider -h</span><br><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line">  scrapy runspider [options] &lt;spider_file&gt;</span><br><span class="line"></span><br><span class="line">Run the spider defined in the given file</span><br><span class="line"></span><br><span class="line">Options</span><br><span class="line">=======</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -o FILE, --output FILE</span><br><span class="line">                        append scraped items to the end of FILE (use - for stdout), to define format set a colon at the end of the output URI (i.e. -o FILE:FORMAT)    </span><br><span class="line">  -O FILE, --overwrite-output FILE</span><br><span class="line">                        dump scraped items into FILE, overwriting any existing file, to define format set a colon at the end of the output URI (i.e. -O FILE:FORMAT)   </span><br><span class="line">  -t FORMAT, --output-format FORMAT</span><br><span class="line">                        format to use for dumping items</span><br></pre></td></tr></table></figure>

<h3 id="scrapy-crawl-——运行特定name的Spider"><a href="#scrapy-crawl-——运行特定name的Spider" class="headerlink" title="scrapy crawl ——运行特定name的Spider"></a><code>scrapy crawl</code> ——运行特定name的Spider</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ scrapy crawl -h    </span><br><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line">  scrapy crawl [options] &lt;spider&gt;</span><br><span class="line"></span><br><span class="line">Run a spider</span><br><span class="line"></span><br><span class="line">Options</span><br><span class="line">=======</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -a NAME=VALUE         set spider argument (may be repeated)</span><br><span class="line">  -o FILE, --output FILE</span><br><span class="line">                        append scraped items to the end of FILE (use - for stdout), to define format set a colon at the end of the output URI (i.e. -o FILE:FORMAT)    </span><br><span class="line">  -O FILE, --overwrite-output FILE</span><br><span class="line">                        dump scraped items into FILE, overwriting any existing file, to define format set a colon at the end of the output URI (i.e. -O FILE:FORMAT)   </span><br><span class="line">  -t FORMAT, --output-format FORMAT</span><br><span class="line">                        format to use for dumping items</span><br></pre></td></tr></table></figure>

<p>在项目顶级目录执行命令来运行Spider：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scrapy crawl quotes</span><br></pre></td></tr></table></figure>

<p>此命令运行name为 <code>quotes</code> 的Spider，得到以下输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">... (omitted for brevity)</span><br><span class="line">2016-12-16 21:24:05 [scrapy.core.engine] INFO: Spider opened</span><br><span class="line">2016-12-16 21:24:05 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)</span><br><span class="line">2016-12-16 21:24:05 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:6023</span><br><span class="line">2016-12-16 21:24:05 [scrapy.core.engine] DEBUG: Crawled (404) &lt;GET https://quotes.toscrape.com/robots.txt&gt; (referer: None)</span><br><span class="line">2016-12-16 21:24:05 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://quotes.toscrape.com/page/1/&gt; (referer: None)</span><br><span class="line">2016-12-16 21:24:05 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://quotes.toscrape.com/page/2/&gt; (referer: None)</span><br><span class="line">2016-12-16 21:24:05 [quotes] DEBUG: Saved file quotes-1.html</span><br><span class="line">2016-12-16 21:24:05 [quotes] DEBUG: Saved file quotes-2.html</span><br><span class="line">2016-12-16 21:24:05 [scrapy.core.engine] INFO: Closing spider (finished)</span><br></pre></td></tr></table></figure>

<h2 id="创建Item"><a href="#创建Item" class="headerlink" title="创建Item"></a>创建Item</h2><p>Web爬取的主要目的是从非结构化的数据源（如，网页）中抽取结构化的数据。Item是以键值对形式定义的Python对象。spiders返回抽取后的数据作为item。</p>
<p>在项目目录的<code>items.py</code>中创建Item并定义字段。</p>
<p>借助 <a href="https://github.com/scrapy/itemadapter">itemadapter</a> 库，Scrapy支持以下多种类型作为item: <a href="https://docs.scrapy.org/en/latest/topics/items.html#dict-items">字典</a>, <a href="https://docs.scrapy.org/en/latest/topics/items.html#item-objects">Item 对象</a>, <a href="https://docs.scrapy.org/en/latest/topics/items.html#dataclass-items">dataclass 对象</a>, and <a href="https://docs.scrapy.org/en/latest/topics/items.html#attrs-items">attrs 对象</a>.</p>
<ul>
<li><strong><code>Item</code>对象</strong></li>
</ul>
<p>定义 <code>Item</code> 类的子类、定义Item字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.item <span class="keyword">import</span> Item, Field</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomItem</span>(<span class="title class_ inherited__">Item</span>):</span><br><span class="line">    one_field = Field()</span><br><span class="line">    another_field = Field()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>dataclass 对象</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomItem</span>:</span><br><span class="line">    one_field: <span class="built_in">str</span></span><br><span class="line">    another_field: <span class="built_in">int</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>attr.s</code> 对象</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> attr</span><br><span class="line"></span><br><span class="line"><span class="meta">@attr.s</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomItem</span>:</span><br><span class="line">    one_field = attr.ib()</span><br><span class="line">    another_field = attr.ib()</span><br></pre></td></tr></table></figure>

<h2 id="使用Item对象"><a href="#使用Item对象" class="headerlink" title="使用Item对象"></a>使用<code>Item</code>对象</h2><h3 id="填充Item"><a href="#填充Item" class="headerlink" title="填充Item"></a>填充Item</h3><p>在项目目录的<code>items.py</code>中创建<code>Item</code>类的子类并定义字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductItem</span>(scrapy.Item):</span><br><span class="line">    name = scrapy.Field()</span><br><span class="line">    price = scrapy.Field()</span><br><span class="line">    stock = scrapy.Field()</span><br><span class="line">    tags = scrapy.Field()</span><br><span class="line">    last_updated = scrapy.Field(serializer=<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>

<p>然后在<code>spiders</code>目录中的spider文件中引入&#96;&#96;items.py&#96;中的Item类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> project.items <span class="keyword">import</span> ProductItem</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasicSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;basic&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;web&quot;</span>]</span><br><span class="line"></span><br><span class="line">    start_urls = (</span><br><span class="line">        <span class="string">&#x27;http://web:9312/properties/property_000000.html&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="comment"># 创建Item对象实例</span></span><br><span class="line">        item = ProductItem()</span><br><span class="line">        item[<span class="string">&#x27;title&#x27;</span>] = response.css(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">        item[<span class="string">&#x27;price&#x27;</span>] = response.css(<span class="string">&#x27;#price&#x27;</span>)</span><br><span class="line">        item[<span class="string">&#x27;description&#x27;</span>] = response.css(<span class="string">&#x27;#description&#x27;</span>)</span><br><span class="line">        item[<span class="string">&#x27;address&#x27;</span>] = response.css(<span class="string">&#x27;#address&#x27;</span>)</span><br><span class="line">        <span class="comment"># 返回 item 对象，将 item 传递给 pipeline</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>

<h3 id="创建Item对象实例"><a href="#创建Item对象实例" class="headerlink" title="创建Item对象实例"></a><a href="https://docs.scrapy.org/en/latest/topics/items.html#creating-items">创建Item对象实例</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>product = Product(name=<span class="string">&quot;Desktop PC&quot;</span>, price=<span class="number">1000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(product)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Product(name=<span class="string">&#x27;Desktop PC&#x27;</span>, price=<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a><a href="https://docs.scrapy.org/en/latest/topics/items.html#getting-field-values">获取字段值</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>product[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">Desktop PC</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>product.get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">Desktop PC</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>product[<span class="string">&quot;price&quot;</span>]</span><br><span class="line"><span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>product[<span class="string">&quot;last_updated&quot;</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    ...</span><br><span class="line">KeyError: <span class="string">&#x27;last_updated&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>product.get(<span class="string">&quot;last_updated&quot;</span>, <span class="string">&quot;not set&quot;</span>)</span><br><span class="line"><span class="keyword">not</span> <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>product[<span class="string">&quot;lala&quot;</span>]  <span class="comment"># getting unknown field</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    ...</span><br><span class="line">KeyError: <span class="string">&#x27;lala&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>product.get(<span class="string">&quot;lala&quot;</span>, <span class="string">&quot;unknown field&quot;</span>)</span><br><span class="line"><span class="string">&#x27;unknown field&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;name&quot;</span> <span class="keyword">in</span> product  <span class="comment"># is name field populated?</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;last_updated&quot;</span> <span class="keyword">in</span> product  <span class="comment"># is last_updated populated?</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;last_updated&quot;</span> <span class="keyword">in</span> product.fields  <span class="comment"># is last_updated a declared field?</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;lala&quot;</span> <span class="keyword">in</span> product.fields  <span class="comment"># is lala a declared field?</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a><a href="https://docs.scrapy.org/en/latest/topics/items.html#setting-field-values">设置字段值</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>product[<span class="string">&quot;last_updated&quot;</span>] = <span class="string">&quot;today&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>product[<span class="string">&quot;last_updated&quot;</span>]</span><br><span class="line">today</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>product[<span class="string">&quot;lala&quot;</span>] = <span class="string">&quot;test&quot;</span>  <span class="comment"># setting unknown field</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    ...</span><br><span class="line">KeyError: <span class="string">&#x27;Product does not support field: lala&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="访问所有已填充的字段"><a href="#访问所有已填充的字段" class="headerlink" title="访问所有已填充的字段"></a><a href="https://docs.scrapy.org/en/latest/topics/items.html#accessing-all-populated-values">访问所有已填充的字段</a></h3><p>To access all populated values, just use the typical <a href="https://docs.python.org/3/library/stdtypes.html#dict"><code>dict</code></a> API:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>product.keys()</span><br><span class="line">[<span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>product.items()</span><br><span class="line">[(<span class="string">&#x27;price&#x27;</span>, <span class="number">1000</span>), (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Desktop PC&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="使用ItemLoader填充item"><a href="#使用ItemLoader填充item" class="headerlink" title="使用ItemLoader填充item"></a>使用<code>ItemLoader</code>填充item</h2><p>工具类<code>ItemLoader</code>提供了很多方法可以方便快速地抽取数据填充item：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scrapy.loader.processors <span class="keyword">import</span> MapCompose, Join</span><br><span class="line"><span class="keyword">from</span> scrapy.loader <span class="keyword">import</span> ItemLoader</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> properties.items <span class="keyword">import</span> PropertiesItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasicSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;basic&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;web&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Start on a property page</span></span><br><span class="line">    start_urls = (</span><br><span class="line">        <span class="string">&#x27;http://web:9312/properties/property_000000.html&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; This function parses a property page.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        @url http://web:9312/properties/property_000000.html</span></span><br><span class="line"><span class="string">        @returns items 1</span></span><br><span class="line"><span class="string">        @scrapes title price description address image_urls</span></span><br><span class="line"><span class="string">        @scrapes url project spider server date</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create the loader using the response</span></span><br><span class="line">        l = ItemLoader(item=PropertiesItem(), response=response)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load fields using XPath expressions</span></span><br><span class="line">        l.add_xpath(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;//*[@itemprop=&quot;name&quot;][1]/text()&#x27;</span>,</span><br><span class="line">                    MapCompose(unicode.strip, unicode.title))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;.//*[@itemprop=&quot;price&quot;][1]/text()&#x27;</span>,</span><br><span class="line">                    MapCompose(<span class="keyword">lambda</span> i: i.replace(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span>), <span class="built_in">float</span>),</span><br><span class="line">                    re=<span class="string">&#x27;[,.0-9]+&#x27;</span>)</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;description&#x27;</span>, <span class="string">&#x27;//*[@itemprop=&quot;description&quot;][1]/text()&#x27;</span>,</span><br><span class="line">                    MapCompose(unicode.strip), Join())</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;address&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;//*[@itemtype=&quot;http://schema.org/Place&quot;][1]/text()&#x27;</span>,</span><br><span class="line">                    MapCompose(unicode.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;image_urls&#x27;</span>, <span class="string">&#x27;//*[@itemprop=&quot;image&quot;][1]/@src&#x27;</span>,</span><br><span class="line">                    MapCompose(<span class="keyword">lambda</span> i: urlparse.urljoin(response.url, i)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Housekeeping fields</span></span><br><span class="line">        l.add_value(<span class="string">&#x27;url&#x27;</span>, response.url)</span><br><span class="line">        l.add_value(<span class="string">&#x27;project&#x27;</span>, self.settings.get(<span class="string">&#x27;BOT_NAME&#x27;</span>))</span><br><span class="line">        l.add_value(<span class="string">&#x27;spider&#x27;</span>, self.name)</span><br><span class="line">        l.add_value(<span class="string">&#x27;server&#x27;</span>, socket.gethostname())</span><br><span class="line">        l.add_value(<span class="string">&#x27;date&#x27;</span>, datetime.datetime.now())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l.load_item()</span><br></pre></td></tr></table></figure>

<h2 id="存储爬取到的数据"><a href="#存储爬取到的数据" class="headerlink" title="存储爬取到的数据"></a>存储爬取到的数据</h2><p>使用 <a href="https://docs.scrapy.org/en/latest/topics/feed-exports.html#topics-feed-exports">Feed exports</a>，无需编写任何额外代码，便可将爬取到的数据保存到文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scrapy crawl myspider -O quotes.json</span><br></pre></td></tr></table></figure>

<p>feed exports 使用 <a href="https://docs.scrapy.org/en/latest/topics/exporters.html#topics-exporters">Item exporters</a> 来序列化爬取到的数据。开箱自带对以下格式的支持：</p>
<ul>
<li><a href="https://docs.scrapy.org/en/latest/topics/feed-exports.html#topics-feed-format-json">JSON</a></li>
<li><a href="https://docs.scrapy.org/en/latest/topics/feed-exports.html#topics-feed-format-jsonlines">JSON lines</a></li>
<li><a href="https://docs.scrapy.org/en/latest/topics/feed-exports.html#topics-feed-format-csv">CSV</a></li>
<li><a href="https://docs.scrapy.org/en/latest/topics/feed-exports.html#topics-feed-format-xml">XML</a></li>
</ul>
<p>开箱自带对以下存储后端的支持：</p>
<ul>
<li><a href="https://docs.scrapy.org/en/latest/topics/feed-exports.html#topics-feed-storage-fs">Local filesystem</a></li>
<li><a href="https://docs.scrapy.org/en/latest/topics/feed-exports.html#topics-feed-storage-ftp">FTP</a></li>
<li><a href="https://docs.scrapy.org/en/latest/topics/feed-exports.html#topics-feed-storage-s3">S3</a> (requires <a href="https://github.com/boto/boto3">boto3</a>)</li>
<li><a href="https://docs.scrapy.org/en/latest/topics/feed-exports.html#topics-feed-storage-gcs">Google Cloud Storage (GCS)</a> (requires <a href="https://cloud.google.com/storage/docs/reference/libraries#client-libraries-install-python">google-cloud-storage</a>)</li>
<li><a href="https://docs.scrapy.org/en/latest/topics/feed-exports.html#topics-feed-storage-stdout">Standard output</a></li>
</ul>
<h2 id="使用contract和命令行工具scrapy-check测试spider的可用性"><a href="#使用contract和命令行工具scrapy-check测试spider的可用性" class="headerlink" title="使用contract和命令行工具scrapy check测试spider的可用性"></a>使用contract和命令行工具<code>scrapy check</code>测试spider的可用性</h2><p>因为被爬取的网站可能会经常更新，从而导致要爬取的网页变化。使用contract和命令行工具<code>scrapy check</code>可以测试当前spider的<code>parse</code>方法是否仍然适应于要爬取的网站。</p>
<p>contract包含在<code>parse</code>方法函数名注释中，并以@开头。其作用是指出该<code>parse</code>方法应该爬取并填充item中的特定字段。并在使用命令行工具<code>scrapy check myspider</code>时，测试该spider的<code>parse</code>方法是否仍然适应于当前网站。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; This function parses a property page.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @url http://web:9312/properties/property_000000.html</span></span><br><span class="line"><span class="string">    @returns items 1</span></span><br><span class="line"><span class="string">    @scrapes title price description address image_urls</span></span><br><span class="line"><span class="string">    @scrapes url project spider server date</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>使用命令行工具测试contract：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ scrapy check -h</span><br><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line">  scrapy check [options] &lt;spider&gt;</span><br><span class="line"></span><br><span class="line">Check spider contracts</span><br><span class="line"></span><br><span class="line">Options</span><br><span class="line">=======</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -l, --list            only list contracts, without checking them</span><br><span class="line">  -v, --verbose         print contract tests for all spiders</span><br></pre></td></tr></table></figure>

<h1 id="实现双向爬取"><a href="#实现双向爬取" class="headerlink" title="实现双向爬取"></a>实现双向爬取</h1><p><strong>纵向与横向爬取：</strong></p>
<ul>
<li><p><strong>横向</strong>：从一个索引页到另外一个索引页。也叫做<strong>水平爬取</strong>，因为这种情况是在同一层级下爬取页面（比如索引页或列表页）。</p>
</li>
<li><p><strong>纵向</strong>：从一个索引页到详情页，并在详情页中抽取数据填充Item。也叫做<strong>垂直爬取</strong>，因为这种方式是从一个更高的层级（比如索引页）到一个更低的层级（比如详情页）。</p>
</li>
</ul>
<p><img src="/2023/learning-scrapy/ch3-1.jpg"></p>
<p><img src="/2023/learning-scrapy/ch3-2.jpg"></p>
<h2 id="手动实现双向爬取"><a href="#手动实现双向爬取" class="headerlink" title="手动实现双向爬取"></a>手动实现双向爬取</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">    <span class="comment"># Get the next index URLs and yield Requests</span></span><br><span class="line">    next_selector = response.xpath(<span class="string">&#x27;//*[contains(@class,&quot;next&quot;)]//@href&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> next_selector.extract():</span><br><span class="line">        <span class="comment"># 返回Request，发起对横向链接的请求</span></span><br><span class="line">        <span class="keyword">yield</span> Request(urlparse.urljoin(response.url, url))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get item URLs and yield Requests</span></span><br><span class="line">    item_selector = response.xpath(<span class="string">&#x27;//*[@itemprop=&quot;url&quot;]/@href&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> item_selector.extract():</span><br><span class="line">        <span class="comment"># 返回Request，发起对纵向链接的请求</span></span><br><span class="line">        <span class="keyword">yield</span> Request(urlparse.urljoin(response.url, url),</span><br><span class="line">                    callback=self.parse_item) <span class="comment"># 将parse_item作为回调函数传递给Request，用以匹配详情页的数据来填充item</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_item</span>(<span class="params">self, response</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; This function parses a property page.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">	  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<h2 id="使用CrawlSpider实现双向爬取"><a href="#使用CrawlSpider实现双向爬取" class="headerlink" title="使用CrawlSpider实现双向爬取"></a>使用CrawlSpider实现双向爬取</h2><p>使用<code>rules</code>变量替换手工实现双向爬取中的水平爬取和垂直爬取。同样的，将<code>parse_item</code>方法作为回调函数传递给<code>Request</code>，用以匹配详情页的数据来填充item。且使用<code>CrawlSpider</code>类和<code>rules</code>变量，则不再需要实现<code>parse</code>方法。</p>
<p><code>LinkExtractor</code>用于抽取链接，默认情况下，它会查找<code>&lt;a&gt;</code>标签的<code>href</code>属性。也可以通过设置<code>tags</code>和<code>attrs</code>参数来进行自定义。</p>
<p>在不设置<code>callback</code>参数的情况下，<code>Rule</code>会跟踪已经抽取的URL，也就是，它会扫描目标页面以获取更多的URL并跟踪它们。如果设置了<code>callback</code>参数，<code>Rule</code>将不会跟踪目标页面中的链接。如果既想设置<code>callback</code>参数，又想让<code>Rule</code>跟踪页面中的链接，则可以将<code>follow</code>参数设置为<code>True</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EasySpider</span>(<span class="title class_ inherited__">CrawlSpider</span>):</span><br><span class="line">    name = <span class="string">&#x27;easy&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;web&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Start on the first index page</span></span><br><span class="line">    start_urls = (</span><br><span class="line">        <span class="string">&#x27;http://web:9312/properties/index_00000.html&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">  	<span class="comment"># Rules for horizontal and vertical crawling</span></span><br><span class="line">    rules = (</span><br><span class="line">        Rule(LinkExtractor(restrict_xpaths=<span class="string">&#x27;//*[contains(@class,&quot;next&quot;)]&#x27;</span>)),</span><br><span class="line">        Rule(LinkExtractor(restrict_xpaths=<span class="string">&#x27;//*[@itemprop=&quot;url&quot;]&#x27;</span>),</span><br><span class="line">             callback=<span class="string">&#x27;parse_item&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_item</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="comment"># 略</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://github.com/scalingexcellence/scrapybook/blob/master/ch03/properties/properties/spiders/easy.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scrapy.loader.processors <span class="keyword">import</span> MapCompose, Join</span><br><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"><span class="keyword">from</span> scrapy.loader <span class="keyword">import</span> ItemLoader</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> properties.items <span class="keyword">import</span> PropertiesItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EasySpider</span>(<span class="title class_ inherited__">CrawlSpider</span>):</span><br><span class="line">    name = <span class="string">&#x27;easy&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;web&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Start on the first index page</span></span><br><span class="line">    start_urls = (</span><br><span class="line">        <span class="string">&#x27;http://web:9312/properties/index_00000.html&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rules for horizontal and vertical crawling</span></span><br><span class="line">    rules = (</span><br><span class="line">        Rule(LinkExtractor(restrict_xpaths=<span class="string">&#x27;//*[contains(@class,&quot;next&quot;)]&#x27;</span>)),</span><br><span class="line">        Rule(LinkExtractor(restrict_xpaths=<span class="string">&#x27;//*[@itemprop=&quot;url&quot;]&#x27;</span>),</span><br><span class="line">             callback=<span class="string">&#x27;parse_item&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_item</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; This function parses a property page.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        @url http://web:9312/properties/property_000000.html</span></span><br><span class="line"><span class="string">        @returns items 1</span></span><br><span class="line"><span class="string">        @scrapes title price description address image_urls</span></span><br><span class="line"><span class="string">        @scrapes url project spider server date</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create the loader using the response</span></span><br><span class="line">        l = ItemLoader(item=PropertiesItem(), response=response)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load fields using XPath expressions</span></span><br><span class="line">        l.add_xpath(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;//*[@itemprop=&quot;name&quot;][1]/text()&#x27;</span>,</span><br><span class="line">                    MapCompose(unicode.strip, unicode.title))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;.//*[@itemprop=&quot;price&quot;][1]/text()&#x27;</span>,</span><br><span class="line">                    MapCompose(<span class="keyword">lambda</span> i: i.replace(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span>), <span class="built_in">float</span>),</span><br><span class="line">                    re=<span class="string">&#x27;[,.0-9]+&#x27;</span>)</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;description&#x27;</span>, <span class="string">&#x27;//*[@itemprop=&quot;description&quot;][1]/text()&#x27;</span>,</span><br><span class="line">                    MapCompose(unicode.strip), Join())</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;address&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;//*[@itemtype=&quot;http://schema.org/Place&quot;][1]/text()&#x27;</span>,</span><br><span class="line">                    MapCompose(unicode.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;image_urls&#x27;</span>, <span class="string">&#x27;//*[@itemprop=&quot;image&quot;][1]/@src&#x27;</span>,</span><br><span class="line">                    MapCompose(<span class="keyword">lambda</span> i: urlparse.urljoin(response.url, i)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Housekeeping fields</span></span><br><span class="line">        l.add_value(<span class="string">&#x27;url&#x27;</span>, response.url)</span><br><span class="line">        l.add_value(<span class="string">&#x27;project&#x27;</span>, self.settings.get(<span class="string">&#x27;BOT_NAME&#x27;</span>))</span><br><span class="line">        l.add_value(<span class="string">&#x27;spider&#x27;</span>, self.name)</span><br><span class="line">        l.add_value(<span class="string">&#x27;server&#x27;</span>, socket.gethostname())</span><br><span class="line">        l.add_value(<span class="string">&#x27;date&#x27;</span>, datetime.datetime.now())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l.load_item()</span><br></pre></td></tr></table></figure>

<h1 id="媒体下载"><a href="#媒体下载" class="headerlink" title="媒体下载"></a>媒体下载</h1><p>Scrapy 的 <a href="https://docs.scrapy.org/en/latest/topics/item-pipeline.html">Item Pipeline</a> 用来对 spider 爬取到的 Item 进行二次加工处理，典型的应用有：</p>
<ul>
<li>清洗HTML数据</li>
<li>验证爬取到的数据（检查items是否包含某些字段）</li>
<li>去重</li>
<li>将爬取到的数据存储到数据库</li>
</ul>
<p>同时，Scrapy 还提供了2个可重用的 Item Pipeline 来方便的实现文件下载和图片下载，它们称为 Media Pipeline。当然，Item Pipeline 是用来对 Item 进行二次加工处理的。所以，<code>FilesPipeline</code>和<code>ImagesPipeline</code>也是对 Item 进行二次加工处理的。<code>FilesPipeline</code>作用于<code>file_urls</code>和<code>files</code>字段，<code>ImagesPipeline</code>作用于<code>image_urls</code>和<code>images</code>字段。</p>
<p><code>FilesPipeline</code>和<code>ImagesPipeline</code>都实现了以下特性：</p>
<ul>
<li>Avoid re-downloading media that was downloaded recently</li>
<li>Specifying where to store the media (filesystem directory, FTP server, Amazon S3 bucket, Google Cloud Storage bucket)</li>
</ul>
<p><code>ImagesPipeline</code>包含一些用于对图片进行处理的额外功能：</p>
<ul>
<li>Convert all downloaded images to a common format (JPG) and mode (RGB)</li>
<li>生成缩略图</li>
<li>Check images width&#x2F;height to make sure they meet a minimum constraint</li>
</ul>
<h2 id="FilesPipeline使用流程"><a href="#FilesPipeline使用流程" class="headerlink" title="FilesPipeline使用流程"></a><a href="https://docs.scrapy.org/en/latest/topics/media-pipeline.html#using-the-files-pipeline"><code>FilesPipeline</code>使用流程</a></h2><p>The typical workflow, when using the <code>FilesPipeline</code> goes like this:</p>
<ol>
<li>In a Spider, you scrape an item and put the URLs of the desired into a <code>file_urls</code> field.</li>
<li>The item is returned from the spider and goes to the item pipeline.</li>
<li>When the item reaches the <code>FilesPipeline</code>, the URLs in the <code>file_urls</code> field are scheduled for download using the standard Scrapy scheduler and downloader (which means the scheduler and downloader middlewares are reused), but with a higher priority, processing them before other pages are scraped. The item remains “locked” at that particular pipeline stage until the files have finish downloading (or fail for some reason).</li>
<li>When the files are downloaded, another field (<code>files</code>) will be populated with the results. This field will contain a list of dicts with information about the downloaded files, such as the downloaded path, the original scraped url (taken from the <code>file_urls</code> field), the file checksum and the file status. The files in the list of the <code>files</code> field will retain the same order of the original <code>file_urls</code> field. If some file failed downloading, an error will be logged and the file won’t be present in the <code>files</code> field.</li>
</ol>
<h2 id="ImagesPipeline使用流程"><a href="#ImagesPipeline使用流程" class="headerlink" title="ImagesPipeline使用流程"></a><a href="https://docs.scrapy.org/en/latest/topics/media-pipeline.html#using-the-images-pipeline"><code>ImagesPipeline</code>使用流程</a></h2><p>Using the <a href="https://docs.scrapy.org/en/latest/topics/media-pipeline.html#scrapy.pipelines.images.ImagesPipeline"><code>ImagesPipeline</code></a> is a lot like using the <code>FilesPipeline</code>, except the default field names used are different: you use <code>image_urls</code> for the image URLs of an item and it will populate an <code>images</code> field for the information about the downloaded images.</p>
<p>The advantage of using the <a href="https://docs.scrapy.org/en/latest/topics/media-pipeline.html#scrapy.pipelines.images.ImagesPipeline"><code>ImagesPipeline</code></a> for image files is that you can configure some extra functions like generating thumbnails and filtering the images based on their size.</p>
<p>The Images Pipeline requires <a href="https://github.com/python-pillow/Pillow">Pillow</a> 7.1.0 or greater. It is used for thumbnailing and normalizing images to JPEG&#x2F;RGB format.</p>
<h2 id="启用-Media-Pipeline"><a href="#启用-Media-Pipeline" class="headerlink" title="启用 Media Pipeline"></a><a href="https://docs.scrapy.org/en/latest/topics/media-pipeline.html#enabling-your-media-pipeline">启用 Media Pipeline</a></h2><p>要启用 media pipeline，需要将其加入到项目的<code>settings.py</code>文件的 <a href="https://docs.scrapy.org/en/latest/topics/settings.html#std-setting-ITEM_PIPELINES"><code>ITEM_PIPELINES</code></a> 设置。</p>
<p>对于 <code>ImagesPipeline</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;<span class="string">&quot;scrapy.pipelines.images.ImagesPipeline&quot;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>FilesPipeline</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;<span class="string">&quot;scrapy.pipelines.files.FilesPipeline&quot;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>然后，还需要将配置文件的下载位置也加入项目的<code>settins.py</code>文件，否则就算是已经设置了项目<code>settins.py</code>中的<code>ITEM_PIPELINES</code>，<code>FilesPipelines</code>和<code>ImagesPipelines</code>依然为disabled。</p>
<p>对于 <code>FilesPipeline</code>, 设置项目<code>settings.py</code>中的<a href="https://docs.scrapy.org/en/latest/topics/media-pipeline.html#std-setting-FILES_STORE"><code>FILES_STORE</code></a> :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FILES_STORE = &quot;/path/to/valid/dir&quot;</span><br></pre></td></tr></table></figure>

<p>对于 <code>ImagesPipeline</code>, 设置项目<code>settings.py</code>中的<a href="https://docs.scrapy.org/en/latest/topics/media-pipeline.html#std-setting-IMAGES_STORE"><code>IMAGES_STORE</code></a>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMAGES_STORE = &quot;/path/to/valid/dir&quot;</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyItem</span>(scrapy.Item):</span><br><span class="line">    <span class="comment"># ... other item fields ...</span></span><br><span class="line">    file_urls = scrapy.Field() <span class="comment"># 必须填充file_urls或image_urls字段，或者指定自定义字段</span></span><br><span class="line">    files = scrapy.Field() <span class="comment"># 必须填充files或images字段，或者指定自定义字段</span></span><br></pre></td></tr></table></figure>

<p>实现<code>FilesPipeline</code>类的子类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> PurePosixPath</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> ItemAdapter</span><br><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> DropItem</span><br><span class="line"><span class="keyword">from</span> scrapy.pipelines.files <span class="keyword">import</span> FilesPipeline</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFilesPipeline</span>(<span class="title class_ inherited__">FilesPipeline</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">file_path</span>(<span class="params">self, request, response=<span class="literal">None</span>, info=<span class="literal">None</span>, *, item=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;files/&quot;</span> + PurePosixPath(urlparse(request.url).path).name</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_media_requests</span>(<span class="params">self, item, info</span>):</span><br><span class="line">      	adapter = ItemAdapter(item)</span><br><span class="line">      	<span class="keyword">for</span> file_url <span class="keyword">in</span> adapter[<span class="string">&quot;file_urls&quot;</span>]:</span><br><span class="line">          	<span class="keyword">yield</span> scrapy.Request(file_url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">item_completed</span>(<span class="params">self, results, item, info</span>):</span><br><span class="line">        file_paths = [x[<span class="string">&quot;path&quot;</span>] <span class="keyword">for</span> ok, x <span class="keyword">in</span> results <span class="keyword">if</span> ok]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> file_paths:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">&quot;Item contains no files&quot;</span>)</span><br><span class="line">        adapter = ItemAdapter(item)</span><br><span class="line">        adapter[<span class="string">&quot;file_paths&quot;</span>] = file_paths</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>

















]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
        <tag>Scraping</tag>
        <tag>Spider</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning vbird 4e</title>
    <url>/2023/learning-vbird-4e/</url>
    <content><![CDATA[<h1 id="Chapter-0-计算机概论"><a href="#Chapter-0-计算机概论" class="headerlink" title="Chapter 0 计算机概论"></a>Chapter 0 计算机概论</h1><h2 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h2><ul>
<li><p><strong>计算机</strong>：接受使用者输入指令与数据，经由中央处理器的数学与逻辑单元运算处理后， 以产生或储存成有用的信息。</p>
</li>
<li><p><strong>计算机5大单元</strong>：计算机由5大单元所组成，包括<strong>输入单元</strong>、 <strong>输出单元</strong>、<strong>CPU 内部的<em>控制单元</em> 和<em>算数逻辑单元</em></strong>，以及<strong>内存</strong>五大部分。</p>
<ul>
<li><strong>输入单元</strong>：包括键盘、鼠标、读卡机、扫描仪、手写板、触摸屏等等一堆；</li>
<li><strong>输出单元</strong>：例如屏幕、打印机等等；</li>
<li><strong>CPU控制单元</strong>：控制单元则主要在协调各周边元件与各单元间的工作；</li>
<li><strong>CPU算数逻辑单元</strong>：算数逻辑单元主要负责程序运算与逻辑判断；</li>
<li><strong>内存</strong>：CPU片内高速缓存价格高昂，使用内存暂存数据。 内存内的数据则是从输入单元所传输进来。而 CPU 处理完毕的数据也必须要先写回内存中，最后数据才从内存传输到输出单元。</li>
</ul>
</li>
</ul>
<p><img src="/2023/learning-vbird-4e/computer02.gif" alt="电脑的五大单元"></p>
<ul>
<li><strong>CPU架构</strong><ul>
<li><strong>精简指令集 （Reduced Instruction Set Computer, RISC）</strong>：这种 CPU 的设计中，微指令集较为精简，每个指令的执行时间都很短，完成的动作也很单纯，指令的执行性能较佳； 但是若要做复杂的事情，就要由多个指令来完成。常见的 RISC 微指令集 CPU 主要例如甲骨文 （Oracle） 公司的 SPARC 系列、 IBM 公司的 Power Architecture （包括 PowerPC） 系列、与安谋公司 （ARM Holdings） 的 ARM CPU 系列等。</li>
<li><strong>复杂指令集（Complex Instruction Set Computer, CISC）</strong>：与RISC不同的，CISC在微指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂， 每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较长， 但每条个别指令可以处理的工作较为丰富。常见的CISC微指令集CPU主要有AMD、Intel、VIA等的x86架构的CPU。</li>
<li>最新的Intel&#x2F;AMD的x86架构中，针对多媒体、虚拟化、省电功能各有哪些重要的微指令集：<ul>
<li>多媒体微指令集：MMX, SSE, SSE2, SSE3, SSE4, AMD-3DNow!</li>
<li>虚拟化微指令集：Intel-VT, AMD-SVM</li>
<li>省电功能：Intel-SpeedStep, AMD-PowerNow!</li>
<li>64&#x2F;32位相容技术：AMD-AMD64, Intel-EM64T</li>
</ul>
</li>
</ul>
</li>
<li><strong>计算机的分类</strong>：如果以计算机的复杂度与运算能力进行分类的话，主要可以分为这几类：<ul>
<li><strong>超级计算机（Supercomputer）</strong>： 超级计算机是运行速度最快的电脑，但是他的维护、操作费用也最高！主要是用于需要有高速计算的计划中。 例如：国防军事、气象预测、太空科技，用在仿真的领域较多。</li>
<li><strong>大型计算机（Mainframe Computer）</strong> ：大型计算机通常也具有数个高速的CPU，功能上虽不及超级计算机，但也可用来处理大量数据与复杂的运算。 例如大型企业的主机、全国性的证券交易所等每天需要处理数百万笔数据的企业机构， 或者是大型企业的数据库服务器等等。</li>
<li><strong>迷你电脑（Minicomputer）</strong>： 迷你电脑仍保有大型计算机同时支持多使用者的特性，但是主机可以放在一般作业场所， 不必像前两个大型计算机需要特殊的空调场所。通常用来作为科学研究、工程分析与工厂的流程管理等。</li>
<li><strong>工作站（Workstation）</strong>：工作站的价格又比迷你电脑便宜许多，是针对特殊用途而设计的电脑。在个人电脑的性能还没有提升到目前的状况之前， 工作站电脑的性能&#x2F;价格比是所有电脑当中较佳的，因此在学术研究与工程分析方面相当常见。</li>
<li><strong>微电脑（Microcomputer）</strong>： 个人电脑就属于这部份的电脑分类。体积最小，价格最低，但功能还是五脏俱全的！ 大致又可分为桌上型、笔记型等等。</li>
</ul>
</li>
<li><strong>容量单位</strong></li>
</ul>
<table>
<thead>
<tr>
<th>进位制</th>
<th>bit</th>
<th>Byte</th>
<th>Kilo</th>
<th>Mega</th>
<th>Giga</th>
<th>Tera</th>
<th>Peta</th>
<th>Exa</th>
<th>Zetta</th>
</tr>
</thead>
<tbody><tr>
<td>二进制</td>
<td>1</td>
<td>8 bit</td>
<td>1024B</td>
<td>1024K</td>
<td>1024M</td>
<td>1024G</td>
<td>1024T</td>
<td>1024P</td>
<td>1024E</td>
</tr>
<tr>
<td>十进制</td>
<td>1</td>
<td>8 bit</td>
<td>1000B</td>
<td>1000K</td>
<td>1000M</td>
<td>1000G</td>
<td>1000T</td>
<td>1000P</td>
<td>1000E</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="个人计算机架构与相关设备"><a href="#个人计算机架构与相关设备" class="headerlink" title="个人计算机架构与相关设备"></a>个人计算机架构与相关设备</h2><p>一般消费者常说的电脑通常指的就是x86的个人计算机架构。由于目前市场占有率还是以 Intel 占大部分，因此下面以目前（2015）相对较新的 Intel 主板架构来谈谈：</p>
<p><img src="/2023/learning-vbird-4e/chipset_z87.jpg" alt="Intel芯片架构"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning Vbird Server 3e</title>
    <url>/2023/learning-vbird-server-3e/</url>
    <content><![CDATA[<h1 id="Chapter-1-架设服务器前的准备工作"><a href="#Chapter-1-架设服务器前的准备工作" class="headerlink" title="Chapter 1 架设服务器前的准备工作"></a>Chapter 1 架设服务器前的准备工作</h1><span id="more"></span>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>FTP</tag>
        <tag>NFS</tag>
        <tag>SELinux</tag>
        <tag>NTP</tag>
        <tag>SSH</tag>
        <tag>RDP</tag>
        <tag>VNC</tag>
        <tag>WWW</tag>
        <tag>NIS</tag>
        <tag>SMB</tag>
        <tag>Samba</tag>
        <tag>Telnet</tag>
        <tag>DNS</tag>
        <tag>TCP Wrappers</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 colly.Context 在 colly.Collector 之间传递自定义数据</title>
    <url>/2023/passing-custom-data-between-colly-collectors/</url>
    <content><![CDATA[<p>爬虫通常需要进行<strong>横向爬取</strong>和<strong>纵向爬取</strong>：</p>
<ul>
<li><p><strong>横向</strong>：从一个索引页到另外一个索引页。也叫做<strong>水平爬取</strong>，因为这种情况是在同一层级下爬取页面（比如索引页或列表页）。</p>
</li>
<li><p><strong>纵向</strong>：从一个索引页到详情页，并在详情页中抽取数据填充Item。也叫做<strong>垂直爬取</strong>，因为这种方式是从一个更高的层级（比如索引页）到一个更低的层级（比如详情页）。</p>
</li>
</ul>
<p>Colly官方文档建议，如果单个爬取作业过于复杂，或者有多个不同的子任务，则应该使用多个<code>colly.Colletor</code>负责不同的子任务。比如，一个负责横向，从索引页获得更多链接。一个负责纵向，爬取详情页中的数据或下载文件。</p>
<p>编写爬虫时，经常需要把一个页面中爬取到的数据传递给下一个请求。例如，由页面A中的数据拼接出下一个Request的URL；或者，由页面A中的数据拼接得到文件名，并将文件名传递给下载文件的Request，用来设置下载文件的文件名。</p>
<p>在 Scrapy 中，我们可以通过<code>Request</code>的<code>meta</code>属性向<code>Response</code>传递数据。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 将数据存放如 request的meta属性中</span></span><br><span class="line">  	<span class="keyword">yield</span> Request(url, meta=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">12</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">		item = Item()</span><br><span class="line">    <span class="comment"># 从response.meta中取出数据</span></span><br><span class="line">    item[<span class="string">&#x27;name&#x27;</span>] = response.meta[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    item[<span class="string">&#x27;age&#x27;</span>] = response.meta[<span class="string">&#x27;age&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">  	request = Request(url)</span><br><span class="line">    <span class="comment"># 将数据存放如 request的meta属性中</span></span><br><span class="line">    request.meta = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">12</span>&#125;</span><br><span class="line">    <span class="keyword">yield</span> request</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">		item = Item()</span><br><span class="line">    <span class="comment"># 从response.meta中取出数据</span></span><br><span class="line">    item[<span class="string">&#x27;name&#x27;</span>] = response.meta[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    item[<span class="string">&#x27;age&#x27;</span>] = response.meta[<span class="string">&#x27;age&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>那么，在 <a href="http://go-colly.org/">Colly</a> 中该如何在 <code>colly.Collector</code> 之间传递数据呢？</p>
<span id="more"></span>



<p>借助 <a href="https://github.com/gocolly/colly/blob/v2.1.0/context.go#L22"><code>colly.Context</code></a> ，我们可以在 <code>colly.Collector</code> 之间传递自定义数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据官方文档，<a href="https://github.com/gocolly/colly/blob/v2.1.0/context.go#L22"><code>colly.Context</code></a> 用来在 callbacks 之间传递数据。</p>
<p><a href="https://github.com/gocolly/colly/blob/v2.1.0/context.go#L22"><code>colly.Context</code></a>相关的函数：</p>
<ul>
<li><a href="https://pkg.go.dev/github.com/gocolly/colly/v2#NewContext"><code>NewContext</code></a>: <code>NewContext</code> initializes a new <code>Context</code> instance.</li>
</ul>
<p><a href="https://github.com/gocolly/colly/blob/v2.1.0/context.go#L22"><code>colly.Context</code></a>的方法：</p>
<ul>
<li><a href="https://pkg.go.dev/github.com/gocolly/colly/v2#Context.Put"><code>Put</code></a>: <code>Put</code> stores a value of any type in <code>Context</code>.</li>
<li><a href="https://pkg.go.dev/github.com/gocolly/colly/v2#Context.Get"><code>Get</code></a>: <code>Get</code> retrieves a string value from <code>Context</code>. <code>Get</code> returns an empty string if key not found.</li>
<li><a href="https://pkg.go.dev/github.com/gocolly/colly/v2#Context.GetAny"><code>GetAny</code></a>: <code>GetAny</code> retrieves a value from <code>Context</code>. <code>GetAny</code> returns nil if key not found.</li>
<li><a href="https://pkg.go.dev/github.com/gocolly/colly/v2#Context.ForEach"><code>ForEach</code></a>: <code>ForEach</code> iterate context.</li>
<li><a href="https://pkg.go.dev/github.com/gocolly/colly/v2#Context.MarshalBinary"><code>MarshalBinary</code></a>: <code>MarshalBinary</code> encodes <code>Context</code> value This function is used by request caching.</li>
<li><a href="https://pkg.go.dev/github.com/gocolly/colly/v2#Context.UnmarshalBinary"><code>UnmarshalBinary</code></a>: <code>UnmarshalBinary</code> decodes <code>Context</code> value to nil This function is used by request caching.</li>
</ul>
<p>实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gocolly/colly/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := colly.NewCollector(</span><br><span class="line">		colly.UserAgent(<span class="string">&quot;myUserAgent&quot;</span>),</span><br><span class="line">		colly.AllowedDomains(<span class="string">&quot;example.com&quot;</span>),</span><br><span class="line">	)</span><br><span class="line">	c2 := c.Clone()</span><br><span class="line"></span><br><span class="line">	c.OnResponse(<span class="function"><span class="keyword">func</span><span class="params">(r *colly.Response)</span></span> &#123;</span><br><span class="line">		<span class="comment">// data items you scraped</span></span><br><span class="line">		filename := <span class="string">&quot;custom_name.html&quot;</span></span><br><span class="line">		url := <span class="string">&quot;http://example.com/index.html&quot;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Context provides a tiny layer for passing data between callbacks</span></span><br><span class="line">		<span class="comment">// Put stores a value of any type in Context</span></span><br><span class="line">		r.Ctx.Put(<span class="string">&quot;filename&quot;</span>, filename)</span><br><span class="line">		r.Ctx.Put(<span class="string">&quot;url&quot;</span>, url)</span><br><span class="line">		item := Item&#123;Name: <span class="string">&quot;Mike&quot;</span>, Age: <span class="number">12</span>&#125;</span><br><span class="line">		r.Ctx.Put(<span class="string">&quot;item&quot;</span>, item)</span><br><span class="line">		<span class="comment">// Use collector’s Request() function to be able to share context with other collectors.</span></span><br><span class="line">		c2.Request(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">nil</span>, r.Ctx, <span class="literal">nil</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	c2.OnResponse(<span class="function"><span class="keyword">func</span><span class="params">(r *colly.Response)</span></span> &#123;</span><br><span class="line">		<span class="comment">// Get retrieves a string value from Context. Get returns an empty string if key not found</span></span><br><span class="line">		filename := r.Ctx.Get(<span class="string">&quot;filename&quot;</span>)</span><br><span class="line">		url := r.Ctx.Get(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// `GetAny` retrieves a value from `Context`. `GetAny` returns nil if key not found.</span></span><br><span class="line">		item := r.Ctx.GetAny(<span class="string">&quot;item&quot;</span>).(Item) <span class="comment">// 取出对象，并断言为Item类型</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;filename:%s url:%s item:%v&quot;</span>, filename, url, item)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// now you can custom the path</span></span><br><span class="line">		r.Save(filename)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	c.Visit(<span class="string">&quot;http://example.com&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后可成功下载文件，并将其保存为自定义的文件名。同时输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run .\main.go</span><br><span class="line">filename:custom_name.html url:http://example.com/index.html item:&#123;Mike 12&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Spider</tag>
        <tag>Colly</tag>
        <tag>Web Scraping</tag>
        <tag>Scraper</tag>
        <tag>Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>Cheat Engine Tutorial 学习笔记2：指令查找</title>
    <url>/2024/cheat_engine_tutorial2/</url>
    <content><![CDATA[<p>本文重点介绍：</p>
<ul>
<li>如何查找对特定地址进行访问或修改的操作指令</li>
</ul>
<p>CE版本如下：</p>
<ul>
<li><p>Cheat Engine Version: 7.4和7.5</p>
</li>
<li><p>Tutorial Version: v3.6</p>
</li>
</ul>
<span id="more"></span>

<h3 id="Step-5"><a href="#Step-5" class="headerlink" title="Step 5"></a>Step 5</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Step 5: Code finder (PW=888899)</span><br><span class="line">Sometimes the location of a value is stored at changes, when you restart the game, or even while you&#x27;re playing. In that case you can use 2 things to still make a table that works.</span><br><span class="line">In this step I&#x27;ll try to describe how to use the Code Finder function.</span><br><span class="line"></span><br><span class="line">The value down here will be at a different location each time you start the tutorial, so a normal entry in the address list wouldn&#x27;t work.</span><br><span class="line">First try to find the address. (You&#x27;ve got to this point so I assume you know how to do that.)</span><br><span class="line">When you&#x27;ve found the address, right-click the address in Cheat Engine and choose &quot;Find out what writes to this address&quot;. A window will pop up with an empty list.</span><br><span class="line">Then click on the Change value button in this tutorial, and go back to Cheat Engine. If everything went right, there should be an address with assembler code there now.</span><br><span class="line">Click it and choose the Replace option to replace it with code that does nothing. That will also add the code address to the code list in the Advanced Options window. (Which gets saved if you save your table.)</span><br><span class="line"></span><br><span class="line">Click on Stop, so the game will start running normal again, and click on Close to close the window.</span><br><span class="line">Now, click on Change value, and if everything went right the Next button should become enabled.</span><br><span class="line"></span><br><span class="line">Note: When you&#x27;re freezing the address with a high enough speed it may happen that Next becomes visible anyhow.</span><br></pre></td></tr></table></figure>

<p>Step 5 主要介绍了如何找到有哪些汇编操作指令在修改特定地址中的值，并使用空指令<code>nop</code>替换该指令。</p>
<p>首先，使用精确值扫描找到 Health 的地址：</p>
<p><img src="/2024/cheat_engine_tutorial2/image-20240503184856179.png"></p>
<p>这里省略了 Health 地址的查找过程：</p>
<p><img src="/2024/cheat_engine_tutorial2/image-20240503185455807.png"></p>
<p><strong>找到 Health 的地址之后，接下来，我们要使用 CE 的 code finder 查找是哪些汇编操作指令在访问或修改 Health 所在地址中保存的值。</strong></p>
<p>鼠标右键点击 addresslist 中的地址条目，然后在右键菜单中点击<code>Find out what accesses this address</code>或者<code>Find out what writes to this address</code>，查找对该地址进行访问或修改的汇编操作指令。在这里，由于我们已经知道操作是在修改 Health 的值，那么基本上是在对 Health 所在地址进行写入操作，我们点击<code>Find out what writes to this address</code>：</p>
<p><img src="/2024/cheat_engine_tutorial2/image-20240503190432364.png"></p>
<p>点击<code>Find out what writes to this address</code>之后，会弹出提示框询问是否将 CE 的 debugger 附加到 CE Tutorial 的进程以便对 CE Tutorial 进行调试。点击 Yes 以继续：</p>
<p><img src="/2024/cheat_engine_tutorial2/image-20240503191226920.png"></p>
<p>然后，回到 Tutorial 点击 <code>Change value</code>改变 Health 的值。</p>
<p><img src="/2024/cheat_engine_tutorial2/image-20240503192355706.png"></p>
<p>点击<code>Change value</code>后，可以看到 debugger 跟踪到了一个向 Health 所在地址 <code>015A7E00</code> 写入值的操作指令。有时候，也有可能会跟踪到多个修改地址中值的操作指令，尤其是使用<code>Find out what accesses this address</code>时，可能会有很多操作指令都在访问某个特定地址。</p>
<p>鼠标双击找到的操作指令条目，以查看详情：</p>
<p><img src="/2024/cheat_engine_tutorial2/image-20240503194159974.png"></p>
<p>通过详情我们可以发现，对 Health 地址中的值进行实际修改的操作指令是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov [rax],edx</span><br></pre></td></tr></table></figure>

<p>点击<code>Option</code>按钮，这将会用空指令<code>nop</code>替换现有指令<code>mov [rax],edx</code>：</p>
<p><img src="/2024/cheat_engine_tutorial2/image-20240503213822275.png"></p>
<p>这将会导致，当我们点击<code>Change value</code>时，在执行地址为<code>10002CB88</code>的指令时，不再执行<code>mov [rax],edx</code>而是执行空操作指令<code>nop</code>，即什么都不做，因此 Health 的值将不会被修改。同时，还会自动把这条指令的地址添加到 <code>Advanced Options</code> 中的 code list 中。</p>
<p>点击 <code>Advanced Options</code>打开 code list：</p>
<p><img src="/2024/cheat_engine_tutorial2/image-20240503215159161.png"></p>
<p><img src="/2024/cheat_engine_tutorial2/image-20240503215246295.png"></p>
<p>右键选中条目，打开右键菜单：</p>
<p><img src="/2024/cheat_engine_tutorial2/image-20240503215532647.png"></p>
<p>选择<code>Open disassembler at this location</code>，在此位置打开反汇编器：</p>
<p><img src="/2024/cheat_engine_tutorial2/image-20240503215732870.png"></p>
<p>点击<code>Change value</code>验证结果：</p>
<p><img src="/2024/cheat_engine_tutorial2/image-20240503214544723.png"></p>
]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
        <tag>PWN</tag>
        <tag>CheatEngine</tag>
      </tags>
  </entry>
  <entry>
    <title>Cheat Engine Tutorial 学习笔记3：手动查找指针与基地址指针</title>
    <url>/2024/cheat_engine_tutorial3/</url>
    <content><![CDATA[<p>本文重点介绍：</p>
<ul>
<li>手动查找指针与基地址指针</li>
</ul>
<p>CE版本如下：</p>
<ul>
<li><p>Cheat Engine Version: 7.4和7.5</p>
</li>
<li><p>Tutorial Version: v3.6</p>
</li>
</ul>
<span id="more"></span>


<h1 id="指针与基地址指针"><a href="#指针与基地址指针" class="headerlink" title="指针与基地址指针"></a>指针与基地址指针</h1><p>使用精确或模糊值扫描找到的值的地址，在每次重新运行程序后可能都是会变的。甚至，很多情况下，不需要重新运行程序，只是切换了程序或游戏的菜单，或是游戏结束了一轮战斗，或者游戏切换了地图，就足以让刚才找到值所在地址引用失效。</p>
<p>为了让外挂在每次重新运行程序后都能准确地定位到特定目标值所在的地址，就需要找到基于程序基地址指向特定目标值所在地址的指针。换句话说，就是需要找到这样一个指针，这个指针指向特定目标值所在的地址，同时，这个指针还必须由程序基地址偏移得到。</p>
<p><strong>要找到基地址指针通常有2种方法：</strong></p>
<ul>
<li>手动查找；</li>
<li>使用<code>Generate pointermap</code>和<code>Pointer scan for this address</code>进行自动查找。</li>
</ul>
<h2 id="手动查找"><a href="#手动查找" class="headerlink" title="手动查找"></a>手动查找</h2><p><strong>操作思路：</strong></p>
<ol>
<li>使用精确或模糊值查找找到目标数值（本例中，即Health）所在的地址；</li>
<li>通过<code>Find out what accesses this address</code>或者<code>Find out what accesses this address</code>查找是哪些指令在访问目标数值（本例中，即Health）的地址；</li>
<li>通过“访问目标数值的汇编指令”推测指向目标数值（本例中，即Health）所在地址的指针的值。</li>
<li>找到指针的值（众所周知“指针的值是一个内存地址”）后，通过“精确值扫描”查找这个地址值，找到哪个地址存放了这个地址值（通常扫描结果不止一个）。</li>
<li>如果足够幸运，第1次扫描得到的指针中就是基地址指针，那么手动查找到底结束。但通常情况下，都必须查找多级指针（即指向指针的指针，指向指针的指针的指针…）才能找到。</li>
</ol>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>对于Step 2，如前所述，首先使用精确值扫描找到 Health 的地址：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427192717805.png"></p>
<p>鼠标指向找到的 Health 地址，鼠标右键单击，在右键菜单中选中<code>Find out what accesses this address</code>或者<code>Find out what accesses this address</code>：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427193150926.png"></p>
<p>在当前情况下，点击 <code>Hit me</code>是修改 Health的数值，所以也算是写入操作，可以点击<code>Find out what writes to this address</code>，尝试先查找看看是哪个地址的操作在向 Health的地址<code>014B2E78</code>写入数值：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427193657655.png"></p>
<p>点击后会提示将调试器附加到当前进程。随后，CE的调试器会跟踪对Health当前地址<code>014B2E78</code>进行写入的操作码：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427193939860.png"></p>
<p>我们点击一下<code>Hit me</code>，触发一下对Health的修改：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427194347707.png"></p>
<p>鼠标双击这条指令，查看详细信息：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427195343453.png"></p>
<p>可以看到，汇编指令<code>sub [rbx+000007F8],eax</code>在修改 Health 的值。因此，我们大概可以猜到<code>[rbx+000007F8]</code>这个地址应该就是 Health 的地址，并且它是由 rbx寄存器中的值偏移<code>000007F8</code>个地址后得到的。那么，rbx 寄存器的值<code>014B2680</code>应该是一个指针的值；并且CE也提示我们，在访问当前Health地址的指针的值可能是<code>014B2680</code>。</p>
<blockquote>
<p>在C语言中，指针作为一种特殊的数据类型，其特点是：指针的值是一个内存地址，通过使用指针，我们可以直接访问或修改指针指向的地址的值。</p>
</blockquote>
<p><strong>既然我们已经知道了这个指针的值<code>014B2680</code>，就可以利用精确值查找的方式找到这个指针的地址。</strong></p>
<p>右键单击或者<code>Ctrl+C</code>可以方便地直接复制这个CE猜测的可能的地址值：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427201327543.png"></p>
<p>点击开启新扫描：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427203555631.png"></p>
<p>填入指针的值，开始第1次扫描：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427204053742.png"></p>
<blockquote>
<p>注意：对于32位平台，指针的大小为4Bytes；64位平台指针的大小位8Bytes。</p>
</blockquote>
<p>通过搜索，我们可以到有哪些地址存放了<code>014B2680</code>这个地址值。可以看到，这63个地址都存放了<code>014B2680</code>这个地址值，那么可能这63个地址都是指针。</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427204348679.png"></p>
<p>有时候，搜索到的结果可能会很多，比如这一次。但幸运的是，可以看到其中有2个绿色的结果，这2个指针就是基于基地址得到的指针。我们可以将它们加入 addresslist 中测试一下是否是我们要找的：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427214934304.png"></p>
<p>双击 addresslist 中的条目，勾选<code>Poniter</code>：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427215129721.png"></p>
<p>可以看到这个基地址指针指向地址正是<code>014B2680</code>，那么可以通过地址<code>014B2680</code>偏移<code>000007F8</code>个地址获得Health所在的地址：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427215439053.png"></p>
<p>修改指针的偏移（offset），验证指针的指向：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427220012598.png"></p>
<p>可以看到，偏移后的地址正好与之前精确值搜索得到的 Health 的地址相同。取消勾选<code>Hexadecimal</code>以十进制显示地址中存放的值，发现值也与 Health 的值相同：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427220425180.png"></p>
<p>以同样的方法修改另一个基地址指针的偏移量：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427220831354.png"></p>
<p>修改后的 addresslist：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427220909297.png"></p>
<p>点击<code>Hit me</code>修改 Health的值，验证 addresslist 中的基地址指针所指向的地址中的值是否会保持一致：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427221052785.png"></p>
<p>可以看到，第一个基地址指针所指向的地址中的值的变化与Health相同，但第二个就不同了：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427221407502.png"></p>
<p>双击查看详情。可以看到，虽然基地址指针的地址没有变化，但是指针的值已经变了。</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427222121253.png"></p>
<p>现在看来，基地址指针<code>&quot;Tutorial-x86_64.exe&quot;+325A70</code>似乎就是我们要找的。我们将Cheat Tables保存为CT文件：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427223149334.png"></p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427223434239.png"></p>
<p>关闭并重新运行 Cheat Engine Tutorial，并加载保存的CT文件：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427223652501.png"></p>
<p>可以看到，之前使用“精确值扫描”找到的地址的值现在已经没法与 CE Tutorial Step 2 的 Health 的值保持一致了，但是基地址指针指向的地址的值依然与 Health 保持一致：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427224024302.png"></p>
<p>将基地址指针指向的地址的值修改为1000，便可立即通关Step 2：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427224206566.png"></p>
<p>Step 2 的按钮<code>Next</code>现在变为可点击：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240427224237129.png"></p>
<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>对于 Step 3, 如前所述，首先使用模糊值扫描找到 Health 的地址：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428221438182.png"></p>
<p>当然如果明确知道值减少了多少，也可以使用<code>decreased value by</code>：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428221758590.png"></p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428221857452.png"></p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428221936547.png"></p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428222024168.png"></p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428222146299.png"></p>
<p>经过验证，发现确实是这个地址保存了 Health 的值：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428222257932.png"></p>
<p>继续手动查找 Step 3 中 Health 的基地址指针。在右键菜单中选中<code>Find out what accesses this address</code>或者<code>Find out what accesses this address</code>，调用debugger，查找访问或修改了这个地址的值的操作：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428222703326.png"></p>
<p>点击<code>Hit me</code>，触发对 Health 值的修改：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428223127849.png"></p>
<p>双击查看<code>Extra info</code>：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428223937001.png"></p>
<p>使用精确值扫描查找指针：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428224650698.png"></p>
<p>虽然扫描得到的结果很多，但幸运的是，其中一个是基地址指针。我们将它加入 addresslist ，测试并验证基地址指针：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428225155145.png"></p>
<p>修改基地址指针的偏移量：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428230244637.png"></p>
<p>准备重新运行Tutorial程序，验证基地址指针：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428230410805.png"></p>
<p>重新运行Tutorial程序后，发现基地址指针所指向的地址的值在合理范围内，似乎是有效的。</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428230713755.png"></p>
<p>修改基地址指针所指向地址的值，验证一下：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240428231014800.png"></p>
<p>到这里，Step 3 中 Health 的基地址指针也找到了。</p>
<h3 id="Step-6"><a href="#Step-6" class="headerlink" title="Step 6"></a>Step 6</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Step 6: Pointers: (PW=098712)</span><br><span class="line">In the previous step I explained how to use the Code finder to handle changing locations. But that method alone makes it difficult to find the address to set the values you want.</span><br><span class="line">That&#x27;s why there are pointers:</span><br><span class="line"></span><br><span class="line">At the bottom you&#x27;ll find 2 buttons. One will change the value, and the other changes the value AND the location of the value.</span><br><span class="line">For this step you don&#x27;t really need to know assembler, but it helps a lot if you do.</span><br><span class="line"></span><br><span class="line">First find the address of the value. When you&#x27;ve found it use the function to find out what accesses this address.</span><br><span class="line">Change the value again, and an item will show up in the list. Double click that item. (or select and click on more info) and a new window will open with detailed information on what happened when the instruction ran.</span><br><span class="line">If the assembler instruction doesn&#x27;t have anything between a &#x27;[&#x27; and &#x27;]&#x27; then use another item in the list.</span><br><span class="line">If it does it will say what it think will be the value of the pointer you need.</span><br><span class="line">Go back to the main cheat engine window (you can keep this extra info window open if you want, but if you close it, remember what is between the &#x27;[&#x27; and &#x27;]&#x27; ) and do a 4 byte scan in hexadecimal for the value the extra info told you.</span><br><span class="line">When done scanning it may return 1 or a few hundred addresses. Most of the time the address you need will be the smallest one. Now click on the &quot;Add Address Manually&quot; button and select the pointer checkbox.</span><br><span class="line"></span><br><span class="line">The window will change and allow you to type in the address of a pointer and an offset.</span><br><span class="line">Fill in the address you just found. It can be in the form: &quot;Tutorial-i386.exe&quot;+xxxxxx (relative to the process), </span><br><span class="line">or you can double click the address to add it to the address list and use the absolute address which appears there.</span><br><span class="line">If the assembler instruction has a calculation (e.g: [esi+12]) at the end then type the value in that&#x27;s at the end above the address field. This is the offset. Otherwise leave it 0. If it was a more complicated instruction look at the following calculation.</span><br><span class="line"></span><br><span class="line">Example of a more complicated instruction:</span><br><span class="line">[EAX*2+EDX+00000310] eax=4C and edx=00801234.</span><br><span class="line">In this case EDX would be the value the pointer has, and EAX*2+00000310 the offset, so the offset you&#x27;d fill in would be 2*4C+00000310=3A8. (This is all in hex, use calc.exe from Windows in Programmer mode to calculate hex values.)</span><br><span class="line"></span><br><span class="line">Back to the tutorial, click OK and the address will be added. If all went right the address will show P-&gt;xxxxxxx, with xxxxxxx being the address of the value you found. If that&#x27;s not right, you&#x27;ve done something wrong.</span><br><span class="line">Now, change the value using the pointer you added in to 5000 and click in the &#x27;Active&#x27; coloumn to freeze it. Then click Change pointer, and if all went right the Next button will become visible.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extra:</span><br><span class="line">You could also use the pointer scanner to find the pointer to this address. https://cheatengine.org/help/pointer-scan.htm</span><br></pre></td></tr></table></figure>

<p>Step 6 主要介绍了如何手动查找基于基地址的指针。</p>
<p>首先，在明确知道初始值的情况下，使用精确值扫描找到变量的直接地址：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240503225106866.png"></p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240503225239581.png"></p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240503225310433.png"></p>
<p>由于修改变量通常是一个写入操作，我们直接查找对这个地址进行写入操作指令：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240503225631632.png"></p>
<p>点击<code>Change value</code>修改值，以便 debugger 跟踪对此地址进行写入的操作指令：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240503230106200.png"></p>
<p>双击条目查看详细信息：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240503230326615.png"></p>
<p>可以看到，地址<code>015A7F80</code>可能是我们要找的指针的值。使用这个值进行精确值扫描，查找保存了这个值的指针：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240503230830300.png"></p>
<p>找到了1个保存了这个值的指针，同时这个指针还是一个基于基地址的指针。双击将其加入 addresslist：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240503231002732.png"></p>
<p>将此地址修改为指针：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240503231651592.png"></p>
<p>点击<code>Change pointer</code>修改目标变量的地址，验证基于基地址的指针指向是否还依然正确：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240503232231809.png"></p>
<p>修改基于基地址指针所指向的地址中的值，并勾选<code>Active</code>锁定值：</p>
<p><img src="/2024/cheat_engine_tutorial3/image-20240503232748147.png"></p>
]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
        <tag>PWN</tag>
        <tag>CheatEngine</tag>
      </tags>
  </entry>
  <entry>
    <title>在Tampermonkey中创建并使用WebWorker</title>
    <url>/2024/create-web-worker-in-tampermonkey-userscript/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         Web Worker Demo</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      2024-04-06</span></span><br><span class="line"><span class="comment">// @description  try to take over the world!</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @match        https://www.example.com/</span></span><br><span class="line"><span class="comment">// @grant        GM_setValue</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Web Worker 内嵌脚本字符串</span></span><br><span class="line">    <span class="keyword">const</span> workerString = <span class="string">`</span></span><br><span class="line"><span class="string">let count = 1;</span></span><br><span class="line"><span class="string">setInterval(()=&gt;&#123;</span></span><br><span class="line"><span class="string">    console.log(&#x27;worker&#x27;, count); </span></span><br><span class="line"><span class="string">    postMessage(&#123;&#x27;workerMsg&#x27;: count&#125;); </span></span><br><span class="line"><span class="string">    count++;</span></span><br><span class="line"><span class="string">&#125;, 3000);</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由字符串创建Web Worker文件URL</span></span><br><span class="line">    <span class="keyword">const</span> workerURL = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([workerString]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Web Worker</span></span><br><span class="line">    <span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(workerURL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Web Worker无法直接访问GM_*方法，将数据返回给页面主线程</span></span><br><span class="line">    worker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">e</span>)&#123;</span><br><span class="line">        <span class="comment">// 由主线程调用GM_*方法</span></span><br><span class="line">        <span class="title function_">GM_setValue</span>(<span class="string">&#x27;workerMsg&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(e.<span class="property">data</span>));</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><img src="/2024/create-web-worker-in-tampermonkey-userscript/image-20240406224118761.png"></p>
<p><img src="/2024/create-web-worker-in-tampermonkey-userscript/image-20240406224158990.png"></p>
]]></content>
      <categories>
        <category>Tampermonkey</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Tampermonkey</tag>
        <tag>UserScript</tag>
        <tag>Front-End</tag>
        <tag>WebWorker</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3 核心笔记</title>
    <url>/2024/vue3-core/</url>
    <content><![CDATA[<p>本文使用以下版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;pinia&quot;: &quot;2.1.7&quot;,</span><br><span class="line">&quot;vue&quot;: &quot;3.4.21&quot;,</span><br><span class="line">&quot;vue-router&quot;: &quot;4.3.0&quot;</span><br></pre></td></tr></table></figure>



<span id="more"></span>

<h1 id="Vue3-核心"><a href="#Vue3-核心" class="headerlink" title="Vue3 核心"></a>Vue3 核心</h1><h2 id="什么是Vue"><a href="#什么是Vue" class="headerlink" title="什么是Vue"></a>什么是Vue</h2><p>Vue (发音为 &#x2F;vjuː&#x2F;，类似 <strong>view</strong>) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型：</p>
<ul>
<li><strong>声明式渲染</strong>：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。</li>
<li><strong>响应性</strong>：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM。</li>
</ul>
<p>你可以用不同的方式使用 Vue：</p>
<ul>
<li>无需构建步骤，渐进式增强静态的 HTML。</li>
<li>在任何页面中作为 Web Components 嵌入</li>
<li>单页应用 (SPA)</li>
<li>全栈 &#x2F; 服务端渲染 (SSR)</li>
<li>Jamstack &#x2F; 静态站点生成 (SSG)</li>
<li>开发桌面端、移动端、WebGL，甚至是命令行终端中的界面</li>
</ul>
<h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a><a href="https://cn.vuejs.org/guide/introduction.html#single-file-components">单文件组件</a></h2><p><strong>单文件组件</strong> (也被称为 <code>*.vue</code> 文件，英文 Single-File Components，缩写为 <strong>SFC</strong>)：</p>
<ul>
<li>一种类似 HTML 格式的文件来书写 Vue 组件；</li>
<li>Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。</li>
<li>需要构建工具的支持。</li>
</ul>
<p>下面我们将用单文件组件的格式重写上面的计数器示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>Count is: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">button</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用单文件组件创建项目时，通常使用基于 <a href="https://vitejs.dev/">Vite</a> 的构建设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm create vue@latest</span><br></pre></td></tr></table></figure>

<p>在项目被创建后，通过以下步骤安装依赖并启动开发服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> &lt;your-project-name&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm run dev</span></span><br></pre></td></tr></table></figure>

<h2 id="通过标签引入Vue并直接使用"><a href="#通过标签引入Vue并直接使用" class="headerlink" title="通过&lt;script&gt;标签引入Vue并直接使用"></a>通过<code>&lt;script&gt;</code>标签引入Vue并直接使用</h2><p>借助 script 标签直接通过 CDN 来使用 Vue 时，</p>
<ul>
<li>不涉及“构建步骤”，无需构建工具支持。</li>
<li>但是，你将无法使用单文件组件 (SFC) 语法。</li>
</ul>
<p>在这些场景中你可以将 Vue 看作一个更加声明式的 jQuery 替代品。</p>
<h3 id="使用全局构建版本"><a href="#使用全局构建版本" class="headerlink" title="使用全局构建版本"></a>使用全局构建版本</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> &#123; createApp, ref &#125; = <span class="title class_">Vue</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">createApp</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello vue!&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        message</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-ES-模块构建版本"><a href="#使用-ES-模块构建版本" class="headerlink" title="使用 ES 模块构建版本"></a>使用 ES 模块构建版本</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; createApp, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">createApp</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">template</span>: <span class="string">`&lt;div&gt;message is &#123;&#123; message &#125;&#125;&lt;/div&gt;`</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello Vue!&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        message</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="启用-Import-maps"><a href="#启用-Import-maps" class="headerlink" title="启用 Import maps"></a>启用 Import maps</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;importmap&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;imports&quot;</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="string">&quot;vue&quot;</span>: <span class="string">&quot;https://unpkg.com/vue@3/dist/vue.esm-browser.js&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; createApp, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">createApp</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello Vue!&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        message</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="API-风格"><a href="#API-风格" class="headerlink" title="API 风格"></a>API 风格</h2><h3 id="选项式API-Options-API"><a href="#选项式API-Options-API" class="headerlink" title="选项式API (Options API)"></a>选项式API (Options API)</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// data() 返回的属性将会成为响应式的状态</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 并且暴露在 `this` 上</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">count</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// methods 是一些用来更改状态与触发更新的函数</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 它们可以在模板中作为事件处理器绑定</span></span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">count</span>++</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 生命周期钩子会在组件生命周期的各个不同阶段被调用</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 例如这个函数就会在组件挂载完成后被调用</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The initial count is <span class="subst">$&#123;<span class="variable language_">this</span>.count&#125;</span>.`</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>Count is: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="组合式-API-Composition-API"><a href="#组合式-API-Composition-API" class="headerlink" title="组合式 API (Composition API)"></a>组合式 API (Composition API)</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 响应式状态</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 用来修改状态、触发更新的函数</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  count.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 生命周期钩子</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The initial count is <span class="subst">$&#123;count.value&#125;</span>.`</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>Count is: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><h3 id="setup-1"><a href="#setup-1" class="headerlink" title="setup()"></a><code>setup()</code></h3><p><a href="https://cn.vuejs.org/guide/extras/composition-api-faq.html#can-i-use-both-apis-in-the-same-component">可以在一个组件中同时使用选项式 API 和 组合式 API 吗？</a>可以。你可以在一个选项式 API 的组件中通过 <a href="https://cn.vuejs.org/api/composition-api-setup.html"><code>setup()</code></a> 选项来使用组合式 API。</p>
<p><code>setup()</code> 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：</p>
<ol>
<li>需要在非单文件组件中使用组合式 API 时。</li>
<li>需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。</li>
</ol>
<p>使用<a href="https://cn.vuejs.org/api/reactivity-core.html">响应式 API</a> 来声明响应式的状态，在 <code>setup()</code> 函数中返回的对象会暴露给模板和组件实例。其他的选项也可以通过组件实例来获取 <code>setup()</code> 暴露的属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// setup() 自身并不含对组件实例的访问权，即在 setup() 中访问 this 会是 undefined。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(this.name)</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 返回值会暴露给模板和其他的选项式 API 钩子</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      count</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 其他的选项也可以通过组件实例来获取 `setup()` 暴露的属性。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 当通过 this 访问时也会自动浅层解包。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">count</span>) <span class="comment">// 0</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在模板中访问从 setup 返回的 ref 时，它会自动浅层解包，因此你无须再在模板中为它写 .value。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="setup-访问-props"><a href="#setup-访问-props" class="headerlink" title="setup 访问 props"></a>setup 访问 props</h3><p><code>setup</code> 函数的第1个参数是组件的 <code>props</code>。和标准的组件一致，一个 <code>setup</code> 函数的 <code>props</code> 是响应式的。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="title class_">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">title</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要解构 <code>props</code> 对象，使用 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#torefs">toRefs()</a> 和 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#toref">toRef()</a> 这两个工具函数，否则结构出来的变量会失去响应性。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs, toRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="comment">// 将 `props` 转为一个其中全是 ref 的对象，然后解构</span></span><br><span class="line">    <span class="keyword">const</span> &#123; title &#125; = <span class="title function_">toRefs</span>(props)</span><br><span class="line">    <span class="comment">// `title` 是一个追踪着 `props.title` 的 ref</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(title.<span class="property">value</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者，将 `props` 的单个属性转为一个 ref</span></span><br><span class="line">    <span class="keyword">const</span> title = <span class="title function_">toRef</span>(props, <span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Setup-上下文"><a href="#Setup-上下文" class="headerlink" title="Setup 上下文"></a>Setup 上下文</h3><p>传入 <code>setup</code> 函数的第2个参数是一个 <strong>Setup 上下文</strong>对象。上下文对象暴露了其他一些在 <code>setup</code> 中可能会用到的值：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="comment">// 该上下文对象是非响应式的，可以安全地解构</span></span><br><span class="line">    <span class="keyword">const</span> &#123; attrs, slots, emit, expose &#125; = context</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 透传 Attributes（非响应式的对象，等价于 $attrs）</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(attrs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插槽（非响应式的对象，等价于 $slots）</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(slots)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件（函数，等价于 $emit）</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(emit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露公共属性（函数）</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(expose)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>attrs</code> 和 <code>slots</code> 都是**有状态（但不是响应式）**的对象：</p>
<ul>
<li>它们总是会随着组件自身的更新而更新。</li>
<li>应当避免解构它们，并始终通过 <code>attrs.x</code> 或 <code>slots.x</code> 的形式使用其中的属性。</li>
<li>如果你想要基于 <code>attrs</code> 或 <code>slots</code> 的改变来执行副作用，那么你应该在 <code>onBeforeUpdate</code> 生命周期钩子中编写相关逻辑。</li>
</ul>
<h3 id="暴露公共属性"><a href="#暴露公共属性" class="headerlink" title="暴露公共属性"></a>暴露公共属性</h3><p><code>expose</code> 函数用于显式地限制该组件暴露出的属性，当父组件通过<a href="https://cn.vuejs.org/guide/essentials/template-refs.html#ref-on-component">模板引用</a> (组件的<code>ref</code>属性) 访问该组件的实例时，将仅能访问 <code>expose</code> 函数暴露出的内容：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, &#123; expose &#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// 让组件实例处于 “关闭状态”</span></span><br><span class="line">    <span class="comment">// 即不向父组件暴露任何东西</span></span><br><span class="line">    <span class="title function_">expose</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> publicCount = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> privateCount = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 有选择地暴露局部状态</span></span><br><span class="line">    <span class="title function_">expose</span>(&#123; <span class="attr">count</span>: publicCount &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setup-返回函数"><a href="#setup-返回函数" class="headerlink" title="setup 返回函数"></a>setup 返回函数</h3><p><code>setup</code>除了返回对象，还可以返回一个函数。修改默认脚手架里的<code>AboutView.vue</code>：</p>
<p><img src="/2024/vue3-core/image-20240327174312645.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="string">&#x27;&lt;p&gt;&lt;i&gt;haha&lt;/i&gt;&lt;/p&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>页面上会直接显示<code>setup</code>返回的内容：</p>
<p><img src="/2024/vue3-core/image-20240327174204982.png"></p>
<p>通常，<code>setup</code>返回函数时，会与渲染函数一起使用。</p>
<h3 id="与渲染函数一起使用"><a href="#与渲染函数一起使用" class="headerlink" title="与渲染函数一起使用"></a>与渲染函数一起使用</h3><p><code>setup</code> 也可以返回一个<a href="https://cn.vuejs.org/guide/extras/render-function.html">渲染函数</a>，此时在渲染函数中可以直接使用在同一作用域下声明的响应式状态：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, count.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回一个渲染函数将会阻止我们返回其他东西，所以，如果我们想通过模板引用将这个组件的方法暴露给父组件，需要通过调用 <a href="https://cn.vuejs.org/api/composition-api-setup.html#exposing-public-properties"><code>expose()</code></a> 解决这个问题：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, &#123; expose &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; ++count.<span class="property">value</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">expose</span>(&#123;</span><br><span class="line">      increment <span class="comment">// 父组件可以通过模板引用来访问这个 increment 方法</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, count.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title="&lt;script setup&gt;"></a><code>&lt;script setup&gt;</code></h3><p>使用<code>setup()</code> 函数需要手动<code>return</code>要暴露的状态和方法，当需要暴露大量的状态和方法时非常繁琐。幸运的是，我们可以通过使用<a href="https://cn.vuejs.org/guide/scaling-up/sfc.html">单文件组件 (SFC)</a> 搭配 <code>&lt;script setup&gt;</code> 来大幅度地简化代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  count.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;script setup&gt;</code> 中的顶层的导入、声明的变量和函数可在同一组件的模板中直接使用。你可以理解为模板是在同一作用域内声明的一个 JavaScript 函数。</p>
<h2 id="创建Vue应用"><a href="#创建Vue应用" class="headerlink" title="创建Vue应用"></a>创建Vue应用</h2><p>每个 Vue 应用都是通过 <a href="https://cn.vuejs.org/api/application.html#createapp"><code>createApp</code></a> 函数创建一个新的 <strong>应用实例</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="comment">/* 根组件选项 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="根组件"><a href="#根组件" class="headerlink" title="根组件"></a><a href="https://cn.vuejs.org/guide/essentials/application.html#the-root-component">根组件</a></h3><p>我们传入 <code>createApp</code> 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。</p>
<p>使用单文件组件作为根组件，直接从另一个文件中导入根组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 从一个单文件组件中导入根组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br></pre></td></tr></table></figure>

<p>使用无构建步骤的方式创建组件对象作为根组件：</p>
<blockquote>
<p>注意：使用<code>template</code>选项提供模板时，必须使用带有编译器的Vue打包版本。否则会报错：</p>
<p><code>[Vue warn]: Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias &quot;vue&quot; to &quot;vue/dist/vue.esm-bundler.js&quot;.</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;https://unpkg.com/vue@3/dist/vue.esm-bundler.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; count &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;count is &#123;&#123; count &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; count &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;count is &#123;&#123; count &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br></pre></td></tr></table></figure>

<p>或者拆分模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my-component.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;https://unpkg.com/vue@3/dist/vue.esm-bundler.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; count &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;count is &#123;&#123; count &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;https://unpkg.com/vue@3/dist/vue.esm-bundler.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./my-component.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">MyComponent</span>)</span><br></pre></td></tr></table></figure>

<h3 id="挂载应用"><a href="#挂载应用" class="headerlink" title="挂载应用"></a>挂载应用</h3><p>应用实例必须在调用了 <code>.mount()</code> 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="DOM-中的根组件模板"><a href="#DOM-中的根组件模板" class="headerlink" title="DOM 中的根组件模板"></a>DOM 中的根组件模板</h4><p>根组件的模板通常是组件本身的一部分，但也可以直接通过在挂载容器内编写模板来单独提供：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>当根组件没有设置 <code>template</code> 选项时，Vue 将自动使用容器的 <code>innerHTML</code> 作为模板。</p>
<h3 id="多个应用实例"><a href="#多个应用实例" class="headerlink" title="多个应用实例"></a><a href="https://cn.vuejs.org/guide/essentials/application.html#multiple-application-instances">多个应用实例</a></h3><p>应用实例并不只限于一个。<code>createApp</code> API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app1 = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line">app1.<span class="title function_">mount</span>(<span class="string">&#x27;#container-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app2 = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line">app2.<span class="title function_">mount</span>(<span class="string">&#x27;#container-2&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h3><p>双大括号标签会被替换为<a href="https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#declaring-reactive-state">相应组件实例中</a> <code>msg</code> 属性的值。同时每次 <code>msg</code> 属性更改时它也会同步更新。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="原始HTML"><a href="#原始HTML" class="headerlink" title="原始HTML"></a>原始HTML</h3><p>双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 <a href="https://cn.vuejs.org/api/built-in-directives.html#v-html"><code>v-html</code> 指令</a>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using text interpolation: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/vue3-core/image-20240401175510523.png"></p>
<h3 id="Attribute-绑定"><a href="#Attribute-绑定" class="headerlink" title="Attribute 绑定"></a><a href="https://cn.vuejs.org/guide/essentials/template-syntax.html#attribute-bindings">Attribute 绑定</a></h3><p>双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 <a href="https://cn.vuejs.org/api/built-in-directives.html#v-bind"><code>v-bind</code> 指令</a>。</p>
<p><code>v-bind</code> 指令指示 Vue 将元素的 <code>id</code> attribute 与组件的 <code>dynamicId</code> 属性保持一致。如果绑定的值是 <code>null</code> 或者 <code>undefined</code>，那么该 attribute 将会从渲染的元素上移除。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Vue3.4及以后版本支持同名简写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 与 :id=&quot;id&quot; 相同 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:id</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这也同样有效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="布尔型-Attribute"><a href="#布尔型-Attribute" class="headerlink" title="布尔型 Attribute"></a><a href="https://cn.vuejs.org/guide/essentials/template-syntax.html#boolean-attributes">布尔型 Attribute</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes#%E5%B8%83%E5%B0%94%E5%80%BC%E5%B1%9E%E6%80%A7">布尔型 attribute</a> 依据 <code>true</code> &#x2F; <code>false</code> 值来决定 attribute 是否应该存在于该元素上。</p>
<p>当 <code>isButtonDisabled</code> 为<a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">真值</a>或一个空字符串 (即 <code>&lt;button disabled=&quot;&quot;&gt;</code>) 时，元素会包含这个 <code>disabled</code> attribute。而当其为其他<a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">假值</a>时 attribute 将被忽略：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">:disabled</span>=<span class="string">&quot;isButtonDisabled&quot;</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="动态绑定多个值"><a href="#动态绑定多个值" class="headerlink" title="动态绑定多个值"></a><a href="https://cn.vuejs.org/guide/essentials/template-syntax.html#dynamically-binding-multiple-attributes">动态绑定多个值</a></h3><p>如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> objectOfAttrs = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;container&#x27;</span>,</span><br><span class="line">  <span class="attr">class</span>: <span class="string">&#x27;wrapper&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过不带参数的 <code>v-bind</code>，你可以将它们绑定到单个元素上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">&quot;objectOfAttrs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-JavaScript-表达式"><a href="#使用-JavaScript-表达式" class="headerlink" title="使用 JavaScript 表达式"></a><a href="https://cn.vuejs.org/guide/essentials/template-syntax.html#using-javascript-expressions">使用 JavaScript 表达式</a></h3><p> Vue 在所有的数据绑定中都支持完整的 JavaScript 表达式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:id</span>=<span class="string">&quot;`list-$&#123;id&#125;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这些表达式都会被作为 JavaScript ，以当前组件实例为作用域解析执行。</p>
<p>在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：</p>
<ul>
<li>在文本插值中 (双大括号)</li>
<li>在任何 Vue 指令 (以 <code>v-</code> 开头的特殊 attribute) attribute 的值中</li>
</ul>
<h4 id="仅支持表达式"><a href="#仅支持表达式" class="headerlink" title="仅支持表达式"></a><a href="https://cn.vuejs.org/guide/essentials/template-syntax.html#expressions-only">仅支持表达式</a></h4><p>每个绑定仅支持<strong>单一表达式</strong>，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是是否可以合法地写在 <code>return</code> 后面。因此，下面的例子都是<strong>无效</strong>的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是一个语句，而非表达式 --&gt;</span></span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 条件控制也不支持，请使用三元表达式 --&gt;</span></span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a><a href="https://cn.vuejs.org/guide/essentials/template-syntax.html#calling-functions">调用函数</a></h4><p>可以在绑定的表达式中使用一个组件暴露的方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">:title</span>=<span class="string">&quot;toTitleDate(date)&quot;</span> <span class="attr">:datetime</span>=<span class="string">&quot;date&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; formatDate(date) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>绑定在表达式中的方法在组件每次更新时都会被重新调用，因此<strong>不</strong>应该产生任何副作用，比如改变数据或触发异步操作。</p>
</blockquote>
<h3 id="指令-Directives"><a href="#指令-Directives" class="headerlink" title="指令 Directives"></a>指令 Directives</h3><p>指令是带有 <code>v-</code> 前缀的特殊 attribute。指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外： <code>v-for</code>、<code>v-on</code> 和 <code>v-slot</code>)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。</p>
<p>以下<a href="https://cn.vuejs.org/api/built-in-directives.html#v-if"><code>v-if</code></a> 指令会基于表达式 <code>seen</code> 的值的真假来移除&#x2F;插入该 <code>&lt;p&gt;</code> 元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>Now you see me<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="参数-Arguments"><a href="#参数-Arguments" class="headerlink" title="参数 Arguments"></a><a href="https://cn.vuejs.org/guide/essentials/template-syntax.html#arguments">参数 Arguments</a></h4><p>某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。例如用 <code>v-bind</code> 指令来响应式地更新一个 HTML attribute：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里 <code>href</code> 就是一个参数，它告诉 <code>v-bind</code> 指令将表达式 <code>url</code> 的值绑定到元素的 <code>href</code> attribute 上。在简写中，参数前的一切 (例如 <code>v-bind:</code>) 都会被缩略为一个 <code>:</code> 字符。</p>
<p>另一个例子是 <code>v-on</code> 指令，它将监听 DOM 事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的参数是要监听的事件名称：<code>click</code>。<code>v-on</code> 有一个相应的缩写，即 <code>@</code> 字符。我们之后也会讨论关于事件处理的更多细节。</p>
<h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a><a href="https://cn.vuejs.org/guide/essentials/template-syntax.html#dynamic-arguments">动态参数</a></h4><p>同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">注意，参数表达式有一些约束，</span></span><br><span class="line"><span class="comment">参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">attributeName</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> attributeName = <span class="string">&#x27;href&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相似地，你还可以将一个函数绑定到动态的事件名称上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:</span>[<span class="attr">eventName</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">eventName</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> eventName = <span class="string">&#x27;click&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>动态参数值的限制：</p>
<ul>
<li>动态参数中表达式的值应当是一个字符串，或者是 <code>null</code>。特殊值 <code>null</code> 意为显式移除该绑定。其他非字符串的值会触发警告。</li>
</ul>
<p>动态参数值的限制：</p>
<ul>
<li>动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。如<code>&lt;a :[&#39;foo&#39; + bar]=&quot;value&quot;&gt; ... &lt;/a&gt;</code>这会触发一个编译器警告。</li>
<li>当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写。如<code>&lt;a :[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt;</code>会被转换为<code>:[someattr]</code>。</li>
</ul>
<h4 id="修饰符-Modifiers"><a href="#修饰符-Modifiers" class="headerlink" title="修饰符 Modifiers"></a><a href="https://cn.vuejs.org/guide/essentials/template-syntax.html#modifiers">修饰符 Modifiers</a></h4><p>修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。例如 <code>.prevent</code> 修饰符会告知 <code>v-on</code> 指令对触发的事件调用 <code>event.preventDefault()</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h2><h3 id="ref"><a href="#ref" class="headerlink" title="ref()"></a><code>ref()</code></h3><p>在组合式 API 中，推荐使用 <a href="https://cn.vuejs.org/api/reactivity-core.html#ref"><code>ref()</code></a> 函数来声明响应式状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><code>ref()</code> 接收参数，并将其包裹在一个带有 <code>.value</code> 属性的 ref 对象中返回：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// &#123; value: 0 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">count.<span class="property">value</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在模板中使用 ref 时，我们<strong>不</strong>需要附加 <code>.value</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你也可以直接在事件监听器中改变一个 ref：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; count &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在同一作用域内声明更改 ref 的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在 JavaScript 中需要 .value</span></span><br><span class="line">    count.<span class="property">value</span>++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后把方法暴露给事件监听器：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构，比如 <code>Map</code>。</p>
<p>Ref 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">nested</span>: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  <span class="attr">arr</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mutateDeeply</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 以下都会按照期望工作</span></span><br><span class="line">  obj.<span class="property">value</span>.<span class="property">nested</span>.<span class="property">count</span>++</span><br><span class="line">  obj.<span class="property">value</span>.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="string">&#x27;baz&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非原始值将通过 <a href="https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#reactive"><code>reactive()</code></a> 转换为响应式代理。</p>
<h4 id="DOM-更新时机"><a href="#DOM-更新时机" class="headerlink" title="DOM 更新时机"></a><a href="https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#dom-update-timing">DOM 更新时机</a></h4><p>当你修改了响应式状态时，DOM 会被自动更新。但 DOM 更新不是同步的。Vue 会在“next tick”更新周期中缓冲所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次。</p>
<p>要等待 DOM 更新完成后再执行额外的代码，可以使用 <a href="https://cn.vuejs.org/api/general.html#nexttick"><code>nextTick()</code></a> 全局 API：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  count.<span class="property">value</span>++</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">nextTick</span>()</span><br><span class="line">  <span class="comment">// 现在 DOM 已经更新了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a><code>reactive()</code></h3><p>与将内部值包装在特殊对象中的 <code>ref()</code> 不同，<code>reactive()</code> 将使对象本身具有响应性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>在模板中使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;state.count++&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; state.count &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>响应式对象是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">JavaScript 代理</a>，Vue 能够拦截对响应式对象所有属性的访问和修改，以便进行依赖追踪和触发更新。</p>
<p><code>reactive()</code> 将深层地转换对象：当访问嵌套对象时，它们也会被 <code>reactive()</code> 包装。当 ref 的值是一个对象时，<code>ref()</code> 也会在内部调用<code>reactive()</code>。</p>
<p><strong><code>reactive()</code> API 有一些局限性：</strong></p>
<ol>
<li><p><strong>有限的值类型</strong>：它只能用于对象类型 (对象、数组和如 <code>Map</code>、<code>Set</code> 这样的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#keyed_collections">集合类型</a>)。它不能持有如 <code>string</code>、<code>number</code> 或 <code>boolean</code> 这样的<a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">原始类型</a>。</p>
</li>
<li><p><strong>不能替换整个对象</strong>：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失。而应该使用<code>Object.assign()</code>来将新对象的值复制给响应式对象：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的 (&#123; count: 0 &#125;) 引用将不再被追踪。响应性连接已丢失！</span></span><br><span class="line">state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Object.assign()不会丢失响应性连接</span></span><br><span class="line">state = <span class="title class_">Object</span>.<span class="title function_">assign</span>(state, &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>对解构操作不友好</strong>：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接。当需要对<code>reactive()</code>创建的响应性对象进行解构时，需要使用<code>toRefs()</code>或<code>toRef()</code>。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当解构时，count 已经与 state.count 断开连接</span></span><br><span class="line"><span class="keyword">let</span> &#123; count &#125; = state</span><br><span class="line"><span class="comment">// 不会影响原始的 state</span></span><br><span class="line">count++</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数接收到的是一个普通的数字</span></span><br><span class="line"><span class="comment">// 并且无法追踪 state.count 的变化</span></span><br><span class="line"><span class="comment">// 我们必须传入整个对象以保持响应性</span></span><br><span class="line"><span class="title function_">callSomeFunction</span>(state.<span class="property">count</span>)</span><br></pre></td></tr></table></figure>

<p>使用<code>toRefs</code> 消费者组件可以解构&#x2F;展开返回的对象而不会失去响应性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stateAsRefs = <span class="title function_">toRefs</span>(state)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 ref 和源属性已经“链接上了”</span></span><br><span class="line">state.<span class="property">foo</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stateAsRefs.<span class="property">foo</span>.<span class="property">value</span>) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">stateAsRefs.<span class="property">foo</span>.<span class="property">value</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">foo</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 toRefs 对 state 进行解构，不会丢失响应性。</span></span><br><span class="line"><span class="keyword">const</span> &#123; bar &#125; = <span class="title function_">toRefs</span>(state)</span><br></pre></td></tr></table></figure>

<p>由于这些限制，我们建议使用 <code>ref()</code> 作为声明响应式状态的主要 API。</p>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><ul>
<li><p>作用：监视数据的变化（和Vue2中的<code>watch</code>作用一致）；</p>
</li>
<li><p>特点：Vue3中的<code>watch</code>只能监视以下4种数据：</p>
<ul>
<li><p><code>ref</code>定义的数据（基本类型、对象）；</p>
</li>
<li><p><code>reactive</code>定义的对象；</p>
</li>
<li><p>getter&#x2F;effect函数，即返回一个值的函数；</p>
</li>
<li><p>或者以上类型的数组；</p>
</li>
</ul>
</li>
</ul>
<ol>
<li><code>watch</code>监视<code>ref</code>：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="watchEffet"><a href="#watchEffet" class="headerlink" title="watchEffet"></a>watchEffet</h2><ul>
<li>立即运行一个函数，同时响应式地追踪器其中所使用的响应式变量，并在其中的响应式变量更该时重新执行该函数。</li>
<li>对比<code>watch</code>：<ul>
<li><code>watch</code>和<code>watchEffect</code>都能监听响应式数据的变化；</li>
<li><code>watch</code>需要手动指定监视的数据；</li>
<li><code>watchEffet</code>不需要手动指定监视的数据，而是通过识别函数中所使用的响应式数据，自动判断需要监视的数据。</li>
</ul>
</li>
</ul>
<h2 id="模板引用：标签中的ref属性"><a href="#模板引用：标签中的ref属性" class="headerlink" title="模板引用：标签中的ref属性"></a>模板引用：标签中的ref属性</h2><ul>
<li><code>ref</code>属性在HTML原生标签中时，获取<code>ref</code>属性所引用的标签；</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&#x27;world&#x27;</span>&gt;</span>World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> world = <span class="title function_">ref</span>(); <span class="comment">// world将引用&lt;h1 ref=&#x27;world&#x27;&gt;World&lt;/h1&gt;HTML原生标签元素</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>ref</code>属性在组件标签中时，获取<code>ref</code>属性所引用的组件实例；</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Person</span> <span class="attr">ref</span>=<span class="string">&#x27;person&#x27;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> person = <span class="title function_">ref</span>(); <span class="comment">// person将引用Person组件的实例</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p><code>defineProps</code>是编译器宏，不需要导入就可使用，用来定义组件的属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// Person.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> x = <span class="title function_">defineProps</span>([<span class="string">&#x27;msg&#x27;</span>]); <span class="comment">// 定义组件属性msg</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">msg</span>); <span class="comment">// haha</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在父组件中使用组件<code>Person</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Person</span> <span class="attr">msg</span>=<span class="string">&quot;haha&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 父组件为Person组件msg属性设置值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用泛型指定props类型：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// Person.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> x = defineProps&lt;&#123; <span class="attr">msg</span>: string &#125;&gt;(); <span class="comment">// 定义组件属性msg，指定类型为string</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">msg</span>); <span class="comment">// haha</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可选props：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// Person.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> x = defineProps&lt;&#123; msg?:string &#125;&gt;(); <span class="comment">// 定义组件可选属性msg</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">msg</span>); <span class="comment">// haha</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>withDefaults</code>定义props默认值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// Person.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> x = <span class="title function_">withDefaults</span>(defineProps&lt;&#123; msg?:string &#125;&gt;(), &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">msg</span>: <span class="string">&#x27;yoyo&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">msg</span>); <span class="comment">// 在父组件没有传递msg属性时，输出yoyo</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当props是对象，如数组时，默认值需要由函数返回：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// Person.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> x = <span class="title function_">withDefaults</span>(defineProps&lt;&#123; msg?:<span class="title class_">Array</span>&lt;string&gt; &#125;&gt;(), &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">msg</span>: <span class="function">()=&gt;</span> [<span class="string">&#x27;haha&#x27;</span>, <span class="string">&#x27;yoyo&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">msg</span>); <span class="comment">// 在父组件没有传递msg属性时，输出[&#x27;haha&#x27;, &#x27;yoyo&#x27;]</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="Vue2生命周期"><a href="#Vue2生命周期" class="headerlink" title="Vue2生命周期"></a>Vue2生命周期</h3><ol>
<li><code>beforeCreate</code>：初始化选项式API前；</li>
<li><code>created</code>：初始化选项式API后；</li>
<li><code>beforeMount</code>: 初始渲染前；</li>
<li><code>mounted</code>：初始渲染、创建和插入DOM节点后；</li>
<li><code>beforeUpdate</code>：重新渲染前；</li>
<li><code>updated</code>：重新渲染后；</li>
<li><code>beforeDestroy</code>：组件销毁前；</li>
<li><code>destroyed</code>：组件销毁后；</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    methods&#123;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">	&#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">beforeCreate</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">	&#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">created</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">beforeMount</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">beforeUpdate</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">updated</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">beforeDestroy</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">destroyed</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="Vue3生命周期"><a href="#Vue3生命周期" class="headerlink" title="Vue3生命周期"></a>Vue3生命周期</h3><ol>
<li><code>setup</code>：将 Vue2 的<code>beforeCreate</code>和<code>created</code>合并了；</li>
<li><code>onBeforeMount</code>： 初始渲染前；</li>
<li><code>onMounted</code>：初始渲染、创建和插入DOM节点后；</li>
<li><code>onBeforeUpdate</code>：重新渲染前；</li>
<li><code>onUpdated</code>：重新渲染后；</li>
<li><code>onBeforeUnmount</code>：组件取消挂载前，相当于 Vue2 的<code>beforeDestroy</code>；</li>
<li><code>onUnmounted</code>：组件取消挂载后，相当于 Vue2 的<code>destroyed</code>；</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建前&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> val = <span class="title function_">ref</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建后&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">onBeforeMount</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;初始渲染前&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;初始渲染后&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">onBeforeUpdate</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新前&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">onUpdated</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新后&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">onBeforeUnmount</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;卸载前&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;卸载后&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>setup</code>标签属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建前&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> val = <span class="title function_">ref</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建后&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">onBeforeMount</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;初始渲染前&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;初始渲染后&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">onBeforeUpdate</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新前&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">onUpdated</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新后&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">onBeforeUnmount</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;卸载前&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;卸载后&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>多组件时，子组件先于父组件被创建。</p>
<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><h1 id="路由-vue-router"><a href="#路由-vue-router" class="headerlink" title="路由 vue-router"></a>路由 vue-router</h1><h2 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h2><p>使用<code>vue-router</code>创建SPA基本步骤：</p>
<ol>
<li>创建路由View组件；</li>
<li><code>createRouter</code>创建<code>router</code>并配置路由参数；</li>
<li><code>app.use(router)</code>引入创建好的<code>router</code>；</li>
<li>在路由视图View呈现页添加<code>&lt;RouterLink&gt;</code>导航和<code>&lt;RouterView&gt;</code>；</li>
</ol>
<p>步骤1：创建路由视图组件。路由视图组件通常放在项目目录的<code>views/</code>目录或<code>pages/</code>目录中；一般组件放在<code>components/</code>目录中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// HomeView.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">TheWelcome</span> <span class="keyword">from</span> <span class="string">&#x27;../components/TheWelcome.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TheWelcome</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// AboutView.vue</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is an about page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">1024px</span>) &#123;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.about</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>步骤2：<code>createRouter</code>创建<code>router</code>并配置路由参数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HomeView</span> <span class="keyword">from</span> <span class="string">&#x27;../views/HomeView.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">HomeView</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">      <span class="comment">// route level code-splitting</span></span><br><span class="line">      <span class="comment">// this generates a separate chunk (About.[hash].js) for this route</span></span><br><span class="line">      <span class="comment">// which is lazy-loaded when the route is visited.</span></span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/AboutView.vue&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<p>步骤3：<code>app.use(router)</code>引入创建好的<code>router</code>；</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>步骤4：在路由视图View呈现页添加<code>&lt;RouterLink&gt;</code>导航和<code>&lt;RouterView&gt;</code>；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; <span class="title class_">RouterLink</span>, <span class="title class_">RouterView</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">RouterView</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="路由器模式"><a href="#路由器模式" class="headerlink" title="路由器模式"></a>路由器模式</h2><p><strong>history模式：</strong></p>
<ul>
<li>优点：URL中不带<code>#</code>，更加美观，更接近传统网站的URL；</li>
<li>缺点：项目上线后，需要后端配合处理路径问题，否则刷新网页会出现404错误；</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(), <span class="comment">// history模式</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>hash模式：</strong></p>
<ul>
<li>优点：兼容性更好，不需要后端处理路径问题；</li>
<li>缺点：URL中带有<code>#</code>，不太美观；对 SEO 不友好；</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(), <span class="comment">// hash模式</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HomeView</span> <span class="keyword">from</span> <span class="string">&#x27;../views/HomeView.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>, <span class="comment">// 命名路由</span></span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">HomeView</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>, <span class="comment">// 命名路由</span></span><br><span class="line">      <span class="comment">// route level code-splitting</span></span><br><span class="line">      <span class="comment">// this generates a separate chunk (About.[hash].js) for this route</span></span><br><span class="line">      <span class="comment">// which is lazy-loaded when the route is visited.</span></span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/AboutView.vue&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>



<h2 id="RouterLink中to属性的2种写法"><a href="#RouterLink中to属性的2种写法" class="headerlink" title="RouterLink中to属性的2种写法"></a><code>RouterLink</code>中<code>to</code>属性的2种写法</h2><p><strong>字符串写法：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p><strong>对象写法：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 路径跳转 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path: &#x27;/&#x27;&#125;&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path: &#x27;/about&#x27;&#125;&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 命名路由跳转 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name: &#x27;home&#x27;&#125;&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name: &#x27;about&#x27;&#125;&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">HomeView</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">NewsView</span>,</span><br><span class="line">      <span class="attr">children</span>:[ <span class="comment">// 子路由</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;sport&#x27;</span>,</span><br><span class="line">      		 <span class="attr">name</span>: <span class="string">&#x27;sport&#x27;</span>,</span><br><span class="line">              <span class="attr">component</span>: <span class="title class_">SportView</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;economy&#x27;</span>,</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;economy&#x27;</span>,</span><br><span class="line">              <span class="attr">component</span>: <span class="title class_">EconomyView</span>,</span><br><span class="line">          &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>, <span class="comment">// 命名路由</span></span><br><span class="line">      <span class="comment">// route level code-splitting</span></span><br><span class="line">      <span class="comment">// this generates a separate chunk (About.[hash].js) for this route</span></span><br><span class="line">      <span class="comment">// which is lazy-loaded when the route is visited.</span></span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/AboutView.vue&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/news/sport&quot;</span>&gt;</span>体育<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/news/economy&quot;</span>&gt;</span>财经<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="路由的querystring参数"><a href="#路由的querystring参数" class="headerlink" title="路由的querystring参数"></a>路由的querystring参数</h2><p><strong>在<code>RouterLink</code>的<code>to</code>属性中传参：</strong></p>
<ul>
<li>写法1：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/news/sport?id=1&amp;title=sportnews&amp;content=arsenalwin&quot;</span>&gt;</span>体育<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/news/economy?id=2&amp;title=economynews&amp;content=btcfalldown&quot;</span>&gt;</span>财经<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>写法2：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 路径跳转 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">    path:&#x27;/news/sport&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    query:&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">		id: news:id,</span></span></span><br><span class="line"><span class="string"><span class="tag">         title: news.title,</span></span></span><br><span class="line"><span class="string"><span class="tag">         content: news.content</span></span></span><br><span class="line"><span class="string"><span class="tag">    	&#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">	&#125;&quot;</span>&gt;</span>体育<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 命名路由 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">    name:&#x27;economy&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    query:&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">		id: news:id,</span></span></span><br><span class="line"><span class="string"><span class="tag">         title: news.title,</span></span></span><br><span class="line"><span class="string"><span class="tag">         content: news.content</span></span></span><br><span class="line"><span class="string"><span class="tag">    	&#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">	&#125;&quot;</span>&gt;</span>财经<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>在路由视图中使用<code>useRoute</code> hooks接收参数：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; route.query.id &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; route.query.title &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; route.query.content &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> route = <span class="title function_">useRoute</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="路由的params参数"><a href="#路由的params参数" class="headerlink" title="路由的params参数"></a>路由的params参数</h2><p>配置路由，在<code>path</code>属性中使用 params 参数占位符：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">HomeView</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">NewsView</span>,</span><br><span class="line">      <span class="attr">children</span>:[ <span class="comment">// 子路由</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;sport/:id/:title/:content&#x27;</span>, <span class="comment">// params占位参数</span></span><br><span class="line">      		 <span class="attr">name</span>: <span class="string">&#x27;sport&#x27;</span>,</span><br><span class="line">              <span class="attr">component</span>: <span class="title class_">SportView</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;economy/:id/:title/:content?&#x27;</span>, <span class="comment">// params占位参数；使用问号?指定可选参数</span></span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;economy&#x27;</span>,</span><br><span class="line">              <span class="attr">component</span>: <span class="title class_">EconomyView</span>,</span><br><span class="line">          &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>, <span class="comment">// 命名路由</span></span><br><span class="line">      <span class="comment">// route level code-splitting</span></span><br><span class="line">      <span class="comment">// this generates a separate chunk (About.[hash].js) for this route</span></span><br><span class="line">      <span class="comment">// which is lazy-loaded when the route is visited.</span></span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/AboutView.vue&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<p>在<code>RouterLink</code>中进行传参：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 写法1 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/news/sport/1/sportnews/arsenalwin&quot;</span>&gt;</span>体育<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;`/news/economy/$&#123;news.id&#125;/$&#123;news.title&#125;/$&#123;news.content&#125;`&quot;</span>&gt;</span>财经<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 写法2: to属性将对象作为params参数传给路由视图组件时，只能使用命名视图路由（name属性），不能使用path属性 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意写法2不允许将对象作为参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">         name:&#x27;sport&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">         params: &#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">             id: news.id,</span></span></span><br><span class="line"><span class="string"><span class="tag">             title: news.title,</span></span></span><br><span class="line"><span class="string"><span class="tag">             content: news.content</span></span></span><br><span class="line"><span class="string"><span class="tag">         &#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#125;&quot;</span>&gt;</span>体育<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">         name:&#x27;economy&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">         params: &#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">             id: news.id,</span></span></span><br><span class="line"><span class="string"><span class="tag">             title: news.title,</span></span></span><br><span class="line"><span class="string"><span class="tag">             content: news.content</span></span></span><br><span class="line"><span class="string"><span class="tag">         &#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#125;&quot;</span>&gt;</span>财经<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">RouterView</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> news = &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">id</span>: <span class="string">&#x27;id&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">title</span>: <span class="string">&#x27;title&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">content</span>: <span class="string">&#x27;content&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在路由视图中获取参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; route.params.title &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; route.params.content &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> route  = <span class="title function_">useRoute</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h2><p>在路由配置中将路由的<code>props</code>设置为<code>true</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">HomeView</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">NewsView</span>,</span><br><span class="line">      <span class="attr">children</span>:[ <span class="comment">// 子路由</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;sport&#x27;</span>,</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;sport/:id/:title/:content&#x27;</span>, </span><br><span class="line">              <span class="attr">component</span>: <span class="title class_">SportView</span>,</span><br><span class="line">              <span class="comment">// 写法1：将路由收到的所有params参数作为props传给路由组件</span></span><br><span class="line">              <span class="attr">props</span>: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;economy&#x27;</span>,</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;economy&#x27;</span>,</span><br><span class="line">              <span class="attr">component</span>: <span class="title class_">EconomyView</span>,</span><br><span class="line">              <span class="comment">// 写法2：props是一个函数，这种写法可以自己决定将什么作为props传给路由组件</span></span><br><span class="line">              <span class="comment">// 此函数接收一个RouteLink传递的路由信息作为参数，可以通过返回其中的特定属性来决定将哪种参数传给路由组件</span></span><br><span class="line">              <span class="attr">props</span>: <span class="function">(<span class="params">route</span>)=&gt;</span>&#123;</span><br><span class="line">                  <span class="comment">// 返回路由的params参数</span></span><br><span class="line">                  <span class="comment">// return route.params</span></span><br><span class="line">                  <span class="comment">// 返回路由的querystring参数</span></span><br><span class="line">                  <span class="keyword">return</span> route.<span class="property">query</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">              // 写法3(不常用)：props是一个对象，可以自己决定将什么作为props传给路由组件</span></span><br><span class="line"><span class="comment">              props: &#123;</span></span><br><span class="line"><span class="comment">                  id: &#x27;id&#x27;,</span></span><br><span class="line"><span class="comment">                  title: &#x27;title&#x27;,</span></span><br><span class="line"><span class="comment">                  content: &#x27;content&#x27;</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">          &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>, <span class="comment">// 命名路由</span></span><br><span class="line">      <span class="comment">// route level code-splitting</span></span><br><span class="line">      <span class="comment">// this generates a separate chunk (About.[hash].js) for this route</span></span><br><span class="line">      <span class="comment">// which is lazy-loaded when the route is visited.</span></span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/AboutView.vue&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<p>在<code>RouterLink</code>中传递参数的方式与传params参数的方式相同：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 写法1：将路由收到的所有params参数作为props传给路由组件 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如前文所述，下面2种写法等价 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/news/sport/1/sportnews/arsenalwin&quot;</span>&gt;</span>体育<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">         name:&#x27;sport&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">         params: &#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">             id: news.id,</span></span></span><br><span class="line"><span class="string"><span class="tag">             title: news.title,</span></span></span><br><span class="line"><span class="string"><span class="tag">             content: news.content</span></span></span><br><span class="line"><span class="string"><span class="tag">         &#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#125;&quot;</span>&gt;</span>体育<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 写法2: props为函数时可以自由决定传递给路由组件的参数 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上文配置中返回的路由的querystring，即将querystring作为props传递给路由组件 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如前文所述，下面2种写法等价 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/news/economy?id=2&amp;title=economynews&amp;content=btcfalldown&quot;</span>&gt;</span>财经<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">    name:&#x27;economy&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    query:&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">		id: news:id,</span></span></span><br><span class="line"><span class="string"><span class="tag">         title: news.title,</span></span></span><br><span class="line"><span class="string"><span class="tag">         content: news.content</span></span></span><br><span class="line"><span class="string"><span class="tag">    	&#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">	&#125;&quot;</span>&gt;</span>财经<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">RouterView</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> news = &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">id</span>: <span class="string">&#x27;id&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">title</span>: <span class="string">&#x27;title&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">content</span>: <span class="string">&#x27;content&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在路由视图中获取参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; id &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; content &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>([<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;content&#x27;</span>]) <span class="comment">// 使用defineProps接收RouterLink传来的params参数</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="RouterLink的replace属性"><a href="#RouterLink的replace属性" class="headerlink" title="RouterLink的replace属性"></a><code>RouterLink</code>的<code>replace</code>属性</h2><p>在<code>RouterLink</code>组件中使用<code>replace</code>属性，则在路由跳转时会使用<code>replace</code>模式，浏览器不会留下此URL的历史记录。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">replace</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">replace</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>与<code>replace</code>模式对应的是<code>push</code>模式，<code>push</code>模式会将访问的URL压入历史记录栈中，从而保存浏览器历史记录。</p>
<h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p><code>&lt;RouterLink&gt;</code>在浏览器渲染后会变成 HTML 原生<code>&lt;a&gt;</code>标签，当需要实现点击<code>&lt;button&gt;</code>跳转URL，或基于编程来实现URL跳转时，即想要脱离<code>&lt;RouterLink&gt;</code>实现路由跳转，需使用编程式路由导航。</p>
<p>简单示例，实现当前组件挂载3秒后自动跳转到路由<code>/news</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 使用useRouter hook 获取 router 对象</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 在当前组件挂载3秒后跳转到路由/news</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        router.<span class="title function_">push</span>(<span class="string">&#x27;/news&#x27;</span>) <span class="comment">// push方法即使用push路由模式跳转URL</span></span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">3000</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例2，使用编程式导航实现以下<code>&lt;RouterLink&gt;</code>路由导航功能：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/news/sport&quot;</span>&gt;</span>NewsSport<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/news/economy&quot;</span>&gt;</span>NewsEconomy<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">RouterView</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; <span class="title class_">RouterLink</span>, <span class="title class_">RouterView</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toHome&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toAbout&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toNewsSport(news)&quot;</span>&gt;</span>NewsSport<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toNewsEconomy(news)&quot;</span>&gt;</span>NewsEconomy<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">RouterView</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; <span class="title class_">RouterLink</span>, <span class="title class_">RouterView</span>, useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> news = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">id</span>: <span class="string">&#x27;id&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">title</span>: <span class="string">&#x27;title&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">content</span>: <span class="string">&#x27;content&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">toHome</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 使用push模式跳转</span></span></span><br><span class="line"><span class="language-javascript">    router.<span class="title function_">push</span>(<span class="string">&#x27;/&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">toAbout</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="comment">// 使用replace模式跳转</span></span></span><br><span class="line"><span class="language-javascript">    router.<span class="title function_">replace</span>(<span class="string">&#x27;/&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">toNewsSport</span>(<span class="params">news</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// push方法接收的参数类型基本与&lt;RouterLink&gt;的to属性接收的参数相同</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 可以接受字符串形式的路由路径，如上面2个方法中那样；</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 也可以向路由视图组件传递querystring参数和params参数：</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// router.push(&#x27;/news/sport?id=id&amp;title=title&amp;content=content&#x27;)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// router.push(`/news/sport?id=$&#123;news.id&#125;&amp;title=$&#123;news.title&#125;&amp;content=$&#123;news.content&#125;`)</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// router.push(&#x27;/news/sport/id/title/content&#x27;)</span></span></span><br><span class="line"><span class="language-javascript">    router.<span class="title function_">push</span>(<span class="string">`/news/sport/<span class="subst">$&#123;news.id&#125;</span>/<span class="subst">$&#123;news.title&#125;</span>/<span class="subst">$&#123;news.content&#125;</span>`</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">toNewsEconomy</span>(<span class="params">news</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 也可以接受对象作为参数，并且也可以向路由视图组件传递querystring参数和params参数：</span></span></span><br><span class="line"><span class="language-javascript">    router.<span class="title function_">push</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="attr">path</span>:<span class="string">&#x27;/news/economy&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">         <span class="attr">query</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="attr">id</span>: news.<span class="property">id</span>,</span></span><br><span class="line"><span class="language-javascript">             <span class="attr">title</span>: news.<span class="property">title</span>,</span></span><br><span class="line"><span class="language-javascript">             <span class="attr">content</span>: news.<span class="property">content</span></span></span><br><span class="line"><span class="language-javascript">         &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    router.<span class="title function_">push</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="attr">name</span>:<span class="string">&#x27;economy&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">         <span class="attr">params</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="attr">id</span>: news.<span class="property">id</span>,</span></span><br><span class="line"><span class="language-javascript">             <span class="attr">title</span>: news.<span class="property">title</span>,</span></span><br><span class="line"><span class="language-javascript">             <span class="attr">content</span>: news.<span class="property">content</span></span></span><br><span class="line"><span class="language-javascript">         &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>在路由配置中进行重定向配置：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">HomeView</span>,</span><br><span class="line">      <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span> <span class="comment">// 访问路由/时重定向至/home</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>, </span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/AboutView.vue&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<h1 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h1><p>安装<code>pinia</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i pinia</span><br></pre></td></tr></table></figure>

<p>在项目入口<code>main.ts</code>文件中引入<code>pinia</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="comment">// 引入pinia</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line"><span class="comment">// 创建pinia</span></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>();</span><br><span class="line"><span class="comment">// 安装pinia</span></span><br><span class="line">app.<span class="title function_">use</span>(pinia);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="使用Pinia存储和读取数据"><a href="#使用Pinia存储和读取数据" class="headerlink" title="使用Pinia存储和读取数据"></a>使用Pinia存储和读取数据</h2><p>根据约定，<code>store</code>目录用来存放Pinia定义的<code>useStore</code>对象的源文件，文件名通常是与其相关功能相对应。</p>
<p><img src="/2024/vue3-core/image-20240326214945605.png"></p>
<p>定义 <code>useCountStore</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// state方法所返回的对象的属性是各个实际存储数据(state)的变量</span></span><br><span class="line">    <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">sum</span>: <span class="number">0</span> <span class="comment">// 实际存储数据的state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在组件中存取<code>sum</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; countStore.sum &#125;&#125;</span><br><span class="line">        &#123;&#123; countStore.$state.sum &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; useCountStore &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/count&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> countStore = <span class="title function_">useCountStore</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 以下方式都可以取得sum</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(countStore.<span class="property">sum</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(countStore.<span class="property">$state</span>.<span class="property">sum</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="修改数据的3种方式"><a href="#修改数据的3种方式" class="headerlink" title="修改数据的3种方式"></a>修改数据的3种方式</h2><p><strong>方法1，直接赋值：</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">countStore.<span class="property">sum</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>方法2，使用<code>$patch</code>方法：</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">countStore.$patch(&#123;</span><br><span class="line">    <span class="attr">sum</span>:<span class="number">888</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果countStore中有多个存有多个state，也可以一次性修改多个state</span></span><br><span class="line">countStore.$patch(&#123;</span><br><span class="line">    <span class="attr">sum</span>:<span class="number">888</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>方法3，在定义store时，定义action方法：</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// actions里面放置的是一个一个的方法，用于响应组件中的“动作”</span></span><br><span class="line">    <span class="attr">actions</span>:&#123;</span><br><span class="line">        <span class="title function_">increment</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">sum</span>++</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sum</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">add</span>(<span class="params">value</span>)&#123; <span class="comment">// action方法也可以接收参数</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">sum</span> += value</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sum</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// state方法所返回的对象的属性是各个实际存储数据(state)的变量</span></span><br><span class="line">    <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">sum</span>: <span class="number">0</span> <span class="comment">// 实际存储数据的state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在组件中调用action方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; countStore.sum &#125;&#125;</span><br><span class="line">        &#123;&#123; countStore.$state.sum &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span></span><br><span class="line">        increment</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add(3)&quot;</span>&gt;</span></span><br><span class="line">        add</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; useCountStore &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/count&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> countStore = <span class="title function_">useCountStore</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    countStore.<span class="title function_">increment</span>();</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">value</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    countStore.<span class="title function_">add</span>(value);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="storeToRefs"><a href="#storeToRefs" class="headerlink" title="storeToRefs"></a><code>storeToRefs</code></h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; useCountStore, storeToRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/count&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> countStore = <span class="title function_">useCountStore</span>()</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 使用storeToRefs结构countStore不会丢失响应式</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> &#123; sum &#125; = <span class="title function_">storeToRefs</span>(countStore)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a><code>getters</code></h2><p>store的getters类似于Vue组件的计算属性：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">sum</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">actions</span>:&#123;</span><br><span class="line">        <span class="title function_">increment</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">sum</span>++</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sum</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">add</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">sum</span> += value</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sum</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 类似于vue组件的计算属性</span></span><br><span class="line">    <span class="attr">getters</span>: &#123;</span><br><span class="line">        <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> state.<span class="property">sum</span> *<span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>取得getters中的值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; useCountStore, storeToRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/count&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> countStore = <span class="title function_">useCountStore</span>()</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> &#123; sum, bigSum &#125; = <span class="title function_">storeToRefs</span>(countStore)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum) <span class="comment">// 1</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(bigSum) <span class="comment">// 10 因为 bigSum = sum * 10 </span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="subscribe方法"><a href="#subscribe方法" class="headerlink" title="$subscribe方法"></a><code>$subscribe</code>方法</h2><p>store的<code>$subscribe</code>方法可以监控store中state的变化，类似于Vue组件的watch：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; useCountStore, storeToRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/count&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> countStore = <span class="title function_">useCountStore</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">countStore.$subscribe(<span class="function">(<span class="params">mutation, state</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(mutation, state)</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="store的组合式写法"><a href="#store的组合式写法" class="headerlink" title="store的组合式写法"></a>store的组合式写法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 组合式写法的state</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 组合式写法的getter</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> doubleCount = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> * <span class="number">2</span>)</span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 组合式写法的action</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    count.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">return</span> &#123; count, doubleCount, increment &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h1><h2 id="props-1"><a href="#props-1" class="headerlink" title="props"></a>props</h2><p>props 是使用频率最高的组件通信方式，常用于进行父子组件间相互传递数据：</p>
<ul>
<li>父传子：父组件直接向子组件的属性值传递数据；</li>
<li>子传父：父组件向子组件的属性值传递一个函数，通过此函数间接获得子组件中的数据。</li>
</ul>
<h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p>父组件直接通过子组件的props向子组件传递数据。</p>
<p>父组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>车：&#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child</span> <span class="attr">:car</span>=<span class="string">&quot;car&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> car = <span class="title function_">ref</span>(<span class="string">&#x27;car&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>玩具：&#123;&#123; toy &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>符给的车：&#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> toy = <span class="title function_">ref</span>(<span class="string">&#x27;toy&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 定义props用于接收来自父组件传递的数据</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>([<span class="string">&#x27;car&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>“子传父”通过向子的props传递一个函数，来间接拿到数据。</p>
<p>父组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>车：&#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将函数getToy传给子组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child</span> <span class="attr">:car</span>=<span class="string">&quot;car&quot;</span> <span class="attr">:sendToy</span>=<span class="string">&quot;getToy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> car = <span class="title function_">ref</span>(<span class="string">&#x27;car&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">getToy</span>(<span class="params">value: string</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;father got&#x27;</span>, value)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>玩具：&#123;&#123; toy &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>符给的车：&#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 子组件调用父组件传来的函数，通过向此函数传参向父组件传递数据 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sendToy(toy)&quot;</span>&gt;</span></span><br><span class="line">            把玩具给父亲</span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> toy = <span class="title function_">ref</span>(<span class="string">&#x27;toy&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 定义props用于接收来自父组件传递的数据</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>([<span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;sendToy&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>通常也可以使用自定义事件来实现 <em>子组件向父组件</em> 传递数据。</p>
<p>父组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>车：&#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 为子组件的自定义事件sendToy绑定回调函数为getToy --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child</span> @<span class="attr">send-toy</span>=<span class="string">&quot;getToy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> car = <span class="title function_">ref</span>(<span class="string">&#x27;car&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">getToy</span>(<span class="params">value: string</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;father got&#x27;</span>, value)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>玩具：&#123;&#123; toy &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 点击按钮，子组件触发sendToy事件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;emit(&#x27;send-toy&#x27;)&quot;</span>&gt;</span></span><br><span class="line">            把玩具给父亲</span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不仅可以触发sendToy事件，还可以传递数据 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;emit(&#x27;send-toy&#x27;, toy)&quot;</span>&gt;</span></span><br><span class="line">            把玩具给父亲</span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> toy = <span class="title function_">ref</span>(<span class="string">&#x27;toy&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 定义自定义事件sendToy</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;send-toy&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="mitt"><a href="#mitt" class="headerlink" title="mitt"></a>mitt</h2><p><a href="https://github.com/developit/mitt">mitt</a> 是一个只有200Bytes的事件发送&#x2F;订阅库，也可以用来实现组件间通信，并且不仅可以实现父子组件之间的通信，还可以实现兄弟组件甚至任意组件间通信。</p>
<p>使用以下命令安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install --save mitt</span><br></pre></td></tr></table></figure>

<p>通常将工具库放到项目<code>src</code>目录下的<code>utils</code>目录中：</p>
<p><img src="/2024/vue3-core/image-20240327214623386.png"></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// emitter.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入mitt</span></span><br><span class="line"><span class="keyword">import</span> mitt <span class="keyword">from</span> <span class="string">&#x27;mitt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="title function_">mitt</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">emitter.on(&#x27;event1&#x27;, ()=&gt;&#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;event1 emitted&#x27;)</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">emitter.on(&#x27;event2&#x27;, ()=&gt;&#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;event2 emitted&#x27;)</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露emitter</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> emitter</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>子组件1<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>玩具：&#123;&#123; toy &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 为子组件的自定义事件sendToy绑定回调函数为getToy --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;emitter.emit(&#x27;send-toy&#x27;, toy)&quot;</span>&gt;</span></span><br><span class="line">            把玩具给子组件2</span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&#x27;@/utils/emitter&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> toy = <span class="title function_">ref</span>(<span class="string">&#x27;toy&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>子组件2<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>子组件1给的玩具：&#123;&#123; toy &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&#x27;@/utils/emitter&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> toy = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 绑定事件回调</span></span></span><br><span class="line"><span class="language-javascript">emitter.<span class="title function_">on</span>(<span class="string">&#x27;send-toy&#x27;</span>, <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到来自子组件1的&#x27;</span>, value);</span></span><br><span class="line"><span class="language-javascript">    toy.<span class="property">value</span> = value</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 在组件卸载后解绑事件</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    emitter.<span class="title function_">off</span>(<span class="string">&#x27;send-toy&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="组件v-model"><a href="#组件v-model" class="headerlink" title="组件v-model"></a>组件<code>v-model</code></h2><p>通常，我们使用<code>v-model</code>实现双向绑定：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-model 用在html标签上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>v-model</code>其实是以下代码的语法糖，这两行代码其实是等价的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;username&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;username = $event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h3><p><strong>其实现双向绑定的本质是：</strong></p>
<ul>
<li><code>:value=&quot;username&quot;</code>将<code>username</code>的值赋给<code>&lt;input&gt;</code>的<code>value</code>属性，实现了将<code>username</code>的值显示在输入框中。</li>
<li><code>@input=&quot;username = $event.target.value&quot;</code>又将输入框中的值传递给<code>username</code>。</li>
<li><code>$event.target.value</code>中，<code>$event</code>是事件对象（在这个例子中是<code>&lt;input&gt;</code>元素的input事件）；<code>target</code>是被触发事件的目标对象（在这个例子中是<code>&lt;input&gt;</code>元素）；<code>value</code>为<code>value</code>属性，即输入框中的值。</li>
</ul>
<p>那么接下来以此为思路封装一个<code>&lt;MyInput&gt;</code>组件，实现父子组件之间的数据双向绑定：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is an about page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-model 用在组件标签上 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">:modelValue</span>=<span class="string">&quot;username&quot;</span> @<span class="attr">update:modelValue</span>=<span class="string">&quot;username = $event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MyInput</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">MyInput</span> <span class="keyword">from</span> <span class="string">&quot;@/components/MyInput.vue&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> username = <span class="title function_">ref</span>(<span class="string">&#x27;zhangsan&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>MyInput.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>([<span class="string">&#x27;modelValue&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;update:modelValue&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>&lt;MyInput&gt;</code>实现的本质是：</strong></p>
<ul>
<li><code>MyInput</code>组件定义了一个名为<code>modelValue</code>的props。父组件通过这个props将<code>username</code>的值传递给<code>modelValue</code>。 然后，<code>MyInput</code>组件又将<code>modelValue</code>收到的值赋给<code>value</code>，从而将<code>username</code>的内容显示在输入框中。</li>
<li><code>MyInput</code>组件定义了一个自定义事件<code>update:modelValue</code>。当<code>input</code>事件被触发时，触发自定义事件<code>update:modelValue</code>并将输入框中的值传递给父组件。父组件在自定义事件<code>update:modelValue</code>被触发时，将<code>MyInput</code>通过事件传递来的值<code>$event</code>赋给<code>username</code>。此处由于<code>update:modelValue</code>是自定义事件，所以<code>$event</code>就是通过自定义事件传递的值。</li>
</ul>
<p>当然，在父组件里你也可以这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is an about page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">:modelValue</span>=<span class="string">&quot;username&quot;</span> @<span class="attr">update:modelValue</span>=<span class="string">&quot;getUsername&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MyInput</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">MyInput</span> <span class="keyword">from</span> <span class="string">&quot;@/components/MyInput.vue&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> username = <span class="title function_">ref</span>(<span class="string">&#x27;zhangsan&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">getUsername</span>(<span class="params">value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  username.<span class="property">value</span> = value</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>更进一步，也可以在父组件里直接使用<code>v-model</code>语法糖：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is an about page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MyInput</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">MyInput</span> <span class="keyword">from</span> <span class="string">&quot;@/components/MyInput.vue&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> username = <span class="title function_">ref</span>(<span class="string">&#x27;zhangsan&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>那么为什么<code>MyInput</code>不能像下面这样直接使用<code>v-model</code>双向绑定props呢？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;props.modelValue&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>([<span class="string">&#x27;modelValue&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到eslint报错了：</p>
<p><img src="/2024/vue3-core/image-20240330141835059.png"></p>
<p><strong>这其实由于Vue只支持 <em>单向数据流</em>，即：</strong></p>
<ul>
<li>父级组件传递给props的响应式变量更新时会向下传递给子组件，子组件中所有的props都会更新为最新的值；</li>
<li>但是反过来则不行，不应该在一个子组件内修改props。</li>
</ul>
<p>同时，如果<code>MyInput</code>像上面那样写，可以看到在Vue DevTools中修改父组件的<code>username</code>后，子组件的中输入框中的内容也跟着变化了：</p>
<p><img src="/2024/vue3-core/image-20240330142605365.png"></p>
<p>但是在Vue DevTools中查看子组件<code>MyInput</code>，可以看到props是不能编辑的，同时<code>update:model-value</code>也是没有声明的。并且，当你直接修改输入框中的内容后，<code>props.modelValue</code>的值也没有变，父组件中<code>username</code>的值也没有变。预想中的双向绑定并没有实现。</p>
<p><img src="/2024/vue3-core/image-20240330143125207.png"></p>
<h3 id="v-model的参数"><a href="#v-model的参数" class="headerlink" title="v-model的参数"></a><code>v-model</code>的参数</h3><p>组件上的 <code>v-model</code> 是可以接受一个参数的。如果不指定参数，则默认为<code>modelValue</code>，即<code>v-model</code>等价于<code>v-model:modelValue</code>。也就是说，组件上的<code>v-model</code>如果不添加参数，则默认是将值传递给组件的prop <code>modelValue</code>。</p>
<p>同样，相应地，组件中自定义事件的默认事件名为<code>update:modelValue</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is an about page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 双向绑定到userName props --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">v-model:userName</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MyInput</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">MyInput</span> <span class="keyword">from</span> <span class="string">&quot;@/components/MyInput.vue&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> username = <span class="title function_">ref</span>(<span class="string">&#x27;zhangsan&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>MyInput</code>组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;userName&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;emit(&#x27;update:userName&#x27;, $event.target.value)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 相应地，子组件中也要把props修改为userName</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>([<span class="string">&#x27;userName&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 相应地，自定义事件也要修改为update:userName</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;update:userName&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="多个v-model绑定"><a href="#多个v-model绑定" class="headerlink" title="多个v-model绑定"></a>多个<code>v-model</code>绑定</h3><p>父组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is an about page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">v-model</span>=<span class="string">&quot;nickname&quot;</span> <span class="attr">v-model:userName</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MyInput</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; nickname &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">MyInput</span> <span class="keyword">from</span> <span class="string">&quot;@/components/MyInput.vue&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> nickname = <span class="title function_">ref</span>(<span class="string">&#x27;nickName&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> username = <span class="title function_">ref</span>(<span class="string">&#x27;zhangsan&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>MyInput</code>组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;userName&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;emit(&#x27;update:userName&#x27;, $event.target.value)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>([<span class="string">&#x27;modelValue&#x27;</span>, <span class="string">&#x27;userName&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;update:modelValue&#x27;</span>, <span class="string">&#x27;update:userName&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染后效果：</p>
<p><img src="/2024/vue3-core/image-20240330150656285.png"></p>
<h2 id="defineModel"><a href="#defineModel" class="headerlink" title="defineModel"></a><code>defineModel</code></h2><p>Vue3.4版本新增的<code>defineModel</code>可以简化父子组件之间的双向绑定。是目前官方推荐的双向绑定实现方式。也就是说，从Vue3.4开始，不必再使用上节中的方式实现父子组件之间的双向绑定。</p>
<p>父组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is an about page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MyInput</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">MyInput</span> <span class="keyword">from</span> <span class="string">&quot;@/components/MyInput.vue&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> value = <span class="title function_">ref</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>MyInput</code>组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;model&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> model = <span class="title function_">defineModel</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/vue3-core/image-20240327235845488.png"></p>
<p>渲染后效果为：</p>
<p><img src="/2024/vue3-core/image-20240327235425665.png"></p>
<p>在子组件的输入框中输入字符，可以看到<code>&lt;p&gt;</code>中出现输入的字符，看来父组件的<code>value</code>和子组件输入框中的值确实实现了双向绑定。</p>
<h3 id="v-model的参数-1"><a href="#v-model的参数-1" class="headerlink" title="v-model的参数"></a><code>v-model</code>的参数</h3><p>使用<code>defineModel</code>时，<code>v-model</code>也可以接收一个参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">v-model:userName</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MyInput</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>父组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is an about page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">v-model:userName</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MyInput</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">MyInput</span> <span class="keyword">from</span> <span class="string">&quot;@/components/MyInput.vue&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> username = <span class="title function_">ref</span>(<span class="string">&#x27;zhangsan&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>MyInput</code>组件中可以通过将字符串作为第一个参数传递给 <code>defineModel()</code> 来支持相应的参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;userName&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> userName = <span class="title function_">defineModel</span>(<span class="string">&#x27;userName&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果需要额外的 prop 选项，应该在 model 名称之后传递：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title = <span class="title function_">defineModel</span>(<span class="string">&#x27;title&#x27;</span>, &#123; <span class="attr">required</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="多个v-model绑定-1"><a href="#多个v-model绑定-1" class="headerlink" title="多个v-model绑定"></a>多个<code>v-model</code>绑定</h3><p>父组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is an about page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">v-model</span>=<span class="string">&quot;nickname&quot;</span> <span class="attr">v-model:userName</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MyInput</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; nickname &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">MyInput</span> <span class="keyword">from</span> <span class="string">&quot;@/components/MyInput.vue&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> nickname = <span class="title function_">ref</span>(<span class="string">&#x27;nickName&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> username = <span class="title function_">ref</span>(<span class="string">&#x27;zhangsan&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>MyInput</code>组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;NickName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;UserName&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">NickName</span> = <span class="title function_">defineModel</span>()</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">UserName</span> = <span class="title function_">defineModel</span>(<span class="string">&#x27;userName&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a><code>$attrs</code></h2><p>组件的<code>$attts</code>属性可用来实现祖先组件、父组件与孙组件相互通信。其中，孙组件与祖先组件通信需借助祖先组件传递给孙组件一个函数来间接实现，类似于子组件使用props与父组件通信。</p>
<h3 id="祖传孙"><a href="#祖传孙" class="headerlink" title="祖传孙"></a>祖传孙</h3><p><img src="/2024/vue3-core/image-20240330182802645.png"></p>
<p><code>GrandFather.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;GrandFather&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>GrandFather<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>a: &#123;&#123; a &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>b: &#123;&#123; b &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>c: &#123;&#123; c &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>d: &#123;&#123; d &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 以下两行是等价的，v-bind是可以传入对象的 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;Father :a=&quot;a&quot; :b=&quot;b&quot; :c=&quot;c&quot; :d=&quot;d&quot; /&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Father</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; a, b, c, d &#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Father</span> <span class="keyword">from</span> <span class="string">&#x27;./Father.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> a = <span class="title function_">ref</span>(<span class="string">&#x27;a&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> b = <span class="title function_">ref</span>(<span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> c = <span class="title function_">ref</span>(<span class="string">&#x27;c&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> d = <span class="title function_">ref</span>(<span class="string">&#x27;d&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Father.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;Father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Father<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>a: &#123;&#123; a &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>未接收的其余props: &#123;&#123; $attrs &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>([<span class="string">&#x27;a&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Child.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;Child&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>未接收的其余props: &#123;&#123; $attrs &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染后为：</p>
<p><img src="/2024/vue3-core/image-20240330183054059.png"></p>
<h3 id="孙传祖"><a href="#孙传祖" class="headerlink" title="孙传祖"></a>孙传祖</h3><p>通过将祖先组件的方法传递给孙组件，孙组件可以间接修改祖先组件中的响应式对象：</p>
<p><img src="/2024/vue3-core/image-20240330184416815.png"></p>
<p><code>GrandFather.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;GrandFather&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>GrandFather<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>a: &#123;&#123; a &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>b: &#123;&#123; b &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>c: &#123;&#123; c &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>d: &#123;&#123; d &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将方法changeA传递给Father --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Father</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; a, b, c, d, changeA &#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Father</span> <span class="keyword">from</span> <span class="string">&#x27;./Father.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> a = <span class="title function_">ref</span>(<span class="string">&#x27;a&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> b = <span class="title function_">ref</span>(<span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> c = <span class="title function_">ref</span>(<span class="string">&#x27;c&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> d = <span class="title function_">ref</span>(<span class="string">&#x27;d&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">changeA</span>(<span class="params">newValue: string</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    a.<span class="property">value</span> = newValue</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Father.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;Father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Father<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>a: &#123;&#123; a &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>未接收的其余props: &#123;&#123; $attrs &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>([<span class="string">&#x27;a&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Child.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;Child&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>未接收的其余props: &#123;&#123; $attrs &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 点击按钮修改祖先组件中的ref a --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeA(&#x27;changeA&#x27;)&quot;</span>&gt;</span>changeA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 从props中接收祖先组件传来的changeA方法</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>([<span class="string">&#x27;changeA&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染后，点击按钮前：</p>
<p><img src="/2024/vue3-core/image-20240330184834433.png"></p>
<p>点击按钮后：</p>
<p><img src="/2024/vue3-core/image-20240330184856590.png"></p>
<h2 id="refs和-parent"><a href="#refs和-parent" class="headerlink" title="$refs和$parent"></a><code>$refs</code>和<code>$parent</code></h2><p><strong><code>$refs</code></strong> ：</p>
<ul>
<li><p>值为对象，包含所有被 <code>ref</code> 属性（模板引用）标识的 DOM 元素或组件实例。</p>
</li>
<li><p>可通过<code>$refs</code>实现父传子通信。</p>
</li>
</ul>
<p><strong><code>$parent</code></strong> ：</p>
<ul>
<li><code>$parent</code>是当前组件的父组件的对象引用。</li>
<li>可通过<code>$parent</code>实现子传父通信。</li>
</ul>
<p><code>Father.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Father<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>car: &#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeToy(&#x27;ttooyy&#x27;)&quot;</span>&gt;</span>修改toy<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- $refs可以获得当前组件所有通过模板引用ref获取到的子组件，即c1和c2 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAll($refs)&quot;</span>&gt;</span>changeAll<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&quot;c1&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child2</span> <span class="attr">ref</span>=<span class="string">&quot;c2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Child2</span> <span class="keyword">from</span> <span class="string">&#x27;./Child2.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> car = <span class="title function_">ref</span>(<span class="string">&#x27;car&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> c1 = <span class="title function_">ref</span>()</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> c2 = <span class="title function_">ref</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">changeToy</span>(<span class="params">newValue: string</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    c1.<span class="property">value</span>.<span class="property">toy</span> = newValue</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">changeAll</span>(<span class="params">refs: any</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> refs) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 如果子组件中有book属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="string">&#x27;book&#x27;</span> <span class="keyword">in</span> refs[key]) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 将book改为&#x27;three body problems&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            refs[key][<span class="string">&#x27;book&#x27;</span>] = <span class="string">&#x27;three body problems&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 如果子组件中有game属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="string">&#x27;game&#x27;</span> <span class="keyword">in</span> refs[key]) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 将game改为&#x27;palworld&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            refs[key][<span class="string">&#x27;game&#x27;</span>] = <span class="string">&#x27;palworld&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 将car暴露给子组件</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineExpose</span>(&#123; car &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Child.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Child&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>toy: &#123;&#123; toy &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>book: &#123;&#123; book &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- $parent 是父组件对象的引用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCar($parent)&quot;</span>&gt;</span>给爹换辆BMW<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> toy = <span class="title function_">ref</span>(<span class="string">&#x27;toy&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> book = <span class="title function_">ref</span>(<span class="string">&#x27;book&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">changeCar</span>(<span class="params">parent: any</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    parent.<span class="property">car</span> = <span class="string">&#x27;BMW&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 由于Vue的单向数据流，如果不使用defineExpose将数据暴露出去，</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 那么，父组件即便使用ref模板引用获取到子组件对象，也没法修改子组件的数据</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 将数据暴露给父组件</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineExpose</span>(&#123; toy, book &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Child2.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Child2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Child2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>computer: &#123;&#123; computer &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>game: &#123;&#123; game &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> computer = <span class="title function_">ref</span>(<span class="string">&#x27;computer&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> game = <span class="title function_">ref</span>(<span class="string">&#x27;game&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 将数据暴露给父组件</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineExpose</span>(&#123; computer, game &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染后：</p>
<p><img src="/2024/vue3-core/image-20240330194816099.png"></p>
<p>点击“修改toy”：</p>
<p><img src="/2024/vue3-core/image-20240330194832278.png"></p>
<p>点击“changeAll”：</p>
<p><img src="/2024/vue3-core/image-20240330194846111.png"></p>
<p>点击“给爹换辆BMW”：</p>
<p><img src="/2024/vue3-core/image-20240330194922057.png"></p>
<h2 id="provide和inject"><a href="#provide和inject" class="headerlink" title="provide和inject"></a><code>provide</code>和<code>inject</code></h2><p><code>GrandFather.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;GrandFather&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>GrandFather<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>money: &#123;&#123; money &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>car: &#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Father</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; provide, reactive, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Father</span> <span class="keyword">from</span> <span class="string">&#x27;./Father.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> money = <span class="title function_">ref</span>(<span class="number">100</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> car = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">brand</span>: <span class="string">&#x27;BMW&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">price</span>: <span class="number">100</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">getMoney</span>(<span class="params">val: number</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    money.<span class="property">value</span> += val</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 向后代组件提供数据</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">provide</span>(<span class="string">&#x27;money&#x27;</span>, money)</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>, car)</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">provide</span>(<span class="string">&#x27;giveMoney&#x27;</span>, getMoney)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.GrandFather</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: aquamarine;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Fahter.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Father<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>car: &#123;&#123; c &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 取出GrandFather provide的car</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> c = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.Father</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Child.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Child&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>money: &#123;&#123; m &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>car: &#123;&#123; c &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;giveMoney(100)&quot;</span>&gt;</span>给爷爷钱<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// inject可以直接收一个参数，但如果没有provide则为undefined</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// const m = inject(&#x27;money&#x27;) // 取出GrandFather provide的money</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// const c = inject(&#x27;car&#x27;) // 取出GrandFather provide的car</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// inject也可以接收默认值作为第二个参数，当第一个参数没有provide时，会返回默认值</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> m = <span class="title function_">inject</span>(<span class="string">&#x27;money&#x27;</span>, <span class="string">&#x27;默认值&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> c = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>, &#123; <span class="attr">brand</span>: <span class="string">&#x27;mini&#x27;</span>, <span class="attr">price</span>: <span class="number">50</span> &#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> giveMoney = <span class="title function_">inject</span>(<span class="string">&#x27;giveMoney&#x27;</span>, <span class="function">(<span class="params">v: number</span>) =&gt;</span> &#123; v &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.Child</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染后：</p>
<p><img src="/2024/vue3-core/image-20240330225823642.png"></p>
<p>点击“给爷爷钱”：</p>
<p><img src="/2024/vue3-core/%E5%8A%A8%E7%94%BB.gif"></p>
<h2 id="Slots"><a href="#Slots" class="headerlink" title="Slots"></a>Slots</h2><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p><code>Father.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Father<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(game, index) in games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                        &#123;&#123; game &#125;&#125;</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(game, index) in games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                        &#123;&#123; game &#125;&#125;</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(game, index) in games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                        &#123;&#123; game &#125;&#125;</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> games = <span class="title function_">reactive</span>([</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&#x27;FIFA 23&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;Palworld&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;WoW&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;Final Fantasy&quot;</span></span></span><br><span class="line"><span class="language-javascript">])</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.Father</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">justify-content</span>: space-evently;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Child.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Child&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.Child</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">2px</span> solid white;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染后：</p>
<p><img src="/2024/vue3-core/image-20240330234559849.png"></p>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p><code>Father.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Father<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:s1</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>热门游戏<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:s2</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(game, index) in games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                            &#123;&#123; game &#125;&#125;</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- #是v-slot的简便写法 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> #<span class="attr">s3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>今日美食<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in foods&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                            &#123;&#123; item &#125;&#125;</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- #是v-slot的简便写法 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> #<span class="attr">s4</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>今日影视<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in films&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                            &#123;&#123; item &#125;&#125;</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> games = <span class="title function_">reactive</span>([</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&#x27;FIFA 23&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;Palworld&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;WoW&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;Final Fantasy&quot;</span></span></span><br><span class="line"><span class="language-javascript">])</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> foods = <span class="title function_">reactive</span>([</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;KFC&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;Burger King&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;McDonald&quot;</span></span></span><br><span class="line"><span class="language-javascript">])</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> films = <span class="title function_">reactive</span>([</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&#x27;Mission Impossible&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;007&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;WoW&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;Final Fantasy&quot;</span></span></span><br><span class="line"><span class="language-javascript">])</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.Father</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">justify-content</span>: space-evently;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Child.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Child&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;s1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;s2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;s3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;s4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.Child</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">2px</span> solid white;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染后：</p>
<p><img src="/2024/vue3-core/image-20240331000844416.png"></p>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>在某些场景下插槽的内容可能想要<strong>在父组件中使用子组件作用域中的数据</strong>，或者，<strong>同时使用父组件域内和子组件域内的数据</strong>。要做到这一点，我们需要使用作用域插槽，来让子组件在渲染时将一部分数据提供给插槽。</p>
<p><code>Father.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Father<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 获取子组件传给slot的props，这里变量名params可以随便起 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">&quot;params&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 现在便可以从params中取出子组件传给slot的propsGames --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(game, index) in params.propsGames&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                            &#123;&#123; game &#125;&#125;</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 这里变量名可以随便起，例如上面是params，这里是args--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">&quot;args&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(game, index) in args.propsGames&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                            &#123;&#123; game &#125;&#125;</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 也直接对象解构 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; propsGames &#125;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(game, index) in propsGames&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                        &#123;&#123; game &#125;&#125;</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.Father</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">justify-content</span>: space-evently;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Child.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Child&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>游戏列表<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将games作为props传递给slot，这样就可以在父组件中获取到 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:propsGames</span>=<span class="string">&quot;games&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> games = <span class="title function_">reactive</span>([</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&#x27;FIFA 23&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;Palworld&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;WoW&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;Final Fantasy&quot;</span></span></span><br><span class="line"><span class="language-javascript">])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.Child</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">2px</span> solid white;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染后：</p>
<p><img src="/2024/vue3-core/image-20240331221005074.png"></p>
<h3 id="具名作用域插槽"><a href="#具名作用域插槽" class="headerlink" title="具名作用域插槽"></a>具名作用域插槽</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>=<span class="string">&quot;headerProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; headerProps &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">&quot;defaultProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; defaultProps &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>=<span class="string">&quot;footerProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; footerProps &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>向具名插槽中传入 props：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span> <span class="attr">message</span>=<span class="string">&quot;hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="其他常用API"><a href="#其他常用API" class="headerlink" title="其他常用API"></a>其他常用API</h1><h2 id="shallowRef与shallowReactive"><a href="#shallowRef与shallowReactive" class="headerlink" title="shallowRef与shallowReactive"></a><code>shallowRef</code>与<code>shallowReactive</code></h2><p>**<code>shallowRef</code> **</p>
<ul>
<li>作用：创建一个响应式数据，但是只对顶层属性进行响应式处理。</li>
<li>用法：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myVar = <span class="title function_">shallowRef</span>(<span class="string">&#x27;initialValue&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：只跟踪引用值的变化，不关心值内部属性的变化。</li>
</ul>
<p><strong><code>shallowReactvie</code></strong></p>
<ul>
<li>作用：创建一个浅层响应式对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的。</li>
<li>用法：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = <span class="title function_">shallowReactive</span>(&#123;&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：对象的顶层属性是响应式的，但嵌套对象的属性不是。</li>
</ul>
<h2 id="readonly和shallowReadonly"><a href="#readonly和shallowReadonly" class="headerlink" title="readonly和shallowReadonly"></a><code>readonly</code>和<code>shallowReadonly</code></h2><h2 id="toRaw和markRaw"><a href="#toRaw和markRaw" class="headerlink" title="toRaw和markRaw"></a><code>toRaw</code>和<code>markRaw</code></h2><h2 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a><code>customRef</code></h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> initValue = <span class="string">&#x27;initValue&#x27;</span></span><br><span class="line"><span class="keyword">let</span> msg = <span class="title function_">customRef</span>(<span class="function">(<span class="params">track, trigger</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// msg 被读取时调用</span></span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">track</span>() <span class="comment">// 跟踪msg的变化，一旦msg变化就更新</span></span><br><span class="line">            <span class="keyword">return</span> initValue</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// msg被修改时调用</span></span><br><span class="line">        <span class="title function_">set</span>(<span class="params">val</span>)&#123;</span><br><span class="line">            initValue = val</span><br><span class="line">            <span class="title function_">trigger</span>() <span class="comment">// msg发生变化了，通知Vue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用<code>customRef</code>封装一个hooks，实现输入框输入数据时延迟显示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// useMsgRef.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; customRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">initValue: <span class="built_in">string</span>, delay: <span class="built_in">number</span></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">timer</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">let</span> msg = <span class="title function_">customRef</span>(<span class="function">(<span class="params">track, trigger</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">// msg 被读取时调用</span></span><br><span class="line">            <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="title function_">track</span>() <span class="comment">// 跟踪msg的变化，一旦msg变化就更新</span></span><br><span class="line">                <span class="keyword">return</span> initValue</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// msg被修改时调用</span></span><br><span class="line">            <span class="title function_">set</span>(<span class="params">val</span>)&#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">                timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                    initValue = val</span><br><span class="line">                	<span class="title function_">trigger</span>() <span class="comment">// msg发生变化了，通知Vue</span></span><br><span class="line">                &#125;, delay)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        msg</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用这个<code>useMsgRef.ts</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> useMsgRef <span class="keyword">from</span> <span class="string">&#x27;./useMsgRef&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 使用useMsgRef来定义一个响应式数据且延迟2秒显示</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> &#123; msg &#125; = <span class="title function_">useMsgRef</span>(<span class="string">&#x27;你好&#x27;</span>, <span class="number">2000</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/2024/vue3-core/adsfasd.gif"></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Front-End</tag>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>《The Go Programming Language》学习笔记</title>
    <url>/2022/notes-of-gopl/</url>
    <content><![CDATA[<blockquote>
<p>本文为《The Go Programming Language》学习笔记，内容主要为<a href="https://books.studygolang.com/gopl-zh/%E7%9A%84%E7%BF%BB%E8%AF%91%E7%89%88%EF%BC%8C%E5%B9%B6%E5%9C%A8%E6%AD%A4%E7%BF%BB%E8%AF%91%E7%89%88%E5%9F%BA%E7%A1%80%E4%B8%8A%E8%B0%83%E6%95%B4%E6%A0%BC%E5%BC%8F%E6%88%96%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%EF%BC%8C%E4%BB%A5%E6%96%B9%E4%BE%BF%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%AE%B0%E5%BF%86%E3%80%82%E9%83%A8%E5%88%86%E9%9A%BE%E7%90%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E4%BC%9A%E5%AF%B9%E7%85%A7%E8%8B%B1%E6%96%87%E7%89%88%E9%87%8D%E6%96%B0%E7%BF%BB%E8%AF%91%E3%80%82">https://books.studygolang.com/gopl-zh/的翻译版，并在此翻译版基础上调整格式或添加注释，以方便学习和记忆。部分难理解的内容，会对照英文版重新翻译。</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="Go语言起源"><a href="#Go语言起源" class="headerlink" title="Go语言起源"></a><a href="https://gopl-zh.github.io/preface.html#go%E8%AF%AD%E8%A8%80%E8%B5%B7%E6%BA%90">Go语言起源</a></h2><p>下图展示了有哪些早期的编程语言对Go语言的设计产生了重要影响。</p>
<p><img src="/2022/notes-of-gopl/ch0-01.png" alt="img"></p>
<h2 id="Go语言项目"><a href="#Go语言项目" class="headerlink" title="Go语言项目"></a><a href="https://gopl-zh.github.io/preface.html#go%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE">Go语言项目</a></h2><p>Go项目包括编程语言本身，附带了相关的工具和标准库，最后但并非代表不重要的是，关于简洁编程哲学的宣言。</p>
<p>Go语言的这些地方都做的还不错：</p>
<ul>
<li><p>拥有自动垃圾回收</p>
</li>
<li><p>一个包系统</p>
</li>
<li><p>函数作为一等公民</p>
</li>
<li><p>词法作用域</p>
</li>
<li><p>系统调用接口</p>
</li>
<li><p>只读的UTF8字符串等</p>
</li>
</ul>
<p>但是Go语言本身只有很少的特性：</p>
<ul>
<li>没有隐式的数值转换</li>
<li>没有构造函数和析构函数</li>
<li>没有运算符重载</li>
<li>没有默认参数</li>
<li>没有继承</li>
<li><del>没有泛型</del></li>
<li>没有异常</li>
<li>没有宏</li>
<li>没有函数修饰</li>
<li>没有线程局部存储</li>
</ul>
<p>在实践中，Go语言简洁的类型系统给程序员带来了更多的安全性和更好的运行时性能。</p>
<p>Go语言提供了基于<code>CSP</code>的并发特性支持。Go语言的动态栈使得轻量级线程<code>goroutine</code>的初始栈可以很小，因此，创建一个<code>goroutine</code>的代价很小，创建百万级的<code>goroutine</code>完全是可行的。</p>
<p>Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I&#x2F;O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。</p>
<span id="more"></span>

<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World"></a><a href="https://gopl-zh.github.io/ch1/ch1-01.html#11-hello-world">Hello, World</a></h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, 世界&quot;</span>) <span class="comment">// Println 函数可以打印以空格间隔的一个或多个值，并在最后添加一个换行符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Go 是一门编译型语言，Go 语言的工具链将源代码及其依赖转换成计算机的机器指令（译注：静态编译）。</p>
<p>Go 语言提供的工具都通过一个单独的命令 <code>go</code> 调用，<code>go</code> 命令有一系列子命令。</p>
<p><code>run</code> 子命令编译一个或多个以<code>.go</code> 结尾的源文件，链接库文件，并运行最终生成的可执行文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run helloworld.go</span></span><br><span class="line">Hello, 世界</span><br></pre></td></tr></table></figure>

<p> <code>build</code> 子命令能够编译这个程序，保存编译后的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build helloworld.go</span></span><br></pre></td></tr></table></figure>

<p>这个命令生成一个与源代码同名的可执行二进制文件，之后你可以随时运行它。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./helloworld</span></span><br><span class="line">Hello, 世界</span><br></pre></td></tr></table></figure>

<h3 id="Go-源文件的组成部分"><a href="#Go-源文件的组成部分" class="headerlink" title="Go 源文件的组成部分"></a>Go 源文件的组成部分</h3><p><strong>包（package）</strong></p>
<p>Go 语言的代码通过<strong>包</strong>（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个 <code>.go</code> 源代码文件组成，目录定义包的作用。</p>
<p> <strong><code>package</code> 声明</strong></p>
<p>每个源文件都以一条 <code>package</code> 声明语句开始，这个例子里就是 <code>package main</code>，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。</p>
<p><code>main</code> 包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在 <code>main</code> 里的 <code>main</code> <em>函数</em> 也很特殊，它是整个程序执行时的入口。<code>main</code> 函数一般调用其它包里的函数完成很多工作（如：<code>fmt.Println</code>）。</p>
<p><strong><code>import</code> 声明</strong></p>
<p><code>import</code> 声明必须跟在文件的 <code>package</code> 声明之后，它告诉编译器源文件需要导入哪些包。<code>hello world</code> 例子只用到了一个包，大多数程序需要导入多个包。缺少了必要的包或者导入了不需要的包，程序都无法编译通过。</p>
<p>Go 的标准库提供了 100 多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如 <code>fmt</code> 包，就含有格式化输出、接收输入的函数。<code>Println</code> 是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符。</p>
<p><strong>程序语句</strong></p>
<p>紧跟在<code>import</code>声明之后的，则是组成程序的函数、变量、常量、类型的声明语句（分别由关键字 <code>func</code>、<code>var</code>、<code>const</code>、<code>type</code> 定义），以及其他程序语句。</p>
<p>Go 语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。</p>
<p>Go 语言在代码格式上采取了很强硬的态度。<code>gofmt</code>工具把代码格式化为标准格式，并且 <code>go</code> 工具中的 <code>fmt</code> 子命令会对指定包，否则默认为当前目录中所有。</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>大多数的程序都是处理输入，产生输出；这也正是“计算”的定义。命令行参数就是最主要的输入源之一。</p>
<p><code>os</code> 包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从 <code>os</code> 包的 <code>Args</code> 变量获取；<code>os</code> 包外部使用 <code>os.Args</code> 访问该变量。</p>
<p><code>os.Args</code> 变量是一个字符串（string）的 <em>切片</em>（slice）。现在先把切片 <code>s</code> 当作数组元素序列，序列的长度动态变化，用 <code>s[i]</code> 访问单个元素，用 <code>s[m:n]</code> 获取子序列。序列的元素数目为 <code>len(s)</code>。和大多数编程语言类似，区间索引时，Go 语言里也采用左闭右开形式，即，区间包括第一个索引元素，不包括最后一个，比如 <code>a=[1,2,3,4,5]</code>, <code>a[0:3]=[1,2,3]</code>，不包含索引为3的元素；比如 <code>s[m:n]</code> 这个切片，<code>0≤m≤n≤len(s)</code>，包含 <code>n-m</code> 个元素。如果省略切片表达式的 <code>m</code> 或 <code>n</code>，会默认传入 <code>0</code> 或 <code>len(s)</code>，即<code>s[:]</code>等同于<code>s[0:len(s)]</code>。</p>
<p><code>os.Args</code> 的第一个元素：<code>os.Args[0]</code>，是命令本身的名字；其它的元素则是程序启动时传给它的参数。</p>
<p>下面是 Unix 里 <code>echo</code> 命令的一份实现，<code>echo</code> 把它的命令行参数打印成一行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Echo1 prints its command-line arguments.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s, sep <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(os.Args); i++ &#123;</span><br><span class="line">        s += sep + os.Args[i]</span><br><span class="line">        sep = <span class="string">&quot; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释语句以 <code>//</code> 开头。</p>
<p><code>var</code> 声明定义了两个 <code>string</code> 类型的变量 <code>s</code> 和 <code>sep</code>。变量会在声明时直接初始化。如果变量没有显式初始化，则被隐式地赋予其类型的 <em>零值</em>（zero value），数值类型是 <code>0</code>，字符串类型是空字符串 <code>&quot;&quot;</code>。</p>
<p>运算符 <code>+=</code> 是赋值运算符（assignment operator），每种数值运算符或逻辑运算符，如 <code>+</code> 或 <code>*</code>，都有对应的赋值运算符。</p>
<p>循环索引变量 <code>i</code> 在 <code>for</code> 循环的第一部分中定义。符号 <code>:=</code> 是 <em>短变量声明</em>（short variable declaration）的一部分，这是定义一个或多个变量并根据它们的初始值为这些变量赋予适当类型的语句。</p>
<p>自增语句 <code>i++</code> 给 <code>i</code> 加 <code>1</code>；这和 <code>i+=1</code> 以及 <code>i=i+1</code> 都是等价的。对应的还有 <code>i--</code> 给 <code>i</code> 减 <code>1</code>。它们是语句，而不像 C 系的其它语言那样是表达式，所以 <code>j=i++</code> 非法。</p>
<p>Go 语言只有 <code>for</code> 循环这一种循环语句。<code>for</code> 循环有多种形式，其中一种如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> initialization; condition; post &#123;</span><br><span class="line">    <span class="comment">// zero or more statements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for</code> 循环三个部分不需括号包围。大括号强制要求，左大括号必须和 <em><code>post</code></em> 语句在同一行。</p>
<ul>
<li><em><code>initialization</code></em> 语句是可选的，在循环开始前执行。<em><code>initalization</code></em> 如果存在，必须是一条 <em>简单语句</em>（simple statement），即，短变量声明、自增语句、赋值语句或函数调用。</li>
<li><code>condition</code> 是一个布尔表达式（boolean expression），其值在每次循环迭代开始时计算。如果为 <code>true</code> 则执行循环体语句。</li>
<li><code>post</code> 语句在循环体执行结束后执行，之后再次对 <code>condition</code> 求值。<code>condition</code> 值为 <code>false</code> 时，循环结束。</li>
</ul>
<p>for 循环的这三个部分每个都可以省略，如果省略 <code>initialization</code> 和 <code>post</code>，分号也可以省略：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a traditional &quot;while&quot; loop</span></span><br><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果连 <code>condition</code> 也省略了，像下面这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a traditional infinite loop</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for 循环的另一种形式，在某种数据类型的区间（range）上遍历，如字符串或切片。以下 echo 的第二版本展示了这种形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Echo2 prints its command-line arguments.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s, sep := <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, arg := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">        s += sep + arg</span><br><span class="line">        sep = <span class="string">&quot; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次循环迭代，<code>range</code> 产生一对值；索引以及在该索引处的元素值。这个例子不需要索引，但 <code>range</code> 的语法要求，要处理元素，必须处理索引。并且 Go 语言不允许使用无用的局部变量（local variables）。这种情况适用于 <em>空标识符</em>（blank identifier），即 <code>_</code>（也就是下划线）。<em>空标识符</em> 可用于在任何语法需要变量名但程序逻辑不需要的时候（如：在循环里）丢弃不需要的循环索引，并保留元素值。</p>
<p>声明一个变量有好几种方式，下面这些都等价：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;&quot;</span>  <span class="comment">// 短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span> <span class="comment">// 依赖于字符串的默认初始化零值机制，被初始化为 &quot;&quot;。</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果连接涉及的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使用 <code>strings</code> 包的 <code>Join</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(strings.Join(os.Args[<span class="number">1</span>:], <span class="string">&quot; &quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找重复的行"><a href="#查找重复的行" class="headerlink" title="查找重复的行"></a><a href="https://gopl-zh.github.io/ch1/ch1-03.html#13-%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E8%A1%8C">查找重复的行</a></h2><p>本节会实现一个名为 <code>dup</code> 的程序的三个版本；灵感来自于 Unix 的 <code>uniq</code> 命令，其寻找相邻的重复行。</p>
<p><code>dup</code> 的第一个版本打印标准输入中多次出现的行，以重复次数开头。该程序将引入 <code>if</code> 语句，<code>map</code> 数据类型以及 <code>bufio</code> 包。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dup1 prints the text of each line that appears more than</span></span><br><span class="line"><span class="comment">// once in the standard input, preceded by its count.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    input := bufio.NewScanner(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        counts[input.Text()]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> ignoring potential errors from input.Err()</span></span><br><span class="line">    <span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123; <span class="comment">// line 为 key, n 为 value</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%d\t%s\n&quot;</span>, n, line)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如 <code>for</code> 循环一样，<code>if</code> 语句条件两边也不加括号，但是主体部分需要加。<code>if</code> 语句的 <code>else</code> 部分是可选的，在 <code>if</code> 的条件为 <code>false</code> 时执行。</p>
<p><strong>map</strong> 存储了键&#x2F;值（key&#x2F;value）的集合，对集合元素，提供常数时间的存、取或测试操作。键可以是任意类型，只要其值能用 <code>==</code> 运算符比较，最常见的例子是字符串；值则可以是任意类型。这个例子中的键是字符串，值是整数。</p>
<p>每次 <code>dup</code> 读取一行输入，该行被当做键存入 <code>map</code>，其对应的值递增。<code>counts[input.Text()]++</code> 语句等价下面两句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">line := input.Text()</span><br><span class="line">counts[line] = counts[line] + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>map</code> 中不含某个键时不用担心，首次读到新行时，等号右边的表达式 <code>counts[line]</code> 的值将被计算为其类型的零值，对于 <code>int</code> 即 <code>0</code>。</p>
<p>为了打印结果，我们使用了基于 <code>range</code> 的循环，以迭代 <code>counts</code>。与迭代 slice 类似，迭代 map 每次得到两个结果：键和键的值。</p>
<blockquote>
<p><strong>注意： map 的迭代顺序被有意设计成不确定的、随机的，每次运行迭代，其顺序都会变化。</strong></p>
</blockquote>
<p><code>bufio</code> 包使处理输入和输出方便又高效。<code>Scanner</code> 类型是该包最有用的特性之一，它读取输入并将其拆成行或单词；通常是处理行形式的输入最简单的方法。</p>
<p>程序使用短变量声明创建 <code>bufio.Scanner</code> 类型的变量 <code>input</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">input := bufio.NewScanner(os.Stdin)</span><br></pre></td></tr></table></figure>

<p>该变量从程序的标准输入中读取内容。每次调用 <code>input.Scan()</code>，即读入下一行，并移除行末的换行符；读取的内容可以调用 <code>input.Text()</code> 得到。<code>Scan</code> 函数在读到一行时返回 <code>true</code>，不再有输入时返回 <code>false</code>。</p>
<p>类似于 C 或其它语言里的 <code>printf</code> 函数，<code>fmt.Printf</code> 函数对一些表达式产生格式化输出。该函数的首个参数是个格式字符串，指定后续参数被如何格式化。各个参数的格式取决于“转换字符”（conversion character），形式为百分号后跟一个字母。</p>
<p><code>Printf</code> 有一大堆这种转换字符，Go程序员称之为<em>动词（verb）</em>。下表展示了常用的几个：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">%d          十进制整数</span><br><span class="line">%x, %o, %b  十六进制，八进制，二进制整数。</span><br><span class="line">%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00</span><br><span class="line">%t          布尔：true或false</span><br><span class="line">%c          字符（rune） (Unicode码点)</span><br><span class="line">%s          字符串</span><br><span class="line">%q          带双引号的字符串&quot;abc&quot;或带单引号的字符&#x27;c&#x27;</span><br><span class="line">%v          变量的自然形式（natural format）</span><br><span class="line">%T          变量的类型</span><br><span class="line">%%          字面上的百分号标志（无操作数）</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>Printf</code> 不会换行，除非格式字符串中存在换行符<code>\n</code>。</p>
<p>按照惯例，以字母 <code>f</code> 结尾的格式化函数，如 <code>log.Printf</code> 和 <code>fmt.Errorf</code>，都采用 <code>fmt.Printf</code> 的格式化准则。而以 <code>ln</code> 结尾的格式化函数，则遵循 <code>Println</code> 的方式，以跟 <code>%v</code> 差不多的方式格式化参数，并在最后添加一个换行符。（译注：后缀 <code>f</code> 指 <code>format</code>，<code>ln</code> 指 <code>line</code>。）</p>
<p><code>dup</code> 程序的下个版本读取标准输入或是使用 <code>os.Open</code> 打开各个具名文件，并操作它们。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dup2 prints the count and text of lines that appear more than once</span></span><br><span class="line"><span class="comment">// in the input.  It reads from stdin or from a list of named files.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    files := os.Args[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span> &#123;</span><br><span class="line">        countLines(os.Stdin, counts)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, arg := <span class="keyword">range</span> files &#123;</span><br><span class="line">            <span class="comment">// 打开文件</span></span><br><span class="line">            f, err := os.Open(arg) <span class="comment">// os.Open 返回 *os.File 和 error</span></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// 如果 err 等于内置值nil（相当于其它语言里的 NULL），那么文件被成功打开。</span></span><br><span class="line">                fmt.Fprintf(os.Stderr, <span class="string">&quot;dup2: %v\n&quot;</span>, err)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            countLines(f, counts)</span><br><span class="line">            f.Close() <span class="comment">// 关闭文件f</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%d\t%s\n&quot;</span>, n, line)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countLines</span><span class="params">(f *os.File, counts <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    input := bufio.NewScanner(f)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        counts[input.Text()]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> ignoring potential errors from input.Err()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>countLines</code> 函数在其声明前被调用。函数和包级别的变量（package-level entities）可以任意顺序声明，并不影响其被调用。</p>
<p><code>map</code> 是一个由 <code>make</code> 函数创建的数据结构的引用。<code>map</code> 作为参数传递给某函数时，该函数接收这个引用的一份拷贝（copy，或译为副本），被调用函数对 <code>map</code> 底层数据结构的任何修改，调用者函数都可以通过持有的 <code>map</code> 引用看到。在我们的例子中，<code>countLines</code> 函数向 <code>counts</code> 插入的值，也会被 <code>main</code> 函数看到。（译注：类似于 C++ 里的引用传递，实际上指针是另一个指针了，但内部存的值指向同一块内存）</p>
<blockquote>
<p><strong>注意：Go 语言只有按值传递，传递的都是变量的一个副本，一个拷贝。只不过拷贝的内容，可能是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；可能是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。</strong></p>
</blockquote>
<p><code>dup</code> 的前两个版本以”流”模式读取输入，并根据需要拆分成多个行。理论上，这些程序可以处理任意数量的输入数据。下面这个版本<code>dup3</code>则是一口气把文件的数据全部读到内存中，一次分割为多行，然后处理它们：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, filename := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">        data, err := os.ReadFile(filename)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">&quot;dup3: %v\n&quot;</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, line := <span class="keyword">range</span> strings.Split(<span class="type">string</span>(data), <span class="string">&quot;\n&quot;</span>) &#123;</span><br><span class="line">            counts[line]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%d\t%s\n&quot;</span>, n, line)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中， <code>os.ReadFile</code> 函数，其读取指定文件的全部内容。<code>strings.Split</code> 函数的作用与前文提到的 <code>strings.Join</code> 相反，把字符串分割成子串的切片。</p>
<blockquote>
<p>包 <code>io/ioutil</code> 已被弃用， 新代码推荐使用包 <code>io</code> 和 <code>os</code>中的实现。如：<code>ioutil.ReadFile()</code>变为<code>os.ReadFile()</code>，<code>ioutil.ReadAll()</code>变为<code>io.ReadAll()</code>。</p>
</blockquote>
<p><code>os.ReadFile</code> 函数返回一个字节切片（byte slice），必须把它转换为 <code>string</code>，才能用 <code>strings.Split</code> 分割。</p>
<p>实现上，<code>bufio.Scanner</code>、<code>ioutil.ReadFile</code> 和 <code>ioutil.WriteFile</code> 都使用 <code>*os.File</code> 的 <code>Read</code> 和 <code>Write</code> 方法，但是，大多数程序员很少需要直接调用那些低级（lower-level）函数。像 <code>bufio</code> 和 <code>io/ioutil</code> 包中所提供的那些高级（higher-level）函数，用起来要容易点。</p>
<h2 id="GIF-动画"><a href="#GIF-动画" class="headerlink" title="GIF 动画"></a><a href="https://gopl-zh.github.io/ch1/ch1-04.html#14-gif%E5%8A%A8%E7%94%BB">GIF 动画</a></h2><p>下面的程序会演示Go语言标准库里的image这个package的用法，我们会用这个包来生成一系列的bit-mapped图，然后将这些图片编码为一个GIF动画。我们生成的图形名字叫利萨如图形（Lissajous figures），这种效果是在1960年代的老电影里出现的一种视觉特效。它们是协振子在两个纬度上振动所产生的曲线，比如两个sin正弦波分别在x轴和y轴输入会产生的曲线。图1.1是这样的一个例子：</p>
<p><img src="/2022/notes-of-gopl/ch1-01.png" alt="img"></p>
<p>译注：要看这个程序的结果，需要将标准输出重定向到一个GIF图像文件（使用 <code>./lissajous &gt; output.gif</code> 命令）。下面是GIF图像动画效果：</p>
<p><img src="/2022/notes-of-gopl/ch1-01.gif" alt="img"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lissajous generates GIF animations of random Lissajous figures.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;image&quot;</span></span><br><span class="line">    <span class="string">&quot;image/color&quot;</span></span><br><span class="line">    <span class="string">&quot;image/gif&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量声明和变量声明在包级别，在整个包中都是可以共享的。</span></span><br><span class="line"><span class="comment">// 变量的字面量定义</span></span><br><span class="line"><span class="keyword">var</span> palette = []color.Color&#123;color.White, color.Black&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量声明</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    whiteIndex = <span class="number">0</span> <span class="comment">// first color in palette</span></span><br><span class="line">    blackIndex = <span class="number">1</span> <span class="comment">// next color in palette</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// The sequence of images is deterministic unless we seed</span></span><br><span class="line">    <span class="comment">// the pseudo-random number generator using the current time.</span></span><br><span class="line">    <span class="comment">// Thanks to Randall McPherson for pointing out the omission.</span></span><br><span class="line">    rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line">    lissajous(os.Stdout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lissajous</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 把常量声明定义在函数体内部，那么这种常量就只能在函数体内用。</span></span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        cycles  = <span class="number">5</span>     <span class="comment">// number of complete x oscillator revolutions</span></span><br><span class="line">        res     = <span class="number">0.001</span> <span class="comment">// angular resolution</span></span><br><span class="line">        size    = <span class="number">100</span>   <span class="comment">// image canvas covers [-size..+size]</span></span><br><span class="line">        nframes = <span class="number">64</span>    <span class="comment">// number of animation frames</span></span><br><span class="line">        delay   = <span class="number">8</span>     <span class="comment">// delay between frames in 10ms units</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    freq := rand.Float64() * <span class="number">3.0</span> <span class="comment">// relative frequency of y oscillator</span></span><br><span class="line">    anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br><span class="line">    phase := <span class="number">0.0</span> <span class="comment">// phase difference</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nframes; i++ &#123;</span><br><span class="line">        rect := image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>*size+<span class="number">1</span>, <span class="number">2</span>*size+<span class="number">1</span>)</span><br><span class="line">        img := image.NewPaletted(rect, palette)</span><br><span class="line">        <span class="keyword">for</span> t := <span class="number">0.0</span>; t &lt; cycles*<span class="number">2</span>*math.Pi; t += res &#123;</span><br><span class="line">            x := math.Sin(t)</span><br><span class="line">            y := math.Sin(t*freq + phase)</span><br><span class="line">            img.SetColorIndex(size+<span class="type">int</span>(x*size+<span class="number">0.5</span>), size+<span class="type">int</span>(y*size+<span class="number">0.5</span>),</span><br><span class="line">                blackIndex)</span><br><span class="line">        &#125;</span><br><span class="line">        phase += <span class="number">0.1</span></span><br><span class="line">        anim.Delay = <span class="built_in">append</span>(anim.Delay, delay)</span><br><span class="line">        anim.Image = <span class="built_in">append</span>(anim.Image, img)</span><br><span class="line">    &#125;</span><br><span class="line">    gif.EncodeAll(out, &amp;anim) <span class="comment">// <span class="doctag">NOTE:</span> ignoring encoding errors</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main函数调用lissajous函数，用它来向标准输出流打印信息，所以下面这个命令会像图1.1中产生一个GIF动画。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build gopl.io/ch1/lissajous</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./lissajous &gt;out.gif</span></span><br></pre></td></tr></table></figure>

<h2 id="获取-URL"><a href="#获取-URL" class="headerlink" title="获取 URL"></a><a href="https://gopl-zh.github.io/ch1/ch1-05.html#15-%E8%8E%B7%E5%8F%96url">获取 URL</a></h2><p>利用Go语言的<code>net</code>包和其他建立在<code>net</code>包基础之上的一系列包，可以更简单地用网络收发信息，还可以建立更底层的网络连接，编写服务器程序。在这些情景下，Go语言原生的并发特性（在第八章中会介绍）显得尤其好用。</p>
<p>为了最简单地展示基于HTTP获取信息的方式，下面给出一个示例程序fetch，这个程序将获取对应的url，并将其源文本打印出来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fetch prints the content found at a URL.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">        resp, err := http.Get(url) <span class="comment">// 创建HTTP请求的函数</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">&quot;fetch: %v\n&quot;</span>, err)</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        b, err := io.ReadAll(resp.Body) <span class="comment">// io.ReadAll函数从response中读取全部内容到b</span></span><br><span class="line">        resp.Body.Close() <span class="comment">// 关闭resp的Body流，防止资源泄露</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">&quot;fetch: reading %s: %v\n&quot;</span>, url, err)</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s&quot;</span>, b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build gopl.io/ch1/fetch</span><br><span class="line">$ ./fetch http:<span class="comment">//gopl.io</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;The Go Programming Language&lt;/title&gt;title&gt;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HTTP请求如果失败了的话，会得到下面这样的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./fetch http://bad.gopl.io</span></span><br><span class="line">fetch: Get http://bad.gopl.io: dial tcp: lookup bad.gopl.io: no such host</span><br></pre></td></tr></table></figure>

<p>译注：在大天朝的网络环境下很容易重现这种错误，下面是Windows下运行得到的错误信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run main.go http://gopl.io</span></span><br><span class="line">fetch: Get http://gopl.io: dial tcp: lookup gopl.io: getaddrinfow: No such host is known.</span><br></pre></td></tr></table></figure>

<p>无论哪种失败原因，我们的程序都用了<code>os.Exit</code>函数来终止进程，并且返回一个status错误码，其值为1。</p>
<h2 id="并发获取多个-URL"><a href="#并发获取多个-URL" class="headerlink" title="并发获取多个 URL"></a><a href="https://gopl-zh.github.io/ch1/ch1-06.html#16-%E5%B9%B6%E5%8F%91%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AAurl">并发获取多个 URL</a></h2><p>Go语言最有意思并且最新奇的特性就是对并发编程的支持。这里我们只浅尝辄止地来体验一下Go语言里的goroutine和channel。</p>
<p>下面的例子fetchall，和前面小节的fetch程序所要做的工作基本一致，fetchall的特别之处在于它会同时去获取所有的URL，所以这个程序的总执行时间不会超过执行时间最长的那一个任务，前面的fetch程序执行时间则是所有任务执行时间之和。fetchall程序只会打印获取的内容大小和经过的时间，不会像之前那样打印获取的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fetchall fetches URLs in parallel and reports their times and sizes.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>) <span class="comment">// 创建一个传递string类型参数的channel</span></span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">        <span class="keyword">go</span> fetch(url, ch) <span class="comment">// start a goroutine</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意 for range 不一定非得使用短变量声明接收迭代中每一项的值</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">        fmt.Println(&lt;-ch) <span class="comment">// receive from channel ch</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%.2fs elapsed\n&quot;</span>, time.Since(start).Seconds())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(url <span class="type">string</span>, ch <span class="keyword">chan</span>&lt;- <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ch &lt;- fmt.Sprint(err) <span class="comment">// send to channel ch</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为我们需要这个方法返回的字节数，但是又不想要其内容。</span></span><br><span class="line">    <span class="comment">// io.Copy把响应的Body拷贝到io.Discard输出流中丢弃</span></span><br><span class="line">    nbytes, err := io.Copy(io.Discard, resp.Body)</span><br><span class="line">    resp.Body.Close() <span class="comment">// don&#x27;t leak resources</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ch &lt;- fmt.Sprintf(<span class="string">&quot;while reading %s: %v&quot;</span>, url, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    secs := time.Since(start).Seconds()</span><br><span class="line">    ch &lt;- fmt.Sprintf(<span class="string">&quot;%.2fs  %7d  %s&quot;</span>, secs, nbytes, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面使用fetchall来请求几个地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build gopl.io/ch1/fetchall</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./fetchall https://golang.org http://gopl.io https://godoc.org</span></span><br><span class="line">0.14s     6852  https://godoc.org</span><br><span class="line">0.16s     7261  https://golang.org</span><br><span class="line">0.48s     2475  http://gopl.io</span><br><span class="line">0.48s elapsed</span><br></pre></td></tr></table></figure>

<p>goroutine是一种函数的并发执行方式，而channel是用来在goroutine之间进行参数传递。main函数本身也运行在一个goroutine中，而go function则表示创建一个新的goroutine，并在这个新的goroutine中执行这个函数。</p>
<p>当一个goroutine尝试在一个channel上做send或者receive操作时，这个goroutine会阻塞在调用处，直到另一个goroutine从这个channel里接收或者写入值，这样两个goroutine才会继续执行channel操作之后的逻辑。在这个例子中，每一个fetch函数在执行时都会往channel里发送一个值（<code>ch &lt;- expression</code>），主函数负责接收这些值（<code>&lt;-ch</code>）。</p>
<p>这个程序中我们用main函数来完整地处理&#x2F;接收所有fetch函数传回的字符串，可以避免因为有两个goroutine同时完成而使得其输出交错在一起的危险。</p>
<h2 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a><a href="https://gopl-zh.github.io/ch1/ch1-07.html#17-web%E6%9C%8D%E5%8A%A1">Web服务</a></h2><p>在本节中，我们会展示一个微型服务器，这个服务器的功能是返回当前用户正在访问的URL。比如用户访问的是 <a href="http://localhost:8000/hello">http://localhost:8000/hello</a> ，那么响应是 <code>URL.Path = &quot;hello&quot;</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Server1 is a minimal &quot;echo&quot; server.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler) <span class="comment">// each request calls handler</span></span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler echoes the Path component of the request URL r.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;URL.Path = %q\n&quot;</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们在后台运行这个服务程序。如果你的操作系统是Mac OS X或者Linux，那么在运行命令的末尾加上一个&amp;符号，即可让程序简单地跑在后台，windows下可以在另外一个命令行窗口去运行这个程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run src/gopl.io/ch1/server1/main.go &amp;</span></span><br></pre></td></tr></table></figure>

<p>现在可以通过命令行来发送客户端请求了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build gopl.io/ch1/fetch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./fetch http://localhost:8000</span></span><br><span class="line">URL.Path = &quot;/&quot;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./fetch http://localhost:8000/help</span></span><br><span class="line">URL.Path = &quot;/help&quot;</span><br></pre></td></tr></table></figure>

<p>还可以直接在浏览器里访问这个URL，然后得到返回结果，如图1.2：</p>
<p><img src="/2022/notes-of-gopl/ch1-02.png"></p>
<p>在这个服务的基础上叠加特性是很容易的。一种比较实用的修改是为访问的url添加某种状态。比如，下面这个版本输出了同样的内容，但是会对请求的次数进行计算，访问<code>/count</code>这个URL返回访问的次数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Server2 is a minimal &quot;echo&quot; and counter server.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果请求pattern是以/结尾，那么所有以该url为前缀的url都会被这条规则匹配。</span></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/count&quot;</span>, counter) <span class="comment">// 对/count这个url的请求会调用到counter这个函数</span></span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler echoes the Path component of the requested URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    count++</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;URL.Path = %q\n&quot;</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// counter echoes the number of calls so far.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Count %d\n&quot;</span>, count)</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这些代码的背后，服务器每一次接收请求处理时都会另起一个goroutine，这样服务器就可以同一时间处理多个请求。然而在并发情况下，假如真的有两个请求同一时刻去更新<code>count</code>，那么这个值可能并不会被正确地增加；这个程序可能会引发一个严重的bug：竞态条件（参见9.1）。为了避免这个问题，我们必须保证每次修改变量的最多只能有一个goroutine，这也就是代码里的<code>mu.Lock()</code>和<code>mu.Unlock()</code>调用将修改<code>count</code>的所有行为包在中间的目的。</p>
<p>下面是一个更为丰富的例子，handler函数会把请求的http头和请求的form数据都打印出来，这样可以使检查和调试这个服务更为方便：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handler echoes the HTTP request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;%s %s %s\n&quot;</span>, r.Method, r.URL, r.Proto)</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Header &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;Header[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Host = %q\n&quot;</span>, r.Host)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;RemoteAddr = %q\n&quot;</span>, r.RemoteAddr)</span><br><span class="line">    <span class="keyword">if</span> err := r.ParseForm(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Print(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;Form[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用<code>http.Request</code>这个struct里的字段来输出下面这样的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /?q=query HTTP/1.1</span><br><span class="line">Header[&quot;Accept-Encoding&quot;] = [&quot;gzip, deflate, sdch&quot;]</span><br><span class="line">Header[&quot;Accept-Language&quot;] = [&quot;en-US,en;q=0.8&quot;]</span><br><span class="line">Header[&quot;Connection&quot;] = [&quot;keep-alive&quot;]</span><br><span class="line">Header[&quot;Accept&quot;] = [&quot;text/html,application/xhtml+xml,application/xml;...&quot;]</span><br><span class="line">Header[&quot;User-Agent&quot;] = [&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)...&quot;]</span><br><span class="line">Host = &quot;localhost:8000&quot;</span><br><span class="line">RemoteAddr = &quot;127.0.0.1:59911&quot;</span><br><span class="line">Form[&quot;q&quot;] = [&quot;query&quot;]</span><br></pre></td></tr></table></figure>

<p>可以看到这里的 <code>ParseForm</code> 被嵌套在了if语句中。Go语言允许这样的一个简单的语句结果作为局部的变量声明出现在 if 语句的最前面，这一点对错误处理很有用处。等同于下面这样写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := r.ParseForm()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Print(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 if 和<code>ParseForm</code>结合可以让代码更加简单，并且可以限制<code>err</code>变量的作用域。</p>
<p>在这些程序中，我们看到了很多不同的类型被输出到标准输出流中。比如前面的fetch程序，把HTTP的响应数据拷贝到了os.Stdout，lissajous程序里我们输出的是一个文件。fetchall程序则完全忽略到了HTTP的响应Body，只是计算了一下响应Body的大小，这个程序中把响应Body拷贝到了<code>io.Discard</code>。在本节的web服务器程序中则是用<code>fmt.Fprintf</code>直接写到了<code>http.ResponseWriter</code>中。</p>
<p>尽管三种具体的实现流程并不太一样，但它们都实现<code>io.Writer</code>接口，即当它们被调用需要一个标准流输出时都可以满足。</p>
<p>让我们简单地将这里的web服务器和之前写的 lissajous 函数结合起来，这样GIF动画可以被写到HTTP的客户端，而不是之前的标准输出流。只要在web服务器的代码里加入下面这几行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">handler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    lissajous(w)</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br></pre></td></tr></table></figure>

<p>或者另一种等价形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    lissajous(w)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>HandleFunc</code> 函数的第二个参数是一个函数的字面值，也就是一个在使用时定义的匿名函数。</p>
<p>做完这些修改之后，在浏览器里访问 <a href="http://localhost:8000/">http://localhost:8000</a> 。每次你载入这个页面都可以看到一个像图1.3那样的动画。</p>
<p><img src="/2022/notes-of-gopl/ch1-03.png" alt="img"></p>
<h2 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h2><p><strong>控制流：</strong> 这里是一个简单的switch的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> coinflip() &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;heads&quot;</span>:</span><br><span class="line">    heads++</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;tails&quot;</span>:</span><br><span class="line">    tails++</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;landed on edge!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在翻转硬币的时候，例子里的<code>coinflip</code>函数返回几种不同的结果，每一个case都会对应一个返回结果，这里需要注意，Go语言并不需要显式地在每一个case后写break，语言默认执行完case后的逻辑语句会自动退出。</p>
<p>Go语言里的switch还可以不带操作对象，可以直接罗列多种条件，像其它语言里面的多个if else一样。这种形式叫做 <strong>无tag switch</strong> (tagless switch)；这和<code>switch true</code>是等价的。switch不带操作对象时默认用true值代替，然后将每个case的表达式和<code>true</code>值进行比较。像for和if控制语句一样，switch也可以紧跟一个简短的变量声明，一个自增表达式、赋值语句，或者一个函数调用。下面是一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Signum</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> +<span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>break和continue语句会改变控制流。和其它语言中的break和continue一样，break会中断当前的循环，并开始执行循环之后的内容，而continue会跳过当前循环，并开始执行下一次循环。这两个语句除了可以控制for循环，还可以用来控制switch和select语句。如果我们想跳过的是更外层的循环的话，我们可以在相应的位置加上label，这样break和continue就可以根据我们的想法来continue和break任意循环。这看起来甚至有点像goto语句的作用了。当然，一般程序员也不会用到这种操作。这两种行为更多地被用到机器生成的代码中。</p>
<p><strong>命名类型：</strong> 类型声明使得我们可以很方便地给一个特殊类型一个名字。因为struct类型声明通常非常地长，所以我们总要给这种struct取一个名字。本章中就有这样一个例子，二维点类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p Point</span><br></pre></td></tr></table></figure>

<p><strong>指针：</strong> Go语言提供了指针。指针是一种直接存储了变量的内存地址的数据类型。在其它语言中，比如C语言，指针操作是完全不受约束的。在另外一些语言中，指针一般被处理为“引用”，除了到处传递这些指针之外，并不能对这些指针做太多事情。Go语言在这两种范围中取了一种平衡。指针是可见的内存地址，<code>&amp;</code>操作符可以返回一个变量的内存地址，并且<code>*</code>操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作。</p>
<p><strong>方法和接口：</strong> <strong>方法</strong>是和命名类型关联的一类函数。Go语言里比较特殊的是方法可以被关联到任意一种命名类型。<strong>接口</strong>是一种抽象类型，这种类型可以让我们以同样的方式来处理不同的固有类型，不用关心它们的具体实现，而只需要关注它们提供的方法。</p>
<p><strong>包（packages）：</strong> Go语言提供了一些很好用的package，并且这些package是可以扩展的。</p>
<p>在你开始写一个新程序之前，最好先去检查一下是不是已经有了现成的库可以帮助你更高效地完成这件事情。你可以在 <a href="https://golang.org/pkg">https://golang.org/pkg</a> 和 <a href="https://godoc.org/">https://godoc.org</a> 中找到标准库和社区写的package。godoc 这个工具可以让你直接在本地命令行阅读标准库的文档。比如下面这个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go doc http.ListenAndServe</span><br><span class="line">package http // import &quot;net/http&quot;</span><br><span class="line">func ListenAndServe(addr string, handler Handler) error</span><br><span class="line">    ListenAndServe listens on the TCP network address addr and then</span><br><span class="line">    calls Serve with handler to handle requests on incoming connections.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>注释：</strong> 我们之前已经提到过了在源文件的开头写的注释是这个源文件的文档。在每一个函数之前写一个说明函数行为的注释也是一个好习惯。这些惯例很重要，因为这些内容会被像<code>godoc</code>这样的工具检测到，并且在执行命令时显示这些注释。</p>
<p>多行注释可以用 <code>/* ... */</code> 来包裹，和其它大多数语言一样。在文件一开头的注释一般都是这种形式，或者一大段的解释性的注释文字也会被这符号包住，来避免每一行都需要加<code>//</code>。在注释中<code>//</code>和<code>/*</code>是没什么意义的，所以不要在注释中再嵌入注释。</p>
<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：<strong>一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。</strong> </p>
<ul>
<li><p>大写字母和小写字母是不同的：<code>heapSort</code>和<code>Heapsort</code>是两个不同的名字。</p>
</li>
<li><p>如果一个名字是在函数内部定义，那么它就只在函数内部有效。</p>
</li>
<li><p>如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。</p>
</li>
<li><p>包级名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是包级名字，且以大写字母开头的，那么它将是导出的，也就是说可以被外部的包访问，例如<code>fmt</code>包的<code>Printf</code>函数就是导出的，可以在<code>fmt</code>包外部访问。包本身的名字一般总是用小写字母。</p>
</li>
<li><p>在习惯上，Go语言程序员推荐使用 <strong>驼峰式</strong> 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。</p>
</li>
</ul>
<p>Go语言中类似if和switch的关键字有25个；关键字不能用于自定义名字，只能在特定语法结构中使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break      default       func     interface   select</span><br><span class="line">case       defer         go       map         struct</span><br><span class="line">chan       else          goto     package     switch</span><br><span class="line">const      fallthrough   if       range       type</span><br><span class="line">continue   for           import   return      var</span><br></pre></td></tr></table></figure>

<p>此外，还有大约30多个预定义的名字，比如<code>int</code>和<code>true</code>等，主要对应内建的常量、类型和函数。这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内建常量: true false iota nil</span><br><span class="line"></span><br><span class="line">内建类型: int int8 int16 int32 int64</span><br><span class="line">          uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line">          float32 float64 complex128 complex64</span><br><span class="line">          bool byte rune string error</span><br><span class="line"></span><br><span class="line">内建函数: make len cap new append copy close delete</span><br><span class="line">          complex real imag</span><br><span class="line">          panic recover</span><br></pre></td></tr></table></figure>



<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：<code>var</code>、<code>const</code>、<code>type</code>和<code>func</code>，分别对应变量、常量、类型和函数实体对象的声明。</p>
<p>一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。</p>
<p>每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。</p>
<p>包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要，函数内部的名字则必须先声明之后才能使用。</p>
<p>例如，下面的例子中声明了一个常量、一个函数和两个变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Boiling prints the boiling point of water.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boilingF = <span class="number">212.0</span>  <span class="comment">// 包级变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f = boilingF  <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">var</span> c = (f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>  <span class="comment">// 局部变量</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;boiling point = %g°F or %g°C\n&quot;</span>, f, c)</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// boiling point = 212°F or 100°C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问。相比之下，局部声明的名字就只能在函数内部很小的范围被访问。</p>
<p>一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。如果函数没有返回值，那么返回值列表是省略的。执行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>var声明语句用于声明变量，并设置变量初始值。其中<code>类型</code>或<code>= 表达式</code>两个部分可以省略其中的一个。变量声明的一般语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名字 类型 = 表达式  <span class="comment">//创建一个特定类型的变量，并设置变量的初始值。</span></span><br><span class="line"><span class="keyword">var</span> 变量名字 = 表达式 <span class="comment">// 省略类型信息，将根据初始化表达式来推导变量的类型信息。</span></span><br><span class="line"><span class="keyword">var</span> 变量名字 类型 <span class="comment">// 初始化表达式被省略，那么将用零值初始化该变量。</span></span><br></pre></td></tr></table></figure>

<p>也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j, k <span class="type">int</span>                 <span class="comment">// int, int, int</span></span><br><span class="line"><span class="keyword">var</span> b, f, s = <span class="literal">true</span>, <span class="number">2.3</span>, <span class="string">&quot;four&quot;</span> <span class="comment">// bool, float64, string</span></span><br></pre></td></tr></table></figure>

<p>一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f, err = os.Open(name) <span class="comment">// os.Open returns a file and an error</span></span><br></pre></td></tr></table></figure>

<p>数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan 和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">fmt.Println(s == <span class="string">&quot;&quot;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">fmt.Println(i == <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n <span class="type">float64</span></span><br><span class="line">fmt.Println(n == <span class="number">0.0</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="type">bool</span></span><br><span class="line">fmt.Println(b == <span class="literal">false</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sli []<span class="type">string</span></span><br><span class="line">fmt.Println(sli == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">fmt.Println(p == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">fmt.Println(c == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">fmt.Println(f == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">fmt.Println(m == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">fmt.Println(arr) <span class="comment">// [0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">fmt.Println(t) <span class="comment">//&#123; 0&#125;</span></span><br><span class="line">fmt.Println(t.name == <span class="string">&quot;&quot;</span>) <span class="comment">// true</span></span><br><span class="line">fmt.Println(t.age == <span class="number">0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态。</p>
<h3 id="简短变量声明"><a href="#简短变量声明" class="headerlink" title="简短变量声明"></a>简短变量声明</h3><p>在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 :&#x3D; 表达式”形式声明变量，变量的类型根据表达式来自动推导。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br><span class="line">freq := rand.Float64() * <span class="number">3.0</span></span><br><span class="line">t := <span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<p>var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">100</span>                  <span class="comment">// an int</span></span><br><span class="line"><span class="keyword">var</span> boiling <span class="type">float64</span> = <span class="number">100</span> <span class="comment">// a float64</span></span><br><span class="line"><span class="keyword">var</span> names []<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="keyword">var</span> p Point</span><br></pre></td></tr></table></figure>

<p>和var形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i, j := <span class="number">0</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>但是这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用，比如for语句的循环的初始化语句部分。</p>
<p>请记住<code>:=</code>是一个变量声明语句，而<code>=</code>是一个变量赋值操作。也不要混淆多个变量的声明和元组的多重赋值，后者是将右边各个表达式的值赋值给左边对应位置的各个变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i, j = j, i <span class="comment">// 交换 i 和 j 的值</span></span><br></pre></td></tr></table></figure>

<p>和普通var形式的变量声明语句一样，简短变量声明语句也可以用函数的返回值来声明和初始化变量，像下面的<code>os.Open</code>函数调用将返回两个值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...use f...</span></span><br><span class="line">f.Close()</span><br></pre></td></tr></table></figure>

<p><strong>注意：简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的作用域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。</strong> 在下面的代码中，第一个语句声明了in和err两个变量。在第二个语句只声明了out一个变量，然后对已经声明的err进行了赋值操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">in, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">out, err := os.Create(outfile)</span><br></pre></td></tr></table></figure>

<p>简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">f, err := os.Create(outfile) <span class="comment">// compile error: no new variables</span></span><br></pre></td></tr></table></figure>

<p>解决的方法是第二个简短变量声明语句改用普通的多重赋值语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">f, err = os.Create(outfile)</span><br></pre></td></tr></table></figure>

<p>简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>一个变量对应一个保存了变量对应类型值的内存空间。普通变量在声明语句创建时被绑定到一个变量名，比如叫<code>x</code>的变量。</p>
<p>一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。</p>
<p>如果用<code>var x int</code>声明语句声明一个<code>x</code>变量，那么<code>&amp;x</code>表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是<code>*int</code>，指针被称之为“指向int类型的指针”。如果指针名字为<code>p</code>，那么可以说“<code>p</code>指针指向变量<code>x</code>”，或者说“<code>p</code>指针保存了x变量的内存地址”。同时<code>*p</code>表达式对应<code>p</code>指针指向的变量的值。一般<code>*p</code>表达式读取指针指向的变量的值，这里为int类型的值，同时因为<code>*p</code>对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">p := &amp;x         <span class="comment">// p, of type *int, points to x</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">*p = <span class="number">2</span>          <span class="comment">// equivalent to x = 2</span></span><br><span class="line">fmt.Println(x)  <span class="comment">// &quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<p>对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="type">string</span></span><br><span class="line">		age  <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> p Person = Person&#123;name: <span class="string">&quot;Mike&quot;</span>, age: <span class="number">12</span>&#125;</span><br><span class="line">	fmt.Println(p.name, p.age) <span class="comment">// Mike 12</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> name *<span class="type">string</span> = &amp;p.name</span><br><span class="line">	<span class="keyword">var</span> age *<span class="type">int</span> = &amp;p.age</span><br><span class="line">	*name = <span class="string">&quot;Micheal&quot;</span></span><br><span class="line">	*age = <span class="number">18</span></span><br><span class="line">	fmt.Println(p)  <span class="comment">// &#123;Micheal 18&#125;</span></span><br></pre></td></tr></table></figure>

<p>任何类型的指针的零值都是<code>nil</code>。如果p指向某个有效变量，那么<code>p != nil</code>测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是<code>nil</code>时才相等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line">fmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == <span class="literal">nil</span>) <span class="comment">// &quot;true false false&quot;</span></span><br></pre></td></tr></table></figure>

<p>在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = f()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    v := <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &amp;v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次调用f函数都将返回不同的结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(f() == f()) <span class="comment">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<p>因为指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">(p *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    *p++ <span class="comment">// 非常重要：只是增加p指向的变量的值，并不改变p指针！！！</span></span><br><span class="line">    <span class="keyword">return</span> *p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v := <span class="number">1</span></span><br><span class="line">incr(&amp;v)              <span class="comment">// side effect: v is now 2</span></span><br><span class="line">fmt.Println(incr(&amp;v)) <span class="comment">// &quot;3&quot; (and v is 3)</span></span><br></pre></td></tr></table></figure>

<p>指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Echo4 prints its command-line arguments.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag.Bool和flag.String函数的参数依次为命令行参数、默认值、参数描述信息</span></span><br><span class="line"><span class="keyword">var</span> n = flag.Bool(<span class="string">&quot;n&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;omit trailing newline&quot;</span>) <span class="comment">// 变量n是一个bool类型的指针，指向命令行标志参数n的变量</span></span><br><span class="line"><span class="keyword">var</span> sep = flag.String(<span class="string">&quot;s&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;separator&quot;</span>) <span class="comment">// 变量sep为一个字符串类型的指针，指向命令行标志参数sep的变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Print(strings.Join(flag.Args(), *sep))</span><br><span class="line">    <span class="keyword">if</span> !*n &#123;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当程序运行时，必须在使用标志参数对应的变量之前先调用<code>flag.Parse</code>函数，用于更新每个标志参数对应变量的值（之前是默认值）。对于非标志参数的普通命令行参数可以通过调用<code>flag.Args()</code>函数来访问，返回值对应一个字符串类型的slice。如果在<code>flag.Parse</code>函数解析命令行参数时遇到错误，默认将打印相关的提示信息，然后调用<code>os.Exit(2)</code>终止程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build gopl.io/ch2/echo4</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./echo4 a bc def</span></span><br><span class="line">a bc def</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./echo4 -s / a bc def</span></span><br><span class="line">a/bc/def</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./echo4 -n a bc def</span></span><br><span class="line">a bc def$</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./echo4 -<span class="built_in">help</span></span></span><br><span class="line">Usage of ./echo4:</span><br><span class="line">  -n    omit trailing newline</span><br><span class="line">  -s string</span><br><span class="line">        separator (default &quot; &quot;)</span><br></pre></td></tr></table></figure>



<h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><p>另一个创建变量的方法是调用内建的new函数。表达式<code>new(T)</code>将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>)   <span class="comment">// p, *int 类型, 指向匿名的 int 变量</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// &quot;0&quot;</span></span><br><span class="line">*p = <span class="number">2</span>          <span class="comment">// 设置 int 匿名变量的值为 2</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// &quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<p>用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用<code>new(T)</code>。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。</p>
<p>下面的两个newInt函数有着相同的行为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dummy <span class="type">int</span></span><br><span class="line">    <span class="keyword">return</span> &amp;dummy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">q := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">fmt.Println(p == q) <span class="comment">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<p>当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是0，例如<code>struct&#123;&#125;</code>和<code>[0]int</code>，有可能有相同的地址（依赖具体的语言实现）（译注：请谨慎使用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查看<code>runtime.SetFinalizer</code>函数相关文档）。</p>
<p>new函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活。</p>
<p>由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。例如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delta</span><span class="params">(old, <span class="built_in">new</span> <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">new</span> - old &#125;</span><br></pre></td></tr></table></figure>

<p>由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的。</p>
<h3 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h3><p>变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在<em>包一级声明</em>的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，每次从创建一个<em>局部变量</em>的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。</p>
<p>那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。</p>
<p>因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</p>
<p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> global *<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    global = &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">    y := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    *y = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；<strong>用Go语言的术语说，这个x局部变量从函数f中逃逸了。</strong> 相反，当g函数返回时，变量<code>*y</code>将是不可达的，也就是说可以马上被回收的。因此，<code>*y</code>并没有从函数g中逃逸，编译器可以选择在栈上分配<code>*y</code>的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</p>
<p>Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>使用赋值语句可以更新一个变量的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span>                       <span class="comment">// 命名变量的赋值</span></span><br><span class="line">*p = <span class="literal">true</span>                   <span class="comment">// 通过指针间接赋值</span></span><br><span class="line">person.name = <span class="string">&quot;bob&quot;</span>         <span class="comment">// 结构体字段赋值</span></span><br><span class="line">count[x] = count[x] * scale <span class="comment">// 数组、slice或map的元素赋值</span></span><br></pre></td></tr></table></figure>

<p>定的二元算术运算符和赋值语句的复合操作有一个简洁形式，例如上面最后的语句可以重写为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">count[x] *= scale</span><br></pre></td></tr></table></figure>

<p>数值变量也可以支持<code>++</code>递增和<code>--</code>递减语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := <span class="number">1</span></span><br><span class="line">v++    <span class="comment">// 等价方式 v = v + 1；v 变成 2</span></span><br><span class="line">v--    <span class="comment">// 等价方式 v = v - 1；v 变成 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>译注：自增和自减是语句，而不是表达式，因此<code>x = i++</code>之类的表达式是错误的。</p>
</blockquote>
<h3 id="元组赋值"><a href="#元组赋值" class="headerlink" title="元组赋值"></a>元组赋值</h3><p>元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。<strong>这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助</strong>，例如我们可以这样交换两个变量的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x, y = y, x</span><br><span class="line"></span><br><span class="line">a[i], a[j] = a[j], a[i]</span><br></pre></td></tr></table></figure>

<p>或者是计算两个整数值的的最大公约数（GCD, greatest common divisor）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> y != <span class="number">0</span> &#123;</span><br><span class="line">        x, y = y, x%y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者是计算斐波纳契数列（Fibonacci）的第N个数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        x, y = y, x+y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元组赋值也可以使一系列琐碎赋值更加紧凑（译注: 特别是在for循环的初始化部分），</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i, j, k = <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋值右边的表达式中时（译注：右边不能再有其它表达式），左边变量的数目必须和右边一致。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err = os.Open(<span class="string">&quot;foo.txt&quot;</span>) <span class="comment">// function call returns two values</span></span><br></pre></td></tr></table></figure>

<p>通常，这类函数会用额外的返回值来表达某种错误类型，例如<code>os.Open</code>是用额外的返回值返回一个error类型的错误，还有一些是用来返回布尔值，通常被称为<code>ok</code>。</p>
<p>和变量声明一样，我们可以用下划线空白标识符<code>_</code>来丢弃不需要的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err = io.Copy(dst, src) <span class="comment">// 丢弃字节数</span></span><br><span class="line">_, ok = x.(T)              <span class="comment">// 只检测类型，忽略具体值</span></span><br></pre></td></tr></table></figure>



<h3 id="可赋值性"><a href="#可赋值性" class="headerlink" title="可赋值性"></a>可赋值性</h3><p>赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。例如下面的语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">medals := []<span class="type">string</span>&#123;<span class="string">&quot;gold&quot;</span>, <span class="string">&quot;silver&quot;</span>, <span class="string">&quot;bronze&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>隐式地对slice的每个元素进行赋值操作，类似这样写的行为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">medals[<span class="number">0</span>] = <span class="string">&quot;gold&quot;</span></span><br><span class="line">medals[<span class="number">1</span>] = <span class="string">&quot;silver&quot;</span></span><br><span class="line">medals[<span class="number">2</span>] = <span class="string">&quot;bronze&quot;</span></span><br></pre></td></tr></table></figure>

<p>map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。</p>
<p>不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。</p>
<p>可赋值性的规则对于不同类型有着不同要求，对每个新类型特殊的地方我们会专门解释。对于目前我们已经讨论过的类型，它的规则是简单的：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。<em>常量</em>则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。</p>
<p>对于两个值是否可以用<code>==</code>或<code>!=</code>进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。和前面一样，我们会对每个新类型比较特殊的地方做专门的解释。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。</p>
<p><strong>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名字 底层类型</span><br></pre></td></tr></table></figure>

<p>类型声明语句一般出现在包一级，因此如果新创建的<strong>类型名字的首字符大写，则在包外部也可以使用</strong>。</p>
<p>为了说明类型声明，我们将不同温度单位分别定义为不同的类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package tempconv performs Celsius and Fahrenheit temperature computations.</span></span><br><span class="line"><span class="keyword">package</span> tempconv</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Celsius <span class="type">float64</span>    <span class="comment">// 摄氏温度</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="type">float64</span> <span class="comment">// 华氏温度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    AbsoluteZeroC Celsius = <span class="number">-273.15</span> <span class="comment">// 绝对零度</span></span><br><span class="line">    FreezingC     Celsius = <span class="number">0</span>       <span class="comment">// 结冰点温度</span></span><br><span class="line">    BoilingC      Celsius = <span class="number">100</span>     <span class="comment">// 沸水温度</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToF</span><span class="params">(c Celsius)</span></span> Fahrenheit &#123; <span class="keyword">return</span> Fahrenheit(c*<span class="number">9</span>/<span class="number">5</span> + <span class="number">32</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FToC</span><span class="params">(f Fahrenheit)</span></span> Celsius &#123; <span class="keyword">return</span> Celsius((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>我们在这个包声明了两种类型：Celsius和Fahrenheit分别对应不同的温度单位。它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；因此需要一个类似Celsius(t)或Fahrenheit(t)形式的显式转型操作才能将float64转为对应的类型。Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。类型转换不会改变值本身，但是会使它们的语义发生变化。另一方面，CToF和FToC两个函数则是对不同温度单位下的温度进行换算，它们会返回不同的值。</p>
<p><strong>对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如<code>(*int)(0)</code>）。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型，但是一般没有这个必要。</strong></p>
<p>**数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的。这类转换可能改变值的表现。**例如，将一个浮点数转为整数将丢弃小数部分，将一个字符串转为<code>[]byte</code>类型的slice将拷贝一个字符串数据的副本。在任何情况下，运行时不会发生转换失败的错误（译注: 错误只会发生在编译阶段）。</p>
<p>底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。这意味着，Celsius和Fahrenheit类型的算术运算行为和底层的float64类型是一样的，正如我们所期望的那样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%g\n&quot;</span>, BoilingC-FreezingC) <span class="comment">// &quot;100&quot; °C</span></span><br><span class="line">boilingF := CToF(BoilingC)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%g\n&quot;</span>, boilingF-CToF(FreezingC)) <span class="comment">// &quot;180&quot; °F</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%g\n&quot;</span>, boilingF-FreezingC)       <span class="comment">// compile error: type mismatch</span></span><br></pre></td></tr></table></figure>

<p>比较运算符<code>==</code>和<code>&lt;</code>也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但是<strong>如果两个值有着不同的类型，则不能直接进行比较</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c Celsius</span><br><span class="line"><span class="keyword">var</span> f Fahrenheit</span><br><span class="line">fmt.Println(c == <span class="number">0</span>)          <span class="comment">// &quot;true&quot;</span></span><br><span class="line">fmt.Println(f &gt;= <span class="number">0</span>)          <span class="comment">// &quot;true&quot;</span></span><br><span class="line">fmt.Println(c == f)          <span class="comment">// compile error: type mismatch</span></span><br><span class="line">fmt.Println(c == Celsius(f)) <span class="comment">// &quot;true&quot;!</span></span><br></pre></td></tr></table></figure>

<p>注意最后那个语句。尽管看起来像函数调用，但是<code>Celsius(f)</code>是类型转换操作，它并不会改变值，仅仅是改变值的类型而已。测试为真的原因是因为c和g都是零值。</p>
<p>一个命名的类型可以提供书写方便，特别是可以避免一遍又一遍地书写复杂类型（译注：例如用匿名的结构体定义变量）。虽然对于像float64这种简单的底层类型没有简洁很多，但是如果是复杂的类型将会简洁很多，特别是我们即将讨论的结构体类型。</p>
<p>命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。</p>
<p>下面的声明语句，Celsius类型的参数c出现在了函数名的前面，表示声明的是Celsius类型的一个名叫String的方法，该方法返回该类型对象c带着°C温度单位的字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Celsius)</span></span> String() <span class="type">string</span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%g°C&quot;</span>, c) &#125;</span><br></pre></td></tr></table></figure>

<h2 id="包和文件"><a href="#包和文件" class="headerlink" title="包和文件"></a>包和文件</h2><p>Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。一个包的源代码保存在一个或多个以<code>.go</code>为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；例如包<code>gopl.io/ch1/helloworld</code>对应的目录路径是<code>$GOPATH/src/gopl.io/ch1/helloworld</code>。</p>
<p>每个包都对应一个独立的名字空间。例如，在<code>image</code>包中的<code>Decode</code>函数和在<code>unicode/utf16</code>包中的 <code>Decode</code>函数是不同的。要在外部引用该函数，必须显式使用<code>image.Decode</code>或<code>utf16.Decode</code>形式访问。</p>
<p>包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。</p>
<p>让我们创建一个名为<code>gopl.io/ch2/tempconv</code>的包，包代码存储在两个源文件中，用来演示如何在一个源文件声明然后在其他的源文件访问。我们把变量的声明、对应的常量，还有方法都放到tempconv.go源文件中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package tempconv performs Celsius and Fahrenheit conversions.</span></span><br><span class="line"><span class="keyword">package</span> tempconv</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Celsius <span class="type">float64</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    AbsoluteZeroC Celsius = <span class="number">-273.15</span></span><br><span class="line">    FreezingC     Celsius = <span class="number">0</span></span><br><span class="line">    BoilingC      Celsius = <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Celsius)</span></span> String() <span class="type">string</span>    &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%g°C&quot;</span>, c) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Fahrenheit)</span></span> String() <span class="type">string</span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%g°F&quot;</span>, f) &#125;</span><br></pre></td></tr></table></figure>

<p>转换函数则放在另一个conv.go源文件中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tempconv</span><br><span class="line"></span><br><span class="line"><span class="comment">// CToF converts a Celsius temperature to Fahrenheit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToF</span><span class="params">(c Celsius)</span></span> Fahrenheit &#123; <span class="keyword">return</span> Fahrenheit(c*<span class="number">9</span>/<span class="number">5</span> + <span class="number">32</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FToC converts a Fahrenheit temperature to Celsius.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FToC</span><span class="params">(f Fahrenheit)</span></span> Celsius &#123; <span class="keyword">return</span> Celsius((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>) &#125;</span><br></pre></td></tr></table></figure>



<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>在Go语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似<code>gopl.io/ch2/tempconv</code>的字符串对应包的导入路径。Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时，一个导入路径代表一个目录中的一个或多个Go源文件。</p>
<p>除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。导入语句将导入的包绑定到一个短小的名字，然后通过该短小的名字就可以引用包中导出的全部内容。</p>
<p>按照惯例，一个包的名字和包的导入路径的最后一个字段相同，例如<code>gopl.io/ch2/tempconv</code>包的名字一般是<code>tempconv</code>。在默认情况下，导入的包绑定到tempconv名字（译注：指包声明语句指定的名字），但是我们也可以绑定到另一个名称，以避免名字冲突。</p>
<p>如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。</p>
<p>要使用<code>gopl.io/ch2/tempconv</code>包，需要先导入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cf converts its numeric argument to Celsius and Fahrenheit.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;gopl.io/ch2/tempconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, arg := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">        t, err := strconv.ParseFloat(arg, <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">&quot;cf: %v\n&quot;</span>, err)</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        f := tempconv.Fahrenheit(t)</span><br><span class="line">        c := tempconv.Celsius(t)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s = %s, %s = %s\n&quot;</span>,</span><br><span class="line">            f, tempconv.FToC(f), c, tempconv.CToF(c))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="包的初始化"><a href="#包的初始化" class="headerlink" title="包的初始化"></a>包的初始化</h3><p>包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b + c <span class="comment">// a 第三个初始化, 为 3</span></span><br><span class="line"><span class="keyword">var</span> b = f()   <span class="comment">// b 第二个初始化, 为 2, 通过调用 f (依赖c)</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>     <span class="comment">// c 第一个初始化, 为 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> c + <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。</p>
<p>对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。</p>
<p>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。</p>
<p>下面的代码定义了一个PopCount函数，用于返回一个数字中含二进制1bit的个数。它使用init初始化函数来生成辅助表格pc，pc表格用于处理每个8bit宽度的数字含二进制的1bit的bit个数，这样的话在处理64bit宽度的数字时就没有必要循环64次，只需要8次查表就可以了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> popcount</span><br><span class="line"></span><br><span class="line"><span class="comment">// pc[i] is the population count of i.</span></span><br><span class="line"><span class="keyword">var</span> pc [<span class="number">256</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> pc &#123;</span><br><span class="line">        pc[i] = pc[i/<span class="number">2</span>] + <span class="type">byte</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PopCount returns the population count (number of set bits) of x.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCount</span><span class="params">(x <span class="type">uint64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">0</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">1</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">2</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">3</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">4</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">5</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">6</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">7</span>*<span class="number">8</span>))])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>译注：对于pc这类需要复杂处理的初始化，可以通过将初始化逻辑包装为一个匿名函数处理，像下面这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pc[i] is the population count of i.</span></span><br><span class="line"><span class="keyword">var</span> pc [<span class="number">256</span>]<span class="type">byte</span> = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (pc [<span class="number">256</span>]<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> pc &#123;</span><br><span class="line">        pc[i] = pc[i/<span class="number">2</span>] + <span class="type">byte</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>要注意的是在init函数中，range循环只使用了索引，省略了没有用到的值部分。循环也可以这样写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pc &#123;</span><br></pre></td></tr></table></figure>



<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。<strong>声明语句的 <em>作用域</em> 是指源代码中可以有效使用这个名字的范围。</strong></p>
<p>不要将作用域和生命周期混为一谈。声明语句的<strong>作用域</strong>对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的<strong>生命周期</strong>是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。</p>
<p><strong>句法块</strong>是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。<strong>句法块内部声明的名字是无法被外部块访问的。<strong>这个块决定了内部声明的名字的作用域范围。我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为</strong>词法块</strong>。对全局的源代码来说，存在一个整体的词法块，称为全局词法块；对于每个包；每个for、if和switch语句，也都有对应词法块；每个switch或select的分支也有独立的词法块；当然也包括显式书写的词法块（花括弧包含的语句）。</p>
<p>声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。还有许多声明语句，比如<code>tempconv.CToF</code>函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。</p>
<p>控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。</p>
<p>一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系。例如，你可以声明一个局部变量，和包级的变量同名。或者是像2.3.3节的例子那样，你可以将一个函数参数的名字声明为new，虽然内置的new是全局作用域的。但是物极必反，如果滥用不同词法域可重名的特性的话，可能导致程序很难阅读。</p>
<p>当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="string">&quot;g&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := <span class="string">&quot;f&quot;</span></span><br><span class="line">    fmt.Println(f) <span class="comment">// &quot;f&quot;; local var f shadows package-level func f</span></span><br><span class="line">    fmt.Println(g) <span class="comment">// &quot;g&quot;; package-level var</span></span><br><span class="line">    fmt.Println(h) <span class="comment">// compile error: undefined: h</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数中词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明。还有许多语法块是if或for等控制流语句构造的。下面的代码有三个不同的变量x，因为它们是定义在不同的词法域（这个例子只是为了演示作用域规则，但不是好的编程风格）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;hello!&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(x); i++ &#123;</span><br><span class="line">        x := x[i]</span><br><span class="line">        <span class="keyword">if</span> x != <span class="string">&#x27;!&#x27;</span> &#123;</span><br><span class="line">            x := x + <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;%c&quot;</span>, x) <span class="comment">// &quot;HELLO&quot; (one letter per iteration)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>x[i]</code>和<code>x + &#39;A&#39; - &#39;a&#39;</code>声明语句的初始化的表达式中都引用了外部作用域声明的x变量，稍后我们会解释这个。（注意，后面的表达式与<code>unicode.ToUpper</code>并不等价。）</p>
<p>正如上面例子所示，并不是所有的词法域都显式地对应到由花括弧包含的语句；还有一些隐含的规则。上面的for语句创建了两个词法域：花括弧包含的是显式的部分，是for的循环体部分词法域，另外一个隐式的部分则是循环的初始化部分，比如用于迭代变量i的初始化。隐式的词法域部分的作用域还包含条件测试部分和循环后的迭代部分（<code>i++</code>），当然也包含循环体词法域。</p>
<p>下面的例子同样有三个不同的x变量，每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化词法域，一个在for循环体词法域；只有两个块是显式创建的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> x &#123;</span><br><span class="line">        x := x + <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c&quot;</span>, x) <span class="comment">// &quot;HELLO&quot; (one letter per iteration)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和for循环类似，if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域。下面的if-else测试链演示了x和y的有效作用域范围：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x := f(); x == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> y := g(x); x == y &#123;</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(x, y) <span class="comment">// compile error: x and y are not visible here</span></span><br></pre></td></tr></table></figure>

<p>第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问。switch语句的每个分支也有类似的词法域规则：条件部分为一个隐式词法域，然后是每个分支的词法域。</p>
<p>在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。</p>
<p>在这个程序中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> f, err := os.Open(fname); err != <span class="literal">nil</span> &#123; <span class="comment">// compile error: unused: f</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">f.ReadByte() <span class="comment">// compile error: undefined f</span></span><br><span class="line">f.Close()    <span class="comment">// compile error: undefined f</span></span><br></pre></td></tr></table></figure>

<p>变量f的作用域只在if语句内，因此后面的语句将无法引入它，这将导致编译错误。你可能会收到一个局部变量f没有声明的错误提示，具体错误信息依赖编译器的实现。</p>
<p>通常需要在if之前声明变量，这样可以确保后面的语句依然可以访问变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(fname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">f.ReadByte()</span><br><span class="line">f.Close()</span><br></pre></td></tr></table></figure>

<p>你可能会考虑通过将ReadByte和Close移动到if的else块来解决这个问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> f, err := os.Open(fname); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// f and err are visible here too</span></span><br><span class="line">    f.ReadByte()</span><br><span class="line">    f.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这不是Go语言推荐的做法，Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进。</p>
<p>要特别注意短变量声明语句的作用域范围，考虑下面的程序，它的目的是获取当前的工作目录然后保存到一个包级的变量中。这本来可以通过直接调用<code>os.Getwd</code>完成，但是将这个从主逻辑中分离出来可能会更好，特别是在需要处理错误的时候。函数<code>log.Fatalf</code>用于打印日志信息，然后调用<code>os.Exit(1)</code>终止程序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cwd <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cwd, err := os.Getwd() <span class="comment">// compile error: unused: cwd</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;os.Getwd failed: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然cwd在外部已经声明过，但是<code>:=</code>语句还是将cwd和err重新声明为新的局部变量。因为内部声明的cwd将屏蔽外部的声明，因此上面的代码并不会正确更新包级声明的cwd变量。</p>
<p>由于当前的编译器会检测到局部声明的cwd并没有使用，然后报告这可能是一个错误，但是这种检测并不可靠。因为一些小的代码变更，例如增加一个局部cwd的打印语句，就可能导致这种检测失效。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cwd <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cwd, err := os.Getwd() <span class="comment">// <span class="doctag">NOTE:</span> wrong!</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;os.Getwd failed: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Working directory = %s&quot;</span>, cwd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局的cwd变量依然是没有被正确初始化的，而且看似正常的日志输出更是让这个BUG更加隐晦。</p>
<p><strong>有许多方式可以避免出现类似潜在的问题。最直接的方法是通过单独声明err变量，来避免使用<code>:=</code>的简短声明方式：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cwd <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    cwd, err = os.Getwd()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;os.Getwd failed: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>Go语言同时提供了有符号和无符号类型的整数运算。这里有<code>int8</code>、<code>int16</code>、<code>int32</code>和<code>int64</code>四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是<code>uint8</code>、<code>uint16</code>、<code>uint32</code>和<code>uint64</code>四种无符号整数类型。</p>
<p>这里还有两种一般对应特定CPU平台机器字大小的有符号和无符号整数<code>int</code>和<code>uint</code>；其中<code>int</code>是应用最广泛的数值类型。这两种类型都有同样的大小，32或64bit。不同的编译器即使在相同的硬件平台上可能产生不同的大小。</p>
<p>Unicode字符<code>rune</code>类型是和<code>int32</code>等价的类型，通常用于表示一个Unicode码点。同样<code>byte</code>也是<code>uint8</code>类型的等价类型，<code>byte</code>类型一般用于强调数值是一个原始的数据而不是一个小的整数。</p>
<p>最后，还有一种无符号的整数类型<code>uintptr</code>，没有指定具体的bit大小但是足以容纳指针。<code>uintptr</code>类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。</p>
<p>下面是Go语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*      /      %      &lt;&lt;       &gt;&gt;     &amp;       &amp;^</span><br><span class="line">+      -      |      ^</span><br><span class="line">==     !=     &lt;      &lt;=       &gt;      &gt;=</span><br><span class="line">&amp;&amp;</span><br><span class="line">||</span><br></pre></td></tr></table></figure>

<p>算术运算符<code>+</code>、<code>-</code>、<code>*</code>和<code>/</code>可以适用于整数、浮点数和复数，但是取模运算符%仅用于整数间的运算。对于不同编程语言，%取模运算的行为可能并不相同。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此<code>-5%3</code>和<code>-5%-3</code>结果都是-2。除法运算符<code>/</code>的行为则依赖于操作数是否全为整数，比如<code>5.0/4.0</code>的结果是1.25，但是5&#x2F;4的结果是1，因为整数除法会向着0方向截断余数。</p>
<p>两个相同的整数类型可以使用下面的二元比较运算符进行比较；比较表达式的结果是布尔类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==    等于</span><br><span class="line">!=    不等于</span><br><span class="line">&lt;     小于</span><br><span class="line">&lt;=    小于等于</span><br><span class="line">&gt;     大于</span><br><span class="line">&gt;=    大于等于</span><br></pre></td></tr></table></figure>



<p>尽管Go语言提供了无符号数的运算，但即使数值本身不可能出现负数，我们还是倾向于使用有符号的<code>int</code>类型。无符号数往往只有在位运算或其它特殊的运算场景才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。它们通常并不用于仅仅是表达非负数量的场合。</p>
<p>一般来说，需要一个显式的转换将一个值从一种类型转化为另一种类型，并且算术和逻辑运算的二元操作中必须是相同的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> compote = <span class="type">int</span>(apples) + <span class="type">int</span>(oranges)</span><br></pre></td></tr></table></figure>

<p>任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666；或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。如今八进制数据通常用于POSIX操作系统上的文件访问权限标志，十六进制数字则更强调数字值的bit位模式。</p>
<p>当使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式，就像下面的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o := <span class="number">0666</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %[1]o %#[1]o\n&quot;</span>, o) <span class="comment">// &quot;438 666 0666&quot;</span></span><br><span class="line">x := <span class="type">int64</span>(<span class="number">0xdeadbeef</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %[1]x %#[1]x %#[1]X\n&quot;</span>, x)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF</span></span><br></pre></td></tr></table></figure>

<p>请注意fmt的两个使用技巧。通常<code>Printf</code>格式化字符串包含多个<code>%</code>参数时将会包含对应相同数量的额外操作数，但是<code>%</code>之后的<code>[1]</code>副词告诉<code>Printf</code>函数再次使用第一个操作数。第二，<code>%</code>后的<code>#</code>副词告诉<code>Printf</code>在用<code>%o</code>、<code>%x</code>或<code>%X</code>输出时生成<code>0</code>、<code>0x</code>或<code>0X</code>前缀。</p>
<p>字符面值通过一对单引号直接包含对应字符。最简单的例子是ASCII中类似’a’写法的字符面值，但是我们也可以通过转义的数值来表示任意的Unicode码点对应的字符，马上将会看到这样的例子。</p>
<p>字符使用<code>%c</code>参数打印，或者是用<code>%q</code>参数打印带单引号的字符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ascii := <span class="string">&#x27;a&#x27;</span></span><br><span class="line">unicode := <span class="string">&#x27;国&#x27;</span></span><br><span class="line">newline := <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %[1]c %[1]q\n&quot;</span>, ascii)   <span class="comment">// &quot;97 a &#x27;a&#x27;&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %[1]c %[1]q\n&quot;</span>, unicode) <span class="comment">// &quot;22269 国 &#x27;国&#x27;&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %[1]q\n&quot;</span>, newline)       <span class="comment">// &quot;10 &#x27;\n&#x27;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>Go语言提供了两种精度的浮点数，float32和float64。它们的算术规范由IEEE754浮点数国际标准定义，该浮点数规范被所有现代的CPU支持。</p>
<p>这些浮点数类型的取值范围可以从很微小到很巨大。浮点数的范围极限值可以在math包找到。常量<code>math.MaxFloat32</code>表示float32能表示的最大数值，大约是 <code>3.4e38</code>；对应的<code>math.MaxFloat64</code>常量大约是<code>1.8e308</code>。它们分别能表示的最小值近似为<code>1.4e-45</code>和<code>4.9e-324</code>。</p>
<p>通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="type">float32</span> = <span class="number">16777216</span> <span class="comment">// 1 &lt;&lt; 24</span></span><br><span class="line">fmt.Println(f == f+<span class="number">1</span>)    <span class="comment">// &quot;true&quot;!</span></span><br></pre></td></tr></table></figure>

<p>浮点数的字面值可以直接写小数部分，像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> e = <span class="number">2.71828</span> <span class="comment">// (approximately)</span></span><br></pre></td></tr></table></figure>

<p>小数点前面或后面的数字都可能被省略（例如.707或1.）。很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Avogadro = <span class="number">6.02214129e23</span>  <span class="comment">// 阿伏伽德罗常数</span></span><br><span class="line"><span class="keyword">const</span> Planck   = <span class="number">6.62606957e-34</span> <span class="comment">// 普朗克常数</span></span><br></pre></td></tr></table></figure>

<p>用<code>Printf</code>函数的<code>%g</code>参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用<code>%e</code>（带指数）或<code>%f</code>的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">8</span>; x++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x = %d e^x = %8.3f\n&quot;</span>, x, math.Exp(<span class="type">float64</span>(x)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码打印e的幂，打印精度是小数点后三个小数精度和8个字符宽度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 0       e^x =    1.000</span><br><span class="line">x = 1       e^x =    2.718</span><br><span class="line">x = 2       e^x =    7.389</span><br><span class="line">x = 3       e^x =   20.086</span><br><span class="line">x = 4       e^x =   54.598</span><br><span class="line">x = 5       e^x =  148.413</span><br><span class="line">x = 6       e^x =  403.429</span><br><span class="line">x = 7       e^x = 1096.633</span><br></pre></td></tr></table></figure>

<p>math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0&#x2F;0或Sqrt(-1).</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="type">float64</span></span><br><span class="line">fmt.Println(z, -z, <span class="number">1</span>/z, <span class="number">-1</span>/z, z/z) <span class="comment">// &quot;0 -0 +Inf -Inf NaN&quot;</span></span><br></pre></td></tr></table></figure>

<p>函数<code>math.IsNaN</code>用于测试一个数是否是非数NaN，<code>math.NaN</code>则返回非数对应的值。虽然可以用<code>math.NaN</code>来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的（译注：在浮点数中，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nan := math.NaN()</span><br><span class="line">fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan) <span class="comment">// &quot;false false false&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果一个函数返回的浮点数结果可能失败，最好的做法是用单独的标志报告失败，像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">()</span></span> (value <span class="type">float64</span>, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> failed &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">complex128</span> = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1+2i</span></span><br><span class="line"><span class="keyword">var</span> y <span class="type">complex128</span> = <span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 3+4i</span></span><br><span class="line">fmt.Println(x*y)                 <span class="comment">// &quot;(-5+10i)&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">real</span>(x*y))           <span class="comment">// &quot;-5&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">imag</span>(x*y))           <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如3.141592i或2i，它将构成一个复数的虚部，复数的实部是0：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="number">1i</span> * <span class="number">1i</span>) <span class="comment">// &quot;(-1+0i)&quot;, i^2 = -1</span></span><br></pre></td></tr></table></figure>

<p>在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），我们可以用自然的方式书写复数，就像<code>1+2i</code>或与之等价的写法<code>2i+1</code>。上面x和y的声明语句还可以简化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line">y := <span class="number">3</span> + <span class="number">4i</span></span><br></pre></td></tr></table></figure>

<p>复数也可以用<code>==</code>和<code>!=</code>进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的（译注：浮点数的相等比较是危险的，需要特别小心处理精度问题）。</p>
<p><code>math/cmplx</code>包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(cmplx.Sqrt(<span class="number">-1</span>)) <span class="comment">// &quot;(0+1i)&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>一个布尔类型的值只有2种：<code>true</code>和<code>false</code>。if和for语句的条件部分都是布尔类型的值，并且<code>==</code>和<code>&lt;</code>等比较操作也会产生布尔型的值。一元操作符<code>!</code>对应逻辑非操作，因此<code>!true</code>的值为<code>false</code>，更罗嗦的说法是<code>(!true==false)==true</code>，虽然表达方式不一样，不过我们一般会采用简洁的布尔表达式，就像用x来表示<code>x==true</code>。</p>
<p>布尔值可以和&amp;&amp;（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s != <span class="string">&quot;&quot;</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其中s[0]操作如果应用于空字符串将会导致panic异常。</p>
<p>因为<code>&amp;&amp;</code>的优先级比<code>||</code>高（助记：<code>&amp;&amp;</code>对应逻辑乘法，<code>||</code>对应逻辑加法，乘法比加法优先级要高），下面形式的布尔表达式是不需要加小括弧的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span> ||</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span> ||</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line">    <span class="comment">// ...ASCII letter or digit...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要经常做类似的转换，包装成一个函数会更方便：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// btoi returns 1 if b is true and 0 if false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">btoi</span><span class="params">(b <span class="type">bool</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数字到布尔型的逆转换则非常简单，不过为了保持对称，我们也可以包装一个函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// itob reports whether i is non-zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itob</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> i != <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。</p>
<p><strong>内置的len函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作<code>s[i]</code>返回第<code>i</code>个字节的字节值，<code>i</code>必须满足<code>0 ≤ i&lt; len(s)</code>条件约束。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))     <span class="comment">// &quot;12&quot;</span></span><br><span class="line">fmt.Println(s[<span class="number">0</span>], s[<span class="number">7</span>]) <span class="comment">// &quot;104 119&quot; (&#x27;h&#x27; and &#x27;w&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>如果试图访问超出字符串索引范围的字节将会导致panic异常：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := s[<span class="built_in">len</span>(s)] <span class="comment">// panic: index out of range</span></span><br></pre></td></tr></table></figure>

<p><strong>第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节。</strong></p>
<p>子字符串操作<code>s[i:j]</code>基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。生成的新字符串将包含<code>j-i</code>个字节。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(s[<span class="number">0</span>:<span class="number">5</span>]) <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>同样，如果索引超出字符串范围或者<code>j</code>小于<code>i</code>的话将导致panic异常。</p>
<p>不管i还是<code>j</code>都可能被忽略，当它们被忽略时将采用0作为开始位置，采用<code>len(s)</code>作为结束的位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(s[:<span class="number">5</span>]) <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">fmt.Println(s[<span class="number">7</span>:]) <span class="comment">// &quot;world&quot;</span></span><br><span class="line">fmt.Println(s[:])  <span class="comment">// &quot;hello, world&quot;</span></span><br></pre></td></tr></table></figure>

<p>其中<code>+</code>操作符将两个字符串连接构造一个新字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;goodbye&quot;</span> + s[<span class="number">5</span>:]) <span class="comment">// &quot;goodbye, world&quot;</span></span><br></pre></td></tr></table></figure>

<p>字符串可以用&#x3D;&#x3D;和&lt;进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。</p>
<p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值。可以像下面这样将一个字符串追加到另一个字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;left foot&quot;</span></span><br><span class="line">t := s</span><br><span class="line">s += <span class="string">&quot;, right foot&quot;</span></span><br></pre></td></tr></table></figure>

<p>这并不会导致原始的字符串值被改变，但是变量s将因为+&#x3D;语句持有一个新的字符串值，但是t依然是包含原先的字符串值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(s) <span class="comment">// &quot;left foot, right foot&quot;</span></span><br><span class="line">fmt.Println(t) <span class="comment">// &quot;left foot&quot;</span></span><br></pre></td></tr></table></figure>

<p>因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;L&#x27;</span> <span class="comment">// compile error: cannot assign to s[0]</span></span><br></pre></td></tr></table></figure>

<p>不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串<code>s</code>和对应的子字符串切片<code>s[7:]</code>的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。</p>
<p>下图演示了一个字符串和两个子串共享相同的底层数据：</p>
<p><img src="/2022/notes-of-gopl/ch3-04.png" alt="img"></p>
<h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>字符串值也可以用字符串面值方式编写，只要将一系列字节序列包含在双引号内即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello, 世界&quot;</span></span><br></pre></td></tr></table></figure>

<p>因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将 <em>Unicode码点</em> 也写到字符串面值中。</p>
<p>在一个双引号包含的字符串面值中，可以用以反斜杠<code>\</code>开头的转义序列插入任意的数据。下面的换行、回车和制表符等是常见的ASCII控制代码的转义方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\a      响铃</span><br><span class="line">\b      退格</span><br><span class="line">\f      换页</span><br><span class="line">\n      换行</span><br><span class="line">\r      回车</span><br><span class="line">\t      制表符</span><br><span class="line">\v      垂直制表符</span><br><span class="line">\&#x27;      单引号（只用在 &#x27;\&#x27;&#x27; 形式的rune符号面值中）</span><br><span class="line">\&quot;      双引号（只用在 &quot;...&quot; 形式的字符串面值中）</span><br><span class="line">\\      反斜杠</span><br></pre></td></tr></table></figure>

<p>一个原生的字符串面值形式是<code>...</code>，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行（译注：在原生字符串面值内部是无法直接写`字符的，可以用八进制或十六进制转义或+”`“连接字符串常量完成）。</p>
<p>原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> GoUsage = <span class="string">`Go is a tool for managing Go source code.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">    go command [arguments]</span></span><br><span class="line"><span class="string">...`</span></span><br></pre></td></tr></table></figure>

<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Unicode（ <a href="http://unicode.org/">http://unicode.org</a> ），它收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode码点，Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类型）。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF8是一个将Unicode码点编码为字节序列的变长编码。UTF8编码是由Go语言之父Ken Thompson和Rob Pike共同发明的，现在已经是Unicode的标准。UTF8编码使用1到4个字节来表示每个Unicode码点，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。</p>
<p>Go语言的源文件采用UTF8编码，并且Go语言处理UTF8编码的文本也很出色。unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等），<code>unicode/utf8</code>包则提供了用于rune字符序列的UTF8编码和解码的功能。</p>
<p>有很多Unicode字符很难直接从键盘输入，并且还有很多字符有着相似的结构；有一些甚至是不可见的字符（译注：中文和日文就有很多相似但不同的字）。Go语言字符串面值中的Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。有两种形式：<code>\uhhhh</code>对应16bit的码点值，<code>\Uhhhhhhhh</code>对应32bit的码点值，其中h是一个十六进制数字；一般很少需要使用32bit的形式。每一个对应码点的UTF8编码。例如：下面的字母串面值都表示相同的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;世界&quot;</span></span><br><span class="line"><span class="string">&quot;\xe4\xb8\x96\xe7\x95\x8c&quot;</span></span><br><span class="line"><span class="string">&quot;\u4e16\u754c&quot;</span></span><br><span class="line"><span class="string">&quot;\U00004e16\U0000754c&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面三个转义序列都为第一个字符串提供替代写法，但是它们的值都是相同的。</p>
<p>Unicode转义也可以使用在rune字符中。下面三个字符是等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;世&#x27;</span> <span class="string">&#x27;\u4e16&#x27;</span> <span class="string">&#x27;\U00004e16&#x27;</span></span><br></pre></td></tr></table></figure>

<p>对于小于256的码点值可以写在一个十六进制转义字节中，例如<code>\x41</code>对应字符’A’，但是对于更大的码点则必须使用<code>\u</code>或<code>\U</code>转义形式。因此，<code>\xe4\xb8\x96</code>并不是一个合法的rune字符，虽然这三个字节对应一个有效的UTF8编码的码点。</p>
<p>得益于UTF8编码优良的设计，诸多字符串操作都不需要解码操作。我们可以不用解码直接测试一个字符串是否是另一个字符串的前缀：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s) &gt;= <span class="built_in">len</span>(prefix) &amp;&amp; s[:<span class="built_in">len</span>(prefix)] == prefix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者是后缀测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasSuffix</span><span class="params">(s, suffix <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s) &gt;= <span class="built_in">len</span>(suffix) &amp;&amp; s[<span class="built_in">len</span>(s)-<span class="built_in">len</span>(suffix):] == suffix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者是包含子串测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> HasPrefix(s[i:], substr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于UTF8编码后文本的处理和原始的字节处理逻辑是一样的。但是对应很多其它编码则并不是这样的。</p>
<p>另一方面，如果我们真的关心每个Unicode字符，我们可以使用其它处理方式。考虑前面的第一个例子中的字符串，它混合了中西两种字符。图3.5展示了它的内存表示形式。字符串包含13个字节，以UTF8形式编码，但是只对应9个Unicode字符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line"></span><br><span class="line">s := <span class="string">&quot;Hello, 世界&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))                    <span class="comment">// &quot;13&quot;</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(s)) <span class="comment">// &quot;9&quot;</span></span><br></pre></td></tr></table></figure>

<p>为了处理这些真实的字符，我们需要一个UTF8解码器。unicode&#x2F;utf8包提供了该功能，我们可以这样使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); &#123;</span><br><span class="line">    r, size := utf8.DecodeRuneInString(s[i:])</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\t%c\n&quot;</span>, i, r)</span><br><span class="line">    i += size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一次调用<code>DecodeRuneInString</code>函数都返回一个r和长度，r对应字符本身，长度对应r采用UTF8编码后的编码字节数目。长度可以用于更新第i个字符在字符串中的字节索引位置。但是这种编码方式是笨拙的，我们需要更简洁的语法。幸运的是，Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串。下面的循环运行如图3.5所示；需要注意的是对于非ASCII，索引更新的步长将超过1个字节。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> <span class="string">&quot;Hello, 世界&quot;</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\t%q\t%d\n&quot;</span>, i, r, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0       &#x27;H&#x27;     72</span></span><br><span class="line"><span class="comment">1       &#x27;e&#x27;     101</span></span><br><span class="line"><span class="comment">2       &#x27;l&#x27;     108</span></span><br><span class="line"><span class="comment">3       &#x27;l&#x27;     108</span></span><br><span class="line"><span class="comment">4       &#x27;o&#x27;     111</span></span><br><span class="line"><span class="comment">5       &#x27;,&#x27;     44</span></span><br><span class="line"><span class="comment">6       &#x27; &#x27;     32</span></span><br><span class="line"><span class="comment">7       &#x27;世&#x27;    19990</span></span><br><span class="line"><span class="comment">10      &#x27;界&#x27;    30028</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/notes-of-gopl/ch3-05.png" alt="图3.5"></p>
<p>我们可以使用一个简单的循环来统计字符串中字符的数目，像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, _ = <span class="keyword">range</span> s &#123;</span><br><span class="line">    n++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像其它形式的循环那样，我们也可以忽略不需要的变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> s &#123;</span><br><span class="line">    n++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者我们可以直接调用<code>utf8.RuneCountInString(s)</code>函数。</p>
<p>每一个UTF8字符解码，不管是显式地调用<code>utf8.DecodeRuneInString</code>解码或是在range循环中隐式地解码，如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符<code>\uFFFD</code>，在印刷中这个符号通常是一个黑色六角或钻石形状，里面包含一个白色的问号”?”。当程序遇到这样的一个字符，通常是一个危险信号，说明输入并不是一个完美没有错误的UTF8字符串。</p>
<p>UTF8字符串作为交换格式是非常方便的，但是在程序内部采用rune序列可能更方便，因为rune大小一致，支持数组索引和方便切割。</p>
<p>将[]rune类型转换应用到UTF8编码的字符串，将返回字符串编码的Unicode码点序列：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;program&quot; in Japanese katakana</span></span><br><span class="line">s := <span class="string">&quot;プログラム&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;% x\n&quot;</span>, s) <span class="comment">// &quot;e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0&quot;</span></span><br><span class="line">r := []<span class="type">rune</span>(s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, r)  <span class="comment">// &quot;[30d7 30ed 30b0 30e9 30e0]&quot;</span></span><br></pre></td></tr></table></figure>

<p>（在第一个<code>Printf</code>中的<code>% x</code>参数用于在每个十六进制数字前插入一个空格。）</p>
<p>如果是将一个<code>[]rune</code>类型的Unicode字符slice或数组转为string，则对它们进行UTF8编码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="type">string</span>(r)) <span class="comment">// &quot;プログラム&quot;</span></span><br></pre></td></tr></table></figure>

<p>将一个整数转型为字符串意思是生成以只包含对应Unicode码点字符的UTF8字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="type">string</span>(<span class="number">65</span>))     <span class="comment">// &quot;A&quot;, not &quot;65&quot;</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(<span class="number">0x4eac</span>)) <span class="comment">// &quot;京&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果对应码点的字符是无效的，则用<code>\uFFFD</code>无效字符作为替换：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="type">string</span>(<span class="number">1234567</span>)) <span class="comment">// &quot;⶧&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串和Byte切片"><a href="#字符串和Byte切片" class="headerlink" title="字符串和Byte切片"></a>字符串和Byte切片</h3><p><strong>标准库中有4个包对字符串处理尤为重要：</strong></p>
<ul>
<li><p><code>strings</code>包：提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。</p>
</li>
<li><p><code>bytes</code>包：也提供了很多与<code>strings</code>包类似功能的函数，但是针对和字符串有着相同结构的<code>[]byte</code>类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用<code>bytes.Buffer</code>类型将会更有效。</p>
</li>
<li><p><code>strconv</code>包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</p>
</li>
<li><p><code>unicode</code>包：提供了<code>IsDigit</code>、<code>IsLetter</code>、<code>IsUpper</code>和<code>IsLower</code>等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像<code>ToUpper</code>和<code>ToLower</code>之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是<code>ToUpper</code>和<code>ToLower</code>，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。</p>
</li>
</ul>
<p>下面例子的basename函数灵感源于Unix shell的同名工具。在我们实现的版本中，<code>basename(s)</code>将看起来像是系统路径的前缀删除，同时将看似文件类型的后缀名部分删除：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(basename(<span class="string">&quot;a/b/c.go&quot;</span>)) <span class="comment">// &quot;c&quot;</span></span><br><span class="line">fmt.Println(basename(<span class="string">&quot;c.d.go&quot;</span>))   <span class="comment">// &quot;c.d&quot;</span></span><br><span class="line">fmt.Println(basename(<span class="string">&quot;abc&quot;</span>))      <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<p>第一个版本并没有使用任何库，全部手工硬编码实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// basename removes directory components and a .suffix.</span></span><br><span class="line"><span class="comment">// e.g., a =&gt; a, a.go =&gt; a, a/b/c.go =&gt; c, a/b.c.go =&gt; b.c</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">basename</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// Discard last &#x27;/&#x27; and everything before.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">            s = s[i+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Preserve everything before last &#x27;.&#x27;.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">            s = s[:i]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个简化版本使用了<code>strings.LastIndex</code>库函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">basename</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    slash := strings.LastIndex(s, <span class="string">&quot;/&quot;</span>) <span class="comment">// -1 if &quot;/&quot; not found</span></span><br><span class="line">    s = s[slash+<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> dot := strings.LastIndex(s, <span class="string">&quot;.&quot;</span>); dot &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        s = s[:dot]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>path</code>和<code>path/filepath</code>包提供了关于文件路径名更一般的函数操作。使用斜杠分隔路径可以在任何操作系统上工作。斜杠本身不应该用于文件名，但是在其他一些领域可能会用于文件名，例如URL路径组件。相比之下，<code>path/filepath</code>包则使用操作系统本身的路径规则，例如POSIX系统使用<code>/foo/bar</code>，而Microsoft Windows使用<code>c:\foo\bar</code>等。</p>
<p>让我们继续另一个字符串的例子。函数的功能是将一个表示整数值的字符串，每隔三个字符插入一个逗号分隔符，例如“12345”处理后成为“12,345”。这个版本只适用于整数类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// comma inserts commas in a non-negative decimal integer string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">comma</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> comma(s[:n<span class="number">-3</span>]) + <span class="string">&quot;,&quot;</span> + s[n<span class="number">-3</span>:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入comma函数的参数是一个字符串。如果输入字符串的长度小于或等于3的话，则不需要插入逗号分隔符。否则，comma函数将在最后三个字符前的位置将字符串切割为两个子串并插入逗号分隔符，然后通过递归调用自身来得出前面的子串。</p>
<p><strong>一个字符串是包含只读字节的数组，一旦创建，是不可变的。相比之下，一个字节slice的元素则可以自由地修改。</strong></p>
<p><strong>字符串和字节slice之间可以相互转换：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">b := []<span class="type">byte</span>(s)</span><br><span class="line">s2 := <span class="type">string</span>(b)</span><br></pre></td></tr></table></figure>

<p>从概念上讲，一个<code>[]byte(s)</code>转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量b被修改的情况下，原始的s字符串也不会改变。将一个<code>[]byte</code>字节slice转换到字符串的<code>string(b)</code>操作则是构造一个字符串拷贝，以确保<code>s2</code>字符串是只读的。</p>
<p><strong>为了避免转换中不必要的内存分配，<code>bytes</code>包和<code>strings</code>同时提供了许多实用函数。下面是<code>strings</code>包中的六个函数：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, sep <span class="type">string</span>)</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep <span class="type">string</span>)</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="type">string</span>, sep <span class="type">string</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p><strong><code>bytes</code>包中也对应的六个函数：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(b, subslice []<span class="type">byte</span>)</span></span> <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, sep []<span class="type">byte</span>)</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s []<span class="type">byte</span>)</span></span> [][]<span class="type">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix []<span class="type">byte</span>)</span></span> <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep []<span class="type">byte</span>)</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(s [][]<span class="type">byte</span>, sep []<span class="type">byte</span>)</span></span> []<span class="type">byte</span></span><br></pre></td></tr></table></figure>

<p><strong>它们之间唯一的区别是字符串类型参数被替换成了字节slice类型的参数。</strong></p>
<p><code>bytes</code>包还提供了<code>Buffer</code>类型用于字节slice的缓存。一个<code>Buffer</code>开始是空的，但是随着<code>string</code>、<code>byte</code>或<code>[]byte</code>等类型数据的写入可以动态增长，一个<code>bytes.Buffer</code>变量并不需要初始化，因为零值也是有效的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// intsToString is like fmt.Sprint(values) but adds commas.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intsToString</span><span class="params">(values []<span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    buf.WriteByte(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            buf.WriteString(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(&amp;buf, <span class="string">&quot;%d&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">    buf.WriteByte(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(intsToString([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)) <span class="comment">// &quot;[1, 2, 3]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当向<code>bytes.Buffer</code>添加任意字符的UTF8编码时，最好使用<code>bytes.Buffer</code>的<code>WriteRune</code>方法，但是<code>WriteByte</code>方法对于写入类似<code>[</code>和<code>]</code>等ASCII字符则会更加有效。</p>
<p><code>bytes.Buffer</code>类型有着很多实用的功能，可以将它用作一个I&#x2F;O的输入和输出对象，例如当做<code>Fprintf</code>的<code>io.Writer</code>输出对象，或者当作<code>io.Reader</code>类型的输入源对象。</p>
<h3 id="字符串和数字的转换"><a href="#字符串和数字的转换" class="headerlink" title="字符串和数字的转换"></a>字符串和数字的转换</h3><p>除了字符串、字符、字节之间的转换，字符串和数值之间的转换也比较常见。由<code>strconv</code>包提供这类转换功能。</p>
<p>将一个整数转为字符串，一种方法是用<code>fmt.Sprintf</code>返回一个格式化的字符串；另一个方法是用<code>strconv.Itoa(&quot;整数到ASCII&quot;)</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">123</span></span><br><span class="line">y := fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">fmt.Println(y, strconv.Itoa(x)) <span class="comment">// &quot;123 123&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>FormatInt</code>和<code>FormatUint</code>函数可以用不同的进制来格式化数字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(strconv.FormatInt(<span class="type">int64</span>(x), <span class="number">2</span>)) <span class="comment">// &quot;1111011&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>fmt.Printf</code>函数的<code>%b</code>、<code>%d</code>、<code>%o</code>和<code>%x</code>等参数提供功能往往比<code>strconv</code>包的<code>Format</code>函数方便很多，特别是在需要包含有附加额外信息的时候：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := fmt.Sprintf(<span class="string">&quot;x=%b&quot;</span>, x) <span class="comment">// &quot;x=1111011&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果要将一个字符串解析为整数，可以使用<code>strconv</code>包的<code>Atoi</code>或<code>ParseInt</code>函数，还有用于解析无符号整数的<code>ParseUint</code>函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x, err := strconv.Atoi(<span class="string">&quot;123&quot;</span>)             <span class="comment">// x is an int</span></span><br><span class="line">y, err := strconv.ParseInt(<span class="string">&quot;123&quot;</span>, <span class="number">10</span>, <span class="number">64</span>) <span class="comment">// base 10, up to 64 bits</span></span><br></pre></td></tr></table></figure>

<p><code>ParseInt</code>函数的第三个参数是用于指定整型数的大小；例如16表示<code>int16</code>，0则表示int。在任何情况下，返回的结果y总是<code>int64</code>类型，你可以通过强制类型转换将它转为更小的整数类型。</p>
<p>有时候也会使用<code>fmt.Scanf</code>来解析输入的字符串和数字，特别是当字符串和数字混合在一行的时候，它可以灵活处理不完整或不规则的输入。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string或数字。</p>
<p>一个常量的声明语句定义了常量的名字，和变量的声明语法类似，常量的值不可修改，这样可以防止在运行期被意外或恶意的修改。例如，常量比变量更适合用于表达像π之类的数学常数，因为它们的值不会发生变化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14159</span> <span class="comment">// approximately; math.Pi is a better approximation</span></span><br></pre></td></tr></table></figure>

<p>和变量声明一样，可以批量声明多个常量；这比较适合声明一组相关的常量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    e  = <span class="number">2.71828182845904523536028747135266249775724709369995957496696763</span></span><br><span class="line">    pi = <span class="number">3.14159265358979323846264338327950288419716939937510582097494459</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>所有常量的运算都可以在编译期完成，这样可以减少运行时的工作，也方便其他编译优化。当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。</p>
<p>常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：<code>len</code>、<code>cap</code>、<code>real</code>、<code>imag</code>、<code>complex</code>和<code>unsafe.Sizeof</code>。</p>
<p>因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> IPv4Len = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parseIPv4 parses an IPv4 address (d.d.d.d).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseIPv4</span><span class="params">(s <span class="type">string</span>)</span></span> IP &#123;</span><br><span class="line">    <span class="keyword">var</span> p [IPv4Len]<span class="type">byte</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。在下面的代码中，<code>time.Duration</code>是一个命名类型，底层类型是int64，<code>time.Minute</code>是对应类型的常量。下面声明的两个常量都是<code>time.Duration</code>类型，可以通过%T参数打印类型信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> noDelay time.Duration = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="number">5</span> * time.Minute</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %[1]v\n&quot;</span>, noDelay)     <span class="comment">// &quot;time.Duration 0&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %[1]v\n&quot;</span>, timeout)     <span class="comment">// &quot;time.Duration 5m0s&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %[1]v\n&quot;</span>, time.Minute) <span class="comment">// &quot;time.Duration 1m0s&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b</span><br><span class="line">    c = <span class="number">2</span></span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Println(a, b, c, d) <span class="comment">// &quot;1 1 2 2&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果只是简单地复制右边的常量表达式，其实并没有太实用的价值。但是它可以带来其它的特性，那就是<code>iota</code>常量生成器语法。</p>
<h3 id="iota-常量生成器"><a href="#iota-常量生成器" class="headerlink" title="iota 常量生成器"></a>iota 常量生成器</h3><p>常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个<code>const</code>声明语句中，在第一个声明的常量所在的行，<code>iota</code>将会被置为0，然后在每一个有常量声明的行加一。</p>
<p>下面是来自time包的例子，它首先定义了一个Weekday命名类型，然后为一周的每天定义了一个常量，从周日0开始。在其它编程语言中，这种类型一般被称为枚举类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Weekday <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Println(Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday) <span class="comment">// 0 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<p>我们也可以在复杂的常量表达式中使用<code>iota</code>，下面是来自<code>net</code>包的例子，用于给一个无符号整数的最低5bit的每个bit指定一个名字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Flags <span class="type">uint</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    FlagUp Flags = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// is up</span></span><br><span class="line">    FlagBroadcast            <span class="comment">// supports broadcast access capability</span></span><br><span class="line">    FlagLoopback             <span class="comment">// is a loopback interface</span></span><br><span class="line">    FlagPointToPoint         <span class="comment">// belongs to a point-to-point link</span></span><br><span class="line">    FlagMulticast            <span class="comment">// supports multicast access capability</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>随着<code>iota</code>的递增，每个常量对应表达式<code>1 &lt;&lt; iota</code>，是连续的2的幂，分别对应一个bit位置。使用这些常量可以用于测试、设置或清除对应的bit位的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsUp</span><span class="params">(v Flags)</span></span> <span class="type">bool</span>     &#123; <span class="keyword">return</span> v&amp;FlagUp == FlagUp &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TurnDown</span><span class="params">(v *Flags)</span></span>     &#123; *v &amp;^= FlagUp &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetBroadcast</span><span class="params">(v *Flags)</span></span> &#123; *v |= FlagBroadcast &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsCast</span><span class="params">(v Flags)</span></span> <span class="type">bool</span>   &#123; <span class="keyword">return</span> v&amp;(FlagBroadcast|FlagMulticast) != <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> v Flags = FlagMulticast | FlagUp</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%b %t\n&quot;</span>, v, IsUp(v)) <span class="comment">// &quot;10001 true&quot;</span></span><br><span class="line">    TurnDown(&amp;v)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%b %t\n&quot;</span>, v, IsUp(v)) <span class="comment">// &quot;10000 false&quot;</span></span><br><span class="line">    SetBroadcast(&amp;v)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%b %t\n&quot;</span>, v, IsUp(v))   <span class="comment">// &quot;10010 false&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%b %t\n&quot;</span>, v, IsCast(v)) <span class="comment">// &quot;10010 true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个更复杂的例子，每个常量都是1024的幂：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _ = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    KiB <span class="comment">// 1024</span></span><br><span class="line">    MiB <span class="comment">// 1048576</span></span><br><span class="line">    GiB <span class="comment">// 1073741824</span></span><br><span class="line">    TiB <span class="comment">// 1099511627776             (exceeds 1 &lt;&lt; 32)</span></span><br><span class="line">    PiB <span class="comment">// 1125899906842624</span></span><br><span class="line">    EiB <span class="comment">// 1152921504606846976</span></span><br><span class="line">    ZiB <span class="comment">// 1180591620717411303424    (exceeds 1 &lt;&lt; 64)</span></span><br><span class="line">    YiB <span class="comment">// 1208925819614629174706176</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>不过iota常量生成规则也有其局限性。例如，它并不能用于产生1000的幂（KB、MB等），因为Go语言并没有计算幂的运算符。</p>
<h3 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h3><p>Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如int或float64，或者是类似<code>time.Duration</code>这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有6种未明确类型的常量类型，分别是：</p>
<ul>
<li>无类型的布尔型</li>
<li>无类型的整数</li>
<li>无类型的字符</li>
<li>无类型的浮点数</li>
<li>无类型的复数</li>
<li>无类型的字符串</li>
</ul>
<p>通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。例如，例子中的ZiB和YiB的值已经超出任何Go语言中整数类型能表达的范围，但是它们依然是合法的常量，而且像下面的常量表达式依然有效（译注：YiB&#x2F;ZiB是在编译期计算出来的，并且结果常量是1024，是Go语言int变量能有效表示的）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(YiB/ZiB) <span class="comment">// &quot;1024&quot;</span></span><br></pre></td></tr></table></figure>

<p>另一个例子，<code>math.Pi</code>无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float32</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> y <span class="type">float64</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> z <span class="type">complex128</span> = math.Pi</span><br></pre></td></tr></table></figure>

<p>如果<code>math.Pi</code>被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi64 <span class="type">float64</span> = math.Pi</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="type">float32</span> = <span class="type">float32</span>(Pi64)</span><br><span class="line"><span class="keyword">var</span> y <span class="type">float64</span> = Pi64</span><br><span class="line"><span class="keyword">var</span> z <span class="type">complex128</span> = <span class="type">complex128</span>(Pi64)</span><br></pre></td></tr></table></figure>

<p>对于常量面值，不同的写法可能会对应不同的类型。例如<code>0</code>、<code>0.0</code>、<code>0i</code>和<code>\u0000</code>虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，<code>true</code>和<code>false</code>也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。</p>
<p>前面说过除法运算符&#x2F;会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达式可能对应不同的结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="number">212</span></span><br><span class="line">fmt.Println((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>)     <span class="comment">// &quot;100&quot;; (f - 32) * 5 is a float64</span></span><br><span class="line">fmt.Println(<span class="number">5</span> / <span class="number">9</span> * (f - <span class="number">32</span>))     <span class="comment">// &quot;0&quot;;   5/9 is an untyped integer, 0</span></span><br><span class="line">fmt.Println(<span class="number">5.0</span> / <span class="number">9.0</span> * (f - <span class="number">32</span>)) <span class="comment">// &quot;100&quot;; 5.0/9.0 is an untyped float</span></span><br></pre></td></tr></table></figure>

<p>只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="number">3</span> + <span class="number">0i</span> <span class="comment">// untyped complex -&gt; float64</span></span><br><span class="line">f = <span class="number">2</span>                  <span class="comment">// untyped integer -&gt; float64</span></span><br><span class="line">f = <span class="number">1e123</span>              <span class="comment">// untyped floating-point -&gt; float64</span></span><br><span class="line">f = <span class="string">&#x27;a&#x27;</span>                <span class="comment">// untyped rune -&gt; float64</span></span><br></pre></td></tr></table></figure>

<p>上面的语句相当于:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="type">float64</span>(<span class="number">3</span> + <span class="number">0i</span>)</span><br><span class="line">f = <span class="type">float64</span>(<span class="number">2</span>)</span><br><span class="line">f = <span class="type">float64</span>(<span class="number">1e123</span>)</span><br><span class="line">f = <span class="type">float64</span>(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    deadbeef = <span class="number">0xdeadbeef</span> <span class="comment">// untyped int with value 3735928559</span></span><br><span class="line">    a = <span class="type">uint32</span>(deadbeef)  <span class="comment">// uint32 with value 3735928559</span></span><br><span class="line">    b = <span class="type">float32</span>(deadbeef) <span class="comment">// float32 with value 3735928576 (rounded up)</span></span><br><span class="line">    c = <span class="type">float64</span>(deadbeef) <span class="comment">// float64 with value 3735928559 (exact)</span></span><br><span class="line">    d = <span class="type">int32</span>(deadbeef)   <span class="comment">// compile error: constant overflows int32</span></span><br><span class="line">    e = <span class="type">float64</span>(<span class="number">1e309</span>)    <span class="comment">// compile error: constant overflows float64</span></span><br><span class="line">    f = <span class="type">uint</span>(<span class="number">-1</span>)          <span class="comment">// compile error: constant underflows uint</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">0</span>      <span class="comment">// untyped integer;        implicit int(0)</span></span><br><span class="line">r := <span class="string">&#x27;\000&#x27;</span> <span class="comment">// untyped rune;           implicit rune(&#x27;\000&#x27;)</span></span><br><span class="line">f := <span class="number">0.0</span>    <span class="comment">// untyped floating-point; implicit float64(0.0)</span></span><br><span class="line">c := <span class="number">0i</span>     <span class="comment">// untyped complex;        implicit complex128(0i)</span></span><br></pre></td></tr></table></figure>

<p>注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。 如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。</p>
<p>如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型，像下面例子这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="type">int8</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int8</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当尝试将这些无类型的常量转为一个接口值时，这些默认类型将显得尤为重要，因为要靠它们明确接口对应的动态类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="number">0</span>)      <span class="comment">// &quot;int&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="number">0.0</span>)    <span class="comment">// &quot;float64&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="number">0i</span>)     <span class="comment">// &quot;complex128&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="string">&#x27;\000&#x27;</span>) <span class="comment">// &quot;int32&quot; (rune)</span></span><br></pre></td></tr></table></figure>



<h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在Go语言中很少直接使用数组。和数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列，slice功能也更灵活，但是要理解slice工作原理的话需要先理解数组。</p>
<p>数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的<code>len</code>函数将返回数组中元素的个数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span>             <span class="comment">// array of 3 integers</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>])        <span class="comment">// print the first element</span></span><br><span class="line">fmt.Println(a[<span class="built_in">len</span>(a)<span class="number">-1</span>]) <span class="comment">// print the last element, a[2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the indices and elements.</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the elements only.</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。我们也可以使用数组字面值语法用一组值来初始化数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> q [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> r [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(r[<span class="number">2</span>]) <span class="comment">// &quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<p>在数组字面值中，如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算。因此，上面q数组的定义可以简化为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">q := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, q) <span class="comment">// &quot;[3]int&quot;</span></span><br></pre></td></tr></table></figure>

<p>数组的长度是数组类型的一个组成部分，因此<code>[3]int</code>和<code>[4]int</code>是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">q := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">q = [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment">// compile error: cannot assign [4]int to [3]int</span></span><br></pre></td></tr></table></figure>

<p>我们将会发现，数组、slice、map和结构体字面值的写法都很相似。上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化，就像下面这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Currency <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    USD Currency = <span class="literal">iota</span> <span class="comment">// 美元</span></span><br><span class="line">    EUR                 <span class="comment">// 欧元</span></span><br><span class="line">    GBP                 <span class="comment">// 英镑</span></span><br><span class="line">    RMB                 <span class="comment">// 人民币</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">symbol := [...]<span class="type">string</span>&#123;USD: <span class="string">&quot;$&quot;</span>, EUR: <span class="string">&quot;€&quot;</span>, GBP: <span class="string">&quot;￡&quot;</span>, RMB: <span class="string">&quot;￥&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(RMB, symbol[RMB]) <span class="comment">// &quot;3 ￥&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而且没用到的索引可以省略，和前面提到的规则一样，未指定初始值的元素将用零值初始化。例如，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := [...]<span class="type">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</p>
<p>如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过&#x3D;&#x3D;比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。不相等比较运算符!&#x3D;遵循同样的规则。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">b := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">c := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(a == b, a == c, b == c) <span class="comment">// &quot;true false false&quot;</span></span><br><span class="line">d := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(a == d) <span class="comment">// compile error: cannot compare [2]int == [3]int</span></span><br></pre></td></tr></table></figure>

<p>作为一个真实的例子，<code>crypto/sha256</code>包的<code>Sum256</code>函数对一个任意的字节slice类型的数据生成一个对应的消息摘要。消息摘要有256bit大小，因此对应<code>[32]byte</code>数组类型。如果两个消息摘要是相同的，那么可以认为两个消息本身也是相同（译注：理论上有HASH码碰撞的情况，但是实际应用可以基本忽略）；如果消息摘要不同，那么消息本身必然也是不同的。下面的例子用SHA256算法分别生成<code>&quot;x&quot;</code>和<code>&quot;X&quot;</code>两个信息的摘要：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c1 := sha256.Sum256([]<span class="type">byte</span>(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">    c2 := sha256.Sum256([]<span class="type">byte</span>(<span class="string">&quot;X&quot;</span>))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%x\n%x\n%t\n%T\n&quot;</span>, c1, c2, c1 == c2, c1)</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881</span></span><br><span class="line">    <span class="comment">// 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015</span></span><br><span class="line">    <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// [32]uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，两个消息虽然只有一个字符的差异，但是生成的消息摘要则几乎有一半的bit位是不相同的。需要注意<code>Printf</code>函数的<code>%x</code>副词参数，它用于指定以十六进制的格式打印数组或slice全部的元素，<code>%t</code>副词参数是用于打印布尔型数据，<code>%T</code>副词参数是用于显示一个值对应的数据类型。</p>
<p>对于Go语言，当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。因为函数参数传递的机制导致传递大的数组类型将是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量。</p>
<p>当然，我们可以显式地传入一个数组指针，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者。下面的函数用于给<code>[32]byte</code>类型的数组清零：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(ptr *[32]<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ptr &#123;</span><br><span class="line">        ptr[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实数组字面值<code>[32]byte&#123;&#125;</code>就可以生成一个32字节的数组。而且每个数组的元素都是零值初始化，也就是0。因此，我们可以将上面的zero函数写的更简洁一点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(ptr *[32]<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">    *ptr = [<span class="number">32</span>]<span class="type">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息。上面的<code>zero</code>函数并不能接收指向<code>[16]byte</code>类型数组的指针，而且也没有任何添加或删除数组元素的方法。由于这些原因，除了像SHA256这类需要处理特定大小数组的特例外，数组依然很少用作函数参数；相反，我们一般使用slice来替代数组。</p>
<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作<code>[]T</code>，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。</p>
<p>数组和slice之间有着紧密的联系。一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的<code>len</code>和<code>cap</code>函数分别返回slice的长度和容量。</p>
<p>多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。图4.1显示了表示一年中每个月份名字的字符串数组，还有重叠引用了该数组的两个slice。</p>
<p><img src="/2022/notes-of-gopl/ch4-01.png" alt="图4.1"></p>
<p>数组这样定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">months := [...]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;January&quot;</span>, <span class="comment">/* ... */</span>, <span class="number">12</span>: <span class="string">&quot;December&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>因此一月份是<code>months[1]</code>，十二月份是<code>months[12]</code>。通常，数组的第一个元素从索引0开始，但是月份一般是从1开始的，因此我们声明数组时直接跳过第0个元素，第0个元素会被自动初始化为空字符串。</p>
<p>slice的切片操作<code>s[i:j]</code>，其中<code>0 ≤ i≤ j≤ cap(s)</code>，用于创建一个新的slice，引用<code>s</code>的从第<code>i</code>个元素开始到第<code>j-1</code>个元素的子序列。新的slice将只有<code>j-i</code>个元素。如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用<code>len(s)</code>代替。因此，<code>months[1:13]</code>切片操作将引用全部有效的月份，和<code>months[1:]</code>操作等价；<code>months[:]</code>切片操作则是引用整个数组。让我们分别定义表示第二季度和北方夏天月份的slice，它们有重叠部分：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Q2 := months[<span class="number">4</span>:<span class="number">7</span>]</span><br><span class="line">summer := months[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">fmt.Println(Q2)     <span class="comment">// [&quot;April&quot; &quot;May&quot; &quot;June&quot;]</span></span><br><span class="line">fmt.Println(summer) <span class="comment">// [&quot;June&quot; &quot;July&quot; &quot;August&quot;]</span></span><br></pre></td></tr></table></figure>

<p>两个slice都包含了六月份，下面的代码是一个包含相同月份的测试（性能较低）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> summer &#123;</span><br><span class="line">    <span class="keyword">for</span> _, q := <span class="keyword">range</span> Q2 &#123;</span><br><span class="line">        <span class="keyword">if</span> s == q &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s appears in both\n&quot;</span>, s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果切片操作超出<code>cap(s)</code>的上限将导致一个panic异常，但是超出<code>len(s)</code>则是意味着扩展了slice，因为新slice的长度会变大：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(summer[:<span class="number">20</span>]) <span class="comment">// panic: out of range</span></span><br><span class="line"></span><br><span class="line">endlessSummer := summer[:<span class="number">5</span>] <span class="comment">// extend a slice (within capacity)</span></span><br><span class="line">fmt.Println(endlessSummer)  <span class="comment">// &quot;[June July August September October]&quot;</span></span><br></pre></td></tr></table></figure>

<p>另外，字符串的切片操作和[]byte字节类型切片的切片操作是类似的。都写作x[m:n]，并且都是返回一个原始字节序列的子序列，底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度。x[m:n]切片操作对于字符串则生成一个新字符串，如果x是[]byte的话则生成一个新的[]byte。</p>
<p>因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名。下面的reverse函数在原内存空间将<code>[]int</code>类型的slice反转，而且它可以用于任意长度的slice。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reverse reverses a slice of ints in place.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        s[i], s[j] = s[j], s[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们反转数组的应用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">reverse(a[:])</span><br><span class="line">fmt.Println(a) <span class="comment">// &quot;[5 4 3 2 1 0]&quot;</span></span><br></pre></td></tr></table></figure>

<p>和数组不同的是，slice之间不能比较，因此我们不能使用&#x3D;&#x3D;操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的<code>bytes.Equal</code>函数来判断两个字节型slice是否相等（<code>[]byte</code>），但是对于其他类型的slice，我们必须自己展开每个元素进行比较：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">equal</span><span class="params">(x, y []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(x) != <span class="built_in">len</span>(y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> x &#123;</span><br><span class="line">        <span class="keyword">if</span> x[i] != y[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为何slice不直接支持比较运算符呢？这方面有两个原因。</p>
<p>第一个原因，一个slice的元素是间接引用的，一个slice甚至可以包含自身（译注：当slice声明为[]interface{}时，slice的元素可以是自身）。虽然有很多办法处理这种情形，但是没有一个是简单有效的。</p>
<p>第二个原因，因为slice的元素是间接引用的，一个固定的slice值（译注：指slice本身的值，不是元素的值）在不同的时刻可能包含不同的元素，因为底层数组的元素可能会被修改。而例如Go语言中map的key只做简单的浅拷贝，它要求key在整个生命周期内保持不变性（译注：例如slice扩容，就会导致其本身的值&#x2F;地址变化）。而用深度相等判断的话，显然在map的key这种场合不合适。对于像指针或chan之类的引用类型，<code>==</code>相等测试可以判断两个是否是引用相同的对象。一个针对slice的浅相等测试的<code>==</code>操作符可能是有一定用处的，也能临时解决map类型的key问题，但是slice和数组不同的相等测试行为会让人困惑。因此，安全的做法是直接禁止slice之间的比较操作。</p>
</blockquote>
<p>slice唯一合法的比较操作是和nil比较，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> summer == <span class="literal">nil</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>一个零值的slice等于<code>nil</code>。<strong>一个<code>nil</code>值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非<code>nil</code>值的slice的长度和容量也是0的，例如<code>[]int&#123;&#125;</code>或<code>make([]int, 3)[3:]</code>。</strong> 与任意类型的<code>nil</code>值一样，我们可以用<code>[]int(nil)</code>类型转换表达式来生成一个对应类型slice的<code>nil</code>值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span>    <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = <span class="literal">nil</span>        <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="type">int</span>(<span class="literal">nil</span>) <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="type">int</span>&#123;&#125;    <span class="comment">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure>

<p><strong>如果你需要测试一个slice是否是空的，使用<code>len(s) == 0</code>来判断，而不应该用<code>s == nil</code>来判断。</strong> 除了和<code>nil</code>相等比较外，一个<code>nil</code>值的slice的行为和其它任意0长度的slice一样；例如<code>reverse(nil)</code>也是安全的。除了文档已经明确说明的地方，所有的Go语言函数应该以相同的方式对待<code>nil</code>值的slice和0长度的slice。</p>
<p><strong>内置的<code>make</code>函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>) <span class="comment">// same as make([]T, cap)[:len]</span></span><br></pre></td></tr></table></figure>

<p>在底层，<code>make</code>创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。在第一种语句中，slice是整个数组的view。在第二个语句中，slice只引用了底层数组的前<code>len</code>个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的。</p>
<h3 id="append函数"><a href="#append函数" class="headerlink" title="append函数"></a>append函数</h3><p>内置的<code>append</code>函数用于向slice追加元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> runes []<span class="type">rune</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">&quot;Hello, 世界&quot;</span> &#123;</span><br><span class="line">    runes = <span class="built_in">append</span>(runes, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, runes) <span class="comment">// &quot;[&#x27;H&#x27; &#x27;e&#x27; &#x27;l&#x27; &#x27;l&#x27; &#x27;o&#x27; &#x27;,&#x27; &#x27; &#x27; &#x27;世&#x27; &#x27;界&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>

<p>在循环中使用<code>append</code>函数构建一个由9个rune字符构成的slice，当然对应这个特殊的问题我们可以通过Go语言内置的<code>[]rune(&quot;Hello, 世界&quot;)</code>转换操作完成。</p>
<p><strong>通常我们并不知道append调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。因此，通常是将append返回的结果直接赋值给输入的slice变量：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">runes = <span class="built_in">append</span>(runes, r)</span><br></pre></td></tr></table></figure>

<p>更新slice变量不仅对调用append函数是必要的，实际上对应任何可能导致长度、容量或底层数组变化的操作都是必要的。要正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是slice对应结构体本身的指针、长度和容量部分是直接访问的。要更新这些信息需要像上面例子那样一个显式的赋值操作。从这个角度看，slice并不是一个纯粹的引用类型，它实际上是一个类似下面结构体的聚合类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSlice <span class="keyword">struct</span> &#123;</span><br><span class="line">    ptr      *<span class="type">int</span></span><br><span class="line">    <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内置的<code>append</code>函数则可以追加多个元素，甚至追加一个slice。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x []<span class="type">int</span></span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">1</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, x...) <span class="comment">// append the slice x</span></span><br><span class="line">fmt.Println(x)      <span class="comment">// &quot;[1 2 3 4 5 6 1 2 3 4 5 6]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Slice内存技巧"><a href="#Slice内存技巧" class="headerlink" title="Slice内存技巧"></a>Slice内存技巧</h3><p>让我们看看更多的例子。给定一个字符串列表，下面的<code>nonempty</code>函数将在原有slice内存空间之上返回不包含空字符串的列表：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Nonempty is an example of an in-place slice algorithm.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nonempty returns a slice holding only the non-empty strings.</span></span><br><span class="line"><span class="comment">// The underlying array is modified during the call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nonempty</span><span class="params">(strings []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strings &#123;</span><br><span class="line">        <span class="keyword">if</span> s != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            strings[i] = s</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strings[:i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较微妙的地方是，输入的slice和输出的slice共享一个底层数组。这可以避免分配另一个数组，不过原来的数据将可能会被覆盖，正如下面两个打印语句看到的那样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, nonempty(data)) <span class="comment">// `[&quot;one&quot; &quot;three&quot;]`</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, data)           <span class="comment">// `[&quot;one&quot; &quot;three&quot; &quot;three&quot;]`</span></span><br></pre></td></tr></table></figure>

<p>因此我们通常会这样使用<code>nonempty</code>函数：<code>data = nonempty(data)</code>。</p>
<p><code>nonempty</code>函数也可以使用<code>append</code>函数实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nonempty2</span><span class="params">(strings []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    out := strings[:<span class="number">0</span>] <span class="comment">// zero-length slice of original</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strings &#123;</span><br><span class="line">        <span class="keyword">if</span> s != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            out = <span class="built_in">append</span>(out, s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论如何实现，以这种方式重用一个slice一般都要求最多为每个输入值产生一个输出值，事实上很多这类算法都是用来过滤或合并序列中相邻的元素。这种slice用法是比较复杂的技巧，虽然使用到了slice的一些技巧，但是对于某些场合是比较清晰和有效的。</p>
<p>一个slice可以用来模拟一个stack。最初给定的空slice对应一个空的stack，然后可以使用<code>append</code>函数将新的值压入stack：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stack = <span class="built_in">append</span>(stack, v) <span class="comment">// push v</span></span><br></pre></td></tr></table></figure>

<p>stack的顶部位置对应slice的最后一个元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">top := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] <span class="comment">// top of stack</span></span><br></pre></td></tr></table></figure>

<p>通过收缩stack可以弹出栈顶的元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>] <span class="comment">// pop</span></span><br></pre></td></tr></table></figure>

<p>要删除slice中间的某个元素并保存原有的元素顺序，可以通过内置的<code>copy</code>函数将后面的子slice向前依次移动一位完成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(slice []<span class="type">int</span>, i <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="built_in">copy</span>(slice[i:], slice[i+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> slice[:<span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    fmt.Println(remove(s, <span class="number">2</span>)) <span class="comment">// &quot;[5 6 8 9]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果删除元素后不用保持原来顺序的话，我们可以简单的用最后一个元素覆盖被删除的元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(slice []<span class="type">int</span>, i <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    slice[i] = slice[<span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> slice[:<span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    fmt.Println(remove(s, <span class="number">2</span>)) <span class="comment">// &quot;[5 6 9 8]</span></span><br></pre></td></tr></table></figure>

<p><strong>练习 4.3：</strong> 重写reverse函数，使用数组指针代替slice。</p>
<p><strong>练习 4.4：</strong> 编写一个rotate函数，通过一次循环完成旋转。</p>
<p><strong>练习 4.5：</strong> 写一个函数在原地完成消除<code>[]string</code>中相邻重复的字符串的操作。</p>
<p><strong>练习 4.6：</strong> 编写一个函数，原地将一个UTF-8编码的<code>[]byte</code>类型的slice中相邻的空格（参考<code>unicode.IsSpace</code>）替换成一个空格返回</p>
<p><strong>练习 4.7：</strong> 修改reverse函数用于原地反转UTF-8编码的<code>[]byte</code>。是否可以不用分配额外的内存？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(strings []<span class="type">rune</span>)</span></span> []<span class="type">rune</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(strings)/<span class="number">2</span>; i++ &#123;</span><br><span class="line">		strings[i], strings[<span class="built_in">len</span>(strings)-i<span class="number">-1</span>] = strings[<span class="built_in">len</span>(strings)-i<span class="number">-1</span>], strings[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strings</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;Hello, 世界&quot;</span></span><br><span class="line">	s1 := reverse([]<span class="type">rune</span>(s))</span><br><span class="line">	fmt.Println(<span class="type">string</span>(s1)) <span class="comment">// 界世 ,olleH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>哈希表是一种巧妙并且实用的数据结构。它是一个无序的key&#x2F;value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。</p>
<p>在Go语言中，一个map就是一个哈希表的引用，map类型可以写为<code>map[K]V</code>，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持<code>==</code>比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法，正如第三章提到的，最坏的情况是可能出现的NaN和任何浮点数都不相等。对于V对应的value数据类型则没有任何的限制。</p>
<p>内置的<code>make</code>函数可以创建一个map：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// mapping from strings to ints</span></span><br></pre></td></tr></table></figure>

<p>我们也可以用map字面值的语法创建map，同时还可以指定一些最初的key&#x2F;value：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;alice&quot;</span>:   <span class="number">31</span>,</span><br><span class="line">    <span class="string">&quot;charlie&quot;</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这相当于</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">ages[<span class="string">&quot;alice&quot;</span>] = <span class="number">31</span></span><br><span class="line">ages[<span class="string">&quot;charlie&quot;</span>] = <span class="number">34</span></span><br></pre></td></tr></table></figure>

<p>因此，另一种创建空的map的表达式是<code>map[string]int&#123;&#125;</code>。</p>
<p>Map中的元素通过key对应的下标语法访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ages[<span class="string">&quot;alice&quot;</span>] = <span class="number">32</span></span><br><span class="line">fmt.Println(ages[<span class="string">&quot;alice&quot;</span>]) <span class="comment">// &quot;32&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用内置的delete函数可以删除元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(ages, <span class="string">&quot;alice&quot;</span>) <span class="comment">// remove element ages[&quot;alice&quot;]</span></span><br></pre></td></tr></table></figure>

<p>所有这些操作是安全的，即使这些元素不在map中也没有关系；如果一个查找失败将返回value类型对应的零值，例如，即使map中不存在“bob”下面的代码也可以正常工作，因为<code>ages[&quot;bob&quot;]</code>失败时将返回0。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ages[<span class="string">&quot;bob&quot;</span>] = ages[<span class="string">&quot;bob&quot;</span>] + <span class="number">1</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>而且<code>x += y</code>和<code>x++</code>等简短赋值语法也可以用在map上，所以上面的代码可以改写成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ages[<span class="string">&quot;bob&quot;</span>] += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>更简单的写法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ages[<span class="string">&quot;bob&quot;</span>]++</span><br></pre></td></tr></table></figure>

<p><strong>但是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_ = &amp;ages[<span class="string">&quot;bob&quot;</span>] <span class="comment">// compile error: cannot take address of map element</span></span><br></pre></td></tr></table></figure>

<p>禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</p>
<p>要想遍历map中全部的key&#x2F;value对的话，可以使用range风格的for循环实现，和之前的slice遍历语法类似。下面的迭代语句将在每次迭代时设置name和age变量，它们对应下一个键&#x2F;值对：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, age := <span class="keyword">range</span> ages &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\t%d\n&quot;</span>, name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key&#x2F;value对，我们必须显式地对key进行排序，可以使用<code>sort</code>包的<code>Strings</code>函数对字符串slice进行排序。下面是常见的处理方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names []<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> name := <span class="keyword">range</span> ages &#123;</span><br><span class="line">    names = <span class="built_in">append</span>(names, name)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(names)</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\t%d\n&quot;</span>, name, ages[name])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们一开始就知道names的最终大小，因此给slice分配一个合适的大小将会更有效。下面的代码创建了一个空的slice，但是slice的容量刚好可以放下map中全部的key：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">names := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(ages))</span><br></pre></td></tr></table></figure>

<p>在上面的第一个range循环中，我们只关心map中的key，所以我们忽略了第二个循环变量。在第二个循环中，我们只关心names中的名字，所以我们使用“_”空白标识符来忽略第一个循环变量，也就是迭代slice时的索引。</p>
<p>map类型的零值是nil，也就是没有引用任何哈希表。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ages <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">fmt.Println(ages == <span class="literal">nil</span>)    <span class="comment">// &quot;true&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(ages) == <span class="number">0</span>) <span class="comment">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<p>map上的大部分操作，包括查找、删除、<code>len</code>和<code>range</code>循环都可以安全工作在<code>nil</code>值的map上，它们的行为和一个空的map类似。<strong>但是向一个<code>nil</code>值的map存入元素将导致一个panic异常：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ages[<span class="string">&quot;carol&quot;</span>] = <span class="number">21</span> <span class="comment">// panic: assignment to entry in nil map</span></span><br></pre></td></tr></table></figure>

<p>如果元素类型是一个数字，你可能需要区分一个已经存在的0，和不存在而返回零值的0，可以像下面这样测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">age, ok := ages[<span class="string">&quot;bob&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="comment">/* &quot;bob&quot; is not a key in this map; age == 0. */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>你会经常看到将这两个结合起来使用，像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">&quot;bob&quot;</span>]; !ok &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在这种场景下，map的下标语法将产生两个值；第二个是一个布尔值，用于报告元素是否真的存在。布尔变量一般命名为<code>ok</code>，特别适合马上用于if条件判断部分。</p>
<p><strong>和slice一样，map之间也不能进行相等比较；唯一的例外是和nil进行比较。要判断两个map是否包含相同的key和value，我们必须通过一个循环实现：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">equal</span><span class="params">(x, y <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(x) != <span class="built_in">len</span>(y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k, xv := <span class="keyword">range</span> x &#123;</span><br><span class="line">        <span class="keyword">if</span> yv, ok := y[k]; !ok || yv != xv &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从例子中可以看到如何用<code>!ok</code>来区分元素不存在，与元素存在但为0的。我们不能简单地用<code>xv != y[k]</code>判断，那样会导致在判断下面两个map时产生错误的结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// True if equal is written incorrectly.</span></span><br><span class="line">equal(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;A&quot;</span>: <span class="number">0</span>&#125;, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;B&quot;</span>: <span class="number">42</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能。为了说明这一点，下面的dedup程序读取多行输入，但是只打印第一次出现的行。（它是1.3节中出现的dup程序的变体。）dedup程序通过map来表示所有的输入行所对应的set集合，以确保已经在集合存在的行不会被重复打印。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>) <span class="comment">// a set of strings</span></span><br><span class="line">    input := bufio.NewScanner(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        line := input.Text()</span><br><span class="line">        <span class="keyword">if</span> !seen[line] &#123;</span><br><span class="line">            seen[line] = <span class="literal">true</span></span><br><span class="line">            fmt.Println(line)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := input.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;dedup: %v\n&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go程序员将这种忽略value的map当作一个字符串集合，并非所有<code>map[string]bool</code>类型value都是无关紧要的；有一些则可能会同时包含true和false的值。</p>
<p>有时候我们需要一个map或set的key是slice类型，但是map的key必须是可比较的类型，但是slice并不满足这个条件。不过，我们可以通过两个步骤绕过这个限制。第一步，定义一个辅助函数k，将slice转为map对应的string类型的key，确保只有x和y相等时k(x) &#x3D;&#x3D; k(y)才成立。然后创建一个key为string类型的map，在每次对map操作时先用k辅助函数将slice转化为string类型。</p>
<p>下面的例子演示了如何使用map来记录提交相同的字符串列表的次数。它使用了fmt.Sprintf函数将字符串列表转换为一个字符串以用于map的key，通过%q参数忠实地记录每个字符串元素的信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">k</span><span class="params">(list []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%q&quot;</span>, list) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(list []<span class="type">string</span>)</span></span>       &#123; m[k(list)]++ &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(list []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> m[k(list)] &#125;</span><br></pre></td></tr></table></figure>

<p>使用同样的技术可以处理任何不可比较的key类型，而不仅仅是slice类型。这种技术对于想使用自定义key比较函数的时候也很有用，例如在比较字符串的时候忽略大小写。同时，辅助函数<code>k(x)</code>也不一定是字符串类型，它可以返回任何可比较的类型，例如整数、数组或结构体等。</p>
<p>这是map的另一个例子，下面的程序用于统计输入中每个Unicode码点出现的次数。虽然Unicode全部码点的数量巨大，但是出现在特定文档中的字符种类并没有多少，使用map可以用比较自然的方式来跟踪那些出现过的字符的次数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Charcount computes counts of Unicode characters.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;unicode&quot;</span></span><br><span class="line">    <span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)    <span class="comment">// counts of Unicode characters</span></span><br><span class="line">    <span class="keyword">var</span> utflen [utf8.UTFMax + <span class="number">1</span>]<span class="type">int</span> <span class="comment">// count of lengths of UTF-8 encodings</span></span><br><span class="line">    invalid := <span class="number">0</span>                    <span class="comment">// count of invalid UTF-8 characters</span></span><br><span class="line"></span><br><span class="line">    in := bufio.NewReader(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        r, n, err := in.ReadRune() <span class="comment">// returns rune, nbytes, error</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">&quot;charcount: %v\n&quot;</span>, err)</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r == unicode.ReplacementChar &amp;&amp; n == <span class="number">1</span> &#123;</span><br><span class="line">            invalid++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        counts[r]++</span><br><span class="line">        utflen[n]++</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;rune\tcount\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> c, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%q\t%d\n&quot;</span>, c, n)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Print(<span class="string">&quot;\nlen\tcount\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, n := <span class="keyword">range</span> utflen &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%d\t%d\n&quot;</span>, i, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> invalid &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;\n%d invalid UTF-8 characters\n&quot;</span>, invalid)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReadRune</code>方法执行UTF-8解码并返回三个值：解码的rune字符的值，字符UTF-8编码后的长度，和一个错误值。我们可预期的错误值只有对应文件结尾的<code>io.EOF</code>。如果输入的是无效的UTF-8编码的字符，返回的将是<code>unicode.ReplacementChar</code>表示无效字符，并且编码长度是1。</p>
<p>charcount程序同时打印不同UTF-8编码长度的字符数目。对此，map并不是一个合适的数据结构；因为UTF-8编码的长度总是从1到<code>utf8.UTFMax</code>（最大是4个字节），使用数组将更有效。</p>
<p>Map的value类型也可以是一个聚合类型，比如是一个map或slice。在下面的代码中，图graph的key类型是一个字符串，value类型<code>map[string]bool</code>代表一个字符串集合。从概念上讲，graph将一个字符串类型的key映射到一组相关的字符串集合，它们指向新的graph的key。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> graph = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addEdge</span><span class="params">(from, to <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    edges := graph[from]</span><br><span class="line">    <span class="keyword">if</span> edges == <span class="literal">nil</span> &#123;</span><br><span class="line">        edges = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">        graph[from] = edges</span><br><span class="line">    &#125;</span><br><span class="line">    edges[to] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasEdge</span><span class="params">(from, to <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> graph[from][to]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>addEdge</code>函数惰性初始化map是一个惯用方式，也就是说在每个值首次作为key时才初始化。<code>addEdge</code>函数显示了如何让map的零值也能正常工作；即使<code>from</code>到<code>to</code>的边不存在，<code>graph[from][to]</code>依然可以返回一个有意义的结果。</p>
<p><strong>练习 4.8：</strong> 修改charcount程序，使用<code>unicode.IsLetter</code>等相关的函数，统计字母、数字等Unicode中不同的字符类别。</p>
<p><strong>练习 4.9：</strong> 编写一个程序wordfreq程序，报告输入文本中每个单词出现的频率。在第一次调用Scan前先调用<code>input.Split(bufio.ScanWords)</code>函数，这样可以按单词而不是按行输入。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。用结构体的经典案例是处理公司的员工信息，每个员工信息包含一个唯一的员工编号、员工的名字、家庭住址、出生日期、工作岗位、薪资、上级领导等等。所有的这些信息都需要绑定到一个实体中，可以作为一个整体单元被复制，作为函数的参数或返回值，或者是被存储到数组中，等等。</p>
<p>下面两个语句声明了一个叫Employee的命名的结构体类型，并且声明了一个Employee类型的变量<code>dilbert</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">int</span></span><br><span class="line">    Name      <span class="type">string</span></span><br><span class="line">    Address   <span class="type">string</span></span><br><span class="line">    DoB       time.Time</span><br><span class="line">    Position  <span class="type">string</span></span><br><span class="line">    Salary    <span class="type">int</span></span><br><span class="line">    ManagerID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dilbert Employee</span><br></pre></td></tr></table></figure>

<p>dilbert结构体变量的成员可以通过点操作符访问，比如<code>dilbert.Name</code>和<code>dilbert.DoB</code>。因为dilbert是一个变量，它所有的成员也同样是变量，我们可以直接对每个成员赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dilbert.Salary -= <span class="number">5000</span> <span class="comment">// demoted, for writing too few lines of code</span></span><br></pre></td></tr></table></figure>

<p>或者是对成员取地址，然后通过指针访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">position := &amp;dilbert.Position</span><br><span class="line">*position = <span class="string">&quot;Senior &quot;</span> + *position <span class="comment">// promoted, for outsourcing to Elbonia</span></span><br></pre></td></tr></table></figure>

<p>点操作符也可以和指向结构体的指针一起工作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeOfTheMonth *Employee = &amp;dilbert</span><br><span class="line">employeeOfTheMonth.Position += <span class="string">&quot; (proactive team player)&quot;</span></span><br></pre></td></tr></table></figure>

<p>相当于下面语句</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(*employeeOfTheMonth).Position += <span class="string">&quot; (proactive team player)&quot;</span></span><br></pre></td></tr></table></figure>

<p>下面的<code>EmployeeByID</code>函数将根据给定的员工ID返回对应的员工信息结构体的指针。我们可以使用点操作符来访问它里面的成员：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EmployeeByID</span><span class="params">(id <span class="type">int</span>)</span></span> *Employee &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(EmployeeByID(dilbert.ManagerID).Position) <span class="comment">// &quot;Pointy-haired boss&quot;</span></span><br><span class="line"></span><br><span class="line">id := dilbert.ID</span><br><span class="line">EmployeeByID(id).Salary = <span class="number">0</span> <span class="comment">// fired for... no real reason</span></span><br></pre></td></tr></table></figure>

<p>后面的语句通过<code>EmployeeByID</code>返回的结构体指针更新了Employee结构体的成员。如果将<code>EmployeeByID</code>函数的返回值从<code>*Employee</code>指针类型改为Employee值类型，那么更新语句将不能编译通过，因为在赋值语句的左边并不确定是一个变量（译注：调用函数返回的是值，并不是一个可取地址的变量）。</p>
<p>通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行，就像下面的Name和Address成员那样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID            <span class="type">int</span></span><br><span class="line">    Name, Address <span class="type">string</span></span><br><span class="line">    DoB           time.Time</span><br><span class="line">    Position      <span class="type">string</span></span><br><span class="line">    Salary        <span class="type">int</span></span><br><span class="line">    ManagerID     <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**结构体成员的输入顺序也有重要的意义。**我们也可以将Position成员合并（因为也是字符串类型），或者是交换Name和Address出现的先后顺序，**那样的话就是定义了不同的结构体类型。**通常，我们只是将相关的成员写到一起。</p>
<p><strong>如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。</strong></p>
<p><strong>一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适用于数组。）但是S类型的结构体可以包含<code>*S</code>指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。</strong></p>
<p>在下面的代码中，我们使用一个二叉树来实现一个插入排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> tree <span class="keyword">struct</span> &#123;</span><br><span class="line">    value       <span class="type">int</span></span><br><span class="line">    left, right *tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort sorts values in place.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(values []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *tree</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">        root = add(root, v)</span><br><span class="line">    &#125;</span><br><span class="line">    appendValues(values[:<span class="number">0</span>], root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// appendValues appends the elements of t to values in order</span></span><br><span class="line"><span class="comment">// and returns the resulting slice.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendValues</span><span class="params">(values []<span class="type">int</span>, t *tree)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">        values = appendValues(values, t.left)</span><br><span class="line">        values = <span class="built_in">append</span>(values, t.value)</span><br><span class="line">        values = appendValues(values, t.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(t *tree, value <span class="type">int</span>)</span></span> *tree &#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Equivalent to return &amp;tree&#123;value: value&#125;.</span></span><br><span class="line">        t = <span class="built_in">new</span>(tree)</span><br><span class="line">        t.value = value</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> value &lt; t.value &#123;</span><br><span class="line">        t.left = add(t.left, value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t.right = add(t.right, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**结构体类型的零值是每个成员都是零值。通常会将零值作为最合理的默认值。**例如，对于<code>bytes.Buffer</code>类型，结构体初始值就是一个随时可用的空缓存，还有<code>sync.Mutex</code>的零值也是有效的未锁定状态。<strong>有时候这种零值可用的特性是自然获得的，但是也有些类型需要一些额外的工作。</strong></p>
<p>**如果结构体没有任何成员的话就是空结构体，写作<code>struct&#123;&#125;</code>。它的大小为0，也不包含任何信息，但是有时候依然是有价值的。**有些Go语言程序员用map来模拟set数据结构时，用它来代替map中布尔类型的value，只是强调key的重要性，但是因为节约的空间有限，而且语法比较复杂，所以我们通常会避免这样的用法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;) <span class="comment">// set of strings</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> _, ok := seen[s]; !ok &#123;</span><br><span class="line">    seen[s] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="comment">// ...first time seeing s...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="结构体字面值"><a href="#结构体字面值" class="headerlink" title="结构体字面值"></a>结构体字面值</h3><p><strong>结构体值也可以用结构体字面值表示，结构体字面值可以指定每个成员的值。</strong></p>
<p><strong>有2种形式的结构体字面值语法：</strong></p>
<ul>
<li>写法1：要求以结构体成员定义的顺序为每个结构体成员指定一个字面值。它要求写代码和读代码的人要记住结构体的每个成员的类型和顺序，不过结构体成员有细微的调整就可能导致上述代码不能编译。因此，上述的语法一般只在定义结构体的包内部使用，或者是在较小的结构体中使用，这些结构体的成员排列比较规则，比如<code>image.Point&#123;x, y&#125;</code>或<code>color.RGBA&#123;red, green, blue, alpha&#125;</code>：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">int</span> &#125;</span><br><span class="line"></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>写法2：以成员名字和相应的值来初始化，可以包含部分或全部的成员。如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要。如1.4节的Lissajous程序的写法：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br></pre></td></tr></table></figure>

<p>**2种不同形式的写法不能混合使用。而且，你不能企图在外部包中用第一种顺序赋值的技巧来偷偷地初始化结构体中未导出的成员：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> p</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123; a, b <span class="type">int</span> &#125; <span class="comment">// a and b are not exported</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> q</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;p&quot;</span></span><br><span class="line"><span class="keyword">var</span> _ = p.T&#123;a: <span class="number">1</span>, b: <span class="number">2</span>&#125; <span class="comment">// compile error: can&#x27;t reference a, b</span></span><br><span class="line"><span class="keyword">var</span> _ = p.T&#123;<span class="number">1</span>, <span class="number">2</span>&#125;       <span class="comment">// compile error: can&#x27;t reference a, b</span></span><br></pre></td></tr></table></figure>

<p>虽然上面最后一行代码的编译错误信息中并没有显式提到未导出的成员，但是这样企图隐式使用未导出成员的行为也是不允许的。</p>
<p>**结构体可以作为函数的参数和返回值。**例如，这个Scale函数将Point类型的值缩放后返回：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span><span class="params">(p Point, factor <span class="type">int</span>)</span></span> Point &#123;</span><br><span class="line">    <span class="keyword">return</span> Point&#123;p.X * factor, p.Y * factor&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(Scale(Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="number">5</span>)) <span class="comment">// &quot;&#123;5 10&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bonus</span><span class="params">(e *Employee, percent <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Salary * percent / <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AwardAnnualRaise</span><span class="params">(e *Employee)</span></span> &#123;</span><br><span class="line">    e.Salary = e.Salary * <span class="number">105</span> / <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因为结构体通常通过指针处理，可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pp := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>它和下面的语句是等价的：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pp := <span class="built_in">new</span>(Point)</span><br><span class="line">*pp = Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>不过<code>&amp;Point&#123;1, 2&#125;</code>写法可以直接在表达式中使用，比如一个函数调用。</p>
<h3 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h3><p><strong>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用<code>==</code>或<code>!=</code>运算符进行比较。相等比较运算符<code>==</code>将比较两个结构体的每个成员，因此下面两个比较的表达式是等价的：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">int</span> &#125;</span><br><span class="line"></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">fmt.Println(p.X == q.X &amp;&amp; p.Y == q.Y) <span class="comment">// &quot;false&quot;</span></span><br><span class="line">fmt.Println(p == q)                   <span class="comment">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">    hostname <span class="type">string</span></span><br><span class="line">    port     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hits := <span class="built_in">make</span>(<span class="keyword">map</span>[address]<span class="type">int</span>)</span><br><span class="line">hits[address&#123;<span class="string">&quot;golang.org&quot;</span>, <span class="number">443</span>&#125;]++</span><br></pre></td></tr></table></figure>

<h3 id="结构体嵌入和匿名成员"><a href="#结构体嵌入和匿名成员" class="headerlink" title="结构体嵌入和匿名成员"></a>结构体嵌入和匿名成员</h3><p>使用Go语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，这样就可以通过简单的点运算符<code>x.f</code>来访问匿名成员链中嵌套的<code>x.d.e.f</code>成员。</p>
<p>考虑一个二维的绘图程序，提供了一个各种图形的库，例如矩形、椭圆形、星形和轮形等几何形状。这里是其中两个的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y, Radius <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y, Radius, Spokes <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个Circle代表的圆形类型包含了标准圆心的X和Y坐标信息，和一个Radius表示的半径信息。一个Wheel轮形除了包含Circle类型所有的全部成员外，还增加了Spokes表示径向辐条的数量。我们可以这样创建一个wheel变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X = <span class="number">8</span></span><br><span class="line">w.Y = <span class="number">8</span></span><br><span class="line">w.Radius = <span class="number">5</span></span><br><span class="line">w.Spokes = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>随着库中几何形状数量的增多，我们一定会注意到它们之间的相似和重复之处，所以我们可能为了便于维护而将相同的属性独立出来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Center Point</span><br><span class="line">    Radius <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle Circle</span><br><span class="line">    Spokes <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样改动之后结构体类型变的清晰了，但是这种修改同时也导致了访问每个成员变得繁琐：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.Circle.Center.X = <span class="number">8</span></span><br><span class="line">w.Circle.Center.Y = <span class="number">8</span></span><br><span class="line">w.Circle.Radius = <span class="number">5</span></span><br><span class="line">w.Spokes = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>*<em>Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫</em>匿名成员*。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。**下面的代码中，Circle和Wheel各自都有一个匿名成员。我们可以说Point类型被嵌入到了Circle结构体，同时Circle类型被嵌入到了Wheel结构体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Radius <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle</span><br><span class="line">    Spokes <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>得益于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X = <span class="number">8</span>            <span class="comment">// equivalent to w.Circle.Point.X = 8</span></span><br><span class="line">w.Y = <span class="number">8</span>            <span class="comment">// equivalent to w.Circle.Point.Y = 8</span></span><br><span class="line">w.Radius = <span class="number">5</span>       <span class="comment">// equivalent to w.Circle.Radius = 5</span></span><br><span class="line">w.Spokes = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p><strong>在右边的注释中给出的显式形式访问这些叶子成员的语法依然有效，因此匿名成员并不是真的无法访问了。其中匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。我们在访问子成员的时候可以忽略任何匿名成员部分。</strong></p>
<p><strong>不幸的是，结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w = Wheel&#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">20</span>&#125;                       <span class="comment">// compile error: unknown fields</span></span><br><span class="line">w = Wheel&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>, Radius: <span class="number">5</span>, Spokes: <span class="number">20</span>&#125; <span class="comment">// compile error: unknown fields</span></span><br></pre></td></tr></table></figure>

<p><strong>结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w = Wheel&#123;Circle&#123;Point&#123;<span class="number">8</span>, <span class="number">8</span>&#125;, <span class="number">5</span>&#125;, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">w = Wheel&#123;</span><br><span class="line">    Circle: Circle&#123;</span><br><span class="line">        Point:  Point&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>&#125;,</span><br><span class="line">        Radius: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    Spokes: <span class="number">20</span>, <span class="comment">// <span class="doctag">NOTE:</span> trailing comma necessary here (and at Radius)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, w)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br><span class="line"></span><br><span class="line">w.X = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, w)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是<code>Printf</code>函数中<code>%v</code>参数包含的<code>#</code>副词，它表示用和Go语言类似的语法打印值。对于结构体类型来说，将包含每个成员的名字。</strong></p>
<p><strong>因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。</strong></p>
<p><strong>同时，因为成员的名字是由其类型隐式地决定的，所以匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.X = <span class="number">8</span> <span class="comment">// equivalent to w.circle.point.X = 8</span></span><br></pre></td></tr></table></figure>

<p><strong>但是在包外部，因为circle和point没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。</strong></p>
<p>**我们将会看到匿名成员并不要求是结构体类型；其实任何命名的类型都可以作为结构体的匿名成员。**但是为什么要嵌入一个没有任何子成员类型的匿名成员类型呢？</p>
<p><strong>答案是匿名类型的方法集。简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一些有简单行为的对象组合成有复杂行为的对象。组合是Go语言中面向对象编程的核心。</strong></p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。在类似的协议中，JSON并不是唯一的一个标准协议。 XML、ASN.1和Google的Protocol Buffers都是类似的协议，并且有各自的特色，但是由于简洁性、可读性和流行程度等原因，JSON是应用最广泛的一个。</p>
<p>Go语言对于这些标准格式的编码和解码都有良好的支持，由标准库中的<code>encoding/json</code>、<code>encoding/xml</code>、<code>encoding/asn1</code>等包提供支持（译注：Protocol Buffers的支持由 <code>github.com/golang/protobuf</code> 包提供），并且这类包都有着相似的API接口。本节，我们将对重要的<code>encoding/json</code>包的用法做个概述。</p>
<p>JSON是对JavaScript中各种类型的值——字符串、数字、布尔值和对象——Unicode本文编码。它可以用有效可读的方式表示基础数据类型和数组、slice、结构体和map等聚合数据类型。</p>
<p>基本的JSON类型有数字（十进制或科学记数法）、布尔值（<code>true</code>或<code>false</code>）、字符串，其中字符串是以双引号包含的Unicode字符序列，支持和Go语言类似的反斜杠转义特性，不过JSON使用的是<code>\Uhhhh</code>转义数字来表示一个UTF-16编码（译注：UTF-16和UTF-8一样是一种变长的编码，有些Unicode码点较大的字符需要用4个字节表示；而且UTF-16还有大端和小端的问题），而不是Go语言的rune类型。</p>
<p>这些基础类型可以通过JSON的数组和对象类型进行递归组合。一个JSON数组是一个有序的值序列，写在一个方括号中并以逗号分隔；一个JSON数组可以用于编码Go语言的数组和slice。一个JSON对象是一个字符串到值的映射，写成一系列的name:value对形式，用花括号包含并以逗号分隔；JSON的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">boolean         <span class="literal">true</span></span><br><span class="line">number          <span class="number">-273.15</span></span><br><span class="line"><span class="type">string</span>          <span class="string">&quot;She said \&quot;Hello, BF\&quot;&quot;</span></span><br><span class="line">array           [<span class="string">&quot;gold&quot;</span>, <span class="string">&quot;silver&quot;</span>, <span class="string">&quot;bronze&quot;</span>]</span><br><span class="line">object          &#123;<span class="string">&quot;year&quot;</span>: <span class="number">1980</span>,</span><br><span class="line">                 <span class="string">&quot;event&quot;</span>: <span class="string">&quot;archery&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;medals&quot;</span>: [<span class="string">&quot;gold&quot;</span>, <span class="string">&quot;silver&quot;</span>, <span class="string">&quot;bronze&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>考虑一个应用程序，该程序负责收集各种电影评论并提供反馈功能。它的Movie数据类型和一个典型的表示电影的值列表如下所示。（在结构体声明中，Year和Color成员后面的字符串面值是结构体成员Tag；我们稍后会解释它的作用。）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title  <span class="type">string</span></span><br><span class="line">    Year   <span class="type">int</span>  <span class="string">`json:&quot;released&quot;`</span></span><br><span class="line">    Color  <span class="type">bool</span> <span class="string">`json:&quot;color,omitempty&quot;`</span></span><br><span class="line">    Actors []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> movies = []Movie&#123;</span><br><span class="line">    &#123;Title: <span class="string">&quot;Casablanca&quot;</span>, Year: <span class="number">1942</span>, Color: <span class="literal">false</span>,</span><br><span class="line">        Actors: []<span class="type">string</span>&#123;<span class="string">&quot;Humphrey Bogart&quot;</span>, <span class="string">&quot;Ingrid Bergman&quot;</span>&#125;&#125;,</span><br><span class="line">    &#123;Title: <span class="string">&quot;Cool Hand Luke&quot;</span>, Year: <span class="number">1967</span>, Color: <span class="literal">true</span>,</span><br><span class="line">        Actors: []<span class="type">string</span>&#123;<span class="string">&quot;Paul Newman&quot;</span>&#125;&#125;,</span><br><span class="line">    &#123;Title: <span class="string">&quot;Bullitt&quot;</span>, Year: <span class="number">1968</span>, Color: <span class="literal">true</span>,</span><br><span class="line">        Actors: []<span class="type">string</span>&#123;<span class="string">&quot;Steve McQueen&quot;</span>, <span class="string">&quot;Jacqueline Bisset&quot;</span>&#125;&#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的数据结构特别适合JSON格式，并且在两者之间相互转换也很容易。将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。编组通过调用<code>json.Marshal</code>函数完成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data, err := json.Marshal(movies)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;JSON marshaling failed: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data)</span><br></pre></td></tr></table></figure>

<p>Marshal函数返回一个编码后的字节slice，包含很长的字符串，并且没有空白缩进；我们将它折行以便于显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;Title&quot;:&quot;Casablanca&quot;,&quot;released&quot;:1942,&quot;Actors&quot;:[&quot;Humphrey Bogart&quot;,&quot;Ingr</span><br><span class="line">id Bergman&quot;]&#125;,&#123;&quot;Title&quot;:&quot;Cool Hand Luke&quot;,&quot;released&quot;:1967,&quot;color&quot;:true,&quot;Ac</span><br><span class="line">tors&quot;:[&quot;Paul Newman&quot;]&#125;,&#123;&quot;Title&quot;:&quot;Bullitt&quot;,&quot;released&quot;:1968,&quot;color&quot;:true,&quot;</span><br><span class="line">Actors&quot;:[&quot;Steve McQueen&quot;,&quot;Jacqueline Bisset&quot;]&#125;]</span><br></pre></td></tr></table></figure>

<p>这种紧凑的表示形式虽然包含了全部的信息，但是很难阅读。为了生成便于阅读的格式，另一个json.MarshalIndent函数将产生整齐缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data, err := json.MarshalIndent(movies, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;JSON marshaling failed: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data)</span><br></pre></td></tr></table></figure>

<p>上面的代码将产生这样的输出（译注：在最后一个成员或元素后面并没有逗号分隔符）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Casablanca&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;released&quot;</span><span class="punctuation">:</span> <span class="number">1942</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Actors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;Humphrey Bogart&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;Ingrid Bergman&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Cool Hand Luke&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;released&quot;</span><span class="punctuation">:</span> <span class="number">1967</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Actors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;Paul Newman&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bullitt&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;released&quot;</span><span class="punctuation">:</span> <span class="number">1968</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Actors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;Steve McQueen&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;Jacqueline Bisset&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。</p>
<p>细心的读者可能已经注意到，其中<code>Year</code>名字的成员在编码后变成了<code>released</code>，还有<code>Color</code>成员编码后变成了小写字母开头的<code>color</code>。这是因为结构体成员Tag所导致的。一个结构体成员Tag是和在编译阶段关联到该成员的元信息字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Year  <span class="type">int</span>  <span class="string">`json:&quot;released&quot;`</span></span><br><span class="line">Color <span class="type">bool</span> <span class="string">`json:&quot;color,omitempty&quot;`</span></span><br></pre></td></tr></table></figure>

<p>结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的<code>key:&quot;value&quot;</code>键值对序列；因为值中含有双引号字符，因此成员Tag一般用原生字符串面值的形式书写。<code>json</code>开头键名对应的值用于控制<code>encoding/json</code>包的编码和解码的行为，并且encoding&#x2F;…下面其它的包也遵循这个约定。成员Tag中json对应值的第一部分用于指定JSON对象的名字，比如将Go语言中的<code>TotalCount</code>成员对应到JSON中的<code>total_count</code>对象。Color成员的Tag还带了一个额外的<code>omitempty</code>选项，表示当Go语言结构体成员为空或零值时不生成该JSON对象（这里<code>false</code>为零值）。果然，Casablanca是一个黑白电影，并没有输出Color成员。</p>
<p>编码的逆操作是解码，对应将JSON数据解码为Go语言的数据结构，Go语言中一般叫unmarshaling，通过<code>json.Unmarshal</code>函数完成。下面的代码将JSON格式的电影数据解码为一个结构体slice，结构体中只有Title成员。通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员。当<code>Unmarshal</code>函数调用返回，slice将被只含有Title信息的值填充，其它JSON成员将被忽略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> titles []<span class="keyword">struct</span>&#123; Title <span class="type">string</span> &#125;</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(data, &amp;titles); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;JSON unmarshaling failed: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(titles) <span class="comment">// &quot;[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]&quot;</span></span><br></pre></td></tr></table></figure>

<p>许多web服务都提供JSON接口，通过HTTP接口发送JSON格式请求并返回JSON格式的信息。为了说明这一点，我们通过Github的issue查询服务来演示类似的用法。首先，我们要定义合适的类型和常量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package github provides a Go API for the GitHub issue tracker.</span></span><br><span class="line"><span class="comment">// See https://developer.github.com/v3/search/#search-issues.</span></span><br><span class="line"><span class="keyword">package</span> github</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IssuesURL = <span class="string">&quot;https://api.github.com/search/issues&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IssuesSearchResult <span class="keyword">struct</span> &#123;</span><br><span class="line">    TotalCount <span class="type">int</span> <span class="string">`json:&quot;total_count&quot;`</span></span><br><span class="line">    Items          []*Issue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Issue <span class="keyword">struct</span> &#123;</span><br><span class="line">    Number    <span class="type">int</span></span><br><span class="line">    HTMLURL   <span class="type">string</span> <span class="string">`json:&quot;html_url&quot;`</span></span><br><span class="line">    Title     <span class="type">string</span></span><br><span class="line">    State     <span class="type">string</span></span><br><span class="line">    User      *User</span><br><span class="line">    CreatedAt time.Time <span class="string">`json:&quot;created_at&quot;`</span></span><br><span class="line">    Body      <span class="type">string</span>    <span class="comment">// in Markdown format</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Login   <span class="type">string</span></span><br><span class="line">    HTMLURL <span class="type">string</span> <span class="string">`json:&quot;html_url&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和前面一样，即使对应的JSON对象名是小写字母，每个结构体的成员名也是声明为大写字母开头的。因为有些JSON成员名字和Go结构体成员名字并不相同，因此需要Go语言结构体成员Tag来指定对应的JSON名字。同样，在解码的时候也需要做同样的处理，GitHub服务返回的信息比我们定义的要多很多。</p>
<p><code>SearchIssues</code>函数发出一个HTTP请求，然后解码返回的JSON格式的结果。因为用户提供的查询条件可能包含类似<code>?</code>和<code>&amp;</code>之类的特殊字符，为了避免对URL造成冲突，我们用<code>url.QueryEscape</code>来对查询中的特殊字符进行转义操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;net/url&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SearchIssues queries the GitHub issue tracker.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchIssues</span><span class="params">(terms []<span class="type">string</span>)</span></span> (*IssuesSearchResult, <span class="type">error</span>) &#123;</span><br><span class="line">    q := url.QueryEscape(strings.Join(terms, <span class="string">&quot; &quot;</span>))</span><br><span class="line">    resp, err := http.Get(IssuesURL + <span class="string">&quot;?q=&quot;</span> + q)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We must close resp.Body on all execution paths.</span></span><br><span class="line">    <span class="comment">// (Chapter 5 presents &#x27;defer&#x27;, which makes this simpler.)</span></span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class="line">        resp.Body.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;search query failed: %s&quot;</span>, resp.Status)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result IssuesSearchResult</span><br><span class="line">    <span class="keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        resp.Body.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    resp.Body.Close()</span><br><span class="line">    <span class="keyword">return</span> &amp;result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在早些的例子中，我们使用了json.Unmarshal函数来将JSON格式的字符串解码为字节slice。但是这个例子中，我们使用了基于流式的解码器json.Decoder，它可以从一个输入流解码JSON数据，尽管这不是必须的。如您所料，还有一个针对输出流的json.Encoder编码对象。</p>
<p>我们调用Decode方法来填充变量。这里有多种方法可以格式化结构。下面是最简单的一种，以一个固定宽度打印每个issue，但是在下一节我们将看到如何利用模板来输出复杂的格式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Issues prints a table of GitHub issues matching the search terms.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;gopl.io/ch4/github&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result, err := github.SearchIssues(os.Args[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d issues:\n&quot;</span>, result.TotalCount)</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> result.Items &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;#%-5d %9.9s %.55s\n&quot;</span>,</span><br><span class="line">            item.Number, item.User.Login, item.Title)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过命令行参数指定检索条件。下面的命令是查询Go语言项目中和JSON解码相关的问题，还有查询返回的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch4/issues</span><br><span class="line">$ ./issues repo:golang/go is:open json decoder</span><br><span class="line">13 issues:</span><br><span class="line">#5680    eaigner encoding/json: set key converter on en/decoder</span><br><span class="line">#6050  gopherbot encoding/json: provide tokenizer</span><br><span class="line">#8658  gopherbot encoding/json: use bufio</span><br><span class="line">#8462  kortschak encoding/json: UnmarshalText confuses json.Unmarshal</span><br><span class="line">#5901        rsc encoding/json: allow override type marshaling</span><br><span class="line">#9812  klauspost encoding/json: string tag not symmetric</span><br><span class="line">#7872  extempora encoding/json: Encoder internally buffers full output</span><br><span class="line">#9650    cespare encoding/json: Decoding gives errPhase when unmarshalin</span><br><span class="line">#6716  gopherbot encoding/json: include field name in unmarshal error me</span><br><span class="line">#6901  lukescott encoding/json, encoding/xml: option to treat unknown fi</span><br><span class="line">#6384    joeshaw encoding/json: encode precise floating point integers u</span><br><span class="line">#6647    btracey x/tools/cmd/godoc: display type kind of each named type</span><br><span class="line">#4237  gjemiller encoding/base64: URLEncoding padding is optional</span><br></pre></td></tr></table></figure>

<h2 id="文本和HTML模板"><a href="#文本和HTML模板" class="headerlink" title="文本和HTML模板"></a>文本和HTML模板</h2><p>如果只是最简单的格式化，使用<code>Printf</code>是完全足够的。但是有时候会需要复杂的打印格式，这时候一般需要将格式化代码分离出来以便更安全地修改。这些功能是由<code>text/template</code>和<code>html/template</code>等模板包提供的，它们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。</p>
<p>一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的<code>&#123;&#123;action&#125;&#125;</code>对象。大部分的字符串只是按字面值打印，但是对于actions部分将触发其它的行为。每个actions都包含了一个用模板语言书写的表达式，一个action虽然简短但是可以输出复杂的打印值，模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流if-else语句和range循环语句，还有其它实例化模板等诸多特性。下面是一个简单的模板字符串：</p>
<p><em>gopl.io&#x2F;ch4&#x2F;issuesreport</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> templ = <span class="string">`&#123;&#123;.TotalCount&#125;&#125; issues:</span></span><br><span class="line"><span class="string">&#123;&#123;range .Items&#125;&#125;----------------------------------------</span></span><br><span class="line"><span class="string">Number: &#123;&#123;.Number&#125;&#125;</span></span><br><span class="line"><span class="string">User:   &#123;&#123;.User.Login&#125;&#125;</span></span><br><span class="line"><span class="string">Title:  &#123;&#123;.Title | printf &quot;%.64s&quot;&#125;&#125;</span></span><br><span class="line"><span class="string">Age:    &#123;&#123;.CreatedAt | daysAgo&#125;&#125; days</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;`</span></span><br></pre></td></tr></table></figure>

<p>这个模板先打印匹配到的issue总数，然后打印每个issue的编号、创建用户、标题还有存在的时间。对于每一个action，都有一个当前值的概念，对应点操作符，写作<code>.</code>。当前值“.”最初被初始化为调用模板时的参数，在当前例子中对应<code>github.IssuesSearchResult</code>类型的变量。模板中<code>&#123;&#123;.TotalCount&#125;&#125;</code>对应action将展开为结构体中<code>TotalCount</code>成员以默认的方式打印的值。模板中<code>&#123;&#123;range .Items&#125;&#125;</code>和<code>&#123;&#123;end&#125;&#125;</code>对应一个循环action，因此它们之间的内容可能会被展开多次，循环每次迭代的当前值对应当前的Items元素的值。</p>
<p>在一个action中，<code>|</code>操作符表示将前一个表达式的结果作为后一个函数的输入，类似于UNIX中管道的概念。在<code>Title</code>这一行的<code>action</code>中，第二个操作是一个<code>printf</code>函数，是一个基于<code>fmt.Sprintf</code>实现的内置函数，所有模板都可以直接使用。对于<code>Age</code>部分，第二个动作是一个叫<code>daysAgo</code>的函数，通过<code>time.Since</code>函数将<code>CreatedAt</code>成员转换为过去的时间长度：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">daysAgo</span><span class="params">(t time.Time)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(time.Since(t).Hours() / <span class="number">24</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>CreatedAt</code>的参数类型是<code>time.Time</code>，并不是字符串。以同样的方式，我们可以通过定义一些方法来控制字符串的格式化（§2.5），一个类型同样可以定制自己的JSON编码和解码行为。<code>time.Time</code>类型对应的JSON值是一个标准时间格式的字符串。</p>
<p>生成模板的输出需要两个处理步骤。第一步是要分析模板并转为内部表示，然后基于指定的输入执行模板。分析模板部分一般只需要执行一次。下面的代码创建并分析上面定义的模板<code>templ</code>。注意方法调用链的顺序：<code>template.New</code>先创建并返回一个模板；<code>Funcs</code>方法将<code>daysAgo</code>等自定义函数注册到模板中，并返回模板；最后调用<code>Parse</code>函数分析模板。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">report, err := template.New(<span class="string">&quot;report&quot;</span>).</span><br><span class="line">    Funcs(template.FuncMap&#123;<span class="string">&quot;daysAgo&quot;</span>: daysAgo&#125;).</span><br><span class="line">    Parse(templ)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为模板通常在编译时就测试好了，如果模板解析失败将是一个致命的错误。<code>template.Must</code>辅助函数可以简化这个致命错误的处理：它接受一个模板和一个error类型的参数，检测error是否为<code>nil</code>（如果不是nil则发出panic异常），然后返回传入的模板。</p>
<p>一旦模板已经创建、注册了<code>daysAgo</code>函数、并通过分析和检测，我们就可以使用<code>github.IssuesSearchResult</code>作为输入源、<code>os.Stdout</code>作为输出源来执行模板：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> report = template.Must(template.New(<span class="string">&quot;issuelist&quot;</span>).</span><br><span class="line">    Funcs(template.FuncMap&#123;<span class="string">&quot;daysAgo&quot;</span>: daysAgo&#125;).</span><br><span class="line">    Parse(templ))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result, err := github.SearchIssues(os.Args[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := report.Execute(os.Stdout, result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出一个纯文本报告：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch4/issuesreport</span><br><span class="line">$ ./issuesreport repo:golang/go is:open json decoder</span><br><span class="line">13 issues:</span><br><span class="line">----------------------------------------</span><br><span class="line">Number: 5680</span><br><span class="line">User:      eaigner</span><br><span class="line">Title:     encoding/json: set key converter on en/decoder</span><br><span class="line">Age:       750 days</span><br><span class="line">----------------------------------------</span><br><span class="line">Number: 6050</span><br><span class="line">User:      gopherbot</span><br><span class="line">Title:     encoding/json: provide tokenizer</span><br><span class="line">Age:       695 days</span><br><span class="line">----------------------------------------</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>现在让我们转到<code>html/template</code>模板包。它使用和<code>text/template</code>包相同的API和模板语言，但是增加了一个将字符串自动转义特性，这可以避免输入字符串和HTML、JavaScript、CSS或URL语法产生冲突的问题。这个特性还可以避免一些长期存在的安全问题，比如通过生成HTML注入攻击，通过构造一个含有恶意代码的问题标题，这些都可能让模板输出错误的输出，从而让他们控制页面。</p>
<p>下面的模板以HTML格式输出issue列表。注意import语句的不同：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;html/template&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> issueList = template.Must(template.New(<span class="string">&quot;issuelist&quot;</span>).Parse(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;h1&gt;&#123;&#123;.TotalCount&#125;&#125; issues&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;table&gt;</span></span><br><span class="line"><span class="string">&lt;tr style=&#x27;text-align: left&#x27;&gt;</span></span><br><span class="line"><span class="string">  &lt;th&gt;#&lt;/th&gt;</span></span><br><span class="line"><span class="string">  &lt;th&gt;State&lt;/th&gt;</span></span><br><span class="line"><span class="string">  &lt;th&gt;User&lt;/th&gt;</span></span><br><span class="line"><span class="string">  &lt;th&gt;Title&lt;/th&gt;</span></span><br><span class="line"><span class="string">&lt;/tr&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;range .Items&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;tr&gt;</span></span><br><span class="line"><span class="string">  &lt;td&gt;&lt;a href=&#x27;&#123;&#123;.HTMLURL&#125;&#125;&#x27;&gt;&#123;&#123;.Number&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">  &lt;td&gt;&#123;&#123;.State&#125;&#125;&lt;/td&gt;</span></span><br><span class="line"><span class="string">  &lt;td&gt;&lt;a href=&#x27;&#123;&#123;.User.HTMLURL&#125;&#125;&#x27;&gt;&#123;&#123;.User.Login&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">  &lt;td&gt;&lt;a href=&#x27;&#123;&#123;.HTMLURL&#125;&#125;&#x27;&gt;&#123;&#123;.Title&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">&lt;/tr&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;/table&gt;</span></span><br><span class="line"><span class="string">`</span>))</span><br></pre></td></tr></table></figure>

<p>下面的命令将在新的模板上执行一个稍微不同的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch4/issueshtml</span><br><span class="line">$ ./issueshtml repo:golang/go commenter:gopherbot json encoder &gt;issues.html</span><br></pre></td></tr></table></figure>

<p>注意，<code>html/template</code>包已经自动将特殊字符转义，因此我们依然可以看到正确的字面值。如果我们使用<code>text/template</code>包的话，这2个issue将会产生错误，其中<code>&amp;lt;</code>四个字符将会被当作小于字符<code>&lt;</code>处理，同时<code>&lt;link&gt;</code>字符串将会被当作一个链接元素处理，它们都会导致HTML文档结构的改变，从而导致有未知的风险。</p>
<p>我们也可以通过对信任的HTML字符串使用<code>template.HTML</code>类型来抑制这种自动转义的行为。还有很多采用类型命名的字符串类型分别对应信任的JavaScript、CSS和URL。下面的程序演示了两个使用不同类型的相同字符串产生的不同结果：A是一个普通字符串，B是一个信任的<code>template.HTML</code>字符串类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> templ = <span class="string">`&lt;p&gt;A: &#123;&#123;.A&#125;&#125;&lt;/p&gt;&lt;p&gt;B: &#123;&#123;.B&#125;&#125;&lt;/p&gt;`</span></span><br><span class="line">    t := template.Must(template.New(<span class="string">&quot;escape&quot;</span>).Parse(templ))</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">        A <span class="type">string</span>        <span class="comment">// untrusted plain text</span></span><br><span class="line">        B template.HTML <span class="comment">// trusted HTML</span></span><br><span class="line">    &#125;</span><br><span class="line">    data.A = <span class="string">&quot;&lt;b&gt;Hello!&lt;/b&gt;&quot;</span></span><br><span class="line">    data.B = <span class="string">&quot;&lt;b&gt;Hello!&lt;/b&gt;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> err := t.Execute(os.Stdout, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图显示了出现在浏览器中的模板输出。我们看到A的黑体标记被转义失效了，但是B没有：</p>
<p><img src="/2022/notes-of-gopl/ch4-06.png" alt="img"></p>
<p>我们这里只讲述了模板系统中最基本的特性。一如既往，如果想了解更多的信息，请自己查看包文档：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> doc text/template</span><br><span class="line">$ <span class="keyword">go</span> doc html/template</span><br></pre></td></tr></table></figure>



<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p><strong>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(parameter-list)</span></span> (result-list) &#123;</span><br><span class="line">    body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。返回值列表描述了函数返回值的变量名以及类型。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。在hypot函数中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hypot</span><span class="params">(x, y <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(hypot(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">// &quot;5&quot;</span></span><br></pre></td></tr></table></figure>

<p>x和y是形参名，3和4是调用时的传入的实参，函数返回了一个float64类型的值。 返回值也可以像形式参数一样被命名。在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为该类型的零值。 如果一个函数在声明时，包含返回值列表，该函数必须以 return语句结尾，除非函数明显无法运行到结尾处。例如函数在结尾时调用了panic异常或函数中存在无限循环。</p>
<p>正如hypot一样，如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。下面2个声明是等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i, j, k <span class="type">int</span>, s, t <span class="type">string</span>)</span></span>                 &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="type">int</span>, j <span class="type">int</span>, k <span class="type">int</span>,  s <span class="type">string</span>, t <span class="type">string</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们给出4种方法声明拥有2个int型参数和1个int型返回值的函数.blank identifier(译者注：即下文的_符号)可以强调某个参数未被使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span>   &#123;<span class="keyword">return</span> x + y&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>)   &#123; z = x - y; <span class="keyword">return</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">first</span><span class="params">(x <span class="type">int</span>, _ <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>      &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, add)   <span class="comment">// &quot;func(int, int) int&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, sub)   <span class="comment">// &quot;func(int, int) int&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, first) <span class="comment">// &quot;func(int, int) int&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, zero)  <span class="comment">// &quot;func(int, int) int&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>函数的类型被称为函数的签名。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。形参和返回值的变量名不影响函数签名，也不影响它们是否可以以省略参数类型的形式表示。</strong></p>
<p>每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。</p>
<p><strong>在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。</strong></p>
<p><strong>实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。</strong></p>
<p>你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数签名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sin</span><span class="params">(x <span class="type">float64</span>)</span></span> float <span class="comment">//implemented in assembly language</span></span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>函数可以是递归的，这意味着函数可以直接或间接的调用自身。对许多问题而言，递归是一种强有力的技术，例如处理递归的数据结构。在4.4节，我们通过遍历二叉树来实现简单的插入排序，在本章节，我们再次使用它来处理HTML文件。</p>
<p>下文的示例代码使用了非标准包 <code>golang.org/x/net/html</code> ，解析HTML。<code>golang.org/x/...</code> 目录下存储了一些由Go团队设计、维护，对网络编程、国际化文件处理、移动平台、图像处理、加密解密、开发者工具提供支持的扩展包。未将这些扩展包加入到标准库原因有二，一是部分包仍在开发中，二是对大多数Go语言的开发者而言，扩展包提供的功能很少被使用。</p>
<p>例子中调用<code>golang.org/x/net/html</code>的部分api如下所示。<code>html.Parse</code>函数读入一组bytes解析后，返回<code>html.Node</code>类型的HTML页面树状结构根节点。HTML拥有很多类型的结点如text（文本）、commnets（注释）类型，在下面的例子中，我们 只关注<code>&lt; name key=&#39;value&#39; &gt;</code>形式的结点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> html</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type                    NodeType</span><br><span class="line">    Data                    <span class="type">string</span></span><br><span class="line">    Attr                    []Attribute</span><br><span class="line">    FirstChild, NextSibling *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NodeType <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    ErrorNode NodeType = <span class="literal">iota</span></span><br><span class="line">    TextNode</span><br><span class="line">    DocumentNode</span><br><span class="line">    ElementNode</span><br><span class="line">    CommentNode</span><br><span class="line">    DoctypeNode</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Attribute <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key, Val <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(r io.Reader)</span></span> (*Node, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>main函数解析HTML标准输入，通过递归函数visit获得links（链接），并打印出这些links：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Findlinks1 prints the links in an HTML document read from standard input.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;golang.org/x/net/html&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doc, err := html.Parse(os.Stdin)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;findlinks1: %v\n&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, link := <span class="keyword">range</span> visit(<span class="literal">nil</span>, doc) &#123;</span><br><span class="line">        fmt.Println(link)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>visit函数遍历HTML的节点树，从每一个anchor元素的<code>href</code>属性获得link,将这些links存入字符串数组中，并返回这个字符串数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// visit appends to links each link found in n and returns the result.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(links []<span class="type">string</span>, n *html.Node)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="string">&quot;a&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, a := <span class="keyword">range</span> n.Attr &#123;</span><br><span class="line">            <span class="keyword">if</span> a.Key == <span class="string">&quot;href&quot;</span> &#123;</span><br><span class="line">                links = <span class="built_in">append</span>(links, a.Val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> c := n.FirstChild; c != <span class="literal">nil</span>; c = c.NextSibling &#123;</span><br><span class="line">        links = visit(links, c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> links</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了遍历结点n的所有后代结点，每次遇到n的孩子结点时，visit递归的调用自身。这些孩子结点存放在FirstChild链表中。</p>
<p>让我们以Go的主页（golang.org）作为目标，运行findlinks。我们以fetch（1.5章）的输出作为findlinks的输入。下面的输出做了简化处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch1/fetch</span><br><span class="line">$ go build gopl.io/ch5/findlinks1</span><br><span class="line">$ ./fetch https://golang.org | ./findlinks1</span><br><span class="line">#</span><br><span class="line">/doc/</span><br><span class="line">/pkg/</span><br><span class="line">/help/</span><br><span class="line">/blog/</span><br><span class="line">http://play.golang.org/</span><br><span class="line">//tour.golang.org/</span><br><span class="line">https://golang.org/dl/</span><br><span class="line">//blog.golang.org/</span><br><span class="line">/LICENSE</span><br><span class="line">/doc/tos.html</span><br><span class="line">http://www.google.com/intl/en/policies/privacy/</span><br></pre></td></tr></table></figure>

<p>注意在页面中出现的链接格式，在之后我们会介绍如何将这些链接，根据根路径（ <a href="https://golang.org/">https://golang.org</a> ）生成可以直接访问的url。</p>
<p>在函数outline中，我们通过递归的方式遍历整个HTML结点树，并输出树的结构。在outline内部，每遇到一个HTML元素标签，就将其入栈，并输出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doc, err := html.Parse(os.Stdin)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;outline: %v\n&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    outline(<span class="literal">nil</span>, doc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outline</span><span class="params">(stack []<span class="type">string</span>, n *html.Node)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n.Type == html.ElementNode &#123;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, n.Data) <span class="comment">// push tag</span></span><br><span class="line">        fmt.Println(stack)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> c := n.FirstChild; c != <span class="literal">nil</span>; c = c.NextSibling &#123;</span><br><span class="line">        outline(stack, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一点值得注意：outline有入栈操作，但没有相对应的出栈操作。当outline调用自身时，被调用者接收的是stack的拷贝。被调用者对stack的元素追加操作，修改的是stack的拷贝，其可能会修改slice底层的数组甚至是申请一块新的内存空间进行扩容；但这个过程并不会修改调用方的stack。因此当函数返回时，调用方的stack与其调用自身之前完全一致。</p>
<p>下面是 <a href="https://golang.org/">https://golang.org</a> 页面的简要结构:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch5/outline</span><br><span class="line">$ ./fetch https://golang.org | ./outline</span><br><span class="line">[html]</span><br><span class="line">[html head]</span><br><span class="line">[html head meta]</span><br><span class="line">[html head title]</span><br><span class="line">[html head link]</span><br><span class="line">[html body]</span><br><span class="line">[html body div]</span><br><span class="line">[html body div]</span><br><span class="line">[html body div div]</span><br><span class="line">[html body div div form]</span><br><span class="line">[html body div div form div]</span><br><span class="line">[html body div div form div a]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>正如你在上面实验中所见，大部分HTML页面只需几层递归就能被处理，但仍然有些页面需要深层次的递归。</p>
<p>大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与此相反，<strong>Go语言使用可变栈，栈的大小按需增加（初始时很小）。这使得我们使用递归时不必考虑溢出和安全问题。</strong></p>
<h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><p>**在Go中，一个函数可以返回多个值。**我们已经在之前例子中看到，许多标准库中的函数返回2个值，一个是期望得到的返回值，另一个是函数出错时的错误信息。下面的例子会展示如何编写多返回值的函数。</p>
<p>下面的程序是findlinks的改进版本。修改后的findlinks可以自己发起HTTP请求，这样我们就不必再运行fetch。因为HTTP请求和解析操作可能会失败，因此findlinks声明了2个返回值：链接列表和错误信息。一般而言，HTML的解析器可以处理HTML页面的错误结点，构造出HTML页面结构，所以解析HTML很少失败。这意味着如果findlinks函数失败了，很可能是由于I&#x2F;O的错误导致的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">        links, err := findLinks(url)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">&quot;findlinks2: %v\n&quot;</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, link := <span class="keyword">range</span> links &#123;</span><br><span class="line">            fmt.Println(link)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// findLinks performs an HTTP GET request for url, parses the</span></span><br><span class="line"><span class="comment">// response as HTML, and extracts and returns the links.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLinks</span><span class="params">(url <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class="line">        resp.Body.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;getting %s: %s&quot;</span>, url, resp.Status)</span><br><span class="line">    &#125;</span><br><span class="line">    doc, err := html.Parse(resp.Body)</span><br><span class="line">    resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;parsing %s as HTML: %v&quot;</span>, url, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visit(<span class="literal">nil</span>, doc), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在findlinks中，有4处return语句，每一处return都返回了一组值。前三处return，将<code>http</code>和<code>html</code>包中的错误信息传递给findlinks的调用者。第一处return直接返回错误信息，其他两处通过<code>fmt.Errorf</code>输出详细的错误信息。如果findlinks成功结束，最后的return语句将一组解析获得的连接返回给用户。</p>
<p><strong>在findlinks中，我们必须确保<code>resp.Body</code>被关闭，释放网络资源。虽然Go的垃圾回收机制会回收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。因此我们必须显式的释放这些资源。</strong></p>
<p><strong>调用多返回值函数时，返回给调用者的是一组值，调用者必须显式的将这些值分配给变量:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">links, err := findLinks(url)</span><br></pre></td></tr></table></figure>

<p><strong>如果某个值不被使用，可以将其分配给blank identifier:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">links, _ := findLinks(url) <span class="comment">// errors ignored</span></span><br></pre></td></tr></table></figure>

<p>一个函数内部可以将另一个有多返回值的函数调用作为返回值，下面的例子展示了与findLinks有相同功能的函数，两者的区别在于下面的例子先输出参数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLinksLog</span><span class="params">(url <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;findLinks %s&quot;</span>, url)</span><br><span class="line">    <span class="keyword">return</span> findLinks(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**当你调用接受多参数的函数时，可以将一个返回多参数的函数调用作为该函数的参数。**虽然这很少出现在实际生产代码中，但这个特性在debug时很方便，我们只需要一条语句就可以输出所有的返回值。下面的代码是等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">log.Println(findLinks(url))</span><br><span class="line"></span><br><span class="line">links, err := findLinks(url)</span><br><span class="line">log.Println(links, err)</span><br></pre></td></tr></table></figure>

<p><strong>准确的变量名可以传达函数返回值的含义。尤其在返回值的类型都相同时，就像下面这样：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Size</span><span class="params">(rect image.Rectangle)</span></span> (width, height <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(path <span class="type">string</span>)</span></span> (dir, file <span class="type">string</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HourMinSec</span><span class="params">(t time.Time)</span></span> (hour, minute, second <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>虽然良好的命名很重要，但你也不必为每一个返回值都取一个适当的名字。比如，按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息，对于这些类似的惯例，我们不必思考合适的命名，它们都无需解释。</p>
<p><strong>如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CountWordsAndImages does an HTTP GET request for the HTML</span></span><br><span class="line"><span class="comment">// document url and returns the number of words and images in it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountWordsAndImages</span><span class="params">(url <span class="type">string</span>)</span></span> (words, images <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    doc, err := html.Parse(resp.Body)</span><br><span class="line">    resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        err = fmt.Errorf(<span class="string">&quot;parsing HTML: %s&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    words, images = countWordsAndImages(doc)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countWordsAndImages</span><span class="params">(n *html.Node)</span></span> (words, images <span class="type">int</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>按照返回值列表的次序，返回所有的返回值，在上面的例子中，每一个return语句等价于：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> words, images, err</span><br></pre></td></tr></table></figure>

<p>当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。举个例子，如果你没有仔细的审查代码，很难发现前2处return等价于 return 0,0,err（Go会将返回值 words和images在函数体的开始处，根据它们的类型，将其初始化为0），最后一处return等价于 return words, image, nil。基于以上原因，不宜过度使用bare return。</p>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>在Go中有一部分函数总是能成功的运行。比如<code>strings.Contains</code>和<code>strconv.FormatBool</code>函数，对各种可能的输入都做了良好的处理，使得运行时几乎不会失败，除非遇到灾难性的、不可预料的情况，比如运行时的内存溢出。导致这种错误的原因很复杂，难以处理，从错误中恢复的可能性也很低。</p>
<p>还有一部分函数只要输入的参数满足一定条件，也能保证运行成功。比如<code>time.Date</code>函数，该函数将年月日等参数构造成<code>time.Time</code>对象，除非最后一个参数（时区）是nil。这种情况下会引发panic异常。panic是来自被调用函数的信号，表示发生了某个已知的bug。一个良好的程序永远不应该发生panic异常。</p>
<p>对于大部分函数而言，永远无法确保能否成功运行。这是因为错误的原因超出了程序员的控制。举个例子，任何进行I&#x2F;O操作的函数都会面临出现错误的可能，**只有没有经验的程序员才会相信读写操作不会失败，即使是简单的读写。**因此，当本该可信的操作出乎意料的失败后，我们必须弄清楚导致失败的原因。</p>
<p>在Go的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。</p>
<p>**对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。**比如，<code>cache.Lookup</code>失败的唯一原因是key不存在，那么代码可以按照下面的方式组织：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := cache.Lookup(key)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="comment">// ...cache[key] does not exist…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通常，导致失败的原因不止一种，尤其是对I&#x2F;O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。</strong></p>
<p>内置的error是接口类型。我们将在第七章了解接口类型的含义，以及它对错误处理的影响。现在我们只需要明白error类型可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。对于non-nil的error类型，我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(err)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v&quot;</span>, err)</span><br></pre></td></tr></table></figure>

<p><strong>通常，当函数返回non-nil的error时，其他的返回值是未定义的（undefined），这些未定义的返回值应该被忽略。然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。因此对函数的返回值要有清晰的说明，以便于其他人使用。</strong></p>
<p><strong>在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。虽然Go有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误。</strong></p>
<p>Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈跟踪信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。</p>
<p>正因此，Go使用控制流机制（如if和return）处理错误，这使得编码人员能更多的关注错误处理。</p>
<h3 id="错误处理策略"><a href="#错误处理策略" class="headerlink" title="错误处理策略"></a>错误处理策略</h3><p><strong>当一次函数调用返回错误时，调用者应该选择合适的方式处理错误。根据情况的不同，有很多处理方式，让我们来看看常用的5种方式。</strong></p>
<p><strong>第1种错误处理策略：最常用的方式是传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。</strong> 下面，我们以5.3节的findLinks函数作为例子。如果findLinks对<code>http.Get</code>的调用失败，findLinks会直接将这个HTTP错误返回给调用者：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对<code>html.Parse</code>的调用失败时，findLinks不会直接返回<code>html.Parse</code>的错误，因为缺少两条重要信息：1、发生错误时的解析器（html parser）；2、发生错误的url。因此，findLinks构造了一个新的错误信息，既包含了这两项，也包括了底层的解析出错的信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">doc, err := html.Parse(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;parsing %s as HTML: %v&quot;</span>, url,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**<code>fmt.Errorf</code>函数使用<code>fmt.Sprintf</code>格式化错误信息并返回。我们使用该函数添加额外的前缀上下文信息到原始错误信息。**当错误最终由main函数处理时，错误信息应提供清晰的从原因到后果的因果链，就像美国宇航局事故调查时做的那样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">genesis: crashed: no parachute: G-switch failed: bad relay orientation</span><br></pre></td></tr></table></figure>

<p>由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。最终的错误信息可能很长，我们可以通过类似grep的工具处理错误信息（译者注：grep是一种文本搜索工具）。</p>
<p>编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。</p>
<p>以<code>os</code>包为例，<code>os</code>包确保文件操作（如<code>os.Open</code>、<code>Read</code>、<code>Write</code>、<code>Close</code>）返回的每个错误的描述不仅仅包含错误的原因（如无权限，文件目录不存在）也包含文件名，这样调用者在构造新的错误信息时无需再添加这些信息。</p>
<p>一般而言，被调用函数<code>f(x)</code>会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者，调用者需要添加一些错误信息中不包含的信息，比如添加<code>url</code>到<code>html.Parse</code>返回的错误中。</p>
<p><strong>第2种错误处理策略：如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。</strong> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WaitForServer attempts to contact the server of a URL.</span></span><br><span class="line"><span class="comment">// It tries for one minute using exponential back-off.</span></span><br><span class="line"><span class="comment">// It reports an error if all attempts fail.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WaitForServer</span><span class="params">(url <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timeout = <span class="number">1</span> * time.Minute</span><br><span class="line">    deadline := time.Now().Add(timeout)</span><br><span class="line">    <span class="keyword">for</span> tries := <span class="number">0</span>; time.Now().Before(deadline); tries++ &#123;</span><br><span class="line">        _, err := http.Head(url)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// success</span></span><br><span class="line">        &#125;</span><br><span class="line">        log.Printf(<span class="string">&quot;server not responding (%s);retrying…&quot;</span>, err)</span><br><span class="line">        time.Sleep(time.Second &lt;&lt; <span class="type">uint</span>(tries)) <span class="comment">// exponential back-off</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;server %s failed to respond after %s&quot;</span>, url, timeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第3种错误处理策略： 如果错误发生后，程序无法继续运行，则输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (In function main.)</span></span><br><span class="line"><span class="keyword">if</span> err := WaitForServer(url); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintf(os.Stderr, <span class="string">&quot;Site is down: %v\n&quot;</span>, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>log.Fatalf</code>可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := WaitForServer(url); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;Site is down: %v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>长时间运行的服务器常采用默认的时间格式，而交互式工具很少采用包含如此多信息的格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2006/01/02 15:04:05 Site is down: no such domain:</span><br><span class="line">bad.gopl.io</span><br></pre></td></tr></table></figure>

<p>我们可以设置log的前缀信息屏蔽时间信息，一般而言，前缀信息会被设置成命令名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">log.SetPrefix(<span class="string">&quot;wait: &quot;</span>)</span><br><span class="line">log.SetFlags(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>第4种错误处理策略：有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。</strong> 我们可以通过log包提供函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;ping failed: %v; networking disabled&quot;</span>,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者标准错误流输出错误信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintf(os.Stderr, <span class="string">&quot;ping failed: %v; networking disabled\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>log包中的所有函数会为没有换行符的字符串增加换行符。</p>
<p><strong>第5种错误处理策略：我们可以直接忽略掉错误。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dir, err := ioutil.TempDir(<span class="string">&quot;&quot;</span>, <span class="string">&quot;scratch&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create temp dir: %v&quot;</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...use temp dir…</span></span><br><span class="line">os.RemoveAll(dir) <span class="comment">// ignore errors; $TMPDIR is cleaned periodically</span></span><br></pre></td></tr></table></figure>

<p>尽管<code>os.RemoveAll</code>会失败，但上面的例子并没有做错误处理。这是因为操作系统会定期的清理临时目录。正因如此，虽然程序没有处理错误，但程序的逻辑不会因此受到影响。我们应该在每次函数调用后，都养成考虑错误处理的习惯，当你决定忽略某个错误时，你应该清晰地写下你的意图。</p>
<p><strong>在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。</strong></p>
<h3 id="文件结尾错误（EOF）"><a href="#文件结尾错误（EOF）" class="headerlink" title="文件结尾错误（EOF）"></a>文件结尾错误（EOF）</h3><p>函数经常会返回多种错误，这对终端用户来说可能会很有趣，但对程序而言，这使得情况变得复杂。很多时候，程序必须根据错误类型，作出不同的响应。让我们考虑这样一个例子：从文件中读取n个字节。如果n等于文件的长度，读取过程的任何错误都表示失败。如果n小于文件的长度，调用者会重复的读取固定大小的数据直到文件结束。这会导致调用者必须分别处理由文件结束引起的各种错误。基于这样的原因，<code>io</code>包保证任何由文件结束引起的读取失败都返回同一个错误——<code>io.EOF</code>，该错误在<code>io</code>包中定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EOF is the error returned by Read when no more input is available.</span></span><br><span class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">&quot;EOF&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>调用者只需通过简单的比较，就可以检测出这个错误。下面的例子展示了如何从标准输入中读取字符，以及判断文件结束。（4.3的chartcount程序展示了更加复杂的代码）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">in := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    r, _, err := in.ReadRune()</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// finished reading</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read failed:%v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...use r…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为文件结束这种错误不需要更多的描述，所以<code>io.EOF</code>有固定的错误信息——“EOF”。对于其他错误，我们可能需要在错误信息中描述错误的类型和数量，这使得我们不能像<code>io.EOF</code>一样采用固定的错误信息。</p>
<h2 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h2><p>**在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。**例子如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> n * n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">negative</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> -n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">product</span><span class="params">(m, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> m * n &#125;</span><br><span class="line"></span><br><span class="line">f := square</span><br><span class="line">fmt.Println(f(<span class="number">3</span>)) <span class="comment">// &quot;9&quot;</span></span><br><span class="line"></span><br><span class="line">f = negative</span><br><span class="line">fmt.Println(f(<span class="number">3</span>))     <span class="comment">// &quot;-3&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f) <span class="comment">// &quot;func(int) int&quot;</span></span><br><span class="line"></span><br><span class="line">f = product <span class="comment">// compile error: can&#x27;t assign func(int, int) int to func(int) int</span></span><br></pre></td></tr></table></figure>

<p><strong>函数类型的零值是nil。调用值为nil的函数值会引起panic错误：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">f(<span class="number">3</span>) <span class="comment">// 此处f的值为nil, 会引起panic错误</span></span><br></pre></td></tr></table></figure>

<p>函数值可以与nil比较：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">  f(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但是函数值之间是不可比较的，也不能用函数值作为map的key。</strong></p>
<p>函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为。标准库中包含许多这样的例子。下面的代码展示了如何使用这个技巧。<code>strings.Map</code>对字符串中的每个字符调用<code>add1</code>函数，并将每个<code>add1</code>函数的返回值组成一个新的字符串返回给调用者。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">rune</span> &#123; <span class="keyword">return</span> r + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">&quot;HAL-9000&quot;</span>)) <span class="comment">// &quot;IBM.:111&quot;</span></span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">&quot;VMS&quot;</span>))      <span class="comment">// &quot;WNT&quot;</span></span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">&quot;Admix&quot;</span>))    <span class="comment">// &quot;Benjy&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p><strong>拥有函数名的函数只能在包级语法块中被声明，我们可以使用函数字面量（function literal）来绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别在于<code>func</code>关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数（anonymous function）。</strong></p>
<p><strong>函数字面量允许我们在使用函数时，再定义它。通过这种技巧，我们可以改写之前对<code>strings.Map</code>的调用：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Map(<span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">rune</span> &#123; <span class="keyword">return</span> r + <span class="number">1</span> &#125;, <span class="string">&quot;HAL-9000&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量，如下例所示：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// squares返回一个匿名函数。</span></span><br><span class="line"><span class="comment">// 该匿名函数每次被调用时都会返回下一个数的平方。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        x++</span><br><span class="line">        <span class="keyword">return</span> x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := squares()</span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;4&quot;</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;9&quot;</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;16&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数squares返回另一个类型为 <code>func() int</code> 的函数。对squares的一次调用会生成一个局部变量x并返回一个匿名函数。每次调用匿名函数时，该函数都会先使x的值加1，再返回x的平方。第二次调用squares时，会生成第二个x变量，并返回一个新的匿名函数。新匿名函数操作的是第二个x变量。</p>
<p><strong>squares的例子证明，函数值不仅仅是一串代码，还记录了状态。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。</strong></p>
<p>通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。</p>
<h3 id="警告：捕获迭代变量"><a href="#警告：捕获迭代变量" class="headerlink" title="警告：捕获迭代变量"></a>警告：捕获迭代变量</h3><p>本节，将介绍Go词法作用域的一个陷阱。请务必仔细的阅读，弄清楚发生问题的原因。即使是经验丰富的程序员也会在这个问题上犯错误。</p>
<p>考虑这样一个问题：你被要求首先创建一些目录，再将目录删除。在下面的例子中我们用函数值来完成删除操作。下面的示例代码需要引入<code>os</code>包。为了使代码简单，我们忽略了所有的异常处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    dir := d <span class="comment">// <span class="doctag">NOTE:</span> necessary!</span></span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>) <span class="comment">// creates parent directories too</span></span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...do some work…</span></span><br><span class="line"><span class="keyword">for</span> _, rmdir := <span class="keyword">range</span> rmdirs &#123;</span><br><span class="line">    rmdir() <span class="comment">// clean up</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>你可能会感到困惑，为什么要在循环体中用循环变量<code>d</code>赋值一个新的局部变量，而不是像下面的代码一样直接使用循环变量<code>dir</code>。&#x3D;&#x3D;需要注意，下面的代码是错误的。&#x3D;&#x3D;</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>)</span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir) <span class="comment">// <span class="doctag">NOTE:</span> incorrect!</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题的原因在于循环变量的作用域。在上面的程序中，for循环语句引入了新的词法块，循环变量<code>dir</code>在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。&#x3D;&#x3D;需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。&#x3D;&#x3D;以<code>dir</code>为例，后续的迭代会不断更新<code>dir</code>的值，当删除操作执行时，for循环已完成，<code>dir</code>中存储的值等于最后一次迭代的值。这意味着，每次对<code>os.RemoveAll</code>的调用删除的都是相同的目录。</strong></p>
<p>通常，为了解决这个问题，我们会引入一个与循环变量同名的局部变量，作为循环变量的副本。比如下面的变量<code>dir</code>，虽然这看起来很奇怪，但却很有用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    dir := dir <span class="comment">// declares inner dir, initialized to outer dir</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题不仅存在基于range的循环，在下面的例子中，对循环变量<code>i</code>的使用也存在同样的问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">dirs := tempDirs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dirs); i++ &#123;</span><br><span class="line">    os.MkdirAll(dirs[i], <span class="number">0755</span>) <span class="comment">// OK</span></span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dirs[i]) <span class="comment">// <span class="doctag">NOTE:</span> incorrect!</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你使用go语句（第八章）或者defer语句（5.8节）会经常遇到此类问题。<strong>这不是go或defer本身导致的，而是因为它们都会等待循环结束后，再执行函数值。</strong></p>
<p>下例更加清楚的展示几种对range语句迭代变量引用方式的不同：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="type">string</span>&#123;<span class="string">&quot;yoyo&quot;</span>, <span class="string">&quot;haha&quot;</span>, <span class="string">&quot;lol&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> arr []<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;1:&quot;</span>, v) <span class="comment">// 匿名函数外</span></span><br><span class="line">		fmt.Println(<span class="function"><span class="keyword">func</span><span class="params">(val <span class="type">string</span>)</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;2:&quot;</span> + val &#125;(v)) <span class="comment">// 通过传参给匿名函数</span></span><br><span class="line">		fmt.Println(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;3:&quot;</span> + v &#125;()) <span class="comment">// 在闭包中直接引用</span></span><br><span class="line">		arr = <span class="built_in">append</span>(arr, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;4:&quot;</span> + v &#125;) <span class="comment">// 在闭包中直接引用，并延迟执行闭包</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		fmt.Println(f()) <span class="comment">//延迟执行闭包</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: yoyo</span><br><span class="line">2:yoyo</span><br><span class="line">3:yoyo</span><br><span class="line">1: haha</span><br><span class="line">2:haha</span><br><span class="line">3:haha</span><br><span class="line">1: lol</span><br><span class="line">2:lol</span><br><span class="line">3:lol</span><br><span class="line">4:lol</span><br><span class="line">4:lol</span><br><span class="line">4:lol</span><br></pre></td></tr></table></figure>

<p>因为所有闭包引用的是变量迭代<code>v</code>的地址，而每次迭代后，变量<code>v</code>都被重新赋了新值，所以当迭代结束后，闭包中引用的变量<code>v</code>值为最后一次迭代时的值。而所有延迟执行的闭包都输出了<code>v</code>最后一次被赋值的值。</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>**参数数量可变的函数称为 <em>可变参数函数</em> 。**典型的例子就是<code>fmt.Printf</code>和类似函数。<code>Printf</code>首先接收一个必备的参数，之后接收任意个数的后续参数。</p>
<p><strong>在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号<code>...</code>，这表示该函数会接收任意数量的该类型参数。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(vals ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">        total += val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sum</code>函数返回任意个<code>int</code>型参数的和。在函数体中，<code>vals</code>被看作是类型为<code>[] int</code>的切片。<code>sum</code>可以接收任意数量的int型参数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(sum())           <span class="comment">// &quot;0&quot;</span></span><br><span class="line">fmt.Println(sum(<span class="number">3</span>))          <span class="comment">// &quot;3&quot;</span></span><br><span class="line">fmt.Println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调用函数。<strong>如果原始参数已经是切片类型，只需在最后一个参数后加上省略符。</strong> 下面的代码功能与上个例子中最后一条语句相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">values := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(sum(values...)) <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>

<p>虽然在可变参数函数内部，<code>...int</code> 型参数的行为看起来很像切片类型，但实际上，可变参数函数和以切片作为参数的函数是不同的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(...<span class="type">int</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">([]<span class="type">int</span>)</span></span> &#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f) <span class="comment">// &quot;func(...int)&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, g) <span class="comment">// &quot;func([]int)&quot;</span></span><br></pre></td></tr></table></figure>

<p>可变参数函数经常被用于格式化字符串。下面的<code>errorf</code>函数构造了一个以行号开头的，经过格式化的错误信息。函数名的后缀f是一种通用的命名规范，代表该可变参数函数可以接收<code>Printf</code>风格的格式化字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errorf</span><span class="params">(linenum <span class="type">int</span>, format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(os.Stderr, <span class="string">&quot;Line %d: &quot;</span>, linenum)</span><br><span class="line">    fmt.Fprintf(os.Stderr, format, args...)</span><br><span class="line">    fmt.Fprintln(os.Stderr)</span><br><span class="line">&#125;</span><br><span class="line">linenum, name := <span class="number">12</span>, <span class="string">&quot;count&quot;</span></span><br><span class="line">errorf(linenum, <span class="string">&quot;undefined: %s&quot;</span>, name) <span class="comment">// &quot;Line 12: undefined: count&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>interface&#123;&#125;</code>表示函数的最后一个参数可以接收任意类型。</p>
<p><strong>练习5.15：</strong> 编写类似<code>sum</code>的可变参数函数<code>max</code>和<code>min</code>。考虑不传参时，<code>max</code>和<code>min</code>该如何处理，再编写至少接收1个参数的版本。</p>
<p>**练习5.16：**编写多参数版本的<code>strings.Join</code>。</p>
<p>**练习5.17：**编写多参数版本的<code>ElementsByTagName</code>，函数接收一个HTML结点树以及任意数量的标签名，返回与这些标签名匹配的所有元素。下面给出了2个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ElementsByTagName</span><span class="params">(doc *html.Node, name...<span class="type">string</span>)</span></span> []*html.Node</span><br><span class="line">images := ElementsByTagName(doc, <span class="string">&quot;img&quot;</span>)</span><br><span class="line">headings := ElementsByTagName(doc, <span class="string">&quot;h1&quot;</span>, <span class="string">&quot;h2&quot;</span>, <span class="string">&quot;h3&quot;</span>, <span class="string">&quot;h4&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Deferred函数"><a href="#Deferred函数" class="headerlink" title="Deferred函数"></a>Deferred函数</h2><p>在findLinks的例子中，我们用<code>http.Get</code>的输出作为<code>html.Parse</code>的输入。只有url的内容的确是HTML格式的，<code>html.Parse</code>才可以正常工作，但实际上，url指向的内容很丰富，可能是图片，纯文本或是其他。将这些格式的内容传递给<code>html.parse</code>，会产生不良后果。</p>
<p>下面的例子获取HTML页面并输出页面的标题。title函数会检查服务器返回的Content-Type字段，如果发现页面不是HTML，将终止函数运行，返回错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">title</span><span class="params">(url <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check Content-Type is HTML (e.g., &quot;text/html;charset=utf-8&quot;).</span></span><br><span class="line">    ct := resp.Header.Get(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> ct != <span class="string">&quot;text/html&quot;</span> &amp;&amp; !strings.HasPrefix(ct,<span class="string">&quot;text/html;&quot;</span>) &#123;</span><br><span class="line">        resp.Body.Close()</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s has type %s, not text/html&quot;</span>,url, ct)</span><br><span class="line">    &#125;</span><br><span class="line">    doc, err := html.Parse(resp.Body)</span><br><span class="line">    resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;parsing %s as HTML: %v&quot;</span>, url,err)</span><br><span class="line">    &#125;</span><br><span class="line">    visitNode := <span class="function"><span class="keyword">func</span><span class="params">(n *html.Node)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="string">&quot;title&quot;</span>&amp;&amp;n.FirstChild != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(n.FirstChild.Data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    forEachNode(doc, visitNode, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面展示了运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch5/title1</span><br><span class="line">$ ./title1 http://gopl.io</span><br><span class="line">The Go Programming Language</span><br><span class="line">$ ./title1 https://golang.org/doc/effective_go.html</span><br><span class="line">Effective Go - The Go Programming Language</span><br><span class="line">$ ./title1 https://golang.org/doc/gopher/frontpage.png</span><br><span class="line">title1: https://golang.org/doc/gopher/frontpage.png has type image/png, not text/html</span><br></pre></td></tr></table></figure>

<p><strong><code>resp.Body.close</code>调用了多次，这是为了确保title在所有执行路径下（即使函数运行失败）都关闭了网络连接。随着函数变得复杂，需要处理的错误也变多，维护清理逻辑变得越来越困难。而Go语言独有的defer机制可以让事情变得简单。</strong></p>
<p><strong>你只需要在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。</strong></p>
<p><strong>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。</strong> 在下面的代码中，一条defer语句替代了之前的所有<code>resp.Body.Close</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">title</span><span class="params">(url <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    ct := resp.Header.Get(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> ct != <span class="string">&quot;text/html&quot;</span> &amp;&amp; !strings.HasPrefix(ct,<span class="string">&quot;text/html;&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s has type %s, not text/html&quot;</span>,url, ct)</span><br><span class="line">    &#125;</span><br><span class="line">    doc, err := html.Parse(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;parsing %s as HTML: %v&quot;</span>, url,err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...print doc&#x27;s title element…</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在处理其他资源时，也可以采用defer机制，比如对文件的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ioutil</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="keyword">return</span> ReadAll(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或是处理互斥锁：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookup</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调试复杂程序时，defer机制也常被用于记录何时进入和退出函数。下例中的<code>bigSlowOperation</code>函数，直接调用<code>trace</code>记录函数的被调情况。<code>bigSlowOperation</code>被调时，<code>trace</code>会返回一个函数值，该函数值会在<code>bigSlowOperation</code>退出时被调用。通过这种方式， 我们可以只通过一条语句控制函数的入口和所有的出口，甚至可以记录函数的运行时间，如例子中的<code>start</code>。需要注意一点：不要忘记defer语句后的圆括号，否则本该在进入时执行的操作会在退出时执行，而本该在退出时执行的，永远不会被执行。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bigSlowOperation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> trace(<span class="string">&quot;bigSlowOperation&quot;</span>)() <span class="comment">// don&#x27;t forget the extra parentheses</span></span><br><span class="line">    <span class="comment">// ...lots of work…</span></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second) <span class="comment">// simulate slow operation by sleeping</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(msg <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    log.Printf(<span class="string">&quot;enter %s&quot;</span>, msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">        log.Printf(<span class="string">&quot;exit %s (%s)&quot;</span>, msg,time.Since(start)) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一次<code>bigSlowOperation</code>被调用，程序都会记录函数的进入，退出，持续时间。（我们用<code>time.Sleep</code>模拟一个耗时的操作）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build gopl.io/ch5/trace</span><br><span class="line">$ ./trace</span><br><span class="line"><span class="number">2015</span>/<span class="number">11</span>/<span class="number">18</span> <span class="number">09</span>:<span class="number">53</span>:<span class="number">26</span> enter bigSlowOperation</span><br><span class="line"><span class="number">2015</span>/<span class="number">11</span>/<span class="number">18</span> <span class="number">09</span>:<span class="number">53</span>:<span class="number">36</span> exit bigSlowOperation (<span class="number">10.000589217</span>s)</span><br></pre></td></tr></table></figure>

<p>我们知道，defer语句中的函数会在return语句更新返回值变量后再执行，又因为在函数中定义的匿名函数可以访问该函数包括返回值变量在内的所有变量，所以，对匿名函数采用defer机制，可以使其观察函数的返回值。</p>
<p>我们只需要首先命名double的返回值，再增加defer语句，我们就可以在double每次被调用时，输出参数以及返回值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(x <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">&quot;double(%d) = %d\n&quot;</span>, x,result) &#125;()</span><br><span class="line">    <span class="keyword">return</span> x + x</span><br><span class="line">&#125;</span><br><span class="line">_ = double(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &quot;double(4) = 8&quot;</span></span><br></pre></td></tr></table></figure>

<p>可能double函数过于简单，看不出这个小技巧的作用，但对于有许多return语句的函数而言，这个技巧很有用。</p>
<p><strong>被延迟执行的匿名函数甚至可以修改函数返回给调用者的返回值：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triple</span><span class="params">(x <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; result += x &#125;()</span><br><span class="line">    <span class="keyword">return</span> double(x)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(triple(<span class="number">4</span>)) <span class="comment">// &quot;12&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行。下面的代码会导致系统的文件描述符耗尽，因为在所有文件都被处理之前，没有文件会被关闭。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close() <span class="comment">// <span class="doctag">NOTE:</span> risky; could run out of file descriptors</span></span><br><span class="line">    <span class="comment">// ...process f…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种解决方法是将循环体中的defer语句移至另外一个函数。在每次循环时，调用这个函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">    <span class="keyword">if</span> err := doFile(filename); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doFile</span><span class="params">(filename <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="comment">// ...process f…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码是fetch（1.5节）的改进版，我们将http响应信息写入本地文件而不是从标准输出流输出。我们通过<code>path.Base</code>提出url路径的最后一段作为文件名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fetch downloads the URL and returns the</span></span><br><span class="line"><span class="comment">// name and length of the local file.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(url <span class="type">string</span>)</span></span> (filename <span class="type">string</span>, n <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    local := path.Base(resp.Request.URL.Path)</span><br><span class="line">    <span class="keyword">if</span> local == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">        local = <span class="string">&quot;index.html&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    f, err := os.Create(local)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    n, err = io.Copy(f, resp.Body)</span><br><span class="line">    <span class="comment">// Close file, but prefer error from Copy, if any.</span></span><br><span class="line">    <span class="keyword">if</span> closeErr := f.Close(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        err = closeErr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> local, n, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>resp.Body.Close</code>延迟调用我们已经见过了，在此不做解释。上例中，通过<code>os.Create</code>打开文件进行写入，在关闭文件时，我们没有对<code>f.close</code>采用defer机制，因为这会产生一些微妙的错误。许多文件系统，尤其是NFS，写入文件时发生的错误会被延迟到文件关闭时反馈。如果没有检查文件关闭时的反馈信息，可能会导致数据丢失，而我们还误以为写入操作成功。如果<code>io.Copy</code>和<code>f.close</code>都失败了，我们倾向于将<code>io.Copy</code>的错误信息反馈给调用者，因为它先于<code>f.close</code>发生，更有可能接近问题的本质。</p>
<p>下面例子更加清楚的展示了defer的机制：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  deferDemo1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;enter&quot;</span>)</span><br><span class="line">	n := <span class="number">1</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;n =&quot;</span>, n)</span><br><span class="line">	<span class="keyword">defer</span> yoyo(n)</span><br><span class="line">	n = <span class="number">2</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;n =&quot;</span>, n)</span><br><span class="line">	fmt.Println(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">yoyo</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;yoyo n =&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过下面输出可以发现，defer在调用时取得n等于1的值，之后n再次被赋值对defer也没有影响了，但等到函数<code>deferDemo1</code>退出后，函数<code>yoyo</code>才真正执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enter</span><br><span class="line">n = 1</span><br><span class="line">n = 2</span><br><span class="line">exit</span><br><span class="line">yoyo n = 1</span><br></pre></td></tr></table></figure>

<p>下面例子更进一步：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  deferDemo2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;enter&quot;</span>)</span><br><span class="line">	n := <span class="number">1</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;n =&quot;</span>, n)</span><br><span class="line">	<span class="keyword">defer</span> haha(n)()</span><br><span class="line">	n = <span class="number">2</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;n =&quot;</span>, n)</span><br><span class="line">	fmt.Println(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">haha</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;haha n =&quot;</span>, n)</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;lol n + 2 =&quot;</span>, n+<span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从下面输出结果可以看出，<code>defer haha(n)</code>在取得<code>n</code>等于1之后立即被运行，并输出结果，但是其返回的匿名函数在函数<code>deferDemo2</code>退出后才执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enter</span><br><span class="line">n = 1</span><br><span class="line">haha n = 1</span><br><span class="line">n = 2</span><br><span class="line">exit</span><br><span class="line">lol n + 2 = 3</span><br></pre></td></tr></table></figure>

<h2 id="Panic异常"><a href="#Panic异常" class="headerlink" title="Panic异常"></a>Panic异常</h2><p><strong>Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。</strong></p>
<p>**一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。panic value通常是某种错误信息。对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。**通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据。因此，在我们填写问题报告时，一般会将panic异常和日志信息一并记录。</p>
<p>**不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用panic。**比如，当程序到达了某条逻辑上不可能到达的路径：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> s := suit(drawCard()); s &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Spades&quot;</span>:                                <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Hearts&quot;</span>:                                <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Diamonds&quot;</span>:                              <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Clubs&quot;</span>:                                 <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;invalid suit %q&quot;</span>, s)) <span class="comment">// Joker?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>断言函数必须满足的前置条件是明智的做法，但这很容易被滥用。除非你能提供更多的错误信息，或者能更快速的发现错误，否则不需要使用断言，编译器在运行时会帮你检查代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reset</span><span class="params">(x *Buffer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;x is nil&quot;</span>) <span class="comment">// unnecessary!</span></span><br><span class="line">    &#125;</span><br><span class="line">    x.elements = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然Go的panic机制类似于其他语言的异常，但panic的适用场景有一些不同。由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致。勤奋的程序员认为任何崩溃都表明代码中存在漏洞，所以对于大部分漏洞，我们应该使用Go提供的错误机制，而不是panic，尽量避免程序的崩溃。在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的I&#x2F;O操作都应该被优雅的处理，最好的处理方式，就是使用Go的错误机制。</p>
<p>考虑<code>regexp.Compile</code>函数，该函数将正则表达式编译成有效的可匹配格式。当输入的正则表达式不合法时，该函数会返回一个错误。当调用者明确的知道正确的输入不会引起函数错误时，要求调用者检查这个错误是不必要和累赘的。我们应该假设函数的输入一直合法，就如前面的断言一样：当调用者输入了不应该出现的输入时，触发panic异常。</p>
<p>在程序源码中，大多数正则表达式是字符串字面值（string literals），因此<code>regexp</code>包提供了包装函数<code>regexp.MustCompile</code>检查输入的合法性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> regexp</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(expr <span class="type">string</span>)</span></span> (*Regexp, <span class="type">error</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MustCompile</span><span class="params">(expr <span class="type">string</span>)</span></span> *Regexp &#123;</span><br><span class="line">    re, err := Compile(expr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包装函数使得调用者可以便捷的用一个编译后的正则表达式为包级别的变量赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> httpSchemeRE = regexp.MustCompile(<span class="string">`^https?:`</span>) <span class="comment">//&quot;http:&quot; or &quot;https:&quot;</span></span><br></pre></td></tr></table></figure>

<p>显然，<code>MustCompile</code>不能接收不合法的输入。函数名中的Must前缀是一种针对此类函数的命名约定，比如<code>template.Must</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;f(%d)\n&quot;</span>, x+<span class="number">0</span>/x) <span class="comment">// panics if x == 0</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;defer %d\n&quot;</span>, x)</span><br><span class="line">    f(x - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中的运行输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(3)</span><br><span class="line">f(2)</span><br><span class="line">f(1)</span><br><span class="line">defer 1</span><br><span class="line">defer 2</span><br><span class="line">defer 3</span><br></pre></td></tr></table></figure>

<p>当<code>f(0)</code>被调用时，发生panic异常，之前被延迟执行的3个<code>fmt.Printf</code>被调用。程序中断执行后，panic信息和堆栈信息会被输出（下面是简化的输出）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">panic: runtime error: integer divide by zero</span><br><span class="line">main.f(0)</span><br><span class="line">src/gopl.io/ch5/defer1/defer.go:14</span><br><span class="line">main.f(1)</span><br><span class="line">src/gopl.io/ch5/defer1/defer.go:16</span><br><span class="line">main.f(2)</span><br><span class="line">src/gopl.io/ch5/defer1/defer.go:16</span><br><span class="line">main.f(3)</span><br><span class="line">src/gopl.io/ch5/defer1/defer.go:16</span><br><span class="line">main.main()</span><br><span class="line">src/gopl.io/ch5/defer1/defer.go:10</span><br></pre></td></tr></table></figure>

<p>我们在下一节将看到，如何使程序从panic异常中恢复，阻止程序的崩溃。</p>
<p>为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在<code>main</code>函数中延迟调用<code>printStack</code>输出堆栈信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> printStack()</span><br><span class="line">    f(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">4096</span>]<span class="type">byte</span></span><br><span class="line">    n := runtime.Stack(buf[:], <span class="literal">false</span>)</span><br><span class="line">    os.Stdout.Write(buf[:n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>printStack</code>的简化输出如下（下面只是<code>printStack</code>的输出，不包括panic的日志信息）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goroutine 1 [running]:</span><br><span class="line">main.printStack()</span><br><span class="line">src/gopl.io/ch5/defer2/defer.go:20</span><br><span class="line">main.f(0)</span><br><span class="line">src/gopl.io/ch5/defer2/defer.go:27</span><br><span class="line">main.f(1)</span><br><span class="line">src/gopl.io/ch5/defer2/defer.go:29</span><br><span class="line">main.f(2)</span><br><span class="line">src/gopl.io/ch5/defer2/defer.go:29</span><br><span class="line">main.f(3)</span><br><span class="line">src/gopl.io/ch5/defer2/defer.go:29</span><br><span class="line">main.main()</span><br><span class="line">src/gopl.io/ch5/defer2/defer.go:15</span><br></pre></td></tr></table></figure>

<p>将panic机制类比其他语言异常机制的读者可能会惊讶，<code>runtime.Stack</code>为何能输出已经被释放函数的信息？<strong>在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。</strong></p>
<h2 id="Recover捕获异常"><a href="#Recover捕获异常" class="headerlink" title="Recover捕获异常"></a>Recover捕获异常</h2><p>通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭；如果不做任何处理，会使得客户端一直处于等待状态。如果web服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。</p>
<p><strong>如果在deferred函数中调用了内置函数recover，并且定义该defer语句所在的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。</strong></p>
<p>让我们以语言解析器为例，说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(input <span class="type">string</span>)</span></span> (s *Syntax, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">&quot;internal error: %v&quot;</span>, p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// ...parser...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>deferred函数帮助Parse从panic中恢复。在deferred函数内部，panic value被附加到错误信息中；并用err变量接收错误信息，返回给调用者。我们也可以通过调用<code>runtime.Stack</code>往错误信息中添加完整的堆栈调用信息。</p>
<p><strong>不加区分的恢复所有的panic异常，不是可取的做法；因为在panic之后，无法保证包级变量的状态仍然和我们预期一致。比如，对数据结构的一次重要更新没有被完整完成、文件或者网络连接没有被关闭、获得的锁没有被释放。此外，如果写日志时产生的panic被不加区分的恢复，可能会导致漏洞被忽略。</strong></p>
<p>虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。</p>
<p>有时我们很难完全遵循规范，举个例子，<code>net/http</code>包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。</p>
<p>基于以上原因，安全的做法是有选择性的recover。换句话说，只恢复应该被恢复的panic异常，此外，这些异常所占的比例应该尽可能的低。为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为error处理，如果不是，则按照正常的panic进行处理（在下面的例子中，我们会看到这种方式）。</p>
<p>下面的例子是title函数的变形，如果HTML页面包含多个<code>&lt;title&gt;</code>，该函数会给调用者返回一个错误（error）。在soleTitle内部处理时，如果检测到有多个<code>&lt;title&gt;</code>，会调用panic，阻止函数继续递归，并将特殊类型bailout作为panic的参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// soleTitle returns the text of the first non-empty title element</span></span><br><span class="line"><span class="comment">// in doc, and an error if there was not exactly one.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">soleTitle</span><span class="params">(doc *html.Node)</span></span> (title <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">type</span> bailout <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> p := <span class="built_in">recover</span>(); p &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:       <span class="comment">// no panic</span></span><br><span class="line">        <span class="keyword">case</span> bailout&#123;&#125;: <span class="comment">// &quot;expected&quot; panic</span></span><br><span class="line">            err = fmt.Errorf(<span class="string">&quot;multiple title elements&quot;</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">panic</span>(p) <span class="comment">// unexpected panic; carry on panicking</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// Bail out of recursion if we find more than one nonempty title.</span></span><br><span class="line">    forEachNode(doc, <span class="function"><span class="keyword">func</span><span class="params">(n *html.Node)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="string">&quot;title&quot;</span> &amp;&amp;</span><br><span class="line">            n.FirstChild != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> title != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(bailout&#123;&#125;) <span class="comment">// multiple title elements</span></span><br><span class="line">            &#125;</span><br><span class="line">            title = n.FirstChild.Data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> title == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;no title element&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> title, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，deferred函数调用recover，并检查panic value。当panic value是<code>bailout&#123;&#125;</code>类型时，deferred函数生成一个error返回给调用者。当panic value是其他non-nil值时，表示发生了未知的panic异常，deferred函数将调用panic函数并将当前的panic value作为参数传入；此时，等同于recover没有做任何操作。（请注意：在例子中，对可预期的错误采用了panic，这违反了之前的建议，我们在此只是想向读者演示这种机制。）</p>
<p>有些情况下，我们无法恢复。某些致命错误会导致Go在运行时终止程序，如内存不足。</p>
<p><strong>练习5.19：</strong> 使用panic和recover编写一个不包含return语句但能返回一个非零值的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := noReturn()</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noReturn</span><span class="params">()</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        p := <span class="built_in">recover</span>()</span><br><span class="line">        result = p.(<span class="type">int</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="number">42</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想知道上面代码的原理，可以观察一下下面代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	</span><br><span class="line">	s := deferDemo3()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T %q&quot;</span>, s, s) <span class="comment">// string &quot;set in defer&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferDemo3</span><span class="params">()</span></span> (s <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s = <span class="string">&quot;set in defer&quot;</span> <span class="comment">// 可以在defer调用中对返回值进行修改</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;on return&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看到，我们可以在defer调用中对命名返回值进行修改。因此，再观察下面代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := causePanic()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T %q&quot;</span>, s, s) <span class="comment">// string &quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">causePanic</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;recover from panic: %s\n&quot;</span>, p)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;oops!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;after panic&quot;</span> <span class="comment">// 永远不会执行到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">recover from panic: oops!</span><br><span class="line">string &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>虽然函数<code>causePanic</code>的return语句因为panic导致永远无法达到，但是由于函数定义了返回值，且自动被初始化为字符串零值，所以<code>main</code>函数中变量<code>s</code>依然获得了返回值<code>&quot;&quot;</code>。</p>
<p>因此，如果返回值是命名返回值（返回值有名字），则可以在panic终止了函数<code>causePanic</code>继续运行后，同样可以在defer调用中对返回值进行修改，前提是必须是返回值必须有名字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := causePanic()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T %q&quot;</span>, s, s) <span class="comment">// string &quot;set in defer&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">causePanic</span><span class="params">()</span></span> (s <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;recover from panic: %s\n&quot;</span>, p)</span><br><span class="line">      s = <span class="string">&quot;set in defer&quot;</span> <span class="comment">// 在defer中对返回值s进行修改</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;oops!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;after panic&quot;</span> <span class="comment">// 永远不会执行到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">recover from panic: oops!</span><br><span class="line">string &quot;set in defer&quot;</span><br></pre></td></tr></table></figure>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h2><p>在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。</p>
<p>下面来写我们第一个方法的例子，这个例子在<code>package geometry</code>下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> geometry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traditional function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distance</span><span class="params">(p, q Point)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// same thing, but as a method of the Point type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码里那个附加的参数p，叫做<strong>方法的接收器（receiver）</strong>，早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。</p>
<p><strong>在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。这里的建议是可以使用其类型的第一个字母，比如这里使用了Point的首字母p。</strong></p>
<p>**在方法调用过程中，接收器参数一般会在方法名之前出现。这和方法声明是一样的，都是接收器参数在方法名字之前。**下面是例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(Distance(p, q)) <span class="comment">// &quot;5&quot;, function call</span></span><br><span class="line">fmt.Println(p.Distance(q))  <span class="comment">// &quot;5&quot;, method call</span></span><br></pre></td></tr></table></figure>

<p>可以看到，上面的两个函数调用都是Distance，但是却没有发生冲突。第一个Distance的调用实际上用的是包级别的函数<code>geometry.Distance</code>，而第二个则是使用刚刚声明的Point，调用的是Point类下声明的<code>Point.Distance</code>方法。</p>
<p>这种<code>p.Distance</code>的表达式叫做 <strong>选择器</strong>，因为他会选择合适的对应p这个对象的Distance方法来执行。选择器也会被用来选择一个struct类型的字段，比如<code>p.X</code>。<strong>由于方法和字段都是在同一命名空间，所以如果我们在这里声明一个<code>X</code>方法的话，编译器会报错，因为在调用<code>p.X</code>时会有歧义。</strong></p>
<p>因为每种类型都有其方法的命名空间，我们在用Distance这个名字的时候，不同的Distance调用指向了不同类型里的Distance方法。让我们来定义一个Path类型，这个Path代表一个线段的集合，并且也给这个Path定义一个叫Distance的方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Path is a journey connecting the points with straight lines.</span></span><br><span class="line"><span class="keyword">type</span> Path []Point</span><br><span class="line"><span class="comment">// Distance returns the distance traveled along the path.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path Path)</span></span> Distance() <span class="type">float64</span> &#123;</span><br><span class="line">    sum := <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> path &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            sum += path[i<span class="number">-1</span>].Distance(path[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Path是一个命名的slice类型，而不是Point那样的struct类型，然而我们依然可以为它定义方法。在能够给任意类型定义方法这一点上，Go和很多其它的面向对象的语言不太一样。<strong>因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型（译注：这个例子里，底层类型是指[]Point这个slice，Path就是命名类型）不是指针或者interface。</strong></p>
<p>两个Distance方法有不同的类型。他们两个方法之间没有任何关系，尽管Path的Distance方法会在内部调用<code>Point.Distance</code>方法来计算每个连接邻接点的线段的长度。</p>
<p>让我们来调用一个新方法，计算三角形的周长：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">perim := Path&#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(perim.Distance()) <span class="comment">// &quot;12&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面两个对Distance名字的方法的调用中，编译器会根据方法的名字以及接收器来决定具体调用的是哪一个函数。第一个例子中<code>path[i-1]</code>数组中的类型是Point，因此<code>Point.Distance</code>这个方法被调用；在第二个例子中perim的类型是Path，因此Distance调用的是<code>Path.Distance</code>。</p>
<p>对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名，比如我们这里Point和Path就都有Distance这个名字的方法；所以我们没有必要非在方法名之前加类型名来消除歧义，比如PathDistance。这里我们已经看到了方法比之函数的一些好处：方法名可以简短。当我们在包外调用的时候这种好处就会被放大，因为我们可以使用这个短名字，而可以省略掉包的名字，下面是例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;gopl.io/ch6/geometry&quot;</span></span><br><span class="line"></span><br><span class="line">perim := geometry.Path&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">5</span>, <span class="number">1</span>&#125;, &#123;<span class="number">5</span>, <span class="number">4</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">fmt.Println(geometry.PathDistance(perim)) <span class="comment">// &quot;12&quot;, standalone function</span></span><br><span class="line">fmt.Println(perim.Distance())             <span class="comment">// &quot;12&quot;, method of geometry.Path</span></span><br></pre></td></tr></table></figure>

<h2 id="基于指针对象的方法"><a href="#基于指针对象的方法" class="headerlink" title="基于指针对象的方法"></a>基于指针对象的方法</h2><p><strong>当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。当我们要对接收者变量本身进行修改时，我可以用其指针而不是对象来声明方法：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span></span> ScaleBy(factor <span class="type">float64</span>) &#123;</span><br><span class="line">    p.X *= factor</span><br><span class="line">    p.Y *= factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个方法的名字是<code>(*Point).ScaleBy</code>。这里的括号是必须的；没有括号的话这个表达式可能会被理解为<code>*(Point.ScaleBy)</code>。</strong></p>
<p>在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。我们在这里打破了这个约定只是为了展示一下两种方法的异同而已。</p>
<p><strong>只有类型（如<code>Point</code>）或指向类型的指针（如<code>*Point</code>），才能成为方法声明中的接收器。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，比如下面这个例子：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> P *<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(P)</span></span> f() &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// compile error: invalid receiver type</span></span><br></pre></td></tr></table></figure>

<p>想要调用指针类型方法<code>(*Point).ScaleBy</code>，只要提供一个Point类型的指针即可，像下面这样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">r.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(*r) <span class="comment">// &quot;&#123;2, 4&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>或者这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">pptr := &amp;p</span><br><span class="line">pptr.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p) <span class="comment">// &quot;&#123;2, 4&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>或者这样:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">(&amp;p).ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p) <span class="comment">// &quot;&#123;2, 4&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>不过后面两种方法有些笨拙。幸运的是，go语言本身在这种地方会帮到我们。<strong>如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.ScaleBy(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><strong>编译器会隐式地帮我们用<code>&amp;p</code>去调用<code>ScaleBy</code>这个方法。这种简写方法只适用于“变量”，包括struct里的字段比如<code>p.X</code>，以及array和slice内的元素比如<code>perim[0]</code>。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;.ScaleBy(<span class="number">2</span>) <span class="comment">// compile error: can&#x27;t take address of Point literal</span></span><br></pre></td></tr></table></figure>

<p><strong>我们也可以用一个<code>*Point</code>这样的接收器来调用Point的方法，因为我们可以通过地址来找到这个变量，只要用解引用符号<code>*</code>来取到该变量即可。编译器在这里也会给我们隐式地插入<code>*</code>这个操作符，所以下面这两种写法等价的：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pptr.Distance(q)</span><br><span class="line">(*pptr).Distance(q)</span><br></pre></td></tr></table></figure>

<p><strong>总结：在每一个合法的方法调用表达式中，也就是下面三种情况里的任意一种情况都是可以的：</strong></p>
<p>要么接收器的实际参数和其形式参数是相同的类型，比如两者都是类型T或者都是类型<code>*T</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;.Distance(q) <span class="comment">//  Point</span></span><br><span class="line">pptr.ScaleBy(<span class="number">2</span>)         <span class="comment">// *Point</span></span><br></pre></td></tr></table></figure>

<p>或者接收器实参是类型T，但接收器形参是类型<code>*T</code>，这种情况下编译器会隐式地为我们取变量的地址：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.ScaleBy(<span class="number">2</span>) <span class="comment">// implicit (&amp;p)</span></span><br></pre></td></tr></table></figure>

<p>或者接收器实参是类型<code>*T</code>，形参是类型T。编译器会隐式地为我们解引用，取到指针指向的实际变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pptr.Distance(q) <span class="comment">// implicit (*pptr)</span></span><br></pre></td></tr></table></figure>

<p>如果自定义类型T的所有方法都是用T类型自己来做接收器（而不是<code>*T</code>），那么拷贝这种类型的实例就是安全的；调用他的任何一个方法也就会产生一个值的拷贝。比如<code>time.Duration</code>的这个类型，在调用其方法时就会被全部拷贝一份，包括在作为参数传入函数的时候。但是如果一个方法使用指针作为接收器，你需要避免对其进行拷贝，因为这样可能会破坏掉该类型内部的不变性。比如你对<code>bytes.Buffer</code>对象进行了拷贝，那么可能会引起原始对象和拷贝对象只是别名而已，实际上它们指向的对象是一样的。紧接着对拷贝后的变量进行修改可能会有让你有意外的结果。</p>
<blockquote>
<p> <strong>译注：</strong> 作者这里说的比较绕，其实有两点：</p>
<ol>
<li>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针&#x2F;非指针类型进行调用的，编译器会帮你做类型转换。</li>
<li>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型保存的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。</li>
</ol>
</blockquote>
<h3 id="nil也是一个合法的接收器类型"><a href="#nil也是一个合法的接收器类型" class="headerlink" title="nil也是一个合法的接收器类型"></a><code>nil</code>也是一个合法的接收器类型</h3><p>就像一些函数允许nil指针作为参数一样，方法理论上也可以用nil指针作为其接收器，尤其当nil对于对象来说是合法的零值时，比如map或者slice。在下面的简单int链表的例子里，nil代表的是空链表：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An IntList is a linked list of integers.</span></span><br><span class="line"><span class="comment">// A nil *IntList represents the empty list.</span></span><br><span class="line"><span class="keyword">type</span> IntList <span class="keyword">struct</span> &#123;</span><br><span class="line">    Value <span class="type">int</span></span><br><span class="line">    Tail  *IntList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Sum returns the sum of the list elements.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *IntList)</span></span> Sum() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> list == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.Value + list.Tail.Sum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的，就像我们上面例子里做的这样。</p>
<p>下面是<code>net/url</code>包里Values类型定义的一部分。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> url</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values maps a string key to a list of values.</span></span><br><span class="line"><span class="keyword">type</span> Values <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span></span><br><span class="line"><span class="comment">// Get returns the first value associated with the given key,</span></span><br><span class="line"><span class="comment">// or &quot;&quot; if there are none.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> vs := v[key]; <span class="built_in">len</span>(vs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vs[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add adds the value to key.</span></span><br><span class="line"><span class="comment">// It appends to any existing values associated with key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span></span> Add(key, value <span class="type">string</span>) &#123;</span><br><span class="line">    v[key] = <span class="built_in">append</span>(v[key], value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个定义向外部暴露了一个map的命名类型，并且提供了一些能够简单操作这个map的方法。这个map的value字段是一个string的slice，所以这个Values是一个多维map。客户端使用这个变量的时候可以使用map固有的一些操作（make，切片，<code>m[key]</code>等等），也可以使用这里提供的操作方法，或者两者并用，都是可以的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := url.Values&#123;<span class="string">&quot;lang&quot;</span>: &#123;<span class="string">&quot;en&quot;</span>&#125;&#125; <span class="comment">// direct construction</span></span><br><span class="line">m.Add(<span class="string">&quot;item&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">m.Add(<span class="string">&quot;item&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(m.Get(<span class="string">&quot;lang&quot;</span>)) <span class="comment">// &quot;en&quot;</span></span><br><span class="line">fmt.Println(m.Get(<span class="string">&quot;q&quot;</span>))    <span class="comment">// &quot;&quot;</span></span><br><span class="line">fmt.Println(m.Get(<span class="string">&quot;item&quot;</span>)) <span class="comment">// &quot;1&quot;      (first value)</span></span><br><span class="line">fmt.Println(m[<span class="string">&quot;item&quot;</span>])     <span class="comment">// &quot;[1 2]&quot;  (direct map access)</span></span><br><span class="line"></span><br><span class="line">m = <span class="literal">nil</span></span><br><span class="line">fmt.Println(m.Get(<span class="string">&quot;item&quot;</span>)) <span class="comment">// &quot;&quot;</span></span><br><span class="line">m.Add(<span class="string">&quot;item&quot;</span>, <span class="string">&quot;3&quot;</span>)         <span class="comment">// panic: assignment to entry in nil map</span></span><br></pre></td></tr></table></figure>

<p>对Get的最后一次调用中，nil接收器的行为即是一个空map的行为。我们可以等价地将这个操作写成<code>Value(nil).Get(&quot;item&quot;)</code>，但是如果你直接写<code>nil.Get(&quot;item&quot;)</code>的话是无法通过编译的，因为nil的字面量编译器无法判断其准确类型。所以相比之下，最后的那行<code>m.Add</code>的调用就会产生一个panic，因为他尝试更新一个空map。</p>
<p>由于<code>url.Values</code>是一个map类型，并且间接引用了其key&#x2F;value对，因此<code>url.Values.Add</code>对这个map里的元素做任何的更新、删除操作对调用方都是可见的。实际上，就像在普通函数中一样，虽然可以通过引用来操作内部值，但在方法想要修改引用本身时是不会影响原始值的，比如把他置换为<code>nil</code>，或者让这个引用指向了其它的对象，调用方都不会受影响。（译注：因为传入的是存储了内存地址的变量，你改变这个变量本身是影响不了原始的变量的，想想C语言，是差不多的）</p>
<h2 id="通过嵌入结构体来扩展类型"><a href="#通过嵌入结构体来扩展类型" class="headerlink" title="通过嵌入结构体来扩展类型"></a>通过嵌入结构体来扩展类型</h2><p>来看看<code>ColoredPoint</code>这个类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;image/color&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Color color.RGBA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们完全可以将<code>ColoredPoint</code>定义为一个有三个字段的struct，但是我们却将<code>Point</code>这个类型嵌入到<code>ColoredPoint</code>来提供<code>X</code>和<code>Y</code>这两个字段。像我们在4.4节中看到的那样，内嵌可以使我们在定义<code>ColoredPoint</code>时得到一种句法上的简写形式，并使其包含<code>Point</code>类型所具有的一切字段，然后再定义一些自己的。如果我们想要的话，我们可以直接认为通过嵌入的字段就是<code>ColoredPoint</code>自身的字段，而完全不需要在调用时指出<code>Point</code>，比如下面这样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cp ColoredPoint</span><br><span class="line">cp.X = <span class="number">1</span></span><br><span class="line">fmt.Println(cp.Point.X) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">cp.Point.Y = <span class="number">2</span></span><br><span class="line">fmt.Println(cp.Y) <span class="comment">// &quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<p>对于Point中的方法我们也有类似的用法，我们可以把ColoredPoint类型当作接收器来调用Point里的方法，即使ColoredPoint里没有声明这些方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">red := color.RGBA&#123;<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>&#125;</span><br><span class="line">blue := color.RGBA&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>&#125;</span><br><span class="line"><span class="keyword">var</span> p = ColoredPoint&#123;Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, red&#125;</span><br><span class="line"><span class="keyword">var</span> q = ColoredPoint&#123;Point&#123;<span class="number">5</span>, <span class="number">4</span>&#125;, blue&#125;</span><br><span class="line">fmt.Println(p.Distance(q.Point)) <span class="comment">// &quot;5&quot;</span></span><br><span class="line">p.ScaleBy(<span class="number">2</span>)</span><br><span class="line">q.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p.Distance(q.Point)) <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>Point</code>类的方法也被引入了<code>ColoredPoint</code>。用这种方式，内嵌可以使我们定义字段特别多的复杂类型，我们可以将字段先按小类型分组，然后定义小类型的方法，之后再把它们组合起来。</strong></p>
<p><strong>读者如果对基于类来实现面向对象的语言比较熟悉的话，可能会倾向于将Point看作一个基类，而<code>ColoredPoint</code>看作其子类或者继承类，或者将<code>ColoredPoint</code>看作”is a” <code>Point</code>类型。但这是错误的理解。请注意上面例子中对<code>Distance</code>方法的调用。<code>Distance</code>有一个参数是<code>Point</code>类型，但<code>q</code>并不是一个<code>Point</code>类，所以尽管<code>q</code>有着<code>Point</code>这个内嵌类型，我们也必须要显式地选择它。尝试直接传<code>q</code>的话你会看到下面这样的错误：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.Distance(q) <span class="comment">// compile error: cannot use q (ColoredPoint) as Point</span></span><br></pre></td></tr></table></figure>

<p><strong>一个<code>ColoredPoint</code>并不是一个<code>Point</code>，但他”has a”Point，并且它有从<code>Point</code>类里引入的<code>Distance</code>和<code>ScaleBy</code>方法。如果你喜欢从实现的角度来考虑问题，内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法，和下面的形式是等价的：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p ColoredPoint)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.Point.Distance(q)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ColoredPoint)</span></span> ScaleBy(factor <span class="type">float64</span>) &#123;</span><br><span class="line">    p.Point.ScaleBy(factor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>Point.Distance</code>被第一个包装方法调用时，它的接收器值是<code>p.Point</code>，而不是<code>p</code>，当然了，在<code>Point</code>类的方法里，你是访问不到<code>ColoredPoint</code>的任何字段的。</p>
<p><strong>在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中（译注：访问需要通过该指针指向的对象去取）。添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。下面这个<code>ColoredPoint</code>的声明内嵌了一个<code>*Point</code>的指针。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Point</span><br><span class="line">    Color color.RGBA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := ColoredPoint&#123;&amp;Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, red&#125;</span><br><span class="line">q := ColoredPoint&#123;&amp;Point&#123;<span class="number">5</span>, <span class="number">4</span>&#125;, blue&#125;</span><br><span class="line">fmt.Println(p.Distance(*q.Point)) <span class="comment">// &quot;5&quot;</span></span><br><span class="line">q.Point = p.Point                 <span class="comment">// p and q now share the same Point</span></span><br><span class="line">p.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(*p.Point, *q.Point) <span class="comment">// &quot;&#123;2 2&#125; &#123;2 2&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>一个struct类型也可能会有多个匿名字段。我们将<code>ColoredPoint</code>定义为下面这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    color.RGBA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这种类型的值便会拥有<code>Point</code>和<code>RGBA</code>类型的所有方法，以及直接定义在<code>ColoredPoint</code>中的方法。当编译器解析一个选择器到方法时，比如<code>p.ScaleBy</code>，它会首先去找直接定义在这个类型里的<code>ScaleBy</code>方法，然后找被<code>ColoredPoint</code>的内嵌字段们引入的方法，然后去找<code>Point</code>和<code>RGBA</code>的内嵌字段引入的方法，然后一直递归向下找。如果选择器有二义性的话编译器会报错，比如你在同一级里有两个同名的方法。</p>
<p>方法只能在命名类型（像<code>Point</code>）或者指向类型的指针上定义，但是多亏了内嵌，有些时候我们给匿名struct类型来定义方法也有了手段。</p>
<p>下面是一个小trick。这个例子展示了简单的cache，其使用两个包级别的变量来实现，一个mutex互斥量（§9.2）和它所操作的cache：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu sync.Mutex <span class="comment">// guards mapping</span></span><br><span class="line">    mapping = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    v := mapping[key]</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个版本在功能上是一致的，但将两个包级别的变量放在了cache这个struct一组内：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    mapping <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    mapping: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    cache.Lock()</span><br><span class="line">    v := cache.mapping[key]</span><br><span class="line">    cache.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们给新的变量起了一个更具表达性的名字：cache。因为<code>sync.Mutex</code>字段也被嵌入到了这个struct里，其<code>Lock</code>和<code>Unlock</code>方法也就都被引入到了这个匿名结构中了，这让我们能够以一个简单明了的语法来对其进行加锁解锁操作。</p>
<h2 id="方法值和方法表达式"><a href="#方法值和方法表达式" class="headerlink" title="方法值和方法表达式"></a>方法值和方法表达式</h2><p><strong>我们经常选择一个方法，并且在同一个表达式里执行，比如常见的<code>p.Distance()</code>形式，实际上将其分成两步来执行也是可能的。<code>p.Distance</code>叫作“选择器”，选择器会返回一个方法“值”——一个将方法（<code>Point.Distance</code>）绑定到特定接收器变量的函数。这个函数可以不通过指定其接收器即可被调用；即调用时不需要指定接收器，只要传入函数的参数即可：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">distanceFromP := p.Distance        <span class="comment">// method value</span></span><br><span class="line">fmt.Println(distanceFromP(q))      <span class="comment">// &quot;5&quot;</span></span><br><span class="line"><span class="keyword">var</span> origin Point                   <span class="comment">// &#123;0, 0&#125;</span></span><br><span class="line">fmt.Println(distanceFromP(origin)) <span class="comment">// &quot;2.23606797749979&quot;, sqrt(5)</span></span><br><span class="line"></span><br><span class="line">scaleP := p.ScaleBy <span class="comment">// method value</span></span><br><span class="line">scaleP(<span class="number">2</span>)           <span class="comment">// p becomes (2, 4)</span></span><br><span class="line">scaleP(<span class="number">3</span>)           <span class="comment">//      then (6, 12)</span></span><br><span class="line">scaleP(<span class="number">10</span>)          <span class="comment">//      then (60, 120)</span></span><br></pre></td></tr></table></figure>

<p>在一个包的API需要一个函数值、且调用方希望操作的是某一个绑定了对象的方法的话，方法“值”会非常实用。举例来说，下面例子中的<code>time.AfterFunc</code>这个函数的功能是在指定的延迟时间之后来执行一个函数。且这个函数操作的是一个<code>Rocket</code>对象<code>r</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Rocket <span class="keyword">struct</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rocket)</span></span> Launch() &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">r := <span class="built_in">new</span>(Rocket)</span><br><span class="line">time.AfterFunc(<span class="number">10</span> * time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; r.Launch() &#125;)</span><br></pre></td></tr></table></figure>

<p>直接用方法“值”传入<code>AfterFunc</code>的话可以更为简短：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">time.AfterFunc(<span class="number">10</span> * time.Second, r.Launch)</span><br></pre></td></tr></table></figure>

<p><strong>和方法“值”相关的还有 <em>方法表达式</em> 。当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器（<code>p.Distance</code>）语法来指定方法的接收器。</strong></p>
<p><strong>当T是一个类型时，方法表达式可能会写作<code>T.f</code>或者<code>(*T).f</code>，会返回一个函数“值”，这种函数会将其第一个参数用作接收器，所以可以用通常（译注：不写选择器）的方式来对其进行调用：</strong> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">distance := Point.Distance   <span class="comment">// method expression</span></span><br><span class="line">fmt.Println(distance(p, q))  <span class="comment">// &quot;5&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, distance) <span class="comment">// &quot;func(Point, Point) float64&quot;</span></span><br><span class="line"></span><br><span class="line">scale := (*Point).ScaleBy</span><br><span class="line">scale(&amp;p, <span class="number">2</span>)</span><br><span class="line">fmt.Println(p)            <span class="comment">// &quot;&#123;2 4&#125;&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, scale) <span class="comment">// &quot;func(*Point, float64)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译注：这个Distance实际上是指定了Point对象为接收器的一个方法func (p Point) Distance()，</span></span><br><span class="line"><span class="comment">// 但通过Point.Distance得到的函数需要比实际的Distance方法多一个参数，</span></span><br><span class="line"><span class="comment">// 即其需要用第一个额外参数指定接收器，后面排列Distance方法的参数。</span></span><br><span class="line"><span class="comment">// 看起来本书中函数和方法的区别是指有没有接收器，而不像其他语言那样是指有没有返回值。</span></span><br></pre></td></tr></table></figure>

<p>当你根据一个变量来决定调用同一个类型的哪个函数时，方法表达式就显得很有用了。你可以根据选择来调用接收器各不相同的方法。下面的例子，变量<code>op</code>代表<code>Point</code>类型的<code>Add</code>或者<code>Sub</code>方法，<code>Path.TranslateBy</code>方法会为其Path数组中的每一个<code>Point</code>来调用对应的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Add(q Point) Point &#123; <span class="keyword">return</span> Point&#123;p.X + q.X, p.Y + q.Y&#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Sub(q Point) Point &#123; <span class="keyword">return</span> Point&#123;p.X - q.X, p.Y - q.Y&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Path []Point</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path Path)</span></span> TranslateBy(offset Point, add <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> op <span class="function"><span class="keyword">func</span><span class="params">(p, q Point)</span></span> Point</span><br><span class="line">    <span class="keyword">if</span> add &#123;</span><br><span class="line">        op = Point.Add</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op = Point.Sub</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> path &#123;</span><br><span class="line">        <span class="comment">// Call either path[i].Add(offset) or path[i].Sub(offset).</span></span><br><span class="line">        path[i] = op(path[i], offset)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="示例-Bit数组"><a href="#示例-Bit数组" class="headerlink" title="示例: Bit数组"></a>示例: Bit数组</h2><p>Go语言里的集合一般会用<code>map[T]bool</code>这种形式来表示，T代表元素类型。集合用map类型来表示虽然非常灵活，但我们可以以一种更好的形式来表示它。例如在数据流分析领域，集合元素通常是一个非负整数，集合会包含很多元素，并且集合会经常进行并集、交集操作，这种情况下，bit数组会比map表现更加理想。（译注：这里再补充一个例子，比如我们执行一个http下载任务，把文件按照16kb一块划分为很多块，需要有一个全局变量来标识哪些块下载完成了，这种时候也需要用到bit数组。）</p>
<p>一个bit数组通常会用一个无符号数或者称之为“字”的slice来表示，每一个元素的每一位都表示集合里的一个值。当集合的第<code>i</code>位被设置时，我们才说这个集合包含元素<code>i</code>。下面的这个程序展示了一个简单的bit数组类型，并且实现了三个函数来对这个bit数组来进行操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An IntSet is a set of small non-negative integers.</span></span><br><span class="line"><span class="comment">// Its zero value represents the empty set.</span></span><br><span class="line"><span class="keyword">type</span> IntSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    words []<span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Has reports whether the set contains the non-negative value x.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span></span> Has(x <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    word, bit := x/<span class="number">64</span>, <span class="type">uint</span>(x%<span class="number">64</span>)</span><br><span class="line">    <span class="keyword">return</span> word &lt; <span class="built_in">len</span>(s.words) &amp;&amp; s.words[word]&amp;(<span class="number">1</span>&lt;&lt;bit) != <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds the non-negative value x to the set.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span></span> Add(x <span class="type">int</span>) &#123;</span><br><span class="line">    word, bit := x/<span class="number">64</span>, <span class="type">uint</span>(x%<span class="number">64</span>)</span><br><span class="line">    <span class="keyword">for</span> word &gt;= <span class="built_in">len</span>(s.words) &#123;</span><br><span class="line">        s.words = <span class="built_in">append</span>(s.words, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    s.words[word] |= <span class="number">1</span> &lt;&lt; bit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnionWith sets s to the union of s and t.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span></span> UnionWith(t *IntSet) &#123;</span><br><span class="line">    <span class="keyword">for</span> i, tword := <span class="keyword">range</span> t.words &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s.words) &#123;</span><br><span class="line">            s.words[i] |= tword</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.words = <span class="built_in">append</span>(s.words, tword)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为每一个字都有64个二进制位，所以为了定位<code>x</code>的bit位，我们用了<code>x/64</code>的商作为字的下标，并且用x%64得到的值作为这个字内的bit的所在位置。<code>UnionWith</code>这个方法里用到了bit位的“或”逻辑操作符号|来一次完成64个元素的或计算。（在练习6.5中我们还会有程序用到这个64位字的例子。）</p>
<p>当前这个实现还缺少了很多必要的特性，我们把其中一些作为练习题列在本小节之后。但是有一个方法如果缺失的话我们的bit数组可能会比较难混：将<code>IntSet</code>作为一个字符串来打印。这里我们来实现它，让我们来给上面的例子添加一个<code>String</code>方法，类似2.5节中做的那样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String returns the set as a string of the form &quot;&#123;1 2 3&#125;&quot;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    buf.WriteByte(<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, word := <span class="keyword">range</span> s.words &#123;</span><br><span class="line">        <span class="keyword">if</span> word == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">64</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> word&amp;(<span class="number">1</span>&lt;&lt;<span class="type">uint</span>(j)) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> buf.Len() &gt; <span class="built_in">len</span>(<span class="string">&quot;&#123;&quot;</span>) &#123;</span><br><span class="line">                    buf.WriteByte(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                fmt.Fprintf(&amp;buf, <span class="string">&quot;%d&quot;</span>, <span class="number">64</span>*i+j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buf.WriteByte(<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里留意一下<code>String</code>方法，是不是和3.5.4节中的<code>intsToString</code>方法很相似；<code>bytes.Buffer</code>在<code>String</code>方法里经常这么用。当你为一个复杂的类型定义了一个<code>String</code>方法时，<code>fmt</code>包就会特殊对待这种类型的值，这样可以让这些类型在打印的时候看起来更加友好，而不是直接打印其原始的值。<code>fmt</code>会直接调用用户定义的<code>String</code>方法。这种机制依赖于接口和类型断言，在第7章中我们会详细介绍。</p>
<p>现在我们就可以在实战中直接用上面定义好的<code>IntSet</code>了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y IntSet</span><br><span class="line">x.Add(<span class="number">1</span>)</span><br><span class="line">x.Add(<span class="number">144</span>)</span><br><span class="line">x.Add(<span class="number">9</span>)</span><br><span class="line">fmt.Println(x.String()) <span class="comment">// &quot;&#123;1 9 144&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">y.Add(<span class="number">9</span>)</span><br><span class="line">y.Add(<span class="number">42</span>)</span><br><span class="line">fmt.Println(y.String()) <span class="comment">// &quot;&#123;9 42&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">x.UnionWith(&amp;y)</span><br><span class="line">fmt.Println(x.String()) <span class="comment">// &quot;&#123;1 9 42 144&#125;&quot;</span></span><br><span class="line">fmt.Println(x.Has(<span class="number">9</span>), x.Has(<span class="number">123</span>)) <span class="comment">// &quot;true false&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里要注意：我们声明的<code>String</code>和<code>Has</code>两个方法都是以指针类型<code>*IntSet</code>来作为接收器的，但实际上对于这两个类型来说，把接收器声明为指针类型也没什么必要。不过另外两个函数就不是这样了，因为另外两个函数操作的是<code>s.words</code>对象，如果你不把接收器声明为指针对象，那么实际操作的是拷贝对象，而不是原来的那个对象。因此，因为我们的<code>String</code>方法定义在<code>IntSet</code>指针上，所以当我们的变量是<code>IntSet</code>类型而不是<code>IntSet</code>指针时，可能会有下面这样让人意外的情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(&amp;x)         <span class="comment">// &quot;&#123;1 9 42 144&#125;&quot;</span></span><br><span class="line">fmt.Println(x.String()) <span class="comment">// &quot;&#123;1 9 42 144&#125;&quot;</span></span><br><span class="line">fmt.Println(x)          <span class="comment">// &quot;&#123;[4398046511618 0 65536]&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>在第一个<code>Println</code>中，我们打印一个<code>*IntSet</code>的指针，这个类型的指针确实有自定义的String方法。第二<code>Println</code>，我们直接调用了x变量的<code>String()</code>方法；这种情况下编译器会隐式地在x前插入<code>&amp;</code>操作符，这样相当于我们还是调用的<code>IntSet</code>指针的<code>String</code>方法。在第三个<code>Println</code>中，因为<code>IntSet</code>类型没有<code>String</code>方法，所以<code>Println</code>方法会直接以原始的方式理解并打印。所以在这种情况下<code>&amp;</code>符号是不能忘的。在我们这种场景下，你把<code>String</code>方法绑定到<code>IntSet</code>对象上，而不是<code>IntSet</code>指针上可能会更合适一些，不过这也需要具体问题具体分析。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为**“封装”<strong>。封装有时候也被叫做</strong>信息隐藏**，同时也是面向对象编程最关键的一个方面。</p>
<p><strong>Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。</strong></p>
<p>这也就是前面的小节中<code>IntSet</code>被定义为struct类型的原因，尽管它只有一个字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    words []<span class="type">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以把<code>IntSet</code>定义为一个slice类型，但这样我们就需要把代码中所有方法里用到的<code>s.words</code>用<code>*s</code>替换掉了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSet []<span class="type">uint64</span></span><br></pre></td></tr></table></figure>

<p>尽管这个版本的<code>IntSet</code>在本质上是一样的，但它也允许其它包中可以直接读取并编辑这个slice。换句话说，相对于<code>*s</code>这个表达式会出现在所有的包中，<code>s.words</code>只需要在定义<code>IntSet</code>的包中出现。</p>
<p><strong>这种基于名字的手段使得在语言中最小的封装单元是package，而不是像其它语言一样的类型。一个struct类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。</strong></p>
<p>封装提供了3个优点：</p>
<ul>
<li><p>因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。</p>
</li>
<li><p>隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的API情况下能得到更大的自由。</p>
</li>
<li><p>阻止了外部调用方对对象内部的值任意地进行修改。</p>
</li>
</ul>
<p>把<code>bytes.Buffer</code>这个类型作为例子来考虑。这个类型在做短字符串叠加的时候很常用，所以在设计的时候可以做一些预先的优化，比如提前预留一部分空间，来避免反复的内存分配。又因为Buffer是一个struct类型，这些额外的空间可以用附加的字节数组来保存，且放在一个小写字母开头的字段中。这样在外部的调用方只能看到性能的提升，但并不会得到这个附加变量。Buffer和其增长算法我们列在这里，为了简洁性稍微做了一些精简：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Buffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    buf     []<span class="type">byte</span></span><br><span class="line">    initial [<span class="number">64</span>]<span class="type">byte</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grow expands the buffer&#x27;s capacity, if necessary,</span></span><br><span class="line"><span class="comment">// to guarantee space for another n bytes. [...]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span></span> Grow(n <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> b.buf == <span class="literal">nil</span> &#123;</span><br><span class="line">        b.buf = b.initial[:<span class="number">0</span>] <span class="comment">// use preallocated space initially</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b.buf)+n &gt; <span class="built_in">cap</span>(b.buf) &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="type">byte</span>, b.Len(), <span class="number">2</span>*<span class="built_in">cap</span>(b.buf) + n)</span><br><span class="line">        <span class="built_in">copy</span>(buf, b.buf)</span><br><span class="line">        b.buf = buf</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装的第三个优点也是最重要的优点，是阻止了外部调用方对对象内部的值任意地进行修改。因为对象内部变量只可以被同一个包内的函数修改，所以包的作者可以让这些函数确保对象内部的一些值的不变性。比如下面的<code>Counter</code>类型允许调用方来增加<code>n</code>变量的值，并且允许将这个值<code>reset</code>为<code>0</code>，但是不允许从包外随便设置这个值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123; n <span class="type">int</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> N() <span class="type">int</span>     &#123; <span class="keyword">return</span> c.n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Increment() &#123; c.n++ &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Reset()     &#123; c.n = <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<p>只用来访问或修改内部变量的函数被称为<code>setter</code>或者<code>getter</code>，例子如下，比如log包里的Logger类型对应的一些函数。在命名一个<code>getter</code>方法时，我们通常会省略掉前面的<code>Get</code>前缀。这种简洁上的偏好也可以推广到各种类型的前缀比如<code>Fetch</code>，<code>Find</code>或者<code>Lookup</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> log</span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">    flags  <span class="type">int</span></span><br><span class="line">    prefix <span class="type">string</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Flags() <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> SetFlags(flag <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Prefix() <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> SetPrefix(prefix <span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<p>Go的编码风格不禁止直接导出字段。当然，一旦进行了导出，就没有办法在保证API兼容的情况下去除对其的导出，所以在一开始的选择一定要经过深思熟虑并且要考虑到包内部的一些不变量的保证，未来可能的变化，以及调用方的代码质量是否会因为包的一点修改而变差。</p>
<p>封装并不总是理想的。 虽然封装在有些情况是必要的，但有时候我们也需要暴露一些内部内容，比如：<code>time.Duration</code>将其表现暴露为一个int64数字的纳秒，使得我们可以用一般的数值操作来对时间进行对比，甚至可以定义这种类型的常量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> day = <span class="number">24</span> * time.Hour</span><br><span class="line">fmt.Println(day.Seconds()) <span class="comment">// &quot;86400&quot;</span></span><br></pre></td></tr></table></figure>

<p>另一个例子，将<code>IntSet</code>和本章开头的<code>geometry.Path</code>进行对比。Path被定义为一个slice类型，这允许其调用slice的字面方法来对其内部的<code>points</code>用range进行迭代遍历；在这一点上，<code>IntSet</code>是没有办法让你这么做的。</p>
<p>这两种类型决定性的不同：<code>geometry.Path</code>的本质是一个坐标点的序列，不多也不少，我们可以预见到之后也并不会给他增加额外的字段，所以在<code>geometry</code>包中将<code>Path</code>暴露为一个slice。相比之下，<code>IntSet</code>仅仅是在这里用了一个<code>[]uint64</code>的slice。这个类型还可以用<code>[]uint</code>类型来表示，或者我们甚至可以用其它完全不同的占用更小内存空间的东西来表示这个集合，所以我们可能还会需要额外的字段来在这个类型中记录元素的个数。也正是因为这些原因，我们让<code>IntSet</code>对调用方不透明。</p>
<p>在这章中，我们学到了如何将方法与命名类型进行组合，并且知道了如何调用这些方法。尽管方法对于OOP编程来说至关重要，但他们只是OOP编程里的半边天。为了完成OOP，我们还需要接口。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口约定"><a href="#接口约定" class="headerlink" title="接口约定"></a>接口约定</h2><p>目前为止，我们看到的类型都是具体的类型。一个具体的类型可以准确的描述它所代表的值，并且展示出对类型本身的一些操作方式：就像数字类型的算术操作，切片类型的取下标、添加元素和范围获取操作。具体的类型还可以通过它的内置方法提供额外的行为操作。总的来说，当你拿到一个具体的类型时你就知道它的本身是什么和你可以用它来做什么。</p>
<p><strong>在Go语言中还存在着另外一种类型：<em>接口类型</em>。<em>接口类型</em> 是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。</strong></p>
<p>在本书中，我们一直使用两个相似的函数来进行字符串的格式化：<code>fmt.Printf</code>，它会把结果写到标准输出，和<code>fmt.Sprintf</code>，它会把结果以字符串的形式返回。得益于使用接口，我们不必可悲的因为返回结果在使用方式上的一些浅显不同就必需把格式化这个最困难的过程复制一份。实际上，这两个函数都使用了另一个函数<code>fmt.Fprintf</code>来进行封装。<code>fmt.Fprintf</code>这个函数对它的计算结果会被怎么使用是完全不知道的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintf(os.Stdout, format, args...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    Fprintf(&amp;buf, format, args...)</span><br><span class="line">    <span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Fprintf</code>的前缀F表示文件（File）也表明格式化输出结果应该被写入第1个参数提供的文件中。在<code>Printf</code>函数中的第1个参数<code>os.Stdout</code>是<code>*os.File</code>类型；在<code>Sprintf</code>函数中的第1个参数<code>&amp;buf</code>是一个指向可以写入字节的内存缓冲区，然而它并不是一个文件类型尽管它在某种意义上和文件类型相似。</p>
<p>即使<code>Fprintf</code>函数中的第1个参数也不是一个文件类型。<strong>它是<code>io.Writer</code>类型，这是一个接口类型定义如下：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Write writes len(p) bytes from p to the underlying data stream.</span></span><br><span class="line">    <span class="comment">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))</span></span><br><span class="line">    <span class="comment">// and any error encountered that caused the write to stop early.</span></span><br><span class="line">    <span class="comment">// Write must return a non-nil error if it returns n &lt; len(p).</span></span><br><span class="line">    <span class="comment">// Write must not modify the slice data, even temporarily.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Implementations must not retain p.</span></span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>io.Writer</code>类型定义了函数<code>Fprintf</code>和这个函数调用者之间的约定。一方面这个约定需要调用者提供具体类型的值就像<code>*os.File</code>和<code>*bytes.Buffer</code>，这些类型都有一个特定签名和行为的<code>Write</code>的函数。另一方面这个约定保证了<code>Fprintf</code>接受任何满足<code>io.Writer</code>接口的值都可以工作。<code>Fprintf</code>函数可能没有假定写入的是一个文件或是一段内存，而是写入一个可以调用<code>Write</code>函数的值。</p>
<p>因为<code>fmt.Fprintf</code>函数没有对具体操作的值做任何假设，而是仅仅通过<code>io.Writer</code>接口的约定来保证行为，所以第1个参数可以安全地传入一个只需要满足<code>io.Writer</code>接口的任意具体类型的值。一个类型可以自由地被另一个满足相同接口的类型替换，被称作可替换性（LSP里氏替换）。这是一个面向对象的特征。</p>
<p>让我们通过一个新的类型来进行校验，下面<code>*ByteCounter</code>类型里的<code>Write</code>方法，仅仅在丢弃写向它的字节前统计它们的长度。（在这个<code>+=</code>赋值语句中，让<code>len(p)</code>的类型和<code>*c</code>的类型匹配的转换是必须的。）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteCounter <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ByteCounter)</span></span> Write(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    *c += ByteCounter(<span class="built_in">len</span>(p)) <span class="comment">// convert int to ByteCounter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>*ByteCounter</code>满足<code>io.Writer</code>的约定，我们可以把它传入<code>Fprintf</code>函数中；<code>Fprintf</code>函数执行字符串格式化的过程不会去关注<code>ByteCounter</code>正确的累加结果的长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c ByteCounter</span><br><span class="line">c.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">fmt.Println(c) <span class="comment">// &quot;5&quot;, = len(&quot;hello&quot;)</span></span><br><span class="line">c = <span class="number">0</span>          <span class="comment">// reset the counter</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Dolly&quot;</span></span><br><span class="line">fmt.Fprintf(&amp;c, <span class="string">&quot;hello, %s&quot;</span>, name)</span><br><span class="line">fmt.Println(c) <span class="comment">// &quot;12&quot;, = len(&quot;hello, Dolly&quot;)</span></span><br></pre></td></tr></table></figure>

<p>除了<code>io.Writer</code>这个接口类型，还有另一个对<code>fmt</code>包很重要的接口类型。<code>Fprintf</code>和<code>Fprintln</code>函数向类型提供了一种控制它们值输出的途径。在2.5节中，我们为<code>Celsius</code>类型提供了一个<code>String</code>方法以便于可以打印成这样”100°C” ，在6.5节中我们给<code>*IntSet</code>添加一个<code>String</code>方法，这样集合可以用传统的符号来进行表示就像<code>&quot;&#123;1 2 3&#125;&quot;</code>。<strong>给一个类型定义<code>String</code>方法，可以让它满足最广泛使用之一的接口类型<code>fmt.Stringer</code>：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="comment">// The String method is used to print values passed</span></span><br><span class="line"><span class="comment">// as an operand to any format that accepts a string</span></span><br><span class="line"><span class="comment">// or to an unformatted printer such as Print.</span></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p><strong>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。</strong></p>
<p><code>io.Writer</code>类型是用得最广泛的接口之一，因为它提供了所有类型的写入bytes的抽象，包括文件类型，内存缓冲区，网络链接，HTTP客户端，压缩工具，哈希等等。<code>io</code>包中定义了很多其它有用的接口类型。<code>Reader</code>可以代表任意可以读取bytes的类型，<code>Closer</code>可以是任意可以关闭的值，例如一个文件或是网络链接。（到现在你可能注意到了很多Go语言中单方法接口的命名习惯）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往下看，我们发现有些新的接口类型通过组合已有的接口来定义。下面是两个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**上面用到的语法和结构内嵌相似，我们可以用这种方式以一个简写命名一个接口，而不用声明它所有的方法。这种方式称为接口内嵌。**尽管略失简洁，我们可以像下面这样，不使用内嵌来声明<code>io.ReadWriter</code>接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者甚至使用一种混合的风格：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面3种定义方式都是一样的效果。方法顺序的变化也没有影响，唯一重要的就是这个集合里面的方法。</p>
<h2 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h2><p><strong>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。</strong> 例如，<code>*os.File</code>类型实现了<code>io.Reader</code>，<code>Writer</code>，<code>Closer</code>，和<code>ReadWriter</code>接口。<code>*bytes.Buffer</code>实现了<code>Reader</code>，<code>Writer</code>，和<code>ReadWriter</code>这些接口，但是它没有实现<code>Closer</code>接口因为它不具有<code>Close</code>方法。Go的程序员经常会简要的把一个具体的类型描述成一个特定的接口类型。举个例子，<code>*bytes.Buffer</code>是<code>io.Writer</code>；<code>*os.Files</code>是<code>io.ReadWriter</code>。</p>
<p><strong>接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口。</strong> 所以：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout           <span class="comment">// OK: *os.File has Write method</span></span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)   <span class="comment">// OK: *bytes.Buffer has Write method</span></span><br><span class="line">w = time.Second         <span class="comment">// compile error: time.Duration lacks Write method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwc io.ReadWriteCloser</span><br><span class="line">rwc = os.Stdout         <span class="comment">// OK: *os.File has Read, Write, Close methods</span></span><br><span class="line">rwc = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// compile error: *bytes.Buffer lacks Close method</span></span><br></pre></td></tr></table></figure>

<p>这个规则甚至适用于等式右边本身也是一个接口类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w = rwc                 <span class="comment">// OK: io.ReadWriteCloser has Write method</span></span><br><span class="line">rwc = w                 <span class="comment">// compile error: io.Writer lacks Close method</span></span><br></pre></td></tr></table></figure>

<p>因为<code>ReadWriter</code>和<code>ReadWriteCloser</code>包含有<code>Writer</code>的方法，所以任何实现了<code>ReadWriter</code>和<code>ReadWriteCloser</code>的类型必定也实现了<code>Writer</code>接口。</p>
<p>在进一步学习前，必须先解释一个类型持有一个方法的表示当中的细节。回想在6.2章中，对于每一个命名过的具体类型T；它的一些方法的接收者是类型T本身然而另一些则是一个<code>*T</code>的指针。还记得在T类型的参数上调用一个<code>*T</code>的方法是合法的，只要这个参数是一个变量；编译器隐式的获取了它的地址。<strong>但这仅仅是一个语法糖：T类型的值不拥有所有<code>*T</code>指针的方法，这样它就可能只实现了更少的接口。</strong></p>
<p>举个例子可能会更清晰一点。在第6.5章中，<strong><code>IntSet</code>类型的<code>String</code>方法的接收者是一个指针类型，所以我们不能在一个不能寻址的<code>IntSet</code>值上调用这个方法：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSet <span class="keyword">struct</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*IntSet)</span></span> String() <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> _ = IntSet&#123;&#125;.String() <span class="comment">// compile error: String requires *IntSet receiver</span></span><br></pre></td></tr></table></figure>

<p>但是我们可以在一个<code>IntSet</code>变量上调用这个方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s IntSet</span><br><span class="line"><span class="keyword">var</span> _ = s.String() <span class="comment">// OK: s is a variable and &amp;s has a String method</span></span><br></pre></td></tr></table></figure>

<p><strong>然而，由于只有<code>*IntSet</code>类型有<code>String</code>方法，所以也只有<code>*IntSet</code>类型实现了<code>fmt.Stringer</code>接口：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ fmt.Stringer = &amp;s <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">var</span> _ fmt.Stringer = s  <span class="comment">// compile error: IntSet lacks String method</span></span><br></pre></td></tr></table></figure>

<p>12.8章包含了一个打印出任意值的所有方法的程序，然后可以使用<code>godoc -analysis=type tool</code>(§10.7.4)展示每个类型的方法和具体类型和接口之间的关系。</p>
<p><strong>就像信封封装和隐藏起信件来一样，接口类型封装和隐藏具体类型和它的值。即使具体类型有其它的方法，也只有接口类型暴露出来的方法会被调用到：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">os.Stdout.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// OK: *os.File has Write method</span></span><br><span class="line">os.Stdout.Close()                <span class="comment">// OK: *os.File has Close method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// OK: io.Writer has Write method</span></span><br><span class="line">w.Close()                <span class="comment">// compile error: io.Writer lacks Close method</span></span><br></pre></td></tr></table></figure>

<p>一个有更多方法的接口类型，比如<code>io.ReadWriter</code>，和少一些方法的接口类型例如<code>io.Reader</code>，进行对比；更多方法的接口类型会告诉我们更多关于它的值持有的信息，并且对实现它的类型要求更加严格。</p>
<p><strong>那么关于<code>interface&#123;&#125;</code>类型，它没有任何方法。这看上去好像没有用，但实际上<code>interface&#123;&#125;</code>被称为 <em>空接口类型</em> 是不可或缺的。因为空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">any = <span class="literal">true</span></span><br><span class="line">any = <span class="number">12.34</span></span><br><span class="line">any = <span class="string">&quot;hello&quot;</span></span><br><span class="line">any = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">any = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>

<p>尽管不是很明显，从本书最早的例子中我们就已经在使用空接口类型。它允许像<code>fmt.Println</code>或者5.7章中的<code>errorf</code>函数接受任何类型的参数。</p>
<p><strong>对于创建的一个<code>interface&#123;&#125;</code>值持有一个boolean，float，string，map，pointer，或者任意其它的类型；我们当然不能直接对它持有的值做操作，因为<code>interface&#123;&#125;</code>没有任何方法。我们会用 <em>类型断言</em> 来获取<code>interface&#123;&#125;</code>中值的方法。</strong></p>
<p>因为接口与实现只依赖于判断两个类型的方法，所以没有必要定义一个具体类型和它实现的接口之间的关系。也就是说，有意地在文档里说明或者程序上断言这种关系偶尔是有用的，但程序上不强制这么做。下面的定义在编译期断言一个<code>*bytes.Buffer</code>的值实现了<code>io.Writer</code>接口类型:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// *bytes.Buffer must satisfy io.Writer</span></span><br><span class="line"><span class="keyword">var</span> w io.Writer = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>

<p>因为任意<code>*bytes.Buffer</code>的值，甚至包括nil通过<code>(*bytes.Buffer)(nil)</code>进行显示的转换都实现了这个接口，所以我们不必分配一个新的变量。并且因为我们绝不会引用变量w，我们可以使用空标识符来进行代替。总的看，这些变化可以让我们得到一个更朴素的版本：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// *bytes.Buffer must satisfy io.Writer</span></span><br><span class="line"><span class="keyword">var</span> _ io.Writer = (*bytes.Buffer)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>非空的接口类型比如io.Writer经常被指针类型实现，尤其当一个或多个接口方法像Write方法那样隐式的给接收者带来变化的时候。一个结构体的指针是非常常见的承载方法的类型。</p>
<p>**但是并不意味着只有指针类型满足接口类型，甚至连一些有设置方法的接口类型也可能会被Go语言中其它的引用类型实现。**我们已经看过slice类型的方法（<code>geometry.Path</code>，§6.1）和map类型的方法（<code>url.Values</code>，§6.2.1），后面还会看到函数类型的方法的例子（<code>http.HandlerFunc</code>，§7.7）。**甚至基本的类型也可能会实现一些接口；**就如我们在7.4章中看到的<code>time.Duration</code>类型实现了<code>fmt.Stringer</code>接口。</p>
<p>一个具体的类型可能实现了很多不相关的接口。考虑在一个组织出售数字文化产品比如音乐，电影和书籍的程序中可能定义了下列的具体类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Album</span><br><span class="line">Book</span><br><span class="line">Movie</span><br><span class="line">Magazine</span><br><span class="line">Podcast</span><br><span class="line">TVEpisode</span><br><span class="line">Track</span><br></pre></td></tr></table></figure>

<p>我们可以把每个抽象的特点用接口来表示。一些特性对于所有的这些文化产品都是共通的，例如标题，创作日期和作者列表。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Artifact <span class="keyword">interface</span> &#123;</span><br><span class="line">    Title() <span class="type">string</span></span><br><span class="line">    Creators() []<span class="type">string</span></span><br><span class="line">    Created() time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它的一些特性只对特定类型的文化产品才有。和文字排版特性相关的只有books和magazines，还有只有movies和TV剧集和屏幕分辨率相关。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Text <span class="keyword">interface</span> &#123;</span><br><span class="line">    Pages() <span class="type">int</span></span><br><span class="line">    Words() <span class="type">int</span></span><br><span class="line">    PageSize() <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Audio <span class="keyword">interface</span> &#123;</span><br><span class="line">    Stream() (io.ReadCloser, <span class="type">error</span>)</span><br><span class="line">    RunningTime() time.Duration</span><br><span class="line">    Format() <span class="type">string</span> <span class="comment">// e.g., &quot;MP3&quot;, &quot;WAV&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Video <span class="keyword">interface</span> &#123;</span><br><span class="line">    Stream() (io.ReadCloser, <span class="type">error</span>)</span><br><span class="line">    RunningTime() time.Duration</span><br><span class="line">    Format() <span class="type">string</span> <span class="comment">// e.g., &quot;MP4&quot;, &quot;WMV&quot;</span></span><br><span class="line">    Resolution() (x, y <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些接口不止是一种有用的方式来分组相关的具体类型和表示他们之间的共同特点。我们后面可能会发现其它的分组。举例，如果我们发现我们需要以同样的方式处理Audio和Video，我们可以定义一个Streamer接口来代表它们之间相同的部分而不必对已经存在的类型做改变。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Streamer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Stream() (io.ReadCloser, <span class="type">error</span>)</span><br><span class="line">    RunningTime() time.Duration</span><br><span class="line">    Format() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个具体类型的组基于它们相同的行为可以表示成一个接口类型。不像基于类的语言，他们一个类实现的接口集合需要进行显式的定义，在Go语言中我们可以在需要的时候定义一个新的抽象或者特定特点的组，而不需要修改具体类型的定义。当具体的类型来自不同的作者时这种方式会特别有用。当然也确实没有必要在具体的类型中指出这些共性。</p>
<h2 id="flag-Value接口"><a href="#flag-Value接口" class="headerlink" title="flag.Value接口"></a>flag.Value接口</h2><p>在本章，我们会学到另一个标准的接口类型<code>flag.Value</code>是怎么帮助命令行标记定义新的符号的。思考下面这个会休眠特定时间的程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> period = flag.Duration(<span class="string">&quot;period&quot;</span>, <span class="number">1</span>*time.Second, <span class="string">&quot;sleep period&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Sleeping for %v...&quot;</span>, *period)</span><br><span class="line">    time.Sleep(*period)</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在它休眠前它会打印出休眠的时间周期。<code>fmt</code>包调用<code>time.Duration</code>的<code>String</code>方法打印这个时间周期是以用户友好的注解方式，而不是一个纳秒数字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch7/sleep</span><br><span class="line">$ ./sleep</span><br><span class="line">Sleeping for 1s...</span><br></pre></td></tr></table></figure>

<p>默认情况下，休眠周期是一秒，但是可以通过 <code>-period</code> 这个命令行标记来控制。<code>flag.Duration</code>函数创建一个<code>time.Duration</code>类型的标记变量并且允许用户通过多种用户友好的方式来设置这个变量的大小，这种方式还包括和<code>String</code>方法相同的符号排版形式。这种对称设计使得用户交互良好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./sleep -period 50ms</span><br><span class="line">Sleeping for 50ms...</span><br><span class="line">$ ./sleep -period 2m30s</span><br><span class="line">Sleeping for 2m30s...</span><br><span class="line">$ ./sleep -period 1.5h</span><br><span class="line">Sleeping for 1h30m0s...</span><br><span class="line">$ ./sleep -period &quot;1 day&quot;</span><br><span class="line">invalid value &quot;1 day&quot; for flag -period: time: invalid duration 1 day</span><br></pre></td></tr></table></figure>

<p>因为时间周期标记值非常的有用，所以这个特性被构建到了<code>flag</code>包中。<strong>通过实现<code>flag.Value</code>接口，我们可以为我们自己的数据类型定义新的标记符号。</strong> 如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> flag</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value is the interface to the value stored in a flag.</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">    Set(<span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code>方法格式化标记的值用在命令行帮助消息中；这样每一个<code>flag.Value</code>也是一个<code>fmt.Stringer</code>。<code>Set</code>方法解析它的字符串参数并且更新标记变量的值。实际上，<code>Set</code>方法和<code>String</code>是两个相反的操作，所以最好的办法就是对他们使用相同的注解方式。</p>
<p>让我们定义一个允许通过摄氏度或者华氏温度变换的形式指定温度的<code>celsiusFlag</code>类型。注意<code>celsiusFlag</code>内嵌了一个<code>Celsius</code>类型（§2.5），因此不用实现本身就已经有<code>String</code>方法了。为了实现<code>flag.Value</code>，我们只需要定义<code>Set</code>方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// *celsiusFlag satisfies the flag.Value interface.</span></span><br><span class="line"><span class="keyword">type</span> celsiusFlag <span class="keyword">struct</span>&#123; Celsius &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *celsiusFlag)</span></span> Set(s <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> unit <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> value <span class="type">float64</span></span><br><span class="line">    fmt.Sscanf(s, <span class="string">&quot;%f%s&quot;</span>, &amp;value, &amp;unit) <span class="comment">// no error check needed</span></span><br><span class="line">    <span class="keyword">switch</span> unit &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>, <span class="string">&quot;°C&quot;</span>:</span><br><span class="line">        f.Celsius = Celsius(value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;F&quot;</span>, <span class="string">&quot;°F&quot;</span>:</span><br><span class="line">        f.Celsius = FToC(Fahrenheit(value))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid temperature %q&quot;</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>fmt.Sscanf</code>函数从输入<code>s</code>中解析一个浮点数（value）和一个字符串（unit）。虽然通常必须检查<code>Sscanf</code>的错误返回，但是在这个例子中我们不需要，因为如果有错误发生，就没有switch case会匹配到。</p>
<p>下面的<code>CelsiusFlag</code>函数将所有逻辑都封装在一起。它返回一个内嵌在<code>celsiusFlag</code>变量<code>f</code>中的<code>Celsius</code>指针给调用者。<code>Celsius</code>字段是一个会通过<code>Set</code>方法在标记处理的过程中更新的变量。调用<code>Var</code>方法将标记加入应用的命令行标记集合中，有异常复杂命令行接口的全局变量<code>flag.CommandLine.Programs</code>可能有几个这个类型的变量。调用<code>Var</code>方法将一个<code>*celsiusFlag</code>参数赋值给一个<code>flag.Value</code>参数，导致编译器去检查<code>*celsiusFlag</code>是否有必须的方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CelsiusFlag defines a Celsius flag with the specified name,</span></span><br><span class="line"><span class="comment">// default value, and usage, and returns the address of the flag variable.</span></span><br><span class="line"><span class="comment">// The flag argument must have a quantity and a unit, e.g., &quot;100C&quot;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CelsiusFlag</span><span class="params">(name <span class="type">string</span>, value Celsius, usage <span class="type">string</span>)</span></span> *Celsius &#123;</span><br><span class="line">    f := celsiusFlag&#123;value&#125;</span><br><span class="line">    flag.CommandLine.Var(&amp;f, name, usage)</span><br><span class="line">    <span class="keyword">return</span> &amp;f.Celsius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以开始在我们的程序中使用新的标记：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = tempconv.CelsiusFlag(<span class="string">&quot;temp&quot;</span>, <span class="number">20.0</span>, <span class="string">&quot;the temperature&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Println(*temp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是典型的场景：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch7/tempflag</span><br><span class="line">$ ./tempflag</span><br><span class="line">20°C</span><br><span class="line">$ ./tempflag -temp -18C</span><br><span class="line">-18°C</span><br><span class="line">$ ./tempflag -temp 212°F</span><br><span class="line">100°C</span><br><span class="line">$ ./tempflag -temp 273.15K</span><br><span class="line">invalid value &quot;273.15K&quot; for flag -temp: invalid temperature &quot;273.15K&quot;</span><br><span class="line">Usage of ./tempflag:</span><br><span class="line">  -temp value</span><br><span class="line">        the temperature (default 20°C)</span><br><span class="line">$ ./tempflag -help</span><br><span class="line">Usage of ./tempflag:</span><br><span class="line">  -temp value</span><br><span class="line">        the temperature (default 20°C)</span><br></pre></td></tr></table></figure>

<h2 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h2><p>**<em>接口值</em> 由2个部分组成：一个具体的类型和这个类型的值。它们被称为接口的动态类型和动态值。**对于像Go语言这种静态类型的语言，类型是编译期的概念；因此一个类型不是一个值。在我们的概念模型中，一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符。</p>
<p>下面4个语句中，变量<code>w</code>得到了3个不同的值。（开始和最后的值是相同的）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer  <span class="comment">// 由于隐式初始化，等价于 var w io.Writer = nil</span></span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>让我们进一步观察在每一个语句后的<code>w</code>变量的值和动态行为。第一个语句定义了变量<code>w</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br></pre></td></tr></table></figure>

<p><strong>在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是<code>nil</code>（如图7.1）。</strong></p>
<p><img src="/2022/notes-of-gopl/ch7-01.png" alt="img"></p>
<p><strong>一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值（接口值为<code>nil</code>）。你可以通过使用<code>w==nil</code>或者<code>w!=nil</code>来判断接口值是否为空。调用一个空接口值（接口值为<code>nil</code>）上的任意方法都会产生panic:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// panic: nil pointer dereference</span></span><br></pre></td></tr></table></figure>

<p>第二个语句将一个<code>*os.File</code>类型的值赋给变量<code>w</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w = os.Stdout</span><br></pre></td></tr></table></figure>

<p>这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用<code>io.Writer(os.Stdout)</code>是等价的。这类转换不管是显式的还是隐式的，都会刻画出操作到的类型和值。这个接口值的动态类型被设为<code>*os.File</code>指针的类型描述符，它的动态值持有<code>os.Stdout</code>的拷贝；这是一个代表处理标准输出的<code>os.File</code>类型变量的指针（如图7.2）。</p>
<p><img src="/2022/notes-of-gopl/ch7-02.png" alt="img"></p>
<p>调用一个包含<code>*os.File</code>类型指针的接口值的<code>Write</code>方法，使得<code>(*os.File).Write</code>方法被调用。这个调用输出“hello”。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法<code>Write</code>上，然后间接调用那个地址。这个调用的接收者是一个接口动态值的拷贝<code>os.Stdout</code>。效果和下面这个直接调用一样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">os.Stdout.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>第三个语句给接口值赋了一个<code>*bytes.Buffer</code>类型的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>

<p>现在动态类型是<code>*bytes.Buffer</code>并且动态值是一个指向新分配的缓冲区的指针（图7.3）。</p>
<p><img src="/2022/notes-of-gopl/ch7-03.png" alt="img"></p>
<p><code>Write</code>方法的调用也使用了和之前一样的机制：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// writes &quot;hello&quot; to the bytes.Buffers</span></span><br></pre></td></tr></table></figure>

<p>这次类型描述符是<code>*bytes.Buffer</code>，所以调用了<code>(*bytes.Buffer).Write</code>方法，并且接收者是该缓冲区的地址。这个调用把字符串“hello”添加到缓冲区中。</p>
<p>最后，第四个语句将<code>nil</code>赋给了接口值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>这个重置将它所有的部分都设为<code>nil</code>值，把变量<code>w</code>恢复到和它之前定义时相同的状态，在图7.1中可以看到。</p>
<p>一个接口值可以持有任意大的动态值。例如，表示时间实例的<code>time.Time</code>类型，这个类型有几个对外不公开的字段。我们从它上面创建一个接口值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = time.Now()</span><br></pre></td></tr></table></figure>

<p>结果可能和图7.4相似。从概念上讲，不论接口值多大，动态值总是可以容下它。（这只是一个概念上的模型；具体的实现可能会非常不同）</p>
<p><img src="/2022/notes-of-gopl/ch7-04.png" alt="img"></p>
<p><strong>接口值可以使用<code>==</code>和<code>!＝</code>来进行比较。两个接口值相等仅当它们都是<code>nil</code>值，或者它们的动态类型相同并且动态值也根据这个动态类型的<code>==</code>操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。</strong></p>
<p><strong>然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(x == x) <span class="comment">// panic: comparing uncomparable type []int</span></span><br></pre></td></tr></table></figure>

<p><strong>考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值。</strong></p>
<p>当我们处理错误或者调试的过程中，得知接口值的动态类型是非常有帮助的。所以我们使用<code>fmt</code>包的<code>%T</code>动作:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, w) <span class="comment">// &quot;&lt;nil&gt;&quot;</span></span><br><span class="line">w = os.Stdout</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, w) <span class="comment">// &quot;*os.File&quot;</span></span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, w) <span class="comment">// &quot;*bytes.Buffer&quot;</span></span><br></pre></td></tr></table></figure>

<p>在<code>fmt</code>包内部，使用反射来获取接口动态类型的名称。</p>
<h3 id="警告：一个包含nil指针的接口不是nil接口"><a href="#警告：一个包含nil指针的接口不是nil接口" class="headerlink" title="警告：一个包含nil指针的接口不是nil接口"></a>警告：一个包含<code>nil</code>指针的接口不是<code>nil</code>接口</h3><p>**一个不包含任何值的<code>nil</code>接口值和一个刚好包含<code>nil</code>指针的接口值是不同的。**这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。</p>
<p>思考下面的程序。当<code>debug</code>变量设置为<code>true</code>时，<code>main</code>函数会将<code>f</code>函数的输出收集到一个<code>bytes.Buffer</code>类型中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        buf = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// enable collection of output</span></span><br><span class="line">    &#125;</span><br><span class="line">    f(buf) <span class="comment">// <span class="doctag">NOTE:</span> subtly incorrect!</span></span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        <span class="comment">// ...use buf...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If out is non-nil, output will be written to it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...do something...</span></span><br><span class="line">    <span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">        out.Write([]<span class="type">byte</span>(<span class="string">&quot;done!\n&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可能会预计当把变量<code>debug</code>设置为<code>false</code>时可以禁止对输出的收集，但是实际上在<code>out.Write</code>方法调用时程序发生了panic：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">    out.Write([]<span class="type">byte</span>(<span class="string">&quot;done!\n&quot;</span>)) <span class="comment">// panic: nil pointer dereference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当<code>main</code>函数调用函数<code>f</code>时，它给<code>f</code>函数的<code>out</code>参数赋了一个<code>*bytes.Buffer</code>的空指针，所以<code>out</code>的动态值是<code>nil</code>。然而，它的动态类型是<code>*bytes.Buffer</code>，意思就是<code>out</code>变量是一个包含空指针值的非空接口（如图7.5），所以防御性检查<code>out!=nil</code>的结果依然是<code>true</code>。</strong></p>
<p><img src="/2022/notes-of-gopl/ch7-05.png" alt="img"></p>
<p><strong>动态分配机制依然决定<code>(*bytes.Buffer).Write</code>的方法会被调用，但是这次的接收者的值是<code>nil</code>。对于一些如<code>*os.File</code>的类型，<code>nil</code>是一个有效的接收者（§6.2.1），但是<code>*bytes.Buffer</code>类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。</strong></p>
<p>问题在于尽管一个<code>nil</code>的<code>*bytes.Buffer</code>指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了<code>(*bytes.Buffer).Write</code>方法隐含的先决条件，即，它的接收者不能是<code>nil</code>；所以将<code>nil</code>指针赋给这个接口是错误的。解决方案就是将<code>main</code>函数中的变量<code>buf</code>的类型改为<code>io.Writer</code>，因此可以避免一开始就将一个不完整的值赋给这个接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf io.Writer</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">    buf = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// enable collection of output</span></span><br><span class="line">&#125;</span><br><span class="line">f(buf) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>打印前文中的代码，似乎只有当接口的动态类型和动态值都为<code>nil</code>时，<code>w == nil</code>才为真：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">fmt.Println(w == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">w = os.Stdout</span><br><span class="line">fmt.Println(w == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">fmt.Println(w == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">w = <span class="literal">nil</span></span><br><span class="line">fmt.Println(w == <span class="literal">nil</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="sort-Interface接口"><a href="#sort-Interface接口" class="headerlink" title="sort.Interface接口"></a><code>sort.Interface</code>接口</h2><p><code>sort</code>包内置的提供了根据一些排序函数来对任何序列排序的功能。它的设计非常独到。在很多语言中，排序算法都是和序列数据类型关联，同时排序函数和具体类型元素关联。相比之下，Go语言的<code>sort.Sort</code>函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型<code>sort.Interface</code>来指定通用的排序算法和可能被排序到的序列类型之间的约定。这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片。</p>
<p>一个内置的排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式；这就是<code>sort.Interface</code>的三个方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span> <span class="comment">// i, j are indices of sequence elements</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用<code>sort.Sort</code>函数。思考对一个字符串切片进行排序，这可能是最简单的例子了。下面是这个新的类型<code>StringSlice</code>和它的<code>Len</code>，<code>Less</code>和<code>Swap</code>方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span></span> Swap(i, j <span class="type">int</span>)      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以通过像下面这样将一个切片转换为一个<code>StringSlice</code>类型来进行排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sort.Sort(StringSlice(names))</span><br></pre></td></tr></table></figure>

<p>这个转换得到一个相同长度，容量，和基于<code>names</code>数组的切片值；并且这个切片值的类型有三个排序需要的方法。</p>
<p>对字符串切片的排序是很常用的需要，所以<code>sort</code>包提供了<code>StringSlice</code>类型，也提供了<code>Strings</code>函数能让上面这些调用简化成<code>sort.Strings(names)</code>。</p>
<p>这里用到的技术很容易适用到其它排序序列中，例如我们可以忽略大小写或者含有的特殊字符。（本书使用Go程序对索引词和页码进行排序也用到了这个技术，对罗马数字做了额外逻辑处理。）对于更复杂的排序，我们使用相同的方法，但是会用更复杂的数据结构和更复杂地实现<code>sort.Interface</code>的方法。</p>
<p>我们会运行上面的例子来对一个表格中的音乐播放列表进行排序。每个track都是单独的一行，每一列都是这个track的属性像艺术家，标题，和运行时间。想象一个图形用户界面来呈现这个表格，并且点击一个属性的顶部会使这个列表按照这个属性进行排序；再一次点击相同属性的顶部会进行逆向排序。让我们看下每个点击会发生什么响应。</p>
<p>下面的变量<code>tracks</code>包含了一个播放列表。（One of the authors apologizes for the other author’s musical tastes.）每个元素都不是<code>Track</code>本身而是指向它的指针。尽管我们在下面的代码中直接存储<code>Tracks</code>也可以工作，<code>sort</code>函数会交换很多对元素，所以如果每个元素都是指针而不是<code>Track</code>类型会更快，指针是一个机器字码长度而<code>Track</code>类型可能是八个或更多。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Track <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title  <span class="type">string</span></span><br><span class="line">    Artist <span class="type">string</span></span><br><span class="line">    Album  <span class="type">string</span></span><br><span class="line">    Year   <span class="type">int</span></span><br><span class="line">    Length time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tracks = []*Track&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Delilah&quot;</span>, <span class="string">&quot;From the Roots Up&quot;</span>, <span class="number">2012</span>, length(<span class="string">&quot;3m38s&quot;</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Moby&quot;</span>, <span class="string">&quot;Moby&quot;</span>, <span class="number">1992</span>, length(<span class="string">&quot;3m37s&quot;</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Go Ahead&quot;</span>, <span class="string">&quot;Alicia Keys&quot;</span>, <span class="string">&quot;As I Am&quot;</span>, <span class="number">2007</span>, length(<span class="string">&quot;4m36s&quot;</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Ready 2 Go&quot;</span>, <span class="string">&quot;Martin Solveig&quot;</span>, <span class="string">&quot;Smash&quot;</span>, <span class="number">2011</span>, length(<span class="string">&quot;4m24s&quot;</span>)&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">length</span><span class="params">(s <span class="type">string</span>)</span></span> time.Duration &#123;</span><br><span class="line">    d, err := time.ParseDuration(s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>printTracks</code>函数将播放列表打印成一个表格。一个图形化的展示可能会更好点，但是这个小程序使用<code>text/tabwriter</code>包来生成一个列整齐对齐和隔开的表格，像下面展示的这样。注意到<code>*tabwriter.Writer</code>是满足<code>io.Writer</code>接口的。它会收集每一片写向它的数据；它的<code>Flush</code>方法会格式化整个表格并且将它写向<code>os.Stdout</code>（标准输出）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTracks</span><span class="params">(tracks []*Track)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> format = <span class="string">&quot;%v\t%v\t%v\t%v\t%v\t\n&quot;</span></span><br><span class="line">    tw := <span class="built_in">new</span>(tabwriter.Writer).Init(os.Stdout, <span class="number">0</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    fmt.Fprintf(tw, format, <span class="string">&quot;Title&quot;</span>, <span class="string">&quot;Artist&quot;</span>, <span class="string">&quot;Album&quot;</span>, <span class="string">&quot;Year&quot;</span>, <span class="string">&quot;Length&quot;</span>)</span><br><span class="line">    fmt.Fprintf(tw, format, <span class="string">&quot;-----&quot;</span>, <span class="string">&quot;------&quot;</span>, <span class="string">&quot;-----&quot;</span>, <span class="string">&quot;----&quot;</span>, <span class="string">&quot;------&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> tracks &#123;</span><br><span class="line">        fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length)</span><br><span class="line">    &#125;</span><br><span class="line">    tw.Flush() <span class="comment">// calculate column widths and print table</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了能按照<code>Artist</code>字段对播放列表进行排序，我们会像对<code>StringSlice</code>那样定义一个新的带有必须的<code>Len</code>，<code>Less</code>和<code>Swap</code>方法的切片类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> byArtist []*Track</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byArtist)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(x) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byArtist)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> x[i].Artist &lt; x[j].Artist &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byArtist)</span></span> Swap(i, j <span class="type">int</span>)      &#123; x[i], x[j] = x[j], x[i] &#125;</span><br></pre></td></tr></table></figure>

<p>为了调用通用的排序程序，我们必须先将<code>tracks</code>转换为新的<code>byArtist</code>类型，它定义了具体的排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sort.Sort(byArtist(tracks))</span><br></pre></td></tr></table></figure>

<p>在按照<code>artist</code>对这个切片进行排序后，<code>printTrack</code>的输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Title       Artist          Album               Year Length</span><br><span class="line">-----       ------          -----               ---- ------</span><br><span class="line">Go Ahead    Alicia Keys     As I Am             2007 4m36s</span><br><span class="line">Go          Delilah         From the Roots Up   2012 3m38s</span><br><span class="line">Ready 2 Go  Martin Solveig  Smash               2011 4m24s</span><br><span class="line">Go          Moby            Moby                1992 3m37s</span><br></pre></td></tr></table></figure>

<p>如果用户第二次请求“按照artist排序”，我们会对<code>tracks</code>进行逆向排序。然而我们不需要定义一个有颠倒<code>Less</code>方法的新类型<code>byReverseArtist</code>，因为<code>sort</code>包中提供了<code>Reverse</code>函数将排序顺序转换成逆序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sort.Sort(sort.Reverse(byArtist(tracks)))</span><br></pre></td></tr></table></figure>

<p>在按照<code>artist</code>对这个切片进行逆向排序后，<code>printTrack</code>的输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Title       Artist          Album               Year Length</span><br><span class="line">-----       ------          -----               ---- ------</span><br><span class="line">Go          Moby            Moby                1992 3m37s</span><br><span class="line">Ready 2 Go  Martin Solveig  Smash               2011 4m24s</span><br><span class="line">Go          Delilah         From the Roots Up   2012 3m38s</span><br><span class="line">Go Ahead    Alicia Keys     As I Am             2007 4m36s</span><br></pre></td></tr></table></figure>

<p><code>sort.Reverse</code>函数值得进行更近一步的学习，因为它使用了（§6.3）章中的组合，这是一个重要的思路。<code>sort</code>包定义了一个不公开的struct类型reverse，它嵌入了一个<code>sort.Interface</code>。<code>reverse</code>的<code>Less</code>方法调用了内嵌的<code>sort.Interface</code>值的<code>Less</code>方法，但是通过交换索引的方式使排序结果变成逆序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reverse <span class="keyword">struct</span>&#123; Interface &#125; <span class="comment">// that is, sort.Interface</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> r.Interface.Less(j, i) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span></span> Interface &#123; <span class="keyword">return</span> reverse&#123;data&#125; &#125;</span><br></pre></td></tr></table></figure>

<p><code>reverse</code>的另外两个方法<code>Len</code>和<code>Swap</code>隐式地由原有内嵌的<code>sort.Interface</code>提供。因为<code>reverse</code>是一个不公开的类型，所以导出函数<code>Reverse</code>返回一个包含原有<code>sort.Interface</code>值的<code>reverse</code>类型实例。</p>
<p>为了可以按照不同的列进行排序，我们必须定义一个新的类型例如<code>byYear</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> byYear []*Track</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byYear)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(x) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byYear)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> x[i].Year &lt; x[j].Year &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byYear)</span></span> Swap(i, j <span class="type">int</span>)      &#123; x[i], x[j] = x[j], x[i] &#125;</span><br></pre></td></tr></table></figure>

<p>在使用<code>sort.Sort(byYear(tracks))</code>按照年对<code>tracks</code>进行排序后，<code>printTrack</code>展示了一个按时间先后顺序的列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Title       Artist          Album               Year Length</span><br><span class="line">-----       ------          -----               ---- ------</span><br><span class="line">Go          Moby            Moby                1992 3m37s</span><br><span class="line">Go Ahead    Alicia Keys     As I Am             2007 4m36s</span><br><span class="line">Ready 2 Go  Martin Solveig  Smash               2011 4m24s</span><br><span class="line">Go          Delilah         From the Roots Up   2012 3m38s</span><br></pre></td></tr></table></figure>

<p>对于我们需要的每个切片元素类型和每个排序函数，我们需要定义一个新的<code>sort.Interface</code>实现。如你所见，<code>Len</code>和<code>Swap</code>方法对于所有的切片类型都有相同的定义。下个例子，具体的类型<code>customSort</code>会将一个切片和函数结合，使我们只需要写比较函数就可以定义一个新的排序。<strong>顺便说下，实现了<code>sort.Interface</code>的具体类型不一定是切片类型；<code>customSort</code>是一个结构体类型。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> customSort <span class="keyword">struct</span> &#123;</span><br><span class="line">    t    []*Track</span><br><span class="line">    less <span class="function"><span class="keyword">func</span><span class="params">(x, y *Track)</span></span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(x.t) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> x.less(x.t[i], x.t[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Swap(i, j <span class="type">int</span>)    &#123; x.t[i], x.t[j] = x.t[j], x.t[i] &#125;</span><br></pre></td></tr></table></figure>

<p>让我们定义一个多层的排序函数，它主要的排序键是标题，第二个键是年，第三个键是运行时间<code>Length</code>。下面是该排序的调用，其中这个排序使用了匿名排序函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sort.Sort(customSort&#123;tracks, <span class="function"><span class="keyword">func</span><span class="params">(x, y *Track)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.Title != y.Title &#123;</span><br><span class="line">        <span class="keyword">return</span> x.Title &lt; y.Title</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> x.Year != y.Year &#123;</span><br><span class="line">        <span class="keyword">return</span> x.Year &lt; y.Year</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> x.Length != y.Length &#123;</span><br><span class="line">        <span class="keyword">return</span> x.Length &lt; y.Length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>这下面是排序的结果。注意到两个标题是“Go”的<code>track</code>按照标题排序是相同的顺序，但是在按照<code>year</code>排序上更久的那个<code>track</code>优先。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Title       Artist          Album               Year Length</span><br><span class="line">-----       ------          -----               ---- ------</span><br><span class="line">Go          Moby            Moby                1992 3m37s</span><br><span class="line">Go          Delilah         From the Roots Up   2012 3m38s</span><br><span class="line">Go Ahead    Alicia Keys     As I Am             2007 4m36s</span><br><span class="line">Ready 2 Go  Martin Solveig  Smash               2011 4m24s</span><br></pre></td></tr></table></figure>

<p>尽管对长度为n的序列排序需要 O(n log n)次比较操作，检查一个序列是否已经有序至少需要n-1次比较。<strong><code>sort</code>包中的<code>IsSorted</code>函数可以检查一个序列是否已经有序。像<code>sort.Sort</code>一样，它也使用<code>sort.Interface</code>对这个序列和它的排序函数进行抽象，但是它从不会调用<code>Swap</code>方法。</strong> 这段代码示范了<code>IntsAreSorted</code>和<code>Ints</code>函数在<code>IntSlice</code>类型上的使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">values := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>&#125;</span><br><span class="line">fmt.Println(sort.IntsAreSorted(values)) <span class="comment">// &quot;false&quot;</span></span><br><span class="line">sort.Ints(values)</span><br><span class="line">fmt.Println(values)                     <span class="comment">// &quot;[1 1 3 4]&quot;</span></span><br><span class="line">fmt.Println(sort.IntsAreSorted(values)) <span class="comment">// &quot;true&quot;</span></span><br><span class="line">sort.Sort(sort.Reverse(sort.IntSlice(values)))</span><br><span class="line">fmt.Println(values)                     <span class="comment">// &quot;[4 3 1 1]&quot;</span></span><br><span class="line">fmt.Println(sort.IntsAreSorted(values)) <span class="comment">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<p>为了使用方便，<code>sort</code>包为<code>[]int</code>、<code>[]string</code>和<code>[]float64</code>的正常排序提供了特定版本的函数和类型。对于其他类型，例如<code>[]int64</code>或者<code>[]uint</code>，尽管路径也很简单，还是依赖我们自己实现。</p>
<h2 id="http-Handler接口"><a href="#http-Handler接口" class="headerlink" title="http.Handler接口"></a><code>http.Handler</code>接口</h2><p>在第一章中，我们粗略的了解了怎么用<code>net/http</code>包去实现网络客户端（§1.5）和服务器（§1.7）。在这个小节中，我们会对那些基于<code>http.Handler</code>接口的服务器API做更进一步的学习：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(w ResponseWriter, r *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(address <span class="type">string</span>, h Handler)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p><code>ListenAndServe</code>函数需要一个例如<code>&quot;localhost:8000&quot;</code>的服务器地址，和一个所有请求都可以分派的Handler接口实例。它会一直运行，直到这个服务因为一个错误而失败（或者启动失败），它的返回值一定是一个非空的错误。</p>
<p>想象一个电子商务网站，为了销售，将数据库中物品的价格映射成美元。下面这个程序可能是能想到的最简单的实现了。它将库存清单模型化为一个命名为<code>database</code>的<code>map</code>类型，我们给这个类型一个<code>ServeHttp</code>方法，这样它可以满足<code>http.Handler</code>接口。这个handler会遍历整个map并输出物品信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">&quot;shoes&quot;</span>: <span class="number">50</span>, <span class="string">&quot;socks&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, db))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dollars <span class="type">float32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dollars)</span></span> String() <span class="type">string</span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;$%.2f&quot;</span>, d) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> database <span class="keyword">map</span>[<span class="type">string</span>]dollars</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    <span class="keyword">for</span> item, price := <span class="keyword">range</span> db &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;%s: %s\n&quot;</span>, item, price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们启动这个服务，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch7/http1</span><br><span class="line">$ ./http1 &amp;</span><br></pre></td></tr></table></figure>

<p>然后用1.5节中的获取程序（如果你更喜欢可以使用web浏览器）来连接服务器，我们得到下面的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch1/fetch</span><br><span class="line">$ ./fetch http://localhost:8000</span><br><span class="line">shoes: $50.00</span><br><span class="line">socks: $5.00</span><br></pre></td></tr></table></figure>

<p>目前为止，这个服务器不考虑URL，只能为每个请求列出它全部的库存清单。更真实的服务器会定义多个不同的URL，每一个都会触发一个不同的行为。让我们使用<code>/list</code>来调用已经存在的这个行为并且增加另一个<code>/price</code>调用表明单个货品的价格，像这样<code>/price?item=socks</code>来指定一个请求参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    <span class="keyword">switch</span> req.URL.Path &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;/list&quot;</span>:</span><br><span class="line">        <span class="keyword">for</span> item, price := <span class="keyword">range</span> db &#123;</span><br><span class="line">            fmt.Fprintf(w, <span class="string">&quot;%s: %s\n&quot;</span>, item, price)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;/price&quot;</span>:</span><br><span class="line">        item := req.URL.Query().Get(<span class="string">&quot;item&quot;</span>)</span><br><span class="line">        price, ok := db[item]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            w.WriteHeader(http.StatusNotFound) <span class="comment">// 404</span></span><br><span class="line">            fmt.Fprintf(w, <span class="string">&quot;no such item: %q\n&quot;</span>, item)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;%s\n&quot;</span>, price)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        w.WriteHeader(http.StatusNotFound) <span class="comment">// 404</span></span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;no such page: %s\n&quot;</span>, req.URL)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在handler基于URL的路径部分（<code>req.URL.Path</code>）来决定执行什么逻辑。如果这个handler不能识别这个路径，它会通过调用<code>w.WriteHeader(http.StatusNotFound)</code>返回客户端一个HTTP错误；这个检查应该在向<code>w</code>写入任何值前完成。（顺便提一下，<code>http.ResponseWriter</code>是另一个接口。它在<code>io.Writer</code>上增加了发送HTTP相应头的方法。）等效地，我们可以使用实用的<code>http.Error</code>函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">msg := fmt.Sprintf(<span class="string">&quot;no such page: %s\n&quot;</span>, req.URL)</span><br><span class="line">http.Error(w, msg, http.StatusNotFound) <span class="comment">// 404</span></span><br></pre></td></tr></table></figure>

<p><code>/price</code>的case会调用URL的Query方法来将HTTP请求参数解析为一个map，或者更准确地说一个<code>net/url</code>包中<code>url.Values</code>类型的多重映射。然后找到第一个<code>item</code>参数并查找它的价格。如果这个货品没有找到会返回一个错误。</p>
<p>这里是一个和新服务器会话的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch7/http2</span><br><span class="line">$ go build gopl.io/ch1/fetch</span><br><span class="line">$ ./http2 &amp;</span><br><span class="line">$ ./fetch http://localhost:8000/list</span><br><span class="line">shoes: $50.00</span><br><span class="line">socks: $5.00</span><br><span class="line">$ ./fetch http://localhost:8000/price?item=socks</span><br><span class="line">$5.00</span><br><span class="line">$ ./fetch http://localhost:8000/price?item=shoes</span><br><span class="line">$50.00</span><br><span class="line">$ ./fetch http://localhost:8000/price?item=hat</span><br><span class="line">no such item: &quot;hat&quot;</span><br><span class="line">$ ./fetch http://localhost:8000/help</span><br><span class="line">no such page: /help</span><br></pre></td></tr></table></figure>

<p>显然我们可以继续向<code>ServeHTTP</code>方法中添加case，但在一个实际的应用中，将每个case中的逻辑定义到一个分开的方法或函数中会很实用。此外，相近的URL可能需要相似的逻辑；例如几个图片文件可能有形如<code>/images/*.png的</code>URL。因为这些原因，<code>net/http</code>包提供了一个请求多路器<code>ServeMux</code>来简化URL和handlers的联系。一个<code>ServeMux</code>将一批<code>http.Handler</code>聚集到一个单一的<code>http.Handler</code>中。再一次，我们可以看到满足同一接口的不同类型是可替换的：web服务器将请求指派给任意的<code>http.Handler</code> 而不需要考虑它后面的具体类型。</p>
<p>对于更复杂的应用，一些<code>ServeMux</code>可以通过组合来处理更加错综复杂的路由需求。Go语言目前没有一个权威的web框架，类似Ruby语言有Rails和python有Django。这并不是说这样的框架不存在，而是Go语言标准库中的构建模块就已经非常灵活以至于这些框架都是不必要的。此外，尽管在一个项目早期使用框架是非常方便的，但是它们带来额外的复杂度会使长期的维护更加困难。</p>
<p>在下面的程序中，我们创建一个<code>ServeMux</code>并且使用它将URL和相应处理<code>/list</code>和<code>/price</code>操作的handler联系起来，这些操作逻辑都已经被分到不同的方法中。然后我们在调用<code>ListenAndServe</code>函数中使用<code>ServeMux</code>为主要的handler。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">&quot;shoes&quot;</span>: <span class="number">50</span>, <span class="string">&quot;socks&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.Handle(<span class="string">&quot;/list&quot;</span>, http.HandlerFunc(db.list))</span><br><span class="line">    mux.Handle(<span class="string">&quot;/price&quot;</span>, http.HandlerFunc(db.price))</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, mux))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> database <span class="keyword">map</span>[<span class="type">string</span>]dollars</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span></span> list(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    <span class="keyword">for</span> item, price := <span class="keyword">range</span> db &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;%s: %s\n&quot;</span>, item, price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span></span> price(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    item := req.URL.Query().Get(<span class="string">&quot;item&quot;</span>)</span><br><span class="line">    price, ok := db[item]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        w.WriteHeader(http.StatusNotFound) <span class="comment">// 404</span></span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;no such item: %q\n&quot;</span>, item)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;%s\n&quot;</span>, price)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们关注这两个注册到handlers上的调用。第一个<code>db.list</code>是一个方法值（§6.4），它是下面这个类型的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span></span><br></pre></td></tr></table></figure>

<p>也就是说<code>db.list</code>的调用会援引一个接收者是db的<code>database.list</code>方法。所以<code>db.list</code>是一个实现了handler类似行为的函数，但是因为它没有方法（理解：该方法没有它自己的方法），所以它不满足<code>http.Handler</code>接口并且不能直接传给<code>mux.Handle</code>。</p>
<p>语句<code>http.HandlerFunc(db.list)</code>是一个转换而非一个函数调用，因为<code>http.HandlerFunc</code>是一个类型。它有如下的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(w ResponseWriter, r *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HandlerFunc</code>显示了在Go语言接口机制中一些不同寻常的特点。这是一个实现了接口<code>http.Handler</code>的方法的函数类型。<code>ServeHTTP</code>方法的行为是调用了它的函数本身。因此<code>HandlerFunc</code>是一个让函数值满足一个接口的适配器，这里函数和这个接口仅有的方法有相同的函数签名。实际上，这个技巧让一个单一的类型例如database以多种方式满足<code>http.Handler</code>接口：一种通过它的<code>list</code>方法，一种通过它的<code>price</code>方法等等。</p>
<p>因为handler通过这种方式注册非常普遍，<code>ServeMux</code>有一个方便的<code>HandleFunc</code>方法，它帮我们简化handler注册代码成这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mux.HandleFunc(<span class="string">&quot;/list&quot;</span>, db.list)</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/price&quot;</span>, db.price)</span><br></pre></td></tr></table></figure>

<p>从上面的代码很容易看出应该怎么构建一个程序：由两个不同的web服务器监听不同的端口，并且定义不同的URL将它们指派到不同的handler。我们只要构建另外一个<code>ServeMux</code>并且再调用一次<code>ListenAndServe</code>（可能并行的）。但是在大多数程序中，一个web服务器就足够了。此外，在一个应用程序的多个文件中定义HTTP handler也是非常典型的，如果它们必须全部都显式地注册到这个应用的<code>ServeMux</code>实例上会比较麻烦。</p>
<p>所以为了方便，<code>net/http</code>包提供了一个全局的<code>ServeMux</code>实例<code>DefaultServerMux</code>和包级别的<code>http.Handle</code>和<code>http.HandleFunc</code>函数。现在，为了使用<code>DefaultServeMux</code>作为服务器的主handler，我们不需要将它传给<code>ListenAndServe</code>函数；<code>nil</code>值就可以工作。</p>
<p>然后服务器的主函数可以简化成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">&quot;shoes&quot;</span>: <span class="number">50</span>, <span class="string">&quot;socks&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/list&quot;</span>, db.list)</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/price&quot;</span>, db.price)</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后，一个重要的提示：web服务器在一个新的协程中调用每一个handler，所以当handler获取其它协程或者这个handler本身的其它请求也可以访问到变量时，一定要使用预防措施，比如锁机制。</strong></p>
<h2 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a><a href="https://gopl-zh.github.io/ch7/ch7-08.html#78-error%E6%8E%A5%E5%8F%A3">error接口</a></h2><p>从本书的开始，我们就已经创建和使用过神秘的预定义error类型，而且没有解释它究竟是什么。实际上它就是interface类型，这个类型有一个返回错误信息的单一方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个error最简单的方法就是调用<code>errors.New</code>函数，它会根据传入的错误信息返回一个新的error。整个<code>errors</code>包仅只有4行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> &amp;errorString&#123;text&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123; text <span class="type">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> e.text &#125;</span><br></pre></td></tr></table></figure>

<p>承载errorString的类型是一个结构体而非一个字符串，这是为了保护它表示的错误避免粗心（或有意）的更新。并且因为是指针类型<code>*errorString</code>满足error接口而非errorString类型，所以每个New函数的调用都分配了一个独特的和其他错误不相同的实例。我们也不想要重要的error例如<code>io.EOF</code>和一个刚好有相同错误消息的error比较后相等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(errors.New(<span class="string">&quot;EOF&quot;</span>) == errors.New(<span class="string">&quot;EOF&quot;</span>)) <span class="comment">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<p>调用<code>errors.New</code>函数是非常稀少的，因为有一个方便的封装函数<code>fmt.Errorf</code>，它还会处理字符串格式化。我们曾多次在第5章中用到它。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(Sprintf(format, args...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然<code>*errorString</code>可能是最简单的错误类型，但远非只有它一个。例如，<code>syscall</code>包提供了Go语言底层系统调用API。在多个平台上，它定义一个实现error接口的数字类型<code>Errno</code>，并且在Unix平台上，<code>Errno</code>的<code>Error</code>方法会从一个字符串表中查找错误消息，如下面展示的这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syscall</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Errno <span class="type">uintptr</span> <span class="comment">// operating system error code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> errors = [...]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="number">1</span>:   <span class="string">&quot;operation not permitted&quot;</span>,   <span class="comment">// EPERM</span></span><br><span class="line">    <span class="number">2</span>:   <span class="string">&quot;no such file or directory&quot;</span>, <span class="comment">// ENOENT</span></span><br><span class="line">    <span class="number">3</span>:   <span class="string">&quot;no such process&quot;</span>,           <span class="comment">// ESRCH</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Errno)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> &lt;= <span class="type">int</span>(e) &amp;&amp; <span class="type">int</span>(e) &lt; <span class="built_in">len</span>(errors) &#123;</span><br><span class="line">        <span class="keyword">return</span> errors[e]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;errno %d&quot;</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的语句创建了一个持有<code>Errno</code>值为<code>2</code>的接口值，表示<code>POSIX ENOENT</code>状况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> err <span class="type">error</span> = syscall.Errno(<span class="number">2</span>)</span><br><span class="line">fmt.Println(err.Error()) <span class="comment">// &quot;no such file or directory&quot;</span></span><br><span class="line">fmt.Println(err)         <span class="comment">// &quot;no such file or directory&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>err</code>的值图形化的呈现在图7.6中：</p>
<p><img src="/2022/notes-of-gopl/ch7-06.png" alt="img"></p>
<p><code>Errno</code>是一个系统调用错误的高效表示方式，它通过一个有限的集合进行描述，并且它满足标准的错误接口。我们会在第7.11节了解到其它满足这个接口的类型。</p>
<h2 id="示例-表达式求值"><a href="#示例-表达式求值" class="headerlink" title="示例: 表达式求值"></a><a href="https://gopl-zh.github.io/ch7/ch7-09.html#79-%E7%A4%BA%E4%BE%8B-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC">示例: 表达式求值</a></h2><p>在本节中，我们会构建一个简单算术表达式的求值器。我们将使用一个接口<code>Expr</code>来表示Go语言中任意的表达式。现在这个接口不需要有方法，但是我们后面会为它增加一些。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An Expr is an arithmetic expression.</span></span><br><span class="line"><span class="keyword">type</span> Expr <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们的表达式语言包括浮点数符号（小数点）；二元操作符<code>+</code>，<code>-</code>，<code>*</code>， 和<code>/</code>；一元操作符<code>-x</code>和<code>+x</code>；调用<code>pow(x,y)</code>，<code>sin(x)</code>，和<code>sqrt(x)</code>的函数；例如<code>x</code>和<code>pi</code>的变量；当然也有括号和标准的优先级运算符。所有的值都是float64类型。这下面是一些表达式的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sqrt(A / pi)</span><br><span class="line">pow(x, <span class="number">3</span>) + pow(y, <span class="number">3</span>)</span><br><span class="line">(F - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>下面的五个具体类型表示了具体的表达式类型。<code>Var</code>类型表示对一个变量的引用。（我们很快会知道为什么它可以被输出。）<code>literal</code>类型表示一个浮点型常量。<code>unary</code>和<code>binary</code>类型表示有一到两个运算对象的运算符表达式，这些操作数可以是任意的<code>Expr</code>类型。<code>call</code>类型表示对一个函数的调用；我们限制它的<code>fn</code>字段只能是<code>pow</code>，<code>sin</code>或者<code>sqrt</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Var identifies a variable, e.g., x.</span></span><br><span class="line"><span class="keyword">type</span> Var <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A literal is a numeric constant, e.g., 3.141.</span></span><br><span class="line"><span class="keyword">type</span> literal <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A unary represents a unary operator expression, e.g., -x.</span></span><br><span class="line"><span class="keyword">type</span> unary <span class="keyword">struct</span> &#123;</span><br><span class="line">    op <span class="type">rune</span> <span class="comment">// one of &#x27;+&#x27;, &#x27;-&#x27;</span></span><br><span class="line">    x  Expr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A binary represents a binary operator expression, e.g., x+y.</span></span><br><span class="line"><span class="keyword">type</span> binary <span class="keyword">struct</span> &#123;</span><br><span class="line">    op   <span class="type">rune</span> <span class="comment">// one of &#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;</span></span><br><span class="line">    x, y Expr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A call represents a function call expression, e.g., sin(x).</span></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">    fn   <span class="type">string</span> <span class="comment">// one of &quot;pow&quot;, &quot;sin&quot;, &quot;sqrt&quot;</span></span><br><span class="line">    args []Expr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了计算一个包含变量的表达式，我们需要一个environment变量将变量的名字映射成对应的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Env <span class="keyword">map</span>[Var]<span class="type">float64</span></span><br></pre></td></tr></table></figure>

<p>我们也需要每个表达式去定义一个<code>Eval</code>方法，这个方法会根据给定的environment变量返回表达式的值。因为每个表达式都必须提供这个方法，我们将它加入到<code>Expr</code>接口中。这个包只会对外公开<code>Expr</code>，<code>Env</code>，和<code>Var</code>类型。调用方不需要获取其它的表达式类型就可以使用这个求值器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Expr <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Eval returns the value of this Expr in the environment env.</span></span><br><span class="line">    Eval(env Env) <span class="type">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给大家展示一个具体的<code>Eval</code>方法。<code>Var</code>类型的这个方法对一个environment变量进行查找，如果这个变量没有在environment中定义过，这个方法会返回一个零值，<code>literal</code>类型的这个方法简单的返回它真实的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Var)</span></span> Eval(env Env) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> env[v]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l literal)</span></span> Eval(_ Env) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>(l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unary</code>和<code>binary</code>的<code>Eval</code>方法会递归的计算它的运算对象，然后将运算符<code>op</code>作用到它们上。我们不将被零或无穷数除作为一个错误，因为它们都会产生一个固定的结果——无限。最后，<code>call</code>的这个方法会计算对于<code>pow</code>，<code>sin</code>，或者<code>sqrt</code>函数的参数值，然后调用对应在<code>math</code>包中的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u unary)</span></span> Eval(env Env) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> u.op &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> +u.x.Eval(env)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> -u.x.Eval(env)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unsupported unary operator: %q&quot;</span>, u.op))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b binary)</span></span> Eval(env Env) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> b.op &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> b.x.Eval(env) + b.y.Eval(env)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> b.x.Eval(env) - b.y.Eval(env)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> b.x.Eval(env) * b.y.Eval(env)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> b.x.Eval(env) / b.y.Eval(env)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unsupported binary operator: %q&quot;</span>, b.op))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c call)</span></span> Eval(env Env) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> c.fn &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;pow&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> math.Pow(c.args[<span class="number">0</span>].Eval(env), c.args[<span class="number">1</span>].Eval(env))</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;sin&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> math.Sin(c.args[<span class="number">0</span>].Eval(env))</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;sqrt&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(c.args[<span class="number">0</span>].Eval(env))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unsupported function call: %s&quot;</span>, c.fn))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些方法会失败。例如，一个<code>call</code>表达式可能有未知的函数或者错误的参数个数。用一个无效的运算符如<code>!</code>或者<code>&lt;</code>去构建一个<code>unary</code>或者<code>binary</code>表达式也是可能会发生的（尽管下面提到的<code>Parse</code>函数不会这样做）。这些错误会让<code>Eval</code>方法panic。其它的错误，像计算一个没有在environment变量中出现过的<code>Var</code>，只会让<code>Eval</code>方法返回一个错误的结果。所有的这些错误都可以通过在计算前检查<code>Expr</code>来发现。这是我们接下来要讲的<code>Check</code>方法的工作，但是让我们先测试<code>Eval</code>方法。</p>
<p>下面的<code>TestEval</code>函数是对evaluator的一个测试。它使用了我们会在第11章讲解的<code>testing</code>包，但是现在知道调用<code>t.Errof</code>会报告一个错误就足够了。这个函数循环遍历一个表格中的输入，这个表格中定义了三个表达式和针对每个表达式不同的环境变量。第一个表达式根据给定圆的面积<code>A</code>计算它的半径，第二个表达式通过两个变量<code>x</code>和<code>y</code>计算两个立方体的体积之和，第三个表达式将华氏温度<code>F</code>转换成摄氏度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEval</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        expr <span class="type">string</span></span><br><span class="line">        env  Env</span><br><span class="line">        want <span class="type">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;sqrt(A / pi)&quot;</span>, Env&#123;<span class="string">&quot;A&quot;</span>: <span class="number">87616</span>, <span class="string">&quot;pi&quot;</span>: math.Pi&#125;, <span class="string">&quot;167&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;pow(x, 3) + pow(y, 3)&quot;</span>, Env&#123;<span class="string">&quot;x&quot;</span>: <span class="number">12</span>, <span class="string">&quot;y&quot;</span>: <span class="number">1</span>&#125;, <span class="string">&quot;1729&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;pow(x, 3) + pow(y, 3)&quot;</span>, Env&#123;<span class="string">&quot;x&quot;</span>: <span class="number">9</span>, <span class="string">&quot;y&quot;</span>: <span class="number">10</span>&#125;, <span class="string">&quot;1729&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="string">&quot;F&quot;</span>: <span class="number">-40</span>&#125;, <span class="string">&quot;-40&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="string">&quot;F&quot;</span>: <span class="number">32</span>&#125;, <span class="string">&quot;0&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="string">&quot;F&quot;</span>: <span class="number">212</span>&#125;, <span class="string">&quot;100&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> prevExpr <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        <span class="comment">// Print expr only when it changes.</span></span><br><span class="line">        <span class="keyword">if</span> test.expr != prevExpr &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;\n%s\n&quot;</span>, test.expr)</span><br><span class="line">            prevExpr = test.expr</span><br><span class="line">        &#125;</span><br><span class="line">        expr, err := Parse(test.expr)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            t.Error(err) <span class="comment">// parse error</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        got := fmt.Sprintf(<span class="string">&quot;%.6g&quot;</span>, expr.Eval(test.env))</span><br><span class="line">        fmt.Printf(<span class="string">&quot;\t%v =&gt; %s\n&quot;</span>, test.env, got)</span><br><span class="line">        <span class="keyword">if</span> got != test.want &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;%s.Eval() in %v = %q, want %q\n&quot;</span>,</span><br><span class="line">            test.expr, test.env, got, test.want)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于表格中的每一条记录，这个测试会解析它的表达式然后在环境变量中计算它，输出结果。这里我们没有空间来展示<code>Parse</code>函数，但是如果你使用<code>go get</code>下载这个包你就可以看到这个函数。</p>
<p><code>go test</code> 命令会运行一个包的测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test -v gopl.io/ch7/eval</span><br></pre></td></tr></table></figure>

<p>这个<code>-v</code>标识可以让我们看到测试用例打印的输出；正常情况下像这样一个成功的测试用例会阻止打印结果的输出。这里是测试用例里<code>fmt.Printf</code>语句的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqrt(A / pi)</span><br><span class="line">    map[A:87616 pi:3.141592653589793] =&gt; 167</span><br><span class="line"></span><br><span class="line">pow(x, 3) + pow(y, 3)</span><br><span class="line">    map[x:12 y:1] =&gt; 1729</span><br><span class="line">    map[x:9 y:10] =&gt; 1729</span><br><span class="line"></span><br><span class="line">5 / 9 * (F - 32)</span><br><span class="line">    map[F:-40] =&gt; -40</span><br><span class="line">    map[F:32] =&gt; 0</span><br><span class="line">    map[F:212] =&gt; 100</span><br></pre></td></tr></table></figure>

<p>幸运的是目前为止所有的输入都是适合的格式，但是我们的运气不可能一直都有。甚至在解释型语言中，为了静态错误检查语法是非常常见的；静态错误就是不用运行程序就可以检测出来的错误。通过将静态检查和动态的部分分开，我们可以快速的检查错误并且对于多次检查只执行一次而不是每次表达式计算的时候都进行检查。</p>
<p>让我们往<code>Expr</code>接口中增加另一个方法。<code>Check</code>方法对一个表达式语义树检查出静态错误。我们马上会说明它的<code>vars</code>参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Expr <span class="keyword">interface</span> &#123;</span><br><span class="line">    Eval(env Env) <span class="type">float64</span></span><br><span class="line">    <span class="comment">// Check reports errors in this Expr and adds its Vars to the set.</span></span><br><span class="line">    Check(vars <span class="keyword">map</span>[Var]<span class="type">bool</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的<code>Check</code>方法展示在下面。<code>literal</code>和<code>Var</code>类型的计算不可能失败，所以这些类型的<code>Check</code>方法会返回一个<code>nil</code>值。对于<code>unary</code>和<code>binary</code>的<code>Check</code>方法会首先检查操作符是否有效，然后递归的检查运算单元。相似地对于<code>call</code>的这个方法首先检查调用的函数是否已知并且有没有正确个数的参数，然后递归的检查每一个参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Var)</span></span> Check(vars <span class="keyword">map</span>[Var]<span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    vars[v] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(literal)</span></span> Check(vars <span class="keyword">map</span>[Var]<span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u unary)</span></span> Check(vars <span class="keyword">map</span>[Var]<span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !strings.ContainsRune(<span class="string">&quot;+-&quot;</span>, u.op) &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unexpected unary op %q&quot;</span>, u.op)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u.x.Check(vars)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b binary)</span></span> Check(vars <span class="keyword">map</span>[Var]<span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !strings.ContainsRune(<span class="string">&quot;+-*/&quot;</span>, b.op) &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unexpected binary op %q&quot;</span>, b.op)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := b.x.Check(vars); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b.y.Check(vars)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c call)</span></span> Check(vars <span class="keyword">map</span>[Var]<span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    arity, ok := numParams[c.fn]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unknown function %q&quot;</span>, c.fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(c.args) != arity &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;call to %s has %d args, want %d&quot;</span>,</span><br><span class="line">            c.fn, <span class="built_in">len</span>(c.args), arity)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, arg := <span class="keyword">range</span> c.args &#123;</span><br><span class="line">        <span class="keyword">if</span> err := arg.Check(vars); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numParams = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;pow&quot;</span>: <span class="number">2</span>, <span class="string">&quot;sin&quot;</span>: <span class="number">1</span>, <span class="string">&quot;sqrt&quot;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们在两个组中有选择地列出有问题的输入和它们得出的错误。<code>Parse</code>函数（这里没有出现）会报出一个语法错误和<code>Check</code>函数会报出语义错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x % 2               unexpected &#x27;%&#x27;</span><br><span class="line">math.Pi             unexpected &#x27;.&#x27;</span><br><span class="line">!true               unexpected &#x27;!&#x27;</span><br><span class="line">&quot;hello&quot;             unexpected &#x27;&quot;&#x27;</span><br><span class="line"></span><br><span class="line">log(10)             unknown function &quot;log&quot;</span><br><span class="line">sqrt(1, 2)          call to sqrt has 2 args, want 1</span><br></pre></td></tr></table></figure>

<p><code>Check</code>方法的参数是一个<code>Var</code>类型的集合，这个集合聚集从表达式中找到的变量名。为了保证成功的计算，这些变量中的每一个都必须出现在环境变量中。从逻辑上讲，这个集合就是调用<code>Check</code>方法返回的结果，但是因为这个方法是递归调用的，所以对于<code>Check</code>方法，填充结果到一个作为参数传入的集合中会更加的方便。调用方在初始调用时必须提供一个空的集合。</p>
<p>在第3.2节中，我们绘制了一个在编译期才确定的函数<code>f(x,y)</code>。现在我们可以解析，检查和计算在字符串中的表达式，我们可以构建一个在运行时从客户端接收表达式的web应用并且它会绘制这个函数的表示的曲面。我们可以使用集合vars来检查表达式是否是一个只有两个变量x和y的函数——实际上是3个，因为我们为了方便会提供半径大小r。并且我们会在计算前使用<code>Check</code>方法拒绝有格式问题的表达式，这样我们就不会在下面函数的40000个计算过程（100x100个栅格，每一个有4个角）重复这些检查。</p>
<p>这个<code>ParseAndCheck</code>函数混合了解析和检查步骤的过程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;gopl.io/ch7/eval&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseAndCheck</span><span class="params">(s <span class="type">string</span>)</span></span> (eval.Expr, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;empty expression&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    expr, err := eval.Parse(s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    vars := <span class="built_in">make</span>(<span class="keyword">map</span>[eval.Var]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">if</span> err := expr.Check(vars); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> vars &#123;</span><br><span class="line">        <span class="keyword">if</span> v != <span class="string">&quot;x&quot;</span> &amp;&amp; v != <span class="string">&quot;y&quot;</span> &amp;&amp; v != <span class="string">&quot;r&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;undefined variable: %s&quot;</span>, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> expr, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了编写这个web应用，所有我们需要做的就是下面这个<code>plot</code>函数，这个函数有和<code>http.HandlerFunc</code>相似的签名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plot</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm()</span><br><span class="line">    expr, err := parseAndCheck(r.Form.Get(<span class="string">&quot;expr&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, <span class="string">&quot;bad expr: &quot;</span>+err.Error(), http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;image/svg+xml&quot;</span>)</span><br><span class="line">    surface(w, <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">        r := math.Hypot(x, y) <span class="comment">// distance from (0,0)</span></span><br><span class="line">        <span class="keyword">return</span> expr.Eval(eval.Env&#123;<span class="string">&quot;x&quot;</span>: x, <span class="string">&quot;y&quot;</span>: y, <span class="string">&quot;r&quot;</span>: r&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/notes-of-gopl/ch7-07.png" alt="img"></p>
<p>这个<code>plot</code>函数解析和检查在HTTP请求中指定的表达式并且用它来创建一个两个变量的匿名函数。这个匿名函数和来自原来<code>surface-plotting</code>程序中的固定函数f有相同的签名，但是它计算一个用户提供的表达式。环境变量中定义了<code>x</code>，<code>y</code>和半径<code>r</code>。最后<code>plot</code>调用<code>surface</code>函数，它就是<code>gopl.io/ch3/surface</code>中的主要函数，修改后它可以接受<code>plot</code>中的函数和输出<code>io.Writer</code>作为参数，而不是使用固定的函数<code>f</code>和<code>os.Stdout</code>。图7.7中显示了通过程序产生的3个曲面。</p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a><a href="https://gopl-zh.github.io/ch7/ch7-10.html#710-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80">类型断言</a></h2><p><strong>类型断言</strong>是一个使用在接口值上的操作。语法上它看起来像<code>x.(T)</code>被称为断言类型，这里<code>x</code>表示一个接口的类型和<code>T</code>表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。</p>
<p>这里有2种可能。第1种，如果断言的类型<code>T</code>是一个具体类型，然后类型断言检查<code>x</code>的动态类型是否和<code>T</code>相同。如果这个检查成功了，类型断言的结果是<code>x</code>的动态值，当然它的类型是<code>T</code>。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出panic。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">f := w.(*os.File)      <span class="comment">// success: f == os.Stdout</span></span><br><span class="line">c := w.(*bytes.Buffer) <span class="comment">// panic: interface holds *os.File, not *bytes.Buffer</span></span><br></pre></td></tr></table></figure>

<p>第2种，如果相反地断言的类型<code>T</code>是一个接口类型，然后类型断言检查是否<code>x</code>的动态类型满足<code>T</code>。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值，但是结果为类型&#96;T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保留了接口值内部的动态类型和值的部分。</p>
<p>在下面的第一个类型断言后，<code>w</code>和<code>rw</code>都持有<code>os.Stdout</code>，因此它们都有一个动态类型<code>*os.File</code>，但是变量<code>w</code>是一个<code>io.Writer</code>类型，只对外公开了文件的<code>Write</code>方法，而<code>rw</code>变量还公开了它的<code>Read</code>方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">rw := w.(io.ReadWriter) <span class="comment">// success: *os.File has both Read and Write</span></span><br><span class="line">w = <span class="built_in">new</span>(ByteCounter)</span><br><span class="line">rw = w.(io.ReadWriter) <span class="comment">// panic: *ByteCounter has no Read method</span></span><br></pre></td></tr></table></figure>

<p>如果断言操作的对象是一个<code>nil</code>接口值，那么不论被断言的类型是什么这个类型断言都会失败。我们几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像是赋值操作一样，除了对于<code>nil</code>接口值的情况。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w = rw             <span class="comment">// io.ReadWriter is assignable to io.Writer</span></span><br><span class="line">w = rw.(io.Writer) <span class="comment">// fails only if rw == nil</span></span><br></pre></td></tr></table></figure>

<p>经常地，对一个接口值的动态类型我们是不确定的，并且我们更愿意去检验它是否是一些特定的类型。如果类型断言出现在一个预期有两个结果的赋值操作中，例如如下的定义，这个操作不会在失败的时候发生panic，但是替代地返回一个额外的第二个结果，这个结果是一个标识成功与否的布尔值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer = os.Stdout</span><br><span class="line">f, ok := w.(*os.File)      <span class="comment">// success:  ok, f == os.Stdout</span></span><br><span class="line">b, ok := w.(*bytes.Buffer) <span class="comment">// failure: !ok, b == nil</span></span><br></pre></td></tr></table></figure>

<p>第二个结果通常赋值给一个命名为<code>ok</code>的变量。如果这个操作失败了，那么<code>ok</code>就是<code>false</code>值，第一个结果等于被断言类型的零值，在这个例子中就是一个<code>nil</code>的<code>*bytes.Buffer</code>类型。</p>
<p>这个<code>ok</code>结果经常立即用于决定程序下面做什么。if语句的扩展格式让这个变的很简洁：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> f, ok := w.(*os.File); ok &#123;</span><br><span class="line">    <span class="comment">// ...use f...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当类型断言的操作对象是一个变量，你有时会看见原来的变量名重用而不是声明一个新的本地变量名，这个重用的变量原来的值会被覆盖（理解：其实是声明了一个同名的新的本地变量，外层原来的<code>w</code>不会被改变），如下面这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> w, ok := w.(*os.File); ok &#123;</span><br><span class="line">    <span class="comment">// ...use w...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于类型断言区别错误类型"><a href="#基于类型断言区别错误类型" class="headerlink" title="基于类型断言区别错误类型"></a><a href="https://gopl-zh.github.io/ch7/ch7-11.html#711-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%8C%BA%E5%88%AB%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B">基于类型断言区别错误类型</a></h2><p>思考在<code>os</code>包中文件操作返回的错误集合。I&#x2F;O可以因为任何数量的原因失败，但是有三种经常的错误必须进行不同的处理：文件已经存在（对于创建操作），找不到文件（对于读取操作），和权限拒绝。<code>os</code>包中提供了3个帮助函数来对给定的错误值表示的失败进行分类：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsExist</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotExist</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPermission</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p>对这些判断的一个缺乏经验的实现可能会去检查错误消息是否包含了特定的子字符串，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotExist</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> not robust!</span></span><br><span class="line">    <span class="keyword">return</span> strings.Contains(err.Error(), <span class="string">&quot;file does not exist&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是处理I&#x2F;O错误的逻辑可能一个和另一个平台非常的不同，所以这种方案并不健壮，并且对相同的失败可能会报出各种不同的错误消息。在测试的过程中，通过检查错误消息的子字符串来保证特定的函数以期望的方式失败是非常有用的，但对于线上的代码是不够的。</p>
<p>一个更可靠的方式是使用一个专门的类型来描述结构化的错误。<code>os</code>包中定义了一个<code>PathError</code>类型来描述在文件路径操作中涉及到的失败，像<code>Open</code>或者<code>Delete</code>操作；并且定义了一个叫<code>LinkError</code>的变体来描述涉及到两个文件路径的操作，像<code>Symlink</code>和<code>Rename</code>。这下面是<code>os.PathError</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">// PathError records an error and the operation and file path that caused it.</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op   <span class="type">string</span></span><br><span class="line">    Path <span class="type">string</span></span><br><span class="line">    Err  <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Op + <span class="string">&quot; &quot;</span> + e.Path + <span class="string">&quot;: &quot;</span> + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数调用方都不知道<code>PathError</code>并且通过调用错误本身的<code>Error</code>方法来统一处理所有的错误。尽管<code>PathError</code>的<code>Error</code>方法简单地把这些字段连接起来生成错误消息，<code>PathError</code>的结构保护了内部的错误组件。调用方需要使用类型断言来检测错误的具体类型以便将一种失败和另一种区分开；具体的类型可以比字符串提供更多的细节。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err := os.Open(<span class="string">&quot;/no/such/file&quot;</span>)</span><br><span class="line">fmt.Println(err) <span class="comment">// &quot;open /no/such/file: No such file or directory&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, err)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &amp;os.PathError&#123;Op:&quot;open&quot;, Path:&quot;/no/such/file&quot;, Err:0x2&#125;</span></span><br></pre></td></tr></table></figure>

<p>这就是3个帮助函数是怎么工作的。例如下面展示的<code>IsNotExist</code>，它会报出是否一个错误和<code>syscall.ENOENT</code>（§7.8）或者和有名的错误<code>os.ErrNotExist</code>相等（可以在§5.4.2中找到<code>io.EOF</code>）；或者是一个<code>*PathError</code>，它内部的错误是<code>syscall.ENOENT</code>和<code>os.ErrNotExist</code>其中之一。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrNotExist = errors.New(<span class="string">&quot;file does not exist&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsNotExist returns a boolean indicating whether the error is known to</span></span><br><span class="line"><span class="comment">// report that a file or directory does not exist. It is satisfied by</span></span><br><span class="line"><span class="comment">// ErrNotExist as well as some syscall errors.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotExist</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> pe, ok := err.(*PathError); ok &#123;</span><br><span class="line">        err = pe.Err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err == syscall.ENOENT || err == ErrNotExist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这里是它的实际使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err := os.Open(<span class="string">&quot;/no/such/file&quot;</span>)</span><br><span class="line">fmt.Println(os.IsNotExist(err)) <span class="comment">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果错误消息结合成一个更大的字符串，当然<code>PathError</code>的结构就不再为人所知，例如通过一个对<code>fmt.Errorf</code>函数的调用。区别错误通常必须在失败操作后，错误传回调用者前进行。</p>
<h2 id="通过类型断言询问行为"><a href="#通过类型断言询问行为" class="headerlink" title="通过类型断言询问行为"></a><a href="https://gopl-zh.github.io/ch7/ch7-12.html#712-%E9%80%9A%E8%BF%87%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E8%AF%A2%E9%97%AE%E8%A1%8C%E4%B8%BA">通过类型断言询问行为</a></h2><p>下面这段逻辑和<code>net/http</code>包中web服务器负责写入HTTP头字段（例如：<code>&quot;Content-type:text/html&quot;</code>）的部分相似。<code>io.Writer</code>接口类型的变量<code>w</code>代表HTTP响应；写入它的字节最终被发送到某个人的web浏览器上。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeHeader</span><span class="params">(w io.Writer, contentType <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := w.Write([]<span class="type">byte</span>(<span class="string">&quot;Content-Type: &quot;</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err := w.Write([]<span class="type">byte</span>(contentType)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>Write</code>方法需要传入一个byte切片而我们希望写入的值是一个字符串，所以我们需要使用<code>[]byte(...)</code>进行转换。这个转换分配内存并且做一个拷贝，但是这个拷贝在转换后几乎立马就被丢弃掉。让我们假装这是一个web服务器的核心部分并且我们的性能分析表示这个内存分配使服务器的速度变慢。这里我们可以避免掉内存分配么？</p>
<p>这个<code>io.Writer</code>接口告诉我们关于<code>w</code>持有的具体类型的唯一东西：就是可以向它写入字节切片。如果我们回顾<code>net/http</code>包中的内幕，我们知道在这个程序中的<code>w</code>变量持有的动态类型也有一个允许字符串高效写入的<code>WriteString</code>方法；这个方法会避免去分配一个临时的拷贝。（这可能像在黑夜中射击一样，但是许多满足<code>io.Writer</code>接口的重要类型同时也有<code>WriteString</code>方法，包括<code>*bytes.Buffer</code>，<code>*os.File</code>和<code>*bufio.Writer</code>。）</p>
<p><strong>对于任意<code>io.Writer</code>类型的变量<code>w</code>，我们不能假设它也拥有<code>WriteString</code>方法。但是我们可以定义一个只有这个方法的新接口并且使用类型断言来检测是否<code>w</code>的动态类型满足这个新接口。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// writeString writes s to w.</span></span><br><span class="line"><span class="comment">// If w has a WriteString method, it is invoked instead of w.Write.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeString</span><span class="params">(w io.Writer, s <span class="type">string</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">type</span> stringWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">        WriteString(<span class="type">string</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sw, ok := w.(stringWriter); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> sw.WriteString(s) <span class="comment">// avoid a copy</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w.Write([]<span class="type">byte</span>(s)) <span class="comment">// allocate temporary copy</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeHeader</span><span class="params">(w io.Writer, contentType <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := writeString(w, <span class="string">&quot;Content-Type: &quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err := writeString(w, contentType); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免重复定义，我们将这个检查移入到一个实用工具函数<code>writeString</code>中，但是它太有用了以致于标准库将它作为<code>io.WriteString</code>函数提供。这是向一个<code>io.Writer</code>接口写入字符串的推荐方法。</p>
<p>这个例子的神奇之处在于，没有定义了<code>WriteString</code>方法的标准接口，也没有指定它是一个所需行为的标准接口。一个具体类型只会通过它的方法决定它是否满足<code>stringWriter</code>接口，而不是任何它和这个接口类型所表达的关系。它的意思就是上面的技术依赖于一个假设，这个假设就是：如果一个类型满足下面的这个接口，然后<code>WriteString(s)</code>方法就必须和<code>Write([]byte(s))</code>有相同的效果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> &#123;</span><br><span class="line">    io.Writer</span><br><span class="line">    WriteString(s <span class="type">string</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管<code>io.WriteString</code>实施了这个假设，但是调用它的函数极少可能会去实施类似的假设。定义一个特定类型的方法隐式地获取了对特定行为的协约。对于Go语言的新手，特别是那些来自有强类型语言使用背景的新手，可能会发现它缺乏显式的意图令人感到混乱，但是在实战的过程中这几乎不是一个问题。除了空接口<code>interface&#123;&#125;</code>，接口类型很少意外巧合地被实现。</p>
<p><strong>上面的<code>writeString</code>函数使用一个类型断言来获知一个普遍接口类型的值是否满足一个更加具体的接口类型；并且如果满足，它会使用这个更具体接口的行为。这个技术可以被很好的使用，不论这个被询问的接口是一个标准如<code>io.ReadWriter</code>，或者用户定义的如<code>stringWriter</code>接口。</strong></p>
<p>这也是<code>fmt.Fprintf</code>函数怎么从其它所有值中区分满足<code>error</code>或者<code>fmt.Stringer</code>接口的值。在<code>fmt.Fprintf</code>内部，有一个将单个操作对象转换成一个字符串的步骤，像下面这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatOneValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err, ok := x.(<span class="type">error</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> err.Error()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> str, ok := x.(Stringer); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> str.String()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...all other types...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>x</code>满足这两个接口类型中的一个，具体满足的接口决定对值的格式化方式。如果都不满足，默认的case或多或少会统一地使用反射来处理所有的其它类型。</p>
<p>再一次的，它假设任何有<code>String</code>方法的类型都满足<code>fmt.Stringer</code>中约定的行为，这个行为会返回一个适合打印的字符串。</p>
<h2 id="类型分支"><a href="#类型分支" class="headerlink" title="类型分支"></a><a href="https://gopl-zh.github.io/ch7/ch7-13.html#713-%E7%B1%BB%E5%9E%8B%E5%88%86%E6%94%AF">类型分支</a></h2><p>接口被以2种不同的方式使用：</p>
<ul>
<li><p>在第1个方式中，以<code>io.Reader</code>，<code>io.Writer</code>，<code>fmt.Stringer</code>，<code>sort.Interface</code>，<code>http.Handler</code>和<code>error</code>为典型，一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代码的细节和这些具体类型本身的操作。重点在于方法上，而不是具体的类型上。</p>
</li>
<li><p>第2个方式是利用一个接口值可以持有各种具体类型值的能力，将这个接口认为是这些类型的联合。类型断言用来动态地区分这些类型，并以不同的方式处理每种情况。在这个方式中，重点在于具体的类型满足这个接口，而不在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。我们将以这种方式使用的接口描述为discriminated unions（可辨识联合）。</p>
</li>
</ul>
<p>如果你熟悉面向对象编程，你可能会将这两种方式当作是subtype polymorphism（子类型多态）和 ad hoc polymorphism（非参数多态），但是你不需要去记住这些术语。对于本章剩下的部分，我们将会呈现一些第二种方式的例子。</p>
<p>和其它那些语言一样，Go语言查询一个SQL数据库的API会干净地将查询中固定的部分和变化的部分分开。一个调用的例子可能看起来像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;database/sql&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listTracks</span><span class="params">(db sql.DB, artist <span class="type">string</span>, minYear, maxYear <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    result, err := db.Exec(</span><br><span class="line">        <span class="string">&quot;SELECT * FROM tracks WHERE artist = ? AND ? &lt;= year AND year &lt;= ?&quot;</span>,</span><br><span class="line">        artist, minYear, maxYear)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Exec</code>方法使用SQL字面量替换在查询字符串中的每个<code>&#39;?&#39;</code>；SQL字面量表示相应参数的值，它有可能是一个布尔值，一个数字，一个字符串，或者<code>nil</code>空值。用这种方式构造查询可以帮助避免SQL注入攻击；这种攻击就是对手可以通过利用输入内容中不正确的引号来控制查询语句。在<code>Exec</code>函数内部，我们可能会找到像下面这样的一个函数，它会将每一个参数值转换成它的SQL字面量符号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqlQuote</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := x.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := x.(<span class="type">uint</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> b, ok := x.(<span class="type">bool</span>); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> b &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;TRUE&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;FALSE&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> s, ok := x.(<span class="type">string</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlQuoteString(s) <span class="comment">// (not shown)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unexpected type %T: %v&quot;</span>, x, x))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch语句可以简化if-else链，如果这个if-else链对一连串值做相等测试。一个相似的type switch（类型分支）可以简化类型断言的if-else链。</p>
<p>在最简单的形式中，一个类型分支像普通的switch语句一样，它的运算对象是<code>x.(type)</code>——它使用了关键词字面量type——并且每个case有一到多个类型。一个类型分支基于这个接口值的动态类型使一个多路分支有效。这个<code>nil</code>的case和<code>if x == nil</code>匹配，并且这个default的case和如果其它case都不匹配的情况匹配。一个对<code>sqlQuote</code>的类型分支可能会有这些case：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:       <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>, <span class="type">uint</span>: <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:      <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和（§1.8）中的普通switch语句一样，每一个case会被顺序的进行考虑，并且当一个匹配找到时，这个case中的内容会被执行。当一个或多个case类型是接口时，case的顺序就会变得很重要，因为可能会有两个case同时匹配的情况。default case相对其它case的位置是无所谓的。它不会允许落空发生。</p>
<p>注意到在原来的函数中，对于bool和string情况的逻辑需要通过类型断言访问提取的值。因为这个做法很典型，类型分支语句有一个扩展的形式，它可以将提取的值绑定到一个在每个case范围内都有效的新变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> x := x.(<span class="keyword">type</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们已经将新的变量也命名为<code>x</code>；和类型断言一样，重用变量名是很常见的。和一个switch语句相似地，一个类型分支隐式的创建了一个词法块，因此新变量<code>x</code>的定义不会和外面块中的<code>x</code>变量冲突。每一个case也会隐式的创建一个单独的词法块。</p>
<p>使用类型分支的扩展形式来重写<code>sqlQuote</code>函数会让这个函数更加的清晰：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqlQuote</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> x := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>, <span class="type">uint</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x) <span class="comment">// x has type interface&#123;&#125; here.</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> x &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;TRUE&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;FALSE&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        <span class="keyword">return</span> sqlQuoteString(x) <span class="comment">// (not shown)</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unexpected type %T: %v&quot;</span>, x, x))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个版本的函数中，在每个单一类型的case内部，变量<code>x</code>和这个case的类型相同。例如，变量<code>x</code>在bool的case中是bool类型和string的case中是string类型。在所有其它的情况中，变量<code>x</code>是switch运算对象的类型（接口）；在这个例子中运算对象是一个<code>interface&#123;&#125;</code>。当多个case需要相同的操作时，比如<code>int</code>和<code>uint</code>的情况，类型分支可以很容易的合并这些情况。</p>
<p>尽管<code>sqlQuote</code>接受一个任意类型的参数，但是这个函数只会在它的参数匹配类型分支中的一个case时运行到结束；其它情况的它会panic出<code>&quot;unexpected type&quot;</code>消息。虽然<code>x</code>的类型是<code>interface&#123;&#125;</code>，但是我们把它认为是一个<code>int</code>，<code>uint</code>，<code>bool</code>，<code>string</code>，和<code>nil</code>值的discriminated union（可识别联合）。</p>
<h2 id="示例-基于标记的XML解码"><a href="#示例-基于标记的XML解码" class="headerlink" title="示例: 基于标记的XML解码"></a><a href="https://gopl-zh.github.io/ch7/ch7-14.html#714-%E7%A4%BA%E4%BE%8B-%E5%9F%BA%E4%BA%8E%E6%A0%87%E8%AE%B0%E7%9A%84xml%E8%A7%A3%E7%A0%81">示例: 基于标记的XML解码</a></h2><p>第4.5章节展示了如何使用<code>encoding/json</code>包中的<code>Marshal</code>和<code>Unmarshal</code>函数来将JSON文档转换成Go语言的数据结构。<code>encoding/xml</code>包提供了一个相似的API。当我们想构造一个文档树的表示时使用<code>encoding/xml</code>包会很方便，但是对于很多程序并不是必须的。<code>encoding/xml</code>包也提供了一个更低层的基于标记的API用于XML解码。在基于标记的样式中，解析器消费输入并产生一个标记流；四个主要的标记类型－<code>StartElement</code>，<code>EndElement</code>，<code>CharData</code>，和<code>Comment</code>－每一个都是<code>encoding/xml</code>包中的具体类型。每一个对<code>(*xml.Decoder).Token</code>的调用都返回一个标记。</p>
<p>这里显示的是和这个API相关的部分：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xml</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Name <span class="keyword">struct</span> &#123;</span><br><span class="line">    Local <span class="type">string</span> <span class="comment">// e.g., &quot;Title&quot; or &quot;id&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Attr <span class="keyword">struct</span> &#123; <span class="comment">// e.g., name=&quot;value&quot;</span></span><br><span class="line">    Name  Name</span><br><span class="line">    Value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Token includes StartElement, EndElement, CharData,</span></span><br><span class="line"><span class="comment">// and Comment, plus a few esoteric types (not shown).</span></span><br><span class="line"><span class="keyword">type</span> Token <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> StartElement <span class="keyword">struct</span> &#123; <span class="comment">// e.g., &lt;name&gt;</span></span><br><span class="line">    Name Name</span><br><span class="line">    Attr []Attr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> EndElement <span class="keyword">struct</span> &#123; Name Name &#125; <span class="comment">// e.g., &lt;/name&gt;</span></span><br><span class="line"><span class="keyword">type</span> CharData []<span class="type">byte</span>                 <span class="comment">// e.g., &lt;p&gt;CharData&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">type</span> Comment []<span class="type">byte</span>                  <span class="comment">// e.g., &lt;!-- Comment --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Decoder <span class="keyword">struct</span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(io.Reader)</span></span> *Decoder</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Decoder)</span></span> Token() (Token, <span class="type">error</span>) <span class="comment">// returns next Token in sequence</span></span><br></pre></td></tr></table></figure>

<p>这个没有方法的<code>Token</code>接口也是一个可识别联合的例子。传统的接口如<code>io.Reader</code>的目的是隐藏满足它的具体类型的细节，这样就可以创造出新的实现：在这个实现中每个具体类型都被统一地对待。相反，满足可识别联合的具体类型的集合被设计为确定和暴露，而不是隐藏。可识别联合的类型几乎没有方法，操作它们的函数使用一个类型分支的case集合来进行表述，这个case集合中每一个case都有不同的逻辑。</p>
<p>下面的<code>xmlselect</code>程序获取和打印在一个XML文档树中确定的元素下找到的文本。使用上面的API，它可以在输入上一次完成它的工作而从来不要实例化这个文档树。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Xmlselect prints the text of selected elements of an XML document.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/xml&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dec := xml.NewDecoder(os.Stdin)</span><br><span class="line">    <span class="keyword">var</span> stack []<span class="type">string</span> <span class="comment">// stack of element names</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        tok, err := dec.Token()</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">&quot;xmlselect: %v\n&quot;</span>, err)</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> tok := tok.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> xml.StartElement:</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, tok.Name.Local) <span class="comment">// push</span></span><br><span class="line">        <span class="keyword">case</span> xml.EndElement:</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>] <span class="comment">// pop</span></span><br><span class="line">        <span class="keyword">case</span> xml.CharData:</span><br><span class="line">            <span class="keyword">if</span> containsAll(stack, os.Args[<span class="number">1</span>:]) &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;%s: %s\n&quot;</span>, strings.Join(stack, <span class="string">&quot; &quot;</span>), tok)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// containsAll reports whether x contains the elements of y, in order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsAll</span><span class="params">(x, y []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(y) &lt;= <span class="built_in">len</span>(x) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(y) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> x[<span class="number">0</span>] == y[<span class="number">0</span>] &#123;</span><br><span class="line">            y = y[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">        x = x[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数中的循环每遇到一个<code>StartElement</code>时，它把这个元素的名称压到一个栈里，并且每次遇到<code>EndElement</code>时，它将名称从这个栈中推出。这个API保证了<code>StartElement</code>和<code>EndElement</code>的序列可以被完全的匹配，甚至在一个糟糕的文档格式中。注释会被忽略。当<code>xmlselect</code>遇到一个<code>CharData</code>时，只有当栈中有序地包含所有通过命令行参数传入的元素名称时，它才会输出相应的文本。</p>
<p>下面的命令打印出任意出现在两层<code>div</code>元素下的<code>h2</code>元素的文本。它的输入是XML的说明文档，并且它自己就是XML文档格式的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch1/fetch</span><br><span class="line">$ ./fetch http://www.w3.org/TR/2006/REC-xml11-20060816 |</span><br><span class="line">    ./xmlselect div div h2</span><br><span class="line">html body div div h2: 1 Introduction</span><br><span class="line">html body div div h2: 2 Documents</span><br><span class="line">html body div div h2: 3 Logical Structures</span><br><span class="line">html body div div h2: 4 Physical Structures</span><br><span class="line">html body div div h2: 5 Conformance</span><br><span class="line">html body div div h2: 6 Notation</span><br><span class="line">html body div div h2: A References</span><br><span class="line">html body div div h2: B Definitions for Character Normalization</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a><a href="https://gopl-zh.github.io/ch7/ch7-15.html#715-%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE">一些建议</a></h2><p>当设计一个新的包时，新手Go程序员总是先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。不要再这么做了。这种接口是不必要的抽象；它们也有一个运行时损耗。你可以使用导出机制（§6.6）来限制一个类型的方法或一个结构体的字段是否在包外可见。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。</p>
<p>当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好方式。</p>
<p>因为在Go语言中只有当两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法的更小的接口（经常和<code>io.Writer</code>或 <code>fmt.Stringer</code>一样只有一个）。当新的类型出现时，小的接口更容易满足。对于接口设计的一个好的标准就是 ask only for what you need（只考虑你需要的东西）</p>
<p>我们完成了对方法和接口的学习过程。Go语言对面向对象风格的编程支持良好，但这并不意味着你只能使用这一风格。不是任何事物都需要被当做一个对象；独立的函数有它们自己的用处，未封装的数据类型也是这样。观察一下，在本书前五章的例子中像<code>input.Scan</code>这样的方法被调用不超过二十次，与之相反的是普遍调用的函数如<code>fmt.Printf</code>。</p>
<h1 id="Goroutines和Channels"><a href="#Goroutines和Channels" class="headerlink" title="Goroutines和Channels"></a><a href="https://gopl-zh.github.io/ch8/ch8.html#%E7%AC%AC8%E7%AB%A0-goroutines%E5%92%8Cchannels">Goroutines和Channels</a></h1><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a><a href="https://gopl-zh.github.io/ch8/ch8-01.html#81-goroutines">Goroutines</a></h2><p>在Go语言中，每一个并发的执行单元叫作一个goroutine。设想这里的一个程序有两个函数，一个函数做计算，另一个输出结果，假设两个函数没有相互之间的调用关系。一个线性的程序会先调用其中的一个函数，然后再调用另一个。如果程序中包含多个goroutine，对两个函数的调用则可能发生在同一时刻。</p>
<p>如果你使用过操作系统或者其它语言提供的线程，那么你可以简单地把goroutine类比作一个线程，但它们是有很大差别的。</p>
<p><strong>当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f()    <span class="comment">// call f(); wait for it to return</span></span><br><span class="line"><span class="keyword">go</span> f() <span class="comment">// create a new goroutine that calls f(); don&#x27;t wait</span></span><br></pre></td></tr></table></figure>

<p>下面的例子，main goroutine将计算菲波那契数列的第45个元素值。由于计算函数使用低效的递归，所以会运行相当长时间，在此期间我们想让用户看到一个可见的标识来表明程序依然在正常运行，所以来做一个动画的小图标：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> spinner(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">const</span> n = <span class="number">45</span></span><br><span class="line">    fibN := fib(n) <span class="comment">// slow</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;\rFibonacci(%d) = %d\n&quot;</span>, n, fibN)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spinner</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">`-\|/`</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;\r%c&quot;</span>, r)</span><br><span class="line">            time.Sleep(delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(x<span class="number">-1</span>) + fib(x<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动画显示了几秒之后，<code>fib(45)</code>的调用成功地返回，并且打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fibonacci(45) = 1134903170</span><br></pre></td></tr></table></figure>

<p>然后主函数返回。**主函数返回时，所有的goroutine都会被直接打断，程序退出。**除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行，但是之后可以看到一种方式来实现这个目的，通过goroutine之间的通信来让一个goroutine请求其它的goroutine，并让被请求的goroutine自行结束执行。</p>
<p>留意一下这里的两个独立的单元是如何进行组合的，spinning和菲波那契的计算。分别在独立的函数中，但两个函数会同时执行。</p>
<h2 id="示例-并发的Clock服务"><a href="#示例-并发的Clock服务" class="headerlink" title="示例: 并发的Clock服务"></a><a href="https://gopl-zh.github.io/ch8/ch8-02.html#82-%E7%A4%BA%E4%BE%8B-%E5%B9%B6%E5%8F%91%E7%9A%84clock%E6%9C%8D%E5%8A%A1">示例: 并发的Clock服务</a></h2><p>网络编程是并发大显身手的一个领域，由于服务器是最典型的需要同时处理很多连接的程序，这些连接一般来自于彼此独立的客户端。在本小节中，我们会讲解go语言的<code>net</code>包，这个包提供编写一个网络客户端或者服务器程序的基本组件，无论两者间通信是使用TCP、UDP或者Unix domain sockets。</p>
<p>我们的第一个例子是一个顺序执行的时钟服务器，它会每隔一秒钟将当前时间写到客户端：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Clock1 is a TCP server that periodically writes the time.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Print(err) <span class="comment">// e.g., connection aborted</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        handleConn(conn) <span class="comment">// handle one connection at a time</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> c.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, err := io.WriteString(c, time.Now().Format(<span class="string">&quot;15:04:05\n&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// e.g., client disconnected</span></span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Listen</code>函数创建了一个<code>net.Listener</code>的对象，这个对象会监听一个网络端口上到来的连接，在这个例子里我们用的是TCP的<code>&quot;localhost:8000&quot;</code>端口。<code>listener</code>对象的<code>Accept</code>方法会直接阻塞，直到一个新的连接被创建，然后会返回一个<code>net.Conn</code>对象来表示这个连接。</p>
<p><code>handleConn</code>函数会处理一个完整的客户端连接。在一个for死循环中，用<code>time.Now()</code>获取当前时刻，然后写到客户端。由于<code>net.Conn</code>实现了<code>io.Writer</code>接口，我们可以直接向其写入内容。这个死循环会一直执行，直到写入失败。最可能的原因是客户端主动断开连接。这种情况下<code>handleConn</code>函数会用defer调用关闭服务器侧的连接，然后返回到主函数，继续等待下一个连接请求。</p>
<p><code>time.Time.Format</code>方法提供了一种格式化日期和时间信息的方式。它的参数是一个格式化模板，标识如何来格式化时间，而这个格式化模板限定为<code>Mon Jan 2 03:04:05PM 2006 UTC-0700</code>。有8个部分（周几、月份、一个月的第几天……）。可以以任意的形式来组合前面这个模板；出现在模板中的部分会作为参考来对时间格式进行输出。在上面的例子中我们只用到了小时、分钟和秒。<code>time</code>包里定义了很多标准时间格式，比如<code>time.RFC1123</code>。在进行格式化的逆向操作<code>time.Parse</code>时，也会用到同样的策略。（译注：这是go语言和其它语言相比比较奇葩的一个地方。你需要记住格式化字符串是<code>1月2日下午3点4分5秒零六年UTC-0700</code>，而不像其它语言那样<code>Y-m-d H:i:s</code>一样，当然了这里可以用1234567的方式来记忆，倒是也不麻烦。）</p>
<p>为了连接例子里的服务器，我们需要一个客户端程序，比如netcat这个工具（<code>nc</code>命令），这个工具可以用来执行网络连接操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch8/clock1</span><br><span class="line">$ ./clock1 &amp;</span><br><span class="line">$ nc localhost 8000</span><br><span class="line">13:58:54</span><br><span class="line">13:58:55</span><br><span class="line">13:58:56</span><br><span class="line">13:58:57</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<p>客户端将服务器发来的时间显示了出来，我们用Control+C来中断客户端的执行，在Unix系统上，你会看到^C这样的响应。如果你的系统没有装nc这个工具，你可以用telnet来实现同样的效果，或者也可以用我们下面的这个用go写的简单的telnet程序，用<code>net.Dial</code>就可以简单地创建一个TCP连接：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Netcat1 is a read-only TCP client.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    mustCopy(os.Stdout, conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mustCopy</span><span class="params">(dst io.Writer, src io.Reader)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := io.Copy(dst, src); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序会从连接中读取数据，并将读到的内容写到标准输出中，直到遇到end of file的条件或者发生错误。<code>mustCopy</code>这个函数我们在本节的几个例子中都会用到。让我们同时运行两个客户端来进行一个测试，这里可以开两个终端窗口，下面左边的是其中的一个的输出，右边的是另一个的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch8/netcat1</span><br><span class="line">$ ./netcat1</span><br><span class="line">13:58:54                               $ ./netcat1</span><br><span class="line">13:58:55</span><br><span class="line">13:58:56</span><br><span class="line">^C</span><br><span class="line">                                       13:58:57</span><br><span class="line">                                       13:58:58</span><br><span class="line">                                       13:58:59</span><br><span class="line">                                       ^C</span><br><span class="line">$ killall clock1</span><br></pre></td></tr></table></figure>

<p>killall命令是一个Unix命令行工具，可以用给定的进程名来杀掉所有名字匹配的进程。</p>
<p>第二个客户端必须等待第一个客户端完成工作，这样服务端才能继续向后执行；因为我们这里的服务器程序同一时间只能处理一个客户端连接。我们这里对服务端程序做一点小改动，使其支持并发：在<code>handleConn</code>函数调用的地方增加go关键字，让每一次<code>handleConn</code>的调用都进入一个独立的goroutine。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Print(err) <span class="comment">// e.g., connection aborted</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> handleConn(conn) <span class="comment">// handle connections concurrently</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在多个客户端可以同时接收到时间了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch8/clock2</span><br><span class="line">$ ./clock2 &amp;</span><br><span class="line">$ go build gopl.io/ch8/netcat1</span><br><span class="line">$ ./netcat1</span><br><span class="line">14:02:54                               $ ./netcat1</span><br><span class="line">14:02:55                               14:02:55</span><br><span class="line">14:02:56                               14:02:56</span><br><span class="line">14:02:57                               ^C</span><br><span class="line">14:02:58</span><br><span class="line">14:02:59                               $ ./netcat1</span><br><span class="line">14:03:00                               14:03:00</span><br><span class="line">14:03:01                               14:03:01</span><br><span class="line">^C                                     14:03:02</span><br><span class="line">                                       ^C</span><br><span class="line">$ killall clock2</span><br></pre></td></tr></table></figure>



<h2 id="示例-并发的Echo服务"><a href="#示例-并发的Echo服务" class="headerlink" title="示例: 并发的Echo服务"></a><a href="https://gopl-zh.github.io/ch8/ch8-03.html#83-%E7%A4%BA%E4%BE%8B-%E5%B9%B6%E5%8F%91%E7%9A%84echo%E6%9C%8D%E5%8A%A1">示例: 并发的Echo服务</a></h2><p>clock服务器每一个连接都会起一个goroutine。在本节中我们会创建一个echo服务器，这个服务在每个连接中会有多个goroutine。大多数echo服务仅仅会返回他们读取到的内容，就像下面这个简单的<code>handleConn</code>函数所做的一样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">    io.Copy(c, c) <span class="comment">// <span class="doctag">NOTE:</span> ignoring errors</span></span><br><span class="line">    c.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个更有意思的echo服务应该模拟一个实际的echo的“回响”，并且一开始要用大写HELLO来表示“声音很大”，之后经过一小段延迟返回一个有所缓和的Hello，然后一个全小写字母的hello表示声音渐渐变小直至消失，像下面这个版本的<code>handleConn</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(c net.Conn, shout <span class="type">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(c, <span class="string">&quot;\t&quot;</span>, strings.ToUpper(shout))</span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">    fmt.Fprintln(c, <span class="string">&quot;\t&quot;</span>, shout)</span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">    fmt.Fprintln(c, <span class="string">&quot;\t&quot;</span>, strings.ToLower(shout))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">    input := bufio.NewScanner(c)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        echo(c, input.Text(), <span class="number">1</span>*time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> ignoring potential errors from input.Err()</span></span><br><span class="line">    c.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要升级我们的客户端程序，这样它就可以发送终端的输入到服务器，并把服务端的返回输出到终端上，这使我们有了使用并发的另一个好机会：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    <span class="keyword">go</span> mustCopy(os.Stdout, conn)</span><br><span class="line">    mustCopy(conn, os.Stdin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当main goroutine从标准输入流中读取内容并将其发送给服务器时，另一个goroutine会读取并打印服务端的响应。当main goroutine碰到输入终止时，例如，用户在终端中按了Control-D(^D)，在windows上是Control-Z，这时程序就会被终止，尽管其它goroutine中还有进行中的任务。（在8.4.1中引入了channels后我们会明白如何让程序等待两边都结束。）</p>
<p>下面这个会话中，客户端的输入是左对齐的，服务端的响应会用缩进来区别显示。 客户端会向服务器“喊三次话”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch8/reverb1</span><br><span class="line">$ ./reverb1 &amp;</span><br><span class="line">$ go build gopl.io/ch8/netcat2</span><br><span class="line">$ ./netcat2</span><br><span class="line">Hello?</span><br><span class="line">    HELLO?</span><br><span class="line">    Hello?</span><br><span class="line">    hello?</span><br><span class="line">Is there anybody there?</span><br><span class="line">    IS THERE ANYBODY THERE?</span><br><span class="line">Yooo-hooo!</span><br><span class="line">    Is there anybody there?</span><br><span class="line">    is there anybody there?</span><br><span class="line">    YOOO-HOOO!</span><br><span class="line">    Yooo-hooo!</span><br><span class="line">    yooo-hooo!</span><br><span class="line">^D</span><br><span class="line">$ killall reverb1</span><br></pre></td></tr></table></figure>

<p>注意客户端的第三次shout在前一个shout处理完成之前一直没有被处理，这貌似看起来不是特别“现实”。真实世界里的回响应该是会由三次shout的回声组合而成的。为了模拟真实世界的回响，我们需要更多的goroutine来做这件事情。这样我们就再一次地需要go这个关键词了，这次我们用它来调用echo：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">    input := bufio.NewScanner(c)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        <span class="keyword">go</span> echo(c, input.Text(), <span class="number">1</span>*time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> ignoring potential errors from input.Err()</span></span><br><span class="line">    c.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>go后跟的函数的参数会在go语句自身执行时被求值；因此<code>input.Text()</code>会在main goroutine中被求值。 现在回响是并发并且会按时间来覆盖掉其它响应了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch8/reverb2</span><br><span class="line">$ ./reverb2 &amp;</span><br><span class="line">$ ./netcat2</span><br><span class="line">Is there anybody there?</span><br><span class="line">    IS THERE ANYBODY THERE?</span><br><span class="line">Yooo-hooo!</span><br><span class="line">    Is there anybody there?</span><br><span class="line">    YOOO-HOOO!</span><br><span class="line">    is there anybody there?</span><br><span class="line">    Yooo-hooo!</span><br><span class="line">    yooo-hooo!</span><br><span class="line">^D</span><br><span class="line">$ killall reverb2</span><br></pre></td></tr></table></figure>

<p>让服务使用并发不只是处理多个客户端的请求，甚至在处理单个连接时也可能会用到，就像我们上面的两个go关键词的用法。然而在我们使用go关键词的同时，需要慎重地考虑<code>net.Conn</code>中的方法在并发地调用时是否安全，事实上对于大多数类型来说也确实不安全。我们会在下一章中详细地探讨并发安全性。</p>
<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a><a href="https://gopl-zh.github.io/ch8/ch8-04.html#84-channels">Channels</a></h2><p><strong>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为<code>chan int</code>。</strong></p>
<p><strong>使用内置的make函数，我们可以创建一个channel：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// ch has type &#x27;chan int&#x27;</span></span><br></pre></td></tr></table></figure>

<p>和map类似，channel也对应一个make创建的底层数据结构的引用。<strong>当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。</strong></p>
<p><strong>两个相同类型的channel可以使用<code>==</code>运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和<code>nil</code>进行比较。</strong></p>
<p>一个channel有发送和接收2个主要操作，都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。发送和接收两个操作都使用<code>&lt;-</code>运算符。</p>
<ul>
<li>在发送语句中，<code>&lt;-</code>运算符分割channel和要发送的值。</li>
<li>在接收语句中，<code>&lt;-</code>运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- x  <span class="comment">// a send statement</span></span><br><span class="line">x = &lt;-ch <span class="comment">// a receive expression in an assignment statement</span></span><br><span class="line">&lt;-ch     <span class="comment">// a receive statement; result is discarded</span></span><br></pre></td></tr></table></figure>

<p><strong>Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。</strong></p>
<p><strong>使用内置的close函数就可以关闭一个channel：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>以最简单方式调用<code>make</code>函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)    <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>) <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>) <span class="comment">// buffered channel with capacity 3</span></span><br></pre></td></tr></table></figure>

<h3 id="不带缓存的Channels"><a href="#不带缓存的Channels" class="headerlink" title="不带缓存的Channels"></a><a href="https://gopl-zh.github.io/ch8/ch8-04.html#841-%E4%B8%8D%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84channels">不带缓存的Channels</a></h3><p><strong>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</strong></p>
<p><strong>基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为<em>同步Channels</em>。</strong> 当通过一个无缓存Channels发送数据时，接收者收到数据发生在再次唤醒发送者goroutine之前（译注：<em>happens before</em>，这是Go语言并发内存模型的一个关键术语！）。</p>
<p><strong>在讨论并发编程时，当我们说x事件在y事件之前发生（<em>happens before</em>），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证在此之前的事件都已经完成了，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。</strong></p>
<p>**当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序。**在下一章中我们将看到，当两个goroutine并发访问了相同的变量时，我们有必要保证某些事件的执行顺序，以避免出现某些并发问题。</p>
<p>在8.3节的客户端程序，它在主goroutine中（译注：就是执行main函数的goroutine）将标准输入复制到server，因此当客户端程序关闭标准输入时，后台goroutine可能依然在工作。我们需要让主goroutine等待后台goroutine完成工作后再退出，我们使用了一个channel来同步两个goroutine：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 空struct不占内存空间</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        io.Copy(os.Stdout, conn) <span class="comment">// <span class="doctag">NOTE:</span> ignoring errors</span></span><br><span class="line">        log.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// signal the main goroutine</span></span><br><span class="line">    &#125;()</span><br><span class="line">    mustCopy(conn, os.Stdin)</span><br><span class="line">    conn.Close()</span><br><span class="line">    &lt;-done <span class="comment">// wait for background goroutine to finish</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当用户关闭了标准输入，主goroutine中的<code>mustCopy</code>函数调用将返回，然后调用<code>conn.Close()</code>关闭读和写方向的网络连接。关闭网络连接中的写方向的连接将导致server程序收到一个文件（end-of-file）结束的信号。关闭网络连接中读方向的连接将导致后台goroutine的<code>io.Copy</code>函数调用返回一个“read from closed connection”（“从关闭的连接读”）类似的错误，因此我们临时移除了错误日志语句；在练习8.3将会提供一个更好的解决方案。（需要注意的是go语句调用了一个函数字面量，这是Go语言中启动goroutine常用的形式。）</p>
<p>在后台goroutine返回之前，它先打印一个日志信息，然后向<code>done</code>对应的channel发送一个值。主goroutine在退出前先等待从<code>done</code>对应的channel接收一个值。因此，总是可以在程序退出前正确输出“done”消息。</p>
<p>基于channels发送消息有两个重要方面。首先每个消息都有一个值，但是有时候通讯的事实和发生的时刻也同样重要。当我们更希望强调通讯发生的时刻时，我们将它称为<strong>消息事件</strong>。有些消息事件并不携带额外的信息，它仅仅是用作两个goroutine之间的同步，这时候我们可以用<code>struct&#123;&#125;</code>空结构体作为channels元素的类型，虽然也可以使用bool或int类型实现同样的功能，<code>done &lt;- 1</code>语句也比<code>done &lt;- struct&#123;&#125;&#123;&#125;</code>更短。</p>
<p><strong>练习 8.3：</strong> 在netcat3例子中，conn虽然是一个interface类型的值，但是其底层真实类型是<code>*net.TCPConn</code>，代表一个TCP连接。一个TCP连接有读和写两个部分，可以使用<code>CloseRead</code>和<code>CloseWrite</code>方法分别关闭它们。修改netcat3的主goroutine代码，只关闭网络连接中写的部分，这样的话后台goroutine可以在标准输入被关闭后继续打印从reverb1服务器传回的数据。（要在reverb2服务器也完成同样的功能是比较困难的；参考<strong>练习 8.4</strong>。）</p>
<h3 id="串联的Channels（Pipeline）"><a href="#串联的Channels（Pipeline）" class="headerlink" title="串联的Channels（Pipeline）"></a><a href="https://gopl-zh.github.io/ch8/ch8-04.html#842-%E4%B8%B2%E8%81%94%E7%9A%84channelspipeline">串联的Channels（Pipeline）</a></h3><p>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的<strong>管道（pipeline）</strong>。下面的程序用两个channels将三个goroutine串联起来，如图8.1所示。</p>
<p><img src="/2022/notes-of-gopl/ch8-01.png" alt="img"></p>
<p>第一个goroutine是一个计数器，用于生成0、1、2、……形式的整数序列，然后通过channel将该整数序列发送给第二个goroutine；第二个goroutine是一个求平方的程序，对收到的每个整数求平方，然后将平方后的结果通过第二个channel发送给第三个goroutine；第三个goroutine是一个打印程序，打印收到的每个整数。为了保持例子清晰，我们有意选择了非常简单的函数，当然三个goroutine的计算很简单，在现实中确实没有必要为如此简单的运算构建三个goroutine。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Counter</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> x := <span class="number">0</span>; ; x++ &#123;</span><br><span class="line">            naturals &lt;- x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Squarer</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            x := &lt;-naturals</span><br><span class="line">            squares &lt;- x * x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Printer (in main goroutine)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(&lt;-squares)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如您所料，上面的程序将生成0、1、4、9、……形式的无穷数列。像这样的串联Channels的管道（Pipelines）可以用在需要长时间运行的服务中，每个长时间运行的goroutine可能会包含一个死循环，在不同goroutine的死循环内部使用串联的Channels来通信。但是，如果我们希望通过Channels只发送有限的数列该如何处理呢？</p>
<p><strong>如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的<code>close</code>函数来关闭channel实现：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(naturals)</span><br></pre></td></tr></table></figure>

<p>**当一个channel被关闭后，再向该channel发送数据将导致panic异常。当一个被关闭的channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。**关闭上面例子中的naturals变量对应的channel并不能终止循环，它依然会收到一个永无休止的零值序列，然后将它们发送给打印者goroutine。</p>
<p>**没有办法直接测试一个channel是否被关闭，但是接收操作有一个变体形式：它多接收一个结果，多接收的第二个结果是一个布尔值ok，ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。**使用这个特性，我们可以修改squarer函数中的循环代码，当naturals对应的channel被关闭并没有值可接收时跳出循环，并且也关闭squares对应的channel.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Squarer</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        x, ok := &lt;-naturals</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// channel was closed and drained</span></span><br><span class="line">        &#125;</span><br><span class="line">        squares &lt;- x * x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(squares)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p><strong>因为上面的语法是笨拙的，而且这种处理模式很常见，因此Go语言的range循环可直接在channels上面迭代。使用range循环是上面处理模式的简洁语法，它依次从channel接收数据，当channel被关闭并且没有值可接收时跳出循环。</strong></p>
<p>在下面的改进中，我们的计数器goroutine只生成100个含数字的序列，然后关闭naturals对应的channel，这将导致计算平方数的squarer对应的goroutine可以正常终止循环并关闭squares对应的channel。（在一个更复杂的程序中，可以通过defer语句关闭对应的channel。）最后，主goroutine也可以正常终止循环并退出程序。</p>
<p><em>gopl.io&#x2F;ch8&#x2F;pipeline2</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Counter</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">            naturals &lt;- x</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(naturals)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Squarer</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> x := <span class="keyword">range</span> naturals &#123;</span><br><span class="line">            squares &lt;- x * x</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(squares)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Printer (in main goroutine)</span></span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> squares &#123;</span><br><span class="line">        fmt.Println(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实你并不需要关闭每一个channel。只有当需要告诉接收者goroutine，所有的数据已经全部发送时才需要关闭channel。不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。（不要将关闭一个打开文件的操作和关闭一个channel操作混淆。对于每个打开的文件，都需要在不使用的时候调用对应的Close方法来关闭文件。）</p>
<p>**试图重复关闭一个channel将导致panic异常，试图关闭一个<code>nil</code>值的channel也将导致panic异常。**关闭一个channels还会触发一个广播机制，我们将在8.9节讨论。</p>
<h3 id="单方向的Channel"><a href="#单方向的Channel" class="headerlink" title="单方向的Channel"></a><a href="https://gopl-zh.github.io/ch8/ch8-04.html#843-%E5%8D%95%E6%96%B9%E5%90%91%E7%9A%84channel">单方向的Channel</a></h3><p>随着程序的增长，人们习惯于将大的函数拆分为小的函数。我们前面的例子中使用了三个goroutine，然后用两个channels来连接它们，它们都是main函数的局部变量。将三个goroutine拆分为以下三个函数是自然的想法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span> <span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out, in <span class="keyword">chan</span> <span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in <span class="keyword">chan</span> <span class="type">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>其中计算平方的<code>square</code>r函数在两个串联Channels的中间，因此拥有两个channel类型的参数，一个用于输入一个用于输出。两个channel都拥有相同的类型，但是它们的使用方式相反：一个只用于接收，另一个只用于发送。参数的名字<code>in</code>和<code>out</code>已经明确表示了这个意图，但是并无法保证<code>squarer</code>函数向一个<code>in</code>参数对应的channel发送数据或者从一个<code>out</code>参数对应的channel接收数据。</p>
<p>这种场景是典型的。当一个channel作为一个函数参数时，它一般总是被专门用于只发送或者只接收。</p>
<p><strong>为了表明这种意图并防止被滥用，Go语言的类型系统提供了单方向的channel类型，分别用于只发送或只接收的channel。类型<code>chan&lt;- int</code>表示一个只发送int的channel，只能发送不能接收。相反，类型<code>&lt;-chan int</code>表示一个只接收int的channel，只能接收不能发送。（箭头<code>&lt;-</code>和关键字<code>chan</code>的相对位置表明了channel的方向。）这种限制将在编译期检测。</strong></p>
<p><strong>因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，因此对一个只接收的channel调用close将是一个编译错误。</strong></p>
<p>这是改进的版本，这一次参数使用了单方向channel类型：</p>
<p><em>gopl.io&#x2F;ch8&#x2F;pipeline3</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">        out &lt;- x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>, in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        out &lt;- v * v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> counter(naturals)</span><br><span class="line">    <span class="keyword">go</span> squarer(squares, naturals)</span><br><span class="line">    printer(squares)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用<code>counter(naturals)</code>时，<code>naturals</code>的类型将隐式地从<code>chan int</code>转换成<code>chan&lt;- int</code>。调用<code>printer(squares)</code>也会导致相似的隐式转换，这一次是转换为<code>&lt;-chan int</code>类型只接收型的channel。任何双向channel向单向channel变量的赋值操作都将导致该隐式转换。这里并没有反向转换的语法：也就是不能将一个类似<code>chan&lt;- int</code>类型的单向型的channel转换为<code>chan int</code>类型的双向型的channel。</strong></p>
<h3 id="带缓存的Channels"><a href="#带缓存的Channels" class="headerlink" title="带缓存的Channels"></a><a href="https://gopl-zh.github.io/ch8/ch8-04.html#844-%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84channels">带缓存的Channels</a></h3><p>**带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用<code>make</code>函数创建channel时通过第2个参数指定的。**下面的语句创建了一个可以持有3个字符串元素的带缓存Channel。图8.2是<code>ch</code>变量对应的channel的图形表示形式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/notes-of-gopl/ch8-02.png" alt="img"></p>
<p><strong>向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。</strong></p>
<p>我们可以在无阻塞的情况下连续向新创建的channel发送三个值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- <span class="string">&quot;A&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;B&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;C&quot;</span></span><br></pre></td></tr></table></figure>

<p>此刻，channel的内部缓存队列将是满的（图8.3），如果有第4个发送操作将发生阻塞。</p>
<p><img src="/2022/notes-of-gopl/ch8-03.png" alt="img"></p>
<p>如果我们接收一个值，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(&lt;-ch) <span class="comment">// &quot;A&quot;</span></span><br></pre></td></tr></table></figure>

<p>那么channel的缓存队列将不是满的也不是空的（图8.4），因此对该channel执行的发送或接收操作都不会发生阻塞。通过这种方式，channel的缓存队列解耦了接收和发送的goroutine。</p>
<p><img src="/2022/notes-of-gopl/ch8-04.png" alt="img"></p>
<p><strong>在某些特殊情况下，程序可能需要知道channel内部缓存的容量，可以用内置的<code>cap</code>函数获取：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="built_in">cap</span>(ch)) <span class="comment">// &quot;3&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>同样，对于内置的<code>len</code>函数，如果传入的是channel，那么将返回channel内部缓存队列中有效元素的个数。因为在并发程序中该信息会随着接收操作而失效，但是它对某些故障诊断和性能优化会有帮助。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="built_in">len</span>(ch)) <span class="comment">// &quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<p>在继续执行2次接收操作后channel内部的缓存队列将又成为空的，如果有第4个接收操作将发生阻塞：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(&lt;-ch) <span class="comment">// &quot;B&quot;</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// &quot;C&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，发送和接收操作都发生在同一个goroutine中，但是在真实的程序中它们一般由不同的goroutine执行。<strong>Go语言新手有时候会将一个带缓存的channel当作同一个goroutine中的队列使用，虽然语法看似简单，但实际上这是一个错误。Channel和goroutine的调度器机制是紧密相连的，如果没有其他goroutine从channel接收，发送者——或许是整个程序——将会面临永远阻塞的风险。如果你只是需要一个简单的队列，使用slice就可以了。</strong></p>
<p>下面的例子展示了一个使用了带缓存channel的应用。它并发地向三个镜像站点发出请求，三个镜像站点分散在不同的地理位置。它们分别将收到的响应发送到带缓存channel，最后接收者只接收第一个收到的响应，也就是最快的那个响应。因此mirroredQuery函数可能在另外两个响应慢的镜像站点响应之前就返回了结果。（顺便说一下，<strong>多个goroutines并发地向同一个channel发送数据，或从同一个channel接收数据都是常见的用法。</strong>）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mirroredQuery</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    responses := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; responses &lt;- request(<span class="string">&quot;asia.gopl.io&quot;</span>) &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; responses &lt;- request(<span class="string">&quot;europe.gopl.io&quot;</span>) &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; responses &lt;- request(<span class="string">&quot;americas.gopl.io&quot;</span>) &#125;()</span><br><span class="line">    <span class="keyword">return</span> &lt;-responses <span class="comment">// return the quickest response</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(hostname <span class="type">string</span>)</span></span> (response <span class="type">string</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果我们使用了无缓存的channel，那么两个慢的goroutines将会因为没有人接收而被永远卡住。这种情况，称为<em>goroutines泄漏</em>，这将是一个BUG。和垃圾变量不同，泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。</strong></p>
<p><strong>关于无缓存或带缓存channels之间的选择，或者是带缓存channels的容量大小的选择，都可能影响程序的正确性。无缓存channel更强地保证了每个发送操作与相应的同步接收操作；但是对于带缓存channel，这些操作是解耦的。同样，即使我们知道将要发送到一个channel的信息的数量上限，创建一个对应容量大小的带缓存channel也是不现实的，因为这要求在执行任何接收操作之前缓存所有已经发送的值。如果未能分配足够的缓存将导致程序死锁。</strong></p>
<p>Channel的缓存也可能影响程序的性能。想象一家蛋糕店有三个厨师，一个烘焙，一个上糖衣，还有一个将每个蛋糕传递到它下一个厨师的生产线。在狭小的厨房空间环境，每个厨师在完成蛋糕后必须等待下一个厨师已经准备好接受它；这类似于在一个无缓存的channel上进行沟通。</p>
<p>如果在每个厨师之间有一个放置一个蛋糕的额外空间，那么每个厨师就可以将一个完成的蛋糕临时放在那里而马上进入下一个蛋糕的制作中；这类似于将channel的缓存队列的容量设置为1。只要每个厨师的平均工作效率相近，那么其中大部分的传输工作将是迅速的，个体之间细小的效率差异将在交接过程中弥补。如果厨师之间有更大的额外空间——也是就更大容量的缓存队列——将可以在不停止生产线的前提下消除更大的效率波动，例如一个厨师可以短暂地休息，然后再加快赶上进度而不影响其他人。</p>
<p>另一方面，如果生产线的前期阶段一直快于后续阶段，那么它们之间的缓存在大部分时间都将是满的。相反，如果后续阶段比前期阶段更快，那么它们之间的缓存在大部分时间都将是空的。对于这类场景，额外的缓存并没有带来任何好处。</p>
<p>生产线的隐喻对于理解channels和goroutines的工作机制是很有帮助的。例如，如果第二阶段是需要精心制作的复杂操作，一个厨师可能无法跟上第一个厨师的进度，或者是无法满足第三阶段厨师的需求。要解决这个问题，我们可以再雇佣另一个厨师来帮助完成第二阶段的工作，他执行相同的任务但是独立工作。这类似于基于相同的channels创建另一个独立的goroutine。</p>
<p>我们没有太多的空间展示全部细节，但是gopl.io&#x2F;ch8&#x2F;cake包模拟了这个蛋糕店，可以通过不同的参数调整。它还对上面提到的几种场景提供对应的基准测试（§11.4） 。</p>
<h2 id="并发的循环"><a href="#并发的循环" class="headerlink" title="并发的循环"></a><a href="https://gopl-zh.github.io/ch8/ch8-05.html#85-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%BE%AA%E7%8E%AF">并发的循环</a></h2><p>本节中，我们会探索一些用来在并行时循环迭代的常见并发模型。我们会探究从全尺寸图片生成一些缩略图的问题。gopl.io&#x2F;ch8&#x2F;thumbnail包提供了<code>ImageFile</code>函数来帮我们拉伸图片。我们不会说明这个函数的实现，只需要从gopl.io下载它。</p>
<p><em>gopl.io&#x2F;ch8&#x2F;thumbnail</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thumbnail</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageFile reads an image from infile and writes</span></span><br><span class="line"><span class="comment">// a thumbnail-size version of it in the same directory.</span></span><br><span class="line"><span class="comment">// It returns the generated file name, e.g., &quot;foo.thumb.jpg&quot;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ImageFile</span><span class="params">(infile <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>下面的程序会循环迭代一些图片文件名，并为每一张图片生成一个缩略图：</p>
<p><em>gopl.io&#x2F;ch8&#x2F;thumbnail</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// makeThumbnails makes thumbnails of the specified files.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails</span><span class="params">(filenames []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        <span class="keyword">if</span> _, err := thumbnail.ImageFile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然我们处理文件的顺序无关紧要，因为每一个图片的拉伸操作和其它图片的处理操作都是彼此独立的。像这种子问题都是完全彼此独立的问题被叫做易并行问题（译注：embarrassingly parallel，直译的话更像是尴尬并行）。易并行问题是最容易被实现成并行的一类问题，并且最能够享受到并发带来的好处，能够随着并行的规模线性地扩展。</p>
<p>下面让我们并行地执行这些操作，从而将文件IO的延迟隐藏掉，并用上多核cpu的计算能力来拉伸图像。我们的第一个并发程序只是使用了一个<code>go</code>关键字。这里我们先忽略掉错误，之后再进行处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> incorrect!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails2</span><span class="params">(filenames []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        <span class="keyword">go</span> thumbnail.ImageFile(f) <span class="comment">// <span class="doctag">NOTE:</span> ignoring errors</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个版本运行的实在有点太快，实际上，由于它比最早的版本使用的时间要短得多，即使当文件名的slice中只包含有一个元素。这就有点奇怪了，如果程序没有并发执行的话，那为什么一个并发的版本还是要快呢？答案其实是makeThumbnails在它还没有完成工作之前就已经返回了。它启动了所有的goroutine，每一个文件名对应一个，但没有等待它们一直到执行完毕。</p>
<p>没有什么直接的办法能够等待goroutine完成，但是我们可以改变goroutine里的代码让其能够将完成情况报告给外部的goroutine知晓，使用的方式是向一个共享的channel中发送事件。因为我们已经确切地知道有<code>len(filenames)</code>个内部goroutine，所以外部的goroutine只需要在返回之前对这些事件计数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// makeThumbnails3 makes thumbnails of the specified files in parallel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails3</span><span class="params">(filenames []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            thumbnail.ImageFile(f) <span class="comment">// <span class="doctag">NOTE:</span> ignoring errors</span></span><br><span class="line">            ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Wait for goroutines to complete.</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意我们将<code>f</code>的值作为一个显式的变量传给了函数，而不是在循环的闭包中声明：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        thumbnail.ImageFile(f) <span class="comment">// <span class="doctag">NOTE:</span> incorrect!</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回忆一下之前在5.6.1节中，匿名函数中的循环变量快照问题。上面这个单独的变量<code>f</code>是被所有的匿名函数值所共享，且会被连续的循环迭代所更新的。当新的goroutine开始执行字面函数时，for循环可能已经更新了<code>f</code>并且开始了另一轮的迭代或者（更有可能的）已经结束了整个循环，所以当这些goroutine开始读取f的值时，它们所看到的值已经是slice的最后一个元素了。显式地添加这个参数，我们能够确保使用的f是当go语句执行时的“当前”那个<code>f</code>。</p>
<p>如果我们想要从每一个worker goroutine往主goroutine中返回值时该怎么办呢？当我们调用<code>thumbnail.ImageFile</code>创建文件失败的时候，它会返回一个错误。下一个版本的<code>makeThumbnails</code>会返回其在做拉伸操作时接收到的第一个错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// makeThumbnails4 makes thumbnails for the specified files in parallel.</span></span><br><span class="line"><span class="comment">// It returns an error if any step failed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails4</span><span class="params">(filenames []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    errors := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            _, err := thumbnail.ImageFile(f)</span><br><span class="line">            errors &lt;- err</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        <span class="keyword">if</span> err := &lt;-errors; err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err <span class="comment">// <span class="doctag">NOTE:</span> incorrect: goroutine leak!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个程序有一个微妙的bug。当它遇到第一个非nil的error时会直接将error返回到调用方，使得没有一个goroutine去排空errors channel。这样剩下的worker goroutine在向这个channel中发送值时，都会永远地阻塞下去，并且永远都不会退出。这种情况叫做<em>goroutine泄露</em>（§8.4.4），可能会导致整个程序卡住或者跑出out of memory的错误。</strong></p>
<p>最简单的解决办法就是用一个具有合适大小的buffered channel，这样这些worker goroutine向channel中发送错误时就不会被阻塞。（一个可选的解决办法是创建一个另外的goroutine，当main goroutine返回第一个错误的同时去排空channel。）</p>
<p>下一个版本的<code>makeThumbnails</code>使用了一个buffered channel来返回生成的图片文件的名字，附带生成时的错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// makeThumbnails5 makes thumbnails for the specified files in parallel.</span></span><br><span class="line"><span class="comment">// It returns the generated file names in an arbitrary order,</span></span><br><span class="line"><span class="comment">// or an error if any step failed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails5</span><span class="params">(filenames []<span class="type">string</span>)</span></span> (thumbfiles []<span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">type</span> item <span class="keyword">struct</span> &#123;</span><br><span class="line">        thumbfile <span class="type">string</span></span><br><span class="line">        err       <span class="type">error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> item, <span class="built_in">len</span>(filenames))</span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">var</span> it item</span><br><span class="line">            it.thumbfile, it.err = thumbnail.ImageFile(f)</span><br><span class="line">            ch &lt;- it</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        it := &lt;-ch</span><br><span class="line">        <span class="keyword">if</span> it.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, it.err</span><br><span class="line">        &#125;</span><br><span class="line">        thumbfiles = <span class="built_in">append</span>(thumbfiles, it.thumbfile)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> thumbfiles, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们最后一个版本的<code>makeThumbnails</code>返回了新文件们的大小总计数（bytes）。和前面的版本都不一样的一点是我们在这个版本里没有把文件名放在slice里，而是通过一个string的channel传过来，所以我们无法对循环的次数进行预测。</p>
<p>为了知道最后一个goroutine什么时候结束（最后一个结束并不一定是最后一个开始），我们需要一个递增的计数器，在每一个goroutine启动时加一，在goroutine退出时减一。这需要一种特殊的计数器，这个计数器需要在多个goroutine操作时做到安全并且提供在其减为零之前一直等待的一种方法。这种计数类型被称为<code>sync.WaitGroup</code>，下面的代码就用到了这种方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// makeThumbnails6 makes thumbnails for each file received from the channel.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes occupied by the files it creates.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails6</span><span class="params">(filenames &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    sizes := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int64</span>)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup <span class="comment">// number of working goroutines</span></span><br><span class="line">    <span class="keyword">for</span> f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// worker</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            thumb, err := thumbnail.ImageFile(f)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Println(err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            info, _ := os.Stat(thumb) <span class="comment">// OK to ignore error</span></span><br><span class="line">            sizes &lt;- info.Size()</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// closer</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        <span class="built_in">close</span>(sizes)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> total <span class="type">int64</span></span><br><span class="line">    <span class="keyword">for</span> size := <span class="keyword">range</span> sizes &#123;</span><br><span class="line">        total += size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>Add</code>和<code>Done</code>方法的不对称。<code>Add</code>是为计数器加一，必须在worker goroutine开始之前调用，而不是在worker goroutine中；否则的话我们没办法确定<code>Add</code>是在”closer” goroutine调用<code>Wait</code>之前被调用。并且<code>Add</code>还有一个参数，但<code>Done</code>却没有任何参数；其实<code>Done()</code>和<code>Add(-1)</code>是等价的。我们使用defer来确保计数器即使是在出错的情况下依然能够正确地被减掉。上面的程序代码结构是当我们使用并发循环，但又不知道迭代次数时很通常而且很地道的写法。</p>
<p>sizes channel携带了每一个文件的大小到main goroutine，在main goroutine中使用了range loop来计算总和。观察一下我们是怎样创建一个closer goroutine，并让其在所有worker goroutine们结束之后再关闭sizes channel的。两步操作：wait和close，必须是基于sizes的循环的并发。</p>
<p>考虑一下另一种方案：如果等待操作被放在了main goroutine中，在循环之前，这样的话就永远都不会结束了，如果在循环之后，那么又变成了不可达的部分，因为没有任何东西去关闭这个channel，这个循环就永远都不会终止。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// makeThumbnails6 makes thumbnails for each file received from the channel.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes occupied by the files it creates.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails6</span><span class="params">(filenames &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    sizes := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int64</span>)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup <span class="comment">// number of working goroutines</span></span><br><span class="line">    <span class="keyword">for</span> f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// worker</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            thumb, err := thumbnail.ImageFile(f)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Println(err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            info, _ := os.Stat(thumb) <span class="comment">// OK to ignore error</span></span><br><span class="line">            sizes &lt;- info.Size()</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// closer</span></span><br><span class="line">    wg.Wait()  <span class="comment">// 会等待所有goroutine结束，但同时又没有消耗channel size中的数据，不消耗，则wg就没法归零，所以会卡死。</span></span><br><span class="line">    <span class="built_in">close</span>(sizes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> total <span class="type">int64</span></span><br><span class="line">  <span class="keyword">for</span> size := <span class="keyword">range</span> sizes &#123;  <span class="comment">// 由于前面的 wg.Wait()，这里无法消耗 channel sizes中的数据</span></span><br><span class="line">        total += size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图8.5 表明了<code>makethumbnails6</code>函数中事件的序列。纵列表示goroutine。窄线段代表sleep，粗线段代表活动。斜线箭头代表用来同步两个goroutine的事件。时间向下流动。注意main goroutine是如何大部分的时间被唤醒执行其range循环，等待worker发送值或者closer来关闭channel的。</p>
<p><img src="/2022/notes-of-gopl/ch8-05.png" alt="img"></p>
<h2 id="示例-并发的Web爬虫"><a href="#示例-并发的Web爬虫" class="headerlink" title="示例: 并发的Web爬虫"></a><a href="https://gopl-zh.github.io/ch8/ch8-06.html#86-%E7%A4%BA%E4%BE%8B-%E5%B9%B6%E5%8F%91%E7%9A%84web%E7%88%AC%E8%99%AB">示例: 并发的Web爬虫</a></h2><p>在5.6节中，我们做了一个简单的web爬虫，用bfs(广度优先)算法来抓取整个网站。在本节中，我们会让这个爬虫并行化，这样每一个彼此独立的抓取命令可以并行进行IO，最大化利用网络资源。crawl函数和gopl.io&#x2F;ch5&#x2F;findlinks3中的是一样的。</p>
<p><em>gopl.io&#x2F;ch8&#x2F;crawl1</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    fmt.Println(url)</span><br><span class="line">    list, err := links.Extract(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Print(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数和5.6节中的breadthFirst(广度优先)类似。像之前一样，一个worklist是一个记录了需要处理的元素的队列，每一个元素都是一个需要抓取的URL列表，不过这一次我们用channel代替slice来做这个队列。每一个对crawl的调用都会在他们自己的goroutine中进行并且会把他们抓到的链接发送回worklist。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    worklist := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start with the command-line arguments.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; worklist &lt;- os.Args[<span class="number">1</span>:] &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Crawl the web concurrently.</span></span><br><span class="line">    seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> list := <span class="keyword">range</span> worklist &#123;</span><br><span class="line">        <span class="keyword">for</span> _, link := <span class="keyword">range</span> list &#123;</span><br><span class="line">            <span class="keyword">if</span> !seen[link] &#123;</span><br><span class="line">                seen[link] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(link <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">                    worklist &lt;- crawl(link)</span><br><span class="line">                &#125;(link)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的crawl所在的goroutine会将link作为一个显式的参数传入，来避免“循环变量快照”的问题（在5.6.1中有讲解）。<strong>另外注意这里将命令行参数传入worklist也是在一个另外的goroutine中进行的，这是为了避免channel两端的main goroutine与crawler goroutine都尝试向对方发送内容，却没有一端接收内容时发生死锁。当然，这里我们也可以用buffered channel来解决问题，这里不再赘述。</strong></p>
<p>现在爬虫可以高并发地运行起来，并且可以产生一大坨的URL了，不过还是会有俩问题。一个问题是在运行一段时间后可能会出现在log的错误信息里的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch8/crawl1</span><br><span class="line">$ ./crawl1 http://gopl.io/</span><br><span class="line">http://gopl.io/</span><br><span class="line">https://golang.org/help/</span><br><span class="line">https://golang.org/doc/</span><br><span class="line">https://golang.org/blog/</span><br><span class="line">...</span><br><span class="line">2015/07/15 18:22:12 Get ...: dial tcp: lookup blog.golang.org: no such host</span><br><span class="line">2015/07/15 18:22:12 Get ...: dial tcp 23.21.222.120:443: socket: too many open files</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>最初的错误信息是一个让人莫名的DNS查找失败，即使这个域名是完全可靠的。而随后的错误信息揭示了原因：这个程序一次性创建了太多网络连接，超过了每一个进程的打开文件数限制，既而导致了在调用<code>net.Dial</code>像DNS查找失败这样的问题。</p>
<p>这个程序实在是太他妈并行了。无穷无尽地并行化并不是什么好事情，因为不管怎么说，你的系统总是会有一些个限制因素，比如CPU核心数会限制你的计算负载，比如你的硬盘转轴和磁头数限制了你的本地磁盘IO操作频率，比如你的网络带宽限制了你的下载速度上限，或者是你的一个web服务的服务容量上限等等。为了解决这个问题，我们可以限制并发程序所使用的资源来使之适应自己的运行环境。对于我们的例子来说，最简单的方法就是限制对<code>links.Extract</code>在同一时间最多不会有超过n次调用，这里的n一般小于文件描述符的上限值，比如20。这和一个夜店里限制客人数目是一个道理，只有当有客人离开时，才会允许新的客人进入店内。</p>
<p>**我们可以用一个有容量限制的buffered channel来控制并发，这类似于操作系统里的计数信号量概念。**从概念上讲，channel里的n个空槽代表n个可以处理内容的token（令牌），从channel里接收一个值会释放其中的一个token，并且生成一个新的空槽位。这样保证了在没有接收介入时最多有n个发送操作。（这里可能我们拿channel里填充的槽来做token更直观一些，不过还是这样吧。）由于channel里的元素类型并不重要，我们用一个零值的<code>struct&#123;&#125;</code>来作为其元素。</p>
<p>让我们重写<code>crawl</code>函数，将对<code>links.Extract</code>的调用操作用获取、释放token的操作包裹起来，来确保同一时间对其只有20个调用。信号量数量和其能操作的IO资源数量应保持接近。</p>
<p><em>gopl.io&#x2F;ch8&#x2F;crawl2</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tokens is a counting semaphore used to</span></span><br><span class="line"><span class="comment">// enforce a limit of 20 concurrent requests.</span></span><br><span class="line"><span class="keyword">var</span> tokens = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    fmt.Println(url)</span><br><span class="line">    tokens &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// acquire a token</span></span><br><span class="line">    list, err := links.Extract(url)</span><br><span class="line">    &lt;-tokens <span class="comment">// release the token</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Print(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以写一个程序来验证一下上面用有缓冲的channel来实现对goroutine并发数量限制的思路：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> tokens = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;len=%d\n&quot;</span>, <span class="built_in">len</span>(tokens))</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			fmt.Printf(<span class="string">&quot;before acquiring a token n=%d\n&quot;</span>, n)</span><br><span class="line">			tokens &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 取得令牌</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;after acquiring a token n=%d\n&quot;</span>, n)</span><br><span class="line">			time.Sleep(time.Second * <span class="number">5</span>) <span class="comment">// 模拟耗时任务</span></span><br><span class="line">			&lt;-tokens <span class="comment">// 释放令牌</span></span><br><span class="line">		&#125;(i)</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">0</span></span><br><span class="line">before acquiring a token n=<span class="number">1</span></span><br><span class="line">after acquiring a token n=<span class="number">1</span></span><br><span class="line"><span class="built_in">len</span>=<span class="number">1</span></span><br><span class="line">before acquiring a token n=<span class="number">2</span></span><br><span class="line">after acquiring a token n=<span class="number">2</span></span><br><span class="line"><span class="built_in">len</span>=<span class="number">2</span></span><br><span class="line">before acquiring a token n=<span class="number">3</span></span><br><span class="line">after acquiring a token n=<span class="number">3</span></span><br><span class="line"><span class="built_in">len</span>=<span class="number">3</span></span><br><span class="line">before acquiring a token n=<span class="number">4</span></span><br><span class="line">after acquiring a token n=<span class="number">4</span></span><br><span class="line"><span class="built_in">len</span>=<span class="number">4</span></span><br><span class="line">before acquiring a token n=<span class="number">5</span></span><br><span class="line">after acquiring a token n=<span class="number">5</span></span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span></span><br><span class="line">before acquiring a token n=<span class="number">6</span></span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span></span><br><span class="line">before acquiring a token n=<span class="number">7</span></span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span></span><br><span class="line">before acquiring a token n=<span class="number">8</span></span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span></span><br><span class="line">before acquiring a token n=<span class="number">9</span></span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span></span><br><span class="line">before acquiring a token n=<span class="number">10</span></span><br><span class="line">after acquiring a token n=<span class="number">6</span></span><br><span class="line">after acquiring a token n=<span class="number">7</span></span><br><span class="line">after acquiring a token n=<span class="number">8</span></span><br><span class="line">after acquiring a token n=<span class="number">9</span></span><br><span class="line">after acquiring a token n=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>可以看到，有缓冲channel并不能限制goroutine被创建的数量，只能让没有取得令牌的goroutine阻塞在领取令牌的位置。如果必须先取得令牌才能发送网络请求或打开文件，确实可以起到限制同时发起网络请求和打开文件的数量。但没法限制goroutine被创建的数量。</p>
<p>第二个问题是这个程序永远都不会终止，即使它已经爬到了所有初始链接衍生出的链接。（当然，除非你慎重地选择了合适的初始化URL或者已经实现了练习8.6中的深度限制，你应该还没有意识到这个问题。）为了使这个程序能够终止，我们需要在worklist为空或者没有crawl的goroutine在运行时退出主循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    worklist := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">string</span>)</span><br><span class="line">    <span class="keyword">var</span> n <span class="type">int</span> <span class="comment">// number of pending sends to worklist</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start with the command-line arguments.</span></span><br><span class="line">    n++</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; worklist &lt;- os.Args[<span class="number">1</span>:] &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Crawl the web concurrently.</span></span><br><span class="line">    seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n-- &#123;</span><br><span class="line">        list := &lt;-worklist</span><br><span class="line">        <span class="keyword">for</span> _, link := <span class="keyword">range</span> list &#123;</span><br><span class="line">            <span class="keyword">if</span> !seen[link] &#123;</span><br><span class="line">                seen[link] = <span class="literal">true</span></span><br><span class="line">                n++</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(link <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">                    worklist &lt;- crawl(link)</span><br><span class="line">                &#125;(link)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个版本中，计数器n对worklist的发送操作数量进行了限制。每一次我们发现有元素需要被发送到worklist时，我们都会进行<code>n++</code>操作，在向worklist中发送初始的命令行参数之前，我们也进行过一次<code>n++</code>操作。这里的操作<code>n++</code>是在每启动一个crawler的goroutine之前。主循环会在n减为0时终止，这时候说明没活可干了。</p>
<p>现在这个并发爬虫会比5.6节中的深度优先搜索版快上20倍，而且不会出什么错，并且在其完成任务时也会正确地终止。</p>
<p>**下面的程序是避免过度并发的另一种思路。**这个版本使用了原来的crawl函数，但没有使用计数信号量，取而代之用了20个常驻的crawler goroutine，这样来保证最多20个HTTP请求在并发。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    worklist := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">string</span>)  <span class="comment">// lists of URLs, may have duplicates</span></span><br><span class="line">    unseenLinks := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>) <span class="comment">// de-duplicated URLs</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add command-line arguments to worklist.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; worklist &lt;- os.Args[<span class="number">1</span>:] &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create 20 crawler goroutines to fetch each unseen link.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> link := <span class="keyword">range</span> unseenLinks &#123;</span><br><span class="line">                foundLinks := crawl(link)</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; worklist &lt;- foundLinks &#125;() <span class="comment">// 猜测：因为worklist无缓冲，所以必须在另一个goroutine中避免死锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The main goroutine de-duplicates worklist items</span></span><br><span class="line">    <span class="comment">// and sends the unseen ones to the crawlers.</span></span><br><span class="line">    seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> list := <span class="keyword">range</span> worklist &#123;</span><br><span class="line">        <span class="keyword">for</span> _, link := <span class="keyword">range</span> list &#123;</span><br><span class="line">            <span class="keyword">if</span> !seen[link] &#123;</span><br><span class="line">                seen[link] = <span class="literal">true</span></span><br><span class="line">                unseenLinks &lt;- link <span class="comment">//没有爬过的链接传给 unseenLinks</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的爬虫goroutine现在都是被同一个channel - unseenLinks喂饱的了。主goroutine负责拆分它从worklist里拿到的元素，然后把没有抓过的经由unseenLinks channel发送给一个爬虫的goroutine。</p>
<p>seen这个map被限定在main goroutine中；也就是说这个map只能在main goroutine中进行访问。类似于其它的信息隐藏方式，这样的约束可以让我们从一定程度上保证程序的正确性。例如，内部变量不能够在函数外部被访问到；变量（§2.3.4）在没有发生变量逃逸（译注：局部变量被全局变量引用地址导致变量被分配在堆上）的情况下是无法在函数外部访问的；一个对象的封装字段无法被该对象的方法以外的方法访问到。在所有的情况下，信息隐藏都可以帮助我们约束我们的程序，使其不发生意料之外的情况。</p>
<p>**crawl函数爬到的链接在一个专有的goroutine中被发送到<code>worklist</code>中来避免死锁。（因为<code>worklist</code>无缓冲？）**为了节省篇幅，这个例子的终止问题我们先不进行详细阐述了。</p>
<p><strong>可以写一个程序来验证一下上面用固定数量常驻goroutine来实现对并发数量限制的思路：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	un := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="keyword">for</span> n := <span class="keyword">range</span> ch &#123;</span><br><span class="line">				fmt.Println(n)</span><br><span class="line">				time.Sleep(time.Second * <span class="number">1</span>) <span class="comment">//模拟1秒耗时任务</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> un &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch) <span class="comment">// 关闭channel，否则goroutine无法退出</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="comment">// 输出此行后会停顿1秒钟</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>可以观察到，当5个goroutine都在处理耗时任务时，输出会停顿1秒钟，之后才会继续处理后5个耗时任务。</p>
<h2 id="基于select的多路复用"><a href="#基于select的多路复用" class="headerlink" title="基于select的多路复用"></a><a href="https://gopl-zh.github.io/ch8/ch8-07.html#87-%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">基于select的多路复用</a></h2><p>下面的程序会进行火箭发射的倒计时。<code>time.Tick</code>函数返回一个channel，程序会周期性地像一个节拍器一样向这个channel发送事件。每一个事件的值是一个时间戳，不过更有意思的是其传送方式。</p>
<p><em>gopl.io&#x2F;ch8&#x2F;countdown1</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Commencing countdown.&quot;</span>)</span><br><span class="line">    tick := time.Tick(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> countdown := <span class="number">10</span>; countdown &gt; <span class="number">0</span>; countdown-- &#123;</span><br><span class="line">        fmt.Println(countdown)</span><br><span class="line">        &lt;-tick</span><br><span class="line">    &#125;</span><br><span class="line">    launch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们让这个程序支持在倒计时中，用户按下return键时直接中断发射流程。首先，我们启动一个goroutine，这个goroutine会尝试从标准输入中读入一个单独的byte并且，如果成功了，会向名为<code>abort</code>的channel发送一个值。</p>
<p><em>gopl.io&#x2F;ch8&#x2F;countdown2</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">abort := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    os.Stdin.Read(<span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1</span>)) <span class="comment">// read a single byte</span></span><br><span class="line">    abort &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>现在每一次计数循环的迭代都需要等待两个channel中的其中一个返回事件了：当一切正常时的ticker channel或者异常时返回的<code>abort</code>事件。我们无法做到从每一个channel中接收信息，如果我们这么做的话，如果第一个channel中没有事件发过来那么程序就会立刻被阻塞，这样我们就无法收到第二个channel中发过来的事件。这时候我们需要多路复用（multiplex）这些操作了，为了能够多路复用，我们使用了select语句。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch2:</span><br><span class="line">    <span class="comment">// ...use x...</span></span><br><span class="line"><span class="keyword">case</span> ch3 &lt;- y:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面是select语句的一般形式。和switch语句稍微有点相似，也会有几个case和最后的default选择分支。每一个case代表一个通信操作（在某个channel上进行发送或者接收），并且会包含一些语句组成的一个语句块。一个接收表达式可能只包含接收表达式自身（不把接收到的值赋值给变量什么的），就像上面的第一个case，或者包含在一个简短的变量声明中，像第二个case里一样；第二种形式让你能够引用接收到的值。</strong></p>
<p><strong>select会等待case中有能够执行的case时去执行。当条件满足时，select才会去通信并执行case之后的语句；这时候其它通信是不会执行的。一个没有任何case的select语句写作<code>select&#123;&#125;</code>，会永远地等待下去。</strong></p>
<p>让我们回到我们的火箭发射程序。<code>time.After</code>函数会立即返回一个channel，并起一个新的goroutine在经过特定的时间后向该channel发送一个独立的值。下面的select语句会一直等待直到两个事件中的一个到达，无论是<code>abort</code>事件或者一个10秒经过的事件。如果10秒经过了还没有<code>abort</code>事件进入，那么火箭就会发射。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...create abort channel...</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Commencing countdown.  Press return to abort.&quot;</span>)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">10</span> * time.Second):</span><br><span class="line">        <span class="comment">// Do nothing.</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-abort:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Launch aborted!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    launch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个例子更微妙。<code>ch</code>这个channel的buffer大小是1，所以会交替的为空或为满，所以只有一个case可以进行下去，无论<code>i</code>是奇数或者偶数，它都会打印0 2 4 6 8。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">        fmt.Println(x) <span class="comment">// &quot;0&quot; &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;8&quot;</span></span><br><span class="line">    <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为方便理解，对上面代码进行一些修改：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 注意buffer为1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">		fmt.Println(<span class="string">&quot;&lt;-ch&quot;</span>, x) <span class="comment">// &quot;0&quot; &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;8&quot;</span></span><br><span class="line">  <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">		fmt.Println(<span class="string">&quot;ch&lt;-&quot;</span>, i) <span class="comment">// &quot;0&quot; &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;8&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ch&lt;- 0</span><br><span class="line">&lt;-ch 0</span><br><span class="line">ch&lt;- 2</span><br><span class="line">&lt;-ch 2</span><br><span class="line">ch&lt;- 4</span><br><span class="line">&lt;-ch 4</span><br><span class="line">ch&lt;- 6</span><br><span class="line">&lt;-ch 6</span><br><span class="line">ch&lt;- 8</span><br><span class="line">&lt;-ch 8</span><br></pre></td></tr></table></figure>

<p>当第一趟循环开始，<code>i</code>为0，由于<code>ch</code>为空，所以只能匹配select语句的<code>case ch &lt;- i</code>，则输出<code>ch&lt;- 0</code>；当第二趟循环开始，<code>i</code>为1，由于<code>ch</code>缓冲满了，继续向<code>ch</code>传递消息会被阻塞，所以只能匹配<code>case x := &lt;-ch</code>，则输出<code>&lt;-ch 0</code>。依次类推，输出为0,2,4,6,8，跳过所有<code>i</code>为奇数的趟。</p>
<p>**如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会。**增加前一个例子的buffer大小会使其输出变得不确定，因为当buffer既不为满也不为空时，select语句的执行情况就像是抛硬币的行为一样是随机的。</p>
<p>下面让我们的发射程序打印倒计时。这里的select语句会使每次循环迭代等待一秒来执行退出操作。</p>
<p><em>gopl.io&#x2F;ch8&#x2F;countdown3</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...create abort channel...</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Commencing countdown.  Press return to abort.&quot;</span>)</span><br><span class="line">    tick := time.Tick(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> countdown := <span class="number">10</span>; countdown &gt; <span class="number">0</span>; countdown-- &#123;</span><br><span class="line">        fmt.Println(countdown)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tick:</span><br><span class="line">            <span class="comment">// Do nothing.</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-abort:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Launch aborted!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    launch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>time.Tick</code>函数表现得好像它创建了一个在循环中调用<code>time.Sleep</code>的goroutine，每次被唤醒时发送一个事件。当countdown函数返回时，它会停止从tick中接收事件，但是ticker这个goroutine还依然存活，继续徒劳地尝试向channel中发送值，然而这时候已经没有其它的goroutine会从该channel中接收值了——这被称为goroutine泄露（§8.4.4）。</p>
<p><code>Tick</code>函数挺方便，但是只有当程序整个生命周期都需要这个时间时我们使用它才比较合适。否则的话，我们应该使用下面的这种模式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">&lt;-ticker.C    <span class="comment">// receive from the ticker&#x27;s channel</span></span><br><span class="line">ticker.Stop() <span class="comment">// cause the ticker&#x27;s goroutine to terminate</span></span><br></pre></td></tr></table></figure>

<p>有时候我们希望能够从channel中发送或者接收值，并避免因为发送或者接收导致的阻塞，尤其是当channel没有准备好写或者读时。select语句就可以实现这样的功能。select会有一个default来设置当其它的操作都不能够马上被处理时程序需要执行哪些逻辑。</p>
<p>下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-abort:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Launch aborted!\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**channel的零值是<code>nil</code>。**也许会让你觉得比较奇怪，<code>nil</code>的channel有时候也是有一些用处的。**因为对一个<code>nil</code>的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select到。这使得我们可以用nil来激活或者禁用case，来达成处理其它输入或输出事件时超时和取消的逻辑。**我们会在下一节中看到一个例子。</p>
<h2 id="并发的退出"><a href="#并发的退出" class="headerlink" title="并发的退出"></a><a href="https://gopl-zh.github.io/ch8/ch8-09.html#89-%E5%B9%B6%E5%8F%91%E7%9A%84%E9%80%80%E5%87%BA">并发的退出</a></h2><p>有时候我们需要通知goroutine停止它正在干的事情，比如一个正在执行计算的web服务，然而它的客户端已经断开了和服务端的连接。</p>
<p>Go语言并没有提供在一个goroutine中终止另一个goroutine的方法，由于这样会导致goroutine之间的共享变量落在未定义的状态上。在8.7节中的rocket launch程序中，我们往名字叫<code>abort</code>的channel里发送了一个简单的值，在countdown的goroutine中会把这个值理解为自己的退出信号。但是如果我们想要退出两个或者任意多个goroutine怎么办呢？</p>
<p>一种可能的手段是向abort的channel里发送和goroutine数目一样多的事件来退出它们。如果这些goroutine中已经有一些自己退出了，那么会导致我们的channel里的事件数比goroutine还多，这样导致我们的发送直接被阻塞。另一方面，如果这些goroutine又生成了其它的goroutine，我们的channel里的数目又太少了，所以有些goroutine可能会无法接收到退出消息。一般情况下我们是很难知道在某一个时刻具体有多少个goroutine在运行着的。另外，当一个goroutine从abort channel中接收到一个值的时候，他会消费掉这个值，这样其它的goroutine就没法看到这条信息。为了能够达到我们退出goroutine的目的，我们需要更靠谱的策略，来通过一个channel把消息广播出去，这样goroutine们能够看到这条事件消息，并且在事件完成之后，可以知道这件事已经发生过了。</p>
<p><strong>回忆一下我们关闭了一个channel并且被消费掉了所有已发送的值，操作channel之后的代码可以立即被执行，并且会产生零值。我们可以将这个机制扩展一下，来作为我们的广播机制：不要向channel发送值，而是用关闭一个channel来进行广播。</strong></p>
<p>只要一些小修改，我们就可以把退出逻辑加入到前一节的du程序。首先，我们创建一个退出的channel，不需要向这个channel发送任何值，但其所在的闭包内要写明程序需要退出。我们同时还定义了一个工具函数，cancelled，这个函数在被调用的时候会轮询退出状态。</p>
<p><em>gopl.io&#x2F;ch8&#x2F;du4</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancelled</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们创建一个从标准输入流中读取内容的goroutine，这是一个比较典型的连接到终端的程序。每当有输入被读到（比如用户按了回车键），这个goroutine就会把取消消息通过关闭<code>done</code>的channel广播出去。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cancel traversal when input is detected.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    os.Stdin.Read(<span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1</span>)) <span class="comment">// read a single byte</span></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>现在我们需要使我们的goroutine来对取消进行响应。在main goroutine中，我们添加了select的第三个case语句，尝试从done channel中接收内容。如果这个case被满足的话，在select到的时候即会返回，但在结束之前我们需要把fileSizes channel中的内容“排”空，在channel被关闭之前，舍弃掉所有值。这样可以保证对walkDir的调用不要被向fileSizes发送信息阻塞住，可以正确地完成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="comment">// Drain fileSizes to allow existing goroutines to finish.</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">range</span> fileSizes &#123;</span><br><span class="line">            <span class="comment">// Do nothing.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> size, ok := &lt;-fileSizes:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>walkDir</code>这个goroutine一启动就会轮询取消状态，如果取消状态被设置的话会直接返回，并且不做额外的事情。这样我们将所有在取消事件之后创建的goroutine改变为无操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkDir</span><span class="params">(dir <span class="type">string</span>, n *sync.WaitGroup, fileSizes <span class="keyword">chan</span>&lt;- <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> n.Done()</span><br><span class="line">    <span class="keyword">if</span> cancelled() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, entry := <span class="keyword">range</span> dirents(dir) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>walkDir</code>函数的循环中我们对取消状态进行轮询可以带来明显的益处，可以避免在取消事件发生时还去创建goroutine。取消本身是有一些代价的；想要快速的响应需要对程序逻辑进行侵入式的修改。确保在取消发生之后不要有代价太大的操作可能会需要修改你代码里的很多地方，但是在一些重要的地方去检查取消事件也确实能带来很大的好处。</p>
<p>对这个程序的一个简单的性能分析可以揭示瓶颈在dirents函数中获取一个信号量。下面的select可以让这种操作可以被取消，并且可以将取消时的延迟从几百毫秒降低到几十毫秒。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dirents</span><span class="params">(dir <span class="type">string</span>)</span></span> []os.FileInfo &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="comment">// acquire token</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// cancelled</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sema &#125;() <span class="comment">// release token</span></span><br><span class="line">    <span class="comment">// ...read directory...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在当取消发生时，所有后台的goroutine都会迅速停止并且主函数会返回。当然，当主函数返回时，一个程序会退出，而我们又无法在主函数退出的时候确认其已经释放了所有的资源（译注：因为程序都退出了，你的代码都没法执行了）。这里有一个方便的窍门我们可以一用：取代掉直接从主函数返回，我们调用一个panic，然后runtime会把每一个goroutine的栈dump下来。如果main goroutine是唯一一个剩下的goroutine的话，他会清理掉自己的一切资源。但是如果还有其它的goroutine没有退出，他们可能没办法被正确地取消掉，也有可能被取消但是取消操作会很花时间；所以这里的一个调研还是很有必要的。我们用panic来获取到足够的信息来验证我们上面的判断，看看最终到底是什么样的情况。</p>
<h2 id="示例-聊天服务"><a href="#示例-聊天服务" class="headerlink" title="示例: 聊天服务"></a><a href="https://gopl-zh.github.io/ch8/ch8-10.html#810-%E7%A4%BA%E4%BE%8B-%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1">示例: 聊天服务</a></h2><p>我们用一个聊天服务器来终结本章节的内容，这个程序可以让一些用户通过服务器向其它所有用户广播文本消息。这个程序中有四种goroutine。main和broadcaster各自是一个goroutine实例，每一个客户端的连接都会有一个handleConn和clientWriter的goroutine。broadcaster是select用法的不错的样例，因为它需要处理三种不同类型的消息。</p>
<p>下面演示的main goroutine的工作，是listen和accept(译注：网络编程里的概念)从客户端过来的连接。对每一个连接，程序都会建立一个新的handleConn的goroutine，就像我们在本章开头的并发的echo服务器里所做的那样。</p>
<p><em>gopl.io&#x2F;ch8&#x2F;chat</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> broadcaster()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Print(err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是<code>broadcaster</code>的goroutine。他的内部变量<code>clients</code>会记录当前建立连接的客户端集合。其记录的内容是每一个客户端的消息发出channel的“资格”信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> client <span class="keyword">chan</span>&lt;- <span class="type">string</span> <span class="comment">// an outgoing message channel</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    entering = <span class="built_in">make</span>(<span class="keyword">chan</span> client)</span><br><span class="line">    leaving  = <span class="built_in">make</span>(<span class="keyword">chan</span> client)</span><br><span class="line">    messages = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>) <span class="comment">// all incoming client messages</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcaster</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 注意：channel类型是可以作为map的键的！</span></span><br><span class="line">    clients := <span class="built_in">make</span>(<span class="keyword">map</span>[client]<span class="type">bool</span>) <span class="comment">// all connected clients</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">            <span class="comment">// Broadcast incoming message to all</span></span><br><span class="line">            <span class="comment">// clients&#x27; outgoing message channels.</span></span><br><span class="line">            <span class="keyword">for</span> cli := <span class="keyword">range</span> clients &#123;</span><br><span class="line">                cli &lt;- msg</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> cli := &lt;-entering:</span><br><span class="line">            clients[cli] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> cli := &lt;-leaving:</span><br><span class="line">            <span class="built_in">delete</span>(clients, cli)</span><br><span class="line">            <span class="built_in">close</span>(cli)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>broadcaster</code>监听来自全局的<code>entering</code>和<code>leaving</code>的channel来获知客户端的到来和离开事件。当其接收到其中的一个事件时，会更新<code>clients</code>集合，当该事件是离开行为时，它会关闭客户端的消息发送channel。<code>broadcaster</code>也会监听全局的消息channel，所有的客户端都会向这个channel中发送消息。当<code>broadcaster</code>接收到什么消息时，就会将其广播至所有连接到服务端的客户端。</p>
<p>现在让我们看看每一个客户端的goroutine。<code>handleConn</code>函数会为它的客户端创建一个消息发送channel并通过<code>entering</code> channel来通知客户端的到来。然后它会读取客户端发来的每一行文本，并通过全局的消息channel来将这些文本发送出去，并为每条消息带上发送者的前缀来标明消息身份。当客户端发送完毕后，<code>handleConn</code>会通过<code>leaving</code>这个channel来通知客户端的离开并关闭连接。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>) <span class="comment">// outgoing client messages</span></span><br><span class="line">    <span class="keyword">go</span> clientWriter(conn, ch)</span><br><span class="line"></span><br><span class="line">    who := conn.RemoteAddr().String()</span><br><span class="line">    ch &lt;- <span class="string">&quot;You are &quot;</span> + who</span><br><span class="line">    messages &lt;- who + <span class="string">&quot; has arrived&quot;</span></span><br><span class="line">    entering &lt;- ch</span><br><span class="line"></span><br><span class="line">    input := bufio.NewScanner(conn)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        messages &lt;- who + <span class="string">&quot;: &quot;</span> + input.Text()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> ignoring potential errors from input.Err()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于上面的for循环，只要客户端不退出，就运行不到下面这一行</span></span><br><span class="line">    leaving &lt;- ch</span><br><span class="line">    messages &lt;- who + <span class="string">&quot; has left&quot;</span></span><br><span class="line">    conn.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clientWriter</span><span class="params">(conn net.Conn, ch &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> msg := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Fprintln(conn, msg) <span class="comment">// <span class="doctag">NOTE:</span> ignoring network errors</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，<code>handleConn</code>为每一个客户端创建了一个<code>clientWriter</code>的goroutine，用来接收向客户端发送消息的channel中的广播消息，并将它们写入到客户端的网络连接。客户端的读取循环会在<code>broadcaster</code>接收到<code>leaving</code>通知并关闭了channel后终止。</p>
<p>下面演示的是当服务器有两个活动的客户端连接，并且在两个窗口中运行的情况，使用netcat来聊天：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch8/chat</span><br><span class="line">$ go build gopl.io/ch8/netcat3</span><br><span class="line">$ ./chat &amp;</span><br><span class="line">$ ./netcat3</span><br><span class="line">You are 127.0.0.1:64208               $ ./netcat3</span><br><span class="line">127.0.0.1:64211 has arrived           You are 127.0.0.1:64211</span><br><span class="line">Hi!</span><br><span class="line">127.0.0.1:64208: Hi!                  127.0.0.1:64208: Hi!</span><br><span class="line">                                      Hi yourself.</span><br><span class="line">127.0.0.1:64211: Hi yourself.         127.0.0.1:64211: Hi yourself.</span><br><span class="line">^C</span><br><span class="line">                                      127.0.0.1:64208 has left</span><br><span class="line">$ ./netcat3</span><br><span class="line">You are 127.0.0.1:64216               127.0.0.1:64216 has arrived</span><br><span class="line">                                      Welcome.</span><br><span class="line">127.0.0.1:64211: Welcome.             127.0.0.1:64211: Welcome.</span><br><span class="line">                                      ^C</span><br><span class="line">127.0.0.1:64211 has left”</span><br></pre></td></tr></table></figure>

<p>当与n个客户端保持聊天session时，这个程序会有2n+2个并发的goroutine，然而这个程序却并不需要显式的锁（§9.2）。clients这个map被限制在了一个独立的goroutine中，broadcaster，所以它不能被并发地访问。多个goroutine共享的变量只有这些channel和net.Conn的实例，两个东西都是并发安全的。我们会在下一章中更多地讲解约束，并发安全以及goroutine中共享变量的含义。</p>
<h1 id="基于共享变量的并发"><a href="#基于共享变量的并发" class="headerlink" title="基于共享变量的并发"></a>基于共享变量的并发</h1><h2 id="竞态"><a href="#竞态" class="headerlink" title="竞态"></a>竞态</h2><p>在一个线性（就是说只有一个goroutine的）的程序中，程序的执行顺序只由程序的逻辑来决定。在有两个或更多goroutine的程序中，每一个goroutine内的语句也是按照既定的顺序去执行的，但是一般情况下我们没法去知道分别位于两个goroutine的事件x和y的执行顺序，x是在y之前还是之后还是同时发生是没法判断的。当我们没有办法自信地确认一个事件是在另一个事件的前面或者后面发生的话，就说明x和y这两个事件是并发的。</p>
<p>考虑一下，一个函数在线性程序中可以正确地工作。如果在并发的情况下，这个函数依然可以正确地工作的话，那么我们就说这个函数是并发安全的，并发安全的函数不需要额外的同步工作。我们可以把这个概念概括为一个特定类型的一些方法和操作函数，<strong>对于某个类型来说，如果其所有可访问的方法和操作都是并发安全的话，那么该类型便是并发安全的。</strong></p>
<p>在一个程序中有非并发安全的类型的情况下，我们依然可以使这个程序并发安全。确实，并发安全的类型是例外，而不是规则，所以只有当文档中明确地说明了其是并发安全的情况下，你才可以并发地去访问它。我们会避免并发访问大多数的类型，无论是将变量局限在单一的一个goroutine内，还是用互斥条件维持更高级别的不变性，都是为了这个目的。我们会在本章中说明这些术语。</p>
<p><strong>相反，包级别的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。</strong></p>
<p>一个函数在并发调用时没法工作的原因太多了，比如死锁（deadlock）、活锁（livelock）和资源耗尽（resource starvation）。我们没有空去讨论所有的问题，这里我们只聚焦在竞争条件上。</p>
<p><strong>竞态</strong> 指的是程序在多个goroutine交叉执行操作时，没有给出正确的结果。竞态是很恶劣的一种场景，因为这种问题会一直潜伏在你的程序里，然后在非常少见的时候蹦出来，或许只是会在很大的负载时才会发生，又或许是会在使用了某一个编译器、某一种平台或者某一种架构的时候才会出现。这些使得竞争条件带来的问题非常难以复现而且难以分析诊断。</p>
<p>传统上经常用经济损失来为竞争条件做比喻，所以我们来看一个简单的银行账户程序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package bank implements a bank with only one account.</span></span><br><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"><span class="keyword">var</span> balance <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123; balance = balance + amount &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> balance &#125;</span><br></pre></td></tr></table></figure>

<p>对于这个简单的程序而言，我们一眼就能看出，以任意顺序调用函数<code>Deposit</code>和<code>Balance</code>都会得到正确的结果。也就是说，<code>Balance</code>函数会给出之前的所有存入的额度之和。然而，当我们并发地而不是顺序地调用这些函数的话，<code>Balance</code>就再也没办法保证结果正确了。考虑一下下面的两个goroutine，其代表了一个银行联合账户的两笔交易：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Alice:</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bank.Deposit(<span class="number">200</span>)                <span class="comment">// A1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;=&quot;</span>, bank.Balance()) <span class="comment">// A2</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bob:</span></span><br><span class="line"><span class="keyword">go</span> bank.Deposit(<span class="number">100</span>)                 <span class="comment">// B</span></span><br></pre></td></tr></table></figure>

<p>Alice存了200，然后检查她的余额，同时Bob存了100。因为A1和A2是和B并发执行的，我们没法预测他们发生的先后顺序。直观地来看的话，我们会认为其执行顺序只有三种可能性：“Alice先”，“Bob先”以及“Alice&#x2F;Bob&#x2F;Alice”交错执行。下面的表格会展示经过每一步骤后<code>balance</code>变量的值。引号里的字符串表示余额单。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alice first        Bob first        Alice/Bob/Alice</span><br><span class="line">          0                0                      0</span><br><span class="line">  A1    200        B     100             A1     200</span><br><span class="line">  A2 &quot;= 200&quot;       A1    300             B      300</span><br><span class="line">  B     300        A2 &quot;= 300&quot;            A2  &quot;= 300&quot;</span><br></pre></td></tr></table></figure>

<p>所有情况下最终的余额都是300。唯一的变数是Alice的余额单是否包含了Bob交易，不过无论怎么着客户都不会在意。</p>
<p>但是事实是上面的直觉推断是错误的。第四种可能的结果是事实存在的，这种情况下Bob的存款会在Alice存款操作中间，在余额被读到（balance + amount）之后，在余额被更新之前（balance &#x3D; …），这样会导致Bob的交易丢失。而这是因为Alice的存款操作A1实际上是两个操作的一个序列，读取然后写；可以称之为A1r和A1w。下面是交叉时产生的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Data race</span><br><span class="line">0</span><br><span class="line">A1r      0     ... = balance + amount</span><br><span class="line">B      100</span><br><span class="line">A1w    200     balance = ...</span><br><span class="line">A2  &quot;= 200&quot;</span><br></pre></td></tr></table></figure>

<p>在A1r之后，balance + amount会被计算为200，所以这是A1w会写入的值，并不受其它存款操作的干预。最终的余额是$200。银行的账户上的资产比Bob实际的资产多了$100。（译注：因为丢失了Bob的存款操作，所以其实是说Bob的钱丢了。）</p>
<p>这个程序包含了一个特定的竞争条件，叫作<strong>数据竞争</strong>。<strong>无论任何时候，只要有两个goroutine并发访问同一变量，且至少其中的一个是写操作的时候就会发生<em>数据竞争</em>。</strong></p>
<p>当发生数据竞争的变量类型是大于一个机器字（译注：32位机器上一个字&#x3D;4个字节）的类型（比如interface，string或者slice类型）时，事情就复杂了。下面的代码会并发地更新两个不同长度的slice：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x []<span class="type">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; x = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>) &#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; x = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1000000</span>) &#125;()</span><br><span class="line">x[<span class="number">999999</span>] = <span class="number">1</span> <span class="comment">// <span class="doctag">NOTE:</span> undefined behavior; memory corruption possible!</span></span><br></pre></td></tr></table></figure>

<p>最后一个语句中的<code>x</code>的值是未定义的；其可能是nil，或者也可能是一个长度为10的slice，也可能是一个长度为1,000,000的slice。但是回忆一下slice的三个组成部分：指针（pointer）、长度（length）和容量（capacity）。如果指针是从第一个make调用来，而长度从第二个make来，<code>x</code>就变成了一个混合体，一个自称长度为1,000,000但实际上内部只有10个元素的slice。这样导致的结果是存储999,999元素的位置会碰撞一个遥远的内存位置，这种情况下难以对值进行预测，而且debug也会变成噩梦。这种语义雷区被称为未定义行为，对C程序员来说应该很熟悉；幸运的是在Go语言里造成的麻烦要比C里小得多。</p>
<p>尽管并发程序的概念让我们知道并发并不是简单的语句交叉执行。我们将会在9.4节中看到，数据竞争可能会有奇怪的结果。许多程序员，甚至一些非常聪明的人也还是会偶尔提出一些理由来允许数据竞争，比如：“互斥条件代价太高”，“这个逻辑只是用来做logging”，“我不介意丢失一些消息”等等。因为在他们的编译器或者平台上很少遇到问题，可能给了他们错误的信心。一个好的经验法则是根本就没有什么所谓的良性数据竞争。所以我们一定要避免数据竞争，那么在我们的程序中要如何做到呢？</p>
<p><strong><em>数据竞态</em>会在两个以上的goroutine并发访问相同的变量且至少其中一个为写操作时发生。根据上述定义，有3种方式可以避免数据竞争：</strong></p>
<p>**第一种方法是不要去写变量。**考虑一下下面的map，会被“懒”填充，也就是说在每个key被第一次请求到的时候才会去填值。如果Icon是被顺序调用的话，这个程序会工作很正常，但如果Icon被并发调用，那么对于这个map来说就会存在数据竞争。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]image.Image)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> not concurrency-safe!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">    icon, ok := icons[name]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        icon = loadIcon(name)</span><br><span class="line">        icons[name] = icon</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> icon</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反之，如果我们在创建goroutine之前的初始化阶段，就初始化了map中的所有条目并且再也不去修改它们，那么任意数量的goroutine并发访问Icon都是安全的，因为每一个goroutine都只是去读取而已。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> icons = <span class="keyword">map</span>[<span class="type">string</span>]image.Image&#123;</span><br><span class="line">    <span class="string">&quot;spades.png&quot;</span>:   loadIcon(<span class="string">&quot;spades.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;hearts.png&quot;</span>:   loadIcon(<span class="string">&quot;hearts.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;diamonds.png&quot;</span>: loadIcon(<span class="string">&quot;diamonds.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;clubs.png&quot;</span>:    loadIcon(<span class="string">&quot;clubs.png&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concurrency-safe.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123; <span class="keyword">return</span> icons[name] &#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子里icons变量在包初始化阶段就已经被赋值了，包的初始化是在程序main函数开始执行之前就完成了的。只要初始化完成了，icons就再也不会被修改。数据结构如果从不被修改或是不变量则是并发安全的，无需进行同步。不过显然，如果update操作是必要的，我们就没法用这种方法，比如说银行账户。</p>
<p>**第二种避免数据竞态的方法是，避免从多个goroutine访问变量。**这也是前一章中大多数程序所采用的方法。例如前面的并发web爬虫（§8.6）的main goroutine是唯一一个能够访问seen map的goroutine，而聊天服务器（§8.10）中的broadcaster goroutine是唯一一个能够访问clients map的goroutine。这些变量都被限定在了一个单独的goroutine中。</p>
<p>由于其它的goroutine不能够直接访问变量，它们只能使用一个channel来发送请求给指定的goroutine来查询更新变量。这也就是Go的口头禅**“不要使用共享内存来通信；使用通信来共享内存”<strong>。使用通道请求来代理一个受限变量的所有访问的goroutine 称为该变量的</strong>监控 goroutine** (monitor goroutine)。例如broadcaster goroutine会监控clients map的全部访问。</p>
<p>下面是一个重写了的银行的例子，这个例子中balance变量被限制在了monitor goroutine中，名为<code>teller</code>：</p>
<p><em>gopl.io&#x2F;ch9&#x2F;bank1</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package bank provides a concurrency-safe bank with one account.</span></span><br><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deposits = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// send amount to deposit</span></span><br><span class="line"><span class="keyword">var</span> balances = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// receive balance</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123; deposits &lt;- amount &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span>       &#123; <span class="keyword">return</span> &lt;-balances &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">teller</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> balance <span class="type">int</span> <span class="comment">// balance is confined to teller goroutine</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> amount := &lt;-deposits:</span><br><span class="line">            balance += amount</span><br><span class="line">        <span class="keyword">case</span> balances &lt;- balance:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> teller() <span class="comment">// start the monitor goroutine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使一个变量无法在整个生命周期受限于单个 goroutine，加以限制仍然可以是解决并发访问的好方法。比如一个常见的场景，可以通过借助通道来把共享变量的地址从上一步传到下一步，从而在流水线上的多个 goroutine 之间共享该变量。在流水线中的每一步，在把变量地址传给下一步后就不再访问该变量了，这样所有对这个变量的访问都是串行的。换个说法，这个变量先受限于流水线的一步，再受限于下一步，以此类推。这种受限有时也称为<strong>串行受限</strong>。</p>
<p>下面的例子中，Cakes会被严格地顺序访问，先是baker gorouine，然后是icer gorouine：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cake <span class="keyword">struct</span>&#123; state <span class="type">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">baker</span><span class="params">(cooked <span class="keyword">chan</span>&lt;- *Cake)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        cake := <span class="built_in">new</span>(Cake)</span><br><span class="line">        cake.state = <span class="string">&quot;cooked&quot;</span></span><br><span class="line">        cooked &lt;- cake <span class="comment">// baker never touches this cake again</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">icer</span><span class="params">(iced <span class="keyword">chan</span>&lt;- *Cake, cooked &lt;-<span class="keyword">chan</span> *Cake)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> cake := <span class="keyword">range</span> cooked &#123;</span><br><span class="line">        cake.state = <span class="string">&quot;iced&quot;</span></span><br><span class="line">        iced &lt;- cake <span class="comment">// icer never touches this cake again</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三种避免数据竞态的方法是允许很多goroutine去访问变量，但是在同一个时刻最多只有一个goroutine在访问。<strong>这种方式被称为</strong>互斥</strong>，在下一节来讨论这个主题。</p>
<h2 id="互斥锁sync-Mutex"><a href="#互斥锁sync-Mutex" class="headerlink" title="互斥锁sync.Mutex"></a>互斥锁<code>sync.Mutex</code></h2><p>在8.6节中，我们使用了一个buffered channel作为一个计数信号量，来保证最多只有20个goroutine会同时执行HTTP请求。<strong>同理，我们可以用一个容量只有1的channel来保证最多只有一个goroutine在同一时刻访问一个共享变量。一个只能为1和0的信号量叫做<em>二元信号量（binary semaphore）</em>。</strong></p>
<p><em>gopl.io&#x2F;ch9&#x2F;bank2</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    sema    = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>) <span class="comment">// a binary semaphore guarding balance</span></span><br><span class="line">    balance <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在sema被消耗之前，没法再次向channel传递变量</span></span><br><span class="line">    <span class="comment">// 所以，在sema已经接收到1个变量后，再向sema传递变量，将会阻塞</span></span><br><span class="line">  	<span class="comment">// 保证了同一时刻只有一个goroutine访问balance</span></span><br><span class="line">    sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// acquire token</span></span><br><span class="line">    balance = balance + amount</span><br><span class="line">    &lt;-sema <span class="comment">// release token</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 在sema被消耗之前，没法再次向channel传递变量</span></span><br><span class="line">    <span class="comment">// 所以，在sema已经接收到1个变量后，再向sema传递变量，将会阻塞</span></span><br><span class="line">    <span class="comment">// 保证了同一时刻只有一个goroutine访问balance</span></span><br><span class="line">    sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// acquire token</span></span><br><span class="line">    b := balance</span><br><span class="line">    &lt;-sema <span class="comment">// release token</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种互斥锁应用非常广泛，所以<code>sync</code>包有一个单独的<code>Mutex</code>类型来直接提供支持。它的<code>Lock</code>方法能够获取到token(此过程也称为<strong>上锁</strong>)，并且<code>Unlock</code>方法会释放这个token：</p>
<p><em>gopl.io&#x2F;ch9&#x2F;bank3</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mutex      sync.Mutex <span class="comment">// guards balance</span></span><br><span class="line">    balance <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    balance = balance + amount</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    b := balance</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**每次一个goroutine访问<code>balance</code>余额变量，它都会调用<code>mutex</code>的<code>Lock</code>方法来获取一个互斥锁。如果其它的goroutine已经获得了这个锁的话，这个操作会被阻塞直到其它goroutine调用了<code>Unlock</code>使该锁变回可用状态。互斥量<code>mutex</code>会保护共享变量。惯例来说，被<code>mutex</code>所保护的变量是在<code>mutex</code>变量声明之后立刻声明的。**如果你的做法和惯例不符，确保在文档里对你的做法进行说明。</p>
<p><strong>在<code>Lock</code>和<code>Unlock</code>之间的代码段中的内容goroutine可以随便读取或者修改，这个代码段叫做<em>临界区</em>。锁的持有者在其他goroutine获取该锁之前需要调用<code>Unlock</code>。goroutine在结束后释放锁是必要的，无论以哪条路径通过函数都需要释放，即使是在错误路径中，也要记得释放。</strong></p>
<p>上面的银行程序展现了一个典型的并发模式。几个导出函数封装了一个或多个变量，于是只能通过这些函数来访问这些变量 (对于一个对象的变量，则用方法来封装)。<strong>每个函数在开始时申请一个互斥锁，在结束时再释放掉，通过这种方式来确保共享变量不会被并发访问。这种函数、互斥锁、变量的组合方式称为<em>监控(monitor)模式</em>。（之前在监控 goroutine中也使用了监控(monitor)这个词，都代表使用一个代理人 (broker)来确保变量按顺序访问。）</strong></p>
<p>由于在存款和查询余额函数中的临界区代码这么短——只有一行，没有分支调用——在代码最后去调用<code>Unlock</code>就显得更为直截了当。在更复杂的临界区的应用中，尤其是必须要尽早处理错误并返回的情况下，就很难去（靠人）判断对<code>Lock</code>和<code>Unlock</code>的调用是在所有路径中都能够严格配对的了。Go语言里的defer简直就是这种情况下的救星：我们用defer来调用<code>Unlock</code>，临界区会隐式地延伸到函数作用域的最后，这样我们就从“总要记得在函数返回之后或者发生错误返回时要记得调用一次Unlock”这种状态中获得了解放。Go会自动帮我们完成这些事情。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mu.Lock() </span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子里<code>Unlock</code>会在return语句读取完<code>balance</code>的值之后执行，所以<code>Balance</code>函数是并发安全的。这带来的另一点好处是，我们再也不需要一个本地变量<code>b</code>了。</p>
<p><strong>此外，一个deferred Unlock即使在临界区发生panic时依然会执行，这对于用recover（§5.10）来恢复的程序来说是很重要的。defer调用只会比显式地调用Unlock成本高那么一点点，不过却在很大程度上保证了代码的整洁性。大多数情况下对于并发程序来说，代码的整洁性比过度的优化更重要。如果可能的话尽量使用defer来将临界区扩展到函数的结束。</strong></p>
<p>考虑一下下面的<code>Withdraw</code>函数。成功的时候，它会正确地减掉余额并返回<code>true</code>。但如果银行记录资金对交易来说不足，那么取款就会恢复余额，并返回<code>false</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> not atomic!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    Deposit(-amount)</span><br><span class="line">    <span class="keyword">if</span> Balance() &lt; <span class="number">0</span> &#123;</span><br><span class="line">        Deposit(amount)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// insufficient funds</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数终于给出了正确的结果，但是还有一点讨厌的副作用。当过多的取款操作同时执行时，<code>balance</code>可能会瞬时被减到0以下。这可能会引起一个并发的取款被不合逻辑地拒绝。所以如果Bob尝试买一辆sports car时，Alice可能就没办法为她的早咖啡付款了。<strong>这里的问题是取款不是一个原子操作：它包含了三个步骤，每一步都需要去获取并释放互斥锁，但任何一次锁都不会锁上整个取款流程。</strong></p>
<p>理想情况下，取款应该只在整个操作中获得一次互斥锁。下面这样的尝试是错误的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> incorrect!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    Deposit(-amount)</span><br><span class="line">    <span class="keyword">if</span> Balance() &lt; <span class="number">0</span> &#123;</span><br><span class="line">        Deposit(amount)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// insufficient funds</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子中，<code>Deposit</code>会调用<code>mu.Lock()</code>第二次去获取互斥锁，但因为<code>mutex</code>已经锁上了，而无法被重入（译注：go里没有重入锁，关于重入锁的概念，请参考java）——也就是说没法对一个已经锁上的<code>mutex</code>来再次上锁——这会导致程序死锁，没法继续执行下去，<code>Withdraw</code>会永远阻塞下去。</p>
<p>关于Go的<code>mutex</code>不能重入这一点我们有很充分的理由。<code>mutex</code>的目的是确保共享变量在程序执行时的关键点上能够保证不变性。不变性的一层含义是“没有goroutine访问共享变量”，但实际上这里对于<code>mutex</code>保护的变量来说，不变性还包含更深层含义：当一个goroutine获得了一个互斥锁时，它能断定被互斥锁保护的变量正处于不变状态（译注：即没有其他代码块正在读写共享变量），在其获取并保持锁期间，可能会去更新共享变量，这样不变性只是短暂地被破坏，然而当其释放锁之后，锁必须保证共享变量重获不变性并且多个goroutine按顺序访问共享变量。尽管一个可以重入的<code>mutex</code>也可以保证没有其它的goroutine在访问共享变量，但它不具备不变性更深层含义。（译注：<a href="https://stackoverflow.com/questions/14670979/recursive-locking-in-go/14671462#14671462">更详细的解释</a>，Russ Cox认为可重入锁是bug的温床，是一个失败的设计）</p>
<p><strong>一个通用的解决方案是将一个函数分离为多个函数，比如我们把<code>Deposit</code>分离成两个：一个不导出的函数<code>deposit</code>，这个函数假设锁总是会被保持并去做实际的操作，另一个是导出的函数<code>Deposit</code>，这个函数会调用<code>deposit</code>，但在调用前会先去获取锁。同理我们可以将<code>Withdraw</code>也表示成这种形式：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    deposit(-amount)</span><br><span class="line">    <span class="keyword">if</span> balance &lt; <span class="number">0</span> &#123;</span><br><span class="line">        deposit(amount)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// insufficient funds</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    deposit(amount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function requires that the lock be held.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123; balance += amount &#125;</span><br></pre></td></tr></table></figure>

<p>当然，这里的存款<code>deposit</code>函数很小，实际上取款<code>Withdraw</code>函数不需要理会对它的调用，尽管如此，这里的表达还是表明了规则。</p>
<h2 id="读写互斥锁sync-RWMutex"><a href="#读写互斥锁sync-RWMutex" class="headerlink" title="读写互斥锁sync.RWMutex"></a>读写互斥锁<code>sync.RWMutex</code></h2><p>在100刀的存款消失时不做记录多少还是会让我们有一些恐慌，Bob写了一个程序，每秒运行几百次来检查他的银行余额。他会在家，在工作中，甚至会在他的手机上来运行这个程序。银行注意到这些陡增的流量使得存款和取款有了延时，因为所有的余额查询请求是顺序执行的，这样会互斥地获得锁，并且会暂时阻止其它的goroutine运行。</p>
<p><strong>由于<code>Balance</code>函数只需要读取变量的状态，所以我们同时让多个<code>Balance</code>调用并发运行事实上是安全的，只要在运行的时候没有存款或者取款操作就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作<em>多读单写锁（multiple readers, single writer lock）</em>，Go语言提供的这样的锁是<code>sync.RWMutex</code>：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"><span class="keyword">var</span> balance <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mu.RLock() <span class="comment">// readers lock</span></span><br><span class="line">    <span class="keyword">defer</span> mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Balance</code>函数现在调用了<code>RLock</code>和<code>RUnlock</code>方法来获取和释放一个读取或者共享锁。<code>Deposit</code>函数没有变化，会调用<code>mu.Lock</code>和<code>mu.Unlock</code>方法来获取和释放一个写或互斥锁。</p>
<p>在这次修改后，Bob的余额查询请求就可以彼此并行地执行并且会很快地完成了。锁在更多的时间范围可用，并且存款请求也能够及时地被响应了。</p>
<p><strong><code>RLock</code> 仅可用于在临界区域内对共享变量无写操作的情形。一般来讲，我们不应当假定那些逻辑上只读的函数和方法不会更新一些变量。比如，一个看起来只是简单访问器的方法可能会递增内部使用的计数器，或者更新一个缓存来让重复的调用更快。如果你有疑问，那么久应当使用互斥锁 <code>Lock</code>。</strong></p>
<p><strong><code>RWMutex</code>只有当获得锁的大部分goroutine都是读操作，而锁在竞争条件下，也就是说，goroutine们必须等待才能获取到锁的时候，<code>RWMutex</code>才是最能带来好处的。<code>RWMutex</code>需要更复杂的内部记录，所以会让它比一般的无竞争锁的<code>mutex</code>慢一些。</strong></p>
<h2 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h2><p><strong>你可能会对 <code>Balance</code> 方法也需要互斥锁 (不管是基于通道的锁还是基于互斥量的锁)感到奇怪。毕竟，与 <code>Deposit</code> 不一样，它只包含单个操作，所以并不存在另外一个goroutine 插在中间执行的风险。其实需要互斥锁<code>Mutex</code>的原因有两个。首先，是防止 <code>Balance</code> 插到其他操作中间也是很重要的，比如 <code>Withdraw</code>。第二个原因更微妙，因为同步不仅涉及多个 goroutine 的执行顺序问题，同步还会影响到内存。</strong></p>
<p>现代的计算机一般都会有多个处理器，每个处理器都有内存的本地缓存。为了提高效率，对内存的写入是缓存在每个处理器中的，只在必要时才刷回内存。甚至刷回内存的顺序都可能与 goroutine 的写入顺序不一致。像通道通信或者互斥锁操作这样的同步原语都会导致处理器把累积的写操作刷回内存并提交，所以这个时刻之前 goroutine 的执行结果就保证了对运行在其他处理器的goroutine 可见。</p>
<p>考虑一下下面代码片段的可能输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x = <span class="number">1</span> <span class="comment">// A1</span></span><br><span class="line">    fmt.Print(<span class="string">&quot;y:&quot;</span>, y, <span class="string">&quot; &quot;</span>) <span class="comment">// A2</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    y = <span class="number">1</span>                   <span class="comment">// B1</span></span><br><span class="line">    fmt.Print(<span class="string">&quot;x:&quot;</span>, x, <span class="string">&quot; &quot;</span>) <span class="comment">// B2</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>因为两个goroutine是并发执行，并且访问共享变量时也没有互斥，会有数据竞争，所以程序的运行结果没法预测的话也请不要惊讶。我们可能希望它能够打印出下面这四种结果中的一种，相当于几种不同的交错执行时的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y:0 x:1</span><br><span class="line">x:0 y:1</span><br><span class="line">x:1 y:1</span><br><span class="line">y:1 x:1</span><br></pre></td></tr></table></figure>

<p>第四行可以被解释为执行顺序A1,B1,A2,B2或者B1,A1,A2,B2的执行结果。然而实际运行时还是有些情况让我们有点惊讶：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x:0 y:0</span><br><span class="line">y:0 x:0</span><br></pre></td></tr></table></figure>

<p>根据所使用的编译器，CPU，或者其它很多影响因子，这两种情况也是有可能发生的。那么这两种情况要怎么解释呢？</p>
<p>在单个goroutine 内，每个语句的执行顺序是可以被保证的，也就是说，goroutine是串行一致的(sequentially consistent)。但在不使用通道channel或者互斥量mutex来显式同步的情况下，并不能保证所有的 goroutine 看到的事件顺序都是一致的。尽管 goroutine A肯定能在读取<code>y</code>之前能观察到 <code>x=1</code> 的效果，但它并不一定能观察到 goroutine B 对 <code>y</code> 写入的效果，所以A可能会输出<code>y</code>的一个旧的值。</p>
<p>尽管很容易把并发简单理解为多个goroutine 中语句的某种交错执行方式，但正如上面的例子所显示的，这并不是一个现代编译器和 CPU 的工作方式。因为赋值和 print 对应不同的变量，所以编译器就可能会认为两个语句的执行顺序不会影响结果，然后就交换了这两个语句的执行顺序。CPU也有类似的问题，如果两个goroutine在不同的 CPU上执行每个CPU都有自己的缓存，那么一个 goroutine 的写人操作在同步到内存之前对另外一个goroutine的<code>Print</code>语句是不可见的。</p>
<p>这些并发问题都可以通过采用简单、成熟的模式来避免。即，在可能的情况下，把变量限制到单个goroutine 中，对于其他多个goroutine都需要访问的变量，使用互斥锁。</p>
<h2 id="延迟初始化-Lazy-Initialization-sync-Once"><a href="#延迟初始化-Lazy-Initialization-sync-Once" class="headerlink" title="延迟初始化(Lazy Initialization): sync.Once"></a>延迟初始化(Lazy Initialization): <code>sync.Once</code></h2><p>如果初始化成本比较大的话，那么将初始化延迟到需要的时候再去做就是一个比较好的选择。如果在程序启动的时候就去做这类初始化的话，会增加程序的启动时间，并且因为执行的时候可能也并不需要这些变量，所以实际上有一些浪费。让我们来看在本章早一些时候的icons变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br></pre></td></tr></table></figure>

<p>这个版本的<code>Icon</code>用到了懒初始化（lazy initialization）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">    icons = <span class="keyword">map</span>[<span class="type">string</span>]image.Image&#123;</span><br><span class="line">        <span class="string">&quot;spades.png&quot;</span>:   loadIcon(<span class="string">&quot;spades.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;hearts.png&quot;</span>:   loadIcon(<span class="string">&quot;hearts.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;diamonds.png&quot;</span>: loadIcon(<span class="string">&quot;diamonds.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;clubs.png&quot;</span>:    loadIcon(<span class="string">&quot;clubs.png&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> not concurrency-safe!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">    <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">        loadIcons() <span class="comment">// one-time initialization</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个变量只被一个单独的goroutine所访问的话，我们可以使用上面的这种模板，但这种模板在Icon被并发调用时并不安全。就像前面银行的那个<code>Deposit</code>函数一样，<code>Icon</code>函数也是由多个步骤组成的：首先测试<code>icons</code>是否为空，然后load这些<code>icons</code>，之后将icons更新为一个非空的值。直觉会告诉我们最差的情况是<code>loadIcons</code>函数被多次访问会带来数据竞争。当第一个goroutine在忙着loading这些<code>icons</code>的时候，另一个goroutine进入了<code>Icon</code>函数，发现变量是nil，然后也会调用<code>loadIcons</code>函数。</p>
<p>不过这种直觉是错误的。（我们希望你从现在开始能够构建自己对并发的直觉，也就是说对并发的直觉总是不能被信任的！），回忆一下9.4节。因为缺少显式的同步，编译器和CPU是可以随意地去更改访问内存的指令顺序，以任意方式，只要保证每一个goroutine自己的执行顺序一致。其中一种可能<code>loadIcons</code>的语句重排是下面这样。它会在填写<code>icons</code>变量的值之前先用一个空map来初始化<code>icons</code>变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">    icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]image.Image)</span><br><span class="line">    icons[<span class="string">&quot;spades.png&quot;</span>] = loadIcon(<span class="string">&quot;spades.png&quot;</span>)</span><br><span class="line">    icons[<span class="string">&quot;hearts.png&quot;</span>] = loadIcon(<span class="string">&quot;hearts.png&quot;</span>)</span><br><span class="line">    icons[<span class="string">&quot;diamonds.png&quot;</span>] = loadIcon(<span class="string">&quot;diamonds.png&quot;</span>)</span><br><span class="line">    icons[<span class="string">&quot;clubs.png&quot;</span>] = loadIcon(<span class="string">&quot;clubs.png&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，一个goroutine在检查<code>icons</code>是非空时，也并不能就假设这个变量的初始化流程已经走完了（译注：可能只是塞了个空map，里面的值还没填完，也就是说填值的语句都没执行完呢）。</p>
<p><strong>最简单且正确的保证所有goroutine能够观察到<code>loadIcons</code>效果的方式，是用一个mutex来同步检查。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex <span class="comment">// guards icons</span></span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concurrency-safe.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">        loadIcons()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而使用互斥访问<code>icons</code>的代价就是没有办法对该变量进行并发访问，即使变量已经被初始化完毕且再也不会进行变动。这里我们可以引入一个允许多读的锁：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex <span class="comment">// guards icons</span></span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"><span class="comment">// Concurrency-safe.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">    mu.RLock()</span><br><span class="line">    <span class="keyword">if</span> icons != <span class="literal">nil</span> &#123;</span><br><span class="line">        icon := icons[name]</span><br><span class="line">        mu.RUnlock()</span><br><span class="line">        <span class="keyword">return</span> icon</span><br><span class="line">    &#125;</span><br><span class="line">    mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// acquire an exclusive lock</span></span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123; <span class="comment">// <span class="doctag">NOTE:</span> must recheck for nil</span></span><br><span class="line">        loadIcons()</span><br><span class="line">    &#125;</span><br><span class="line">    icon := icons[name]</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> icon</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码有两个临界区。goroutine首先会获取一个读锁，查询map，然后释放锁。如果条目被找到了（一般情况下），那么会直接返回。如果没有找到，那goroutine会获取一个写锁。不释放共享锁的话，也没有任何办法来将一个共享锁升级为一个互斥锁，所以我们必须重新检查<code>icons</code>变量是否为<code>nil</code>，以防止在执行这一段代码的时候，<code>icons</code>变量已经被其它gorouine初始化过了。</p>
<p>上面的模式具有更好的并发性，但它更复杂并且更容易出错。幸运的是，<code>sync</code> 包提供了针对一次性初始化问题的特化解决方案:<code>sync.once</code>。从概念上来讲，<code>once</code> 包含一个布尔变量和一个互斥量，布尔变量记录初始化是否已经完成，互斥量则负责保护这个布尔变量和客户端的数据结构。<code>once</code> 的唯一方法 <code>Do</code> 以初始化函数作为它的参数。让我们看一下<code>once</code>简化后的 <code>Icon</code> 函数:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"><span class="comment">// Concurrency-safe.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">    loadIconsOnce.Do(loadIcons)</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次调用 <code>Do(loadIcons)</code> 时会先锁定互斥量并检查里边的布尔变量。在第一次调用时，这个布尔变量为假，<code>Do</code> 会调用 <code>loadIcons</code> 然后把变量设置为真。后续的调用什么都不会做（相当于空操作），只是通过互斥量的同步来保证 <code>loadIcons</code> 对内存产生的效果（在这里就是 <code>icons</code> 变量）对所有的 goroutine 可见。以这种方式来使用 <code>sync.once</code>，可以避免在变量被构建完成之前和其它goroutine共享该变量。</p>
<h2 id="竞态检测器-The-Race-Detector"><a href="#竞态检测器-The-Race-Detector" class="headerlink" title="竞态检测器 The Race Detector"></a>竞态检测器 The Race Detector</h2><p>即使我们小心到不能再小心，但在并发程序中犯错还是太容易了。幸运的是，Go的runtime和工具链为我们装备了一个复杂但好用的动态分析工具：<strong>竞态检测器 (The Race Detector)</strong>。</p>
<p>只要在<code>go build</code>，<code>go run</code>或者<code>go test</code>命令后面加上<code>-race</code>的命令行标志参数。它就会让编译器为你的应用或测试构建一个修改后的版本，这个版本有额外的手法用于高效记录在执行时对共享变量的所有访问，以及读写这些变量的 goroutine 标识。除此之外，修改后的版本还会记录所有的同步事件，比如go语句，channel操作，以及对<code>(*sync.Mutex).Lock</code>，<code>(*sync.WaitGroup).Wait</code>等等的调用。（完整的同步事件集合是在The Go Memory Model文档中有说明，该文档是和语言文档放在一起的。译注：<a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a> ）</p>
<p>竞态检测器会研究事件流，找到那些有问题的案例，即一个 goroutine 写人一个变量后，中间没有任何同步的操作，就有另外一个 goroutine 读写了该变量。这种案例表明有对共享变量的并发访问，即数据竞态。这个工具会输出一份报告，包括变量的标识以及读写goroutine 当时的调用栈。通常情况下这些信息足以定位问题了。在9.7 节就有一个竞态检测器的示例。</p>
<p>竞态检测器报告所有实际运行了的数据竞态。然而，它只能检测到那些在运行时发生的竞态，无法用来保证肯定不会发生竞态。为了获得最佳效果，请确保你的测试包含了并发使用包的场景。</p>
<p>由于存在额外的簿记 (bookkeeping) 工作，带竞态检测功能的程序在执行时需要更长的时间和更多的内存，但即使对于很多生产环境的任务，这种额外开支也是可以接受的。对于那些不常发生的竞态，使用竞态检测器可以帮你节省数小时甚至数天的调试时间。（译注：多少服务端C&#x2F;C++程序员为此竞折腰。）</p>
<h2 id="示例-并发的非阻塞缓存"><a href="#示例-并发的非阻塞缓存" class="headerlink" title="示例: 并发的非阻塞缓存"></a>示例: 并发的非阻塞缓存</h2><p>在本节中，我们会创建一个并发非阻塞的缓存系统，它能解决在并发实战很常见但已有的库也不能很好地解决的一个问题：函数记忆 (memoizing) 问题，即缓存函数的结果，达到多次调用但只须计算一次的效果。我们的解决方案将是并发安全的，并且要避免简单地对整个缓存使用单个锁而带来的锁争夺问题。</p>
<p>我们将使用下面的 <code>httpgetBody</code> 函数作为示例来演示函数记忆。它会发起一个 HTTP GET 请求并读取响应体。调用这个函数相当昂贵，所以我们希望避免不必要的重复调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpGetBody</span><span class="params">(url <span class="type">string</span>)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    <span class="keyword">return</span> io.ReadAll(resp.Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一行略有一些微妙，<code>ReadAll</code> 返回两个结果，一个<code>[]byte</code> 和一个<code>error</code>，因为它们分别可以直接赋给 <code>httpGetBody</code> 声明的结果类型<code>interface&#123;&#125;</code> 和一个<code>error</code>，所以我们可以直接返回这个结果而不用做额外的处理。<code>httpGetBody</code> 选择这样的结果类型是为了满足我们要做的缓存系统的设计。</p>
<p>下面是缓存的初始版本：</p>
<p><em>gopl.io&#x2F;ch9&#x2F;memo1</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package memo provides a concurrency-unsafe</span></span><br><span class="line"><span class="comment">// memoization of a function of type Func.</span></span><br><span class="line"><span class="keyword">package</span> memo</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Memo caches the results of calling a Func.</span></span><br><span class="line"><span class="keyword">type</span> Memo <span class="keyword">struct</span> &#123;</span><br><span class="line">    f     Func</span><br><span class="line">    cache <span class="keyword">map</span>[<span class="type">string</span>]result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Func is the type of the function to memoize.</span></span><br><span class="line"><span class="keyword">type</span> Func <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err   <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(f Func)</span></span> *Memo &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Memo&#123;f: f, cache: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]result)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> not concurrency-safe!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span></span> Get(key <span class="type">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">    res, ok := memo.cache[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        res.value, res.err = memo.f(key)</span><br><span class="line">        memo.cache[key] = res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.value, res.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Memo实例会记录需要缓存的函数<code>f</code>（类型为<code>Func</code>），以及缓存内容（里面是一个string到result映射的map）。每一个result都是简单的函数返回的值对儿——一个值和一个错误值。继续下去我们会展示一些Memo的变种，不过所有的例子都会遵循上面的这些方面。</p>
<p>下面是一个使用Memo的例子。对于流入的URL的每一个元素我们都会调用<code>Get</code>，并打印调用延时以及其返回的数据大小的<code>log</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := memo.New(httpGetBody)</span><br><span class="line"><span class="keyword">for</span> url := <span class="keyword">range</span> incomingURLs() &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    value, err := m.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Print(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s, %s, %d bytes\n&quot;</span>,</span><br><span class="line">    url, time.Since(start), <span class="built_in">len</span>(value.([]<span class="type">byte</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用测试包（第11章的主题）来系统地鉴定缓存的效果。从下面的测试输出，我们可以看到URL流包含了一些重复的情况，尽管我们第一次对每一个URL的<code>(*Memo).Get</code>的调用都会花上几百毫秒，但第二次就只需要花1毫秒就可以返回完整的数据了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test -v gopl.io/ch9/memo1</span><br><span class="line">=== RUN   Test</span><br><span class="line">https://golang.org, 175.026418ms, 7537 bytes</span><br><span class="line">https://godoc.org, 172.686825ms, 6878 bytes</span><br><span class="line">https://play.golang.org, 115.762377ms, 5767 bytes</span><br><span class="line">http://gopl.io, 749.887242ms, 2856 bytes</span><br><span class="line">https://golang.org, 721ns, 7537 bytes</span><br><span class="line">https://godoc.org, 152ns, 6878 bytes</span><br><span class="line">https://play.golang.org, 205ns, 5767 bytes</span><br><span class="line">http://gopl.io, 326ns, 2856 bytes</span><br><span class="line">--- PASS: Test (1.21s)</span><br><span class="line">PASS</span><br><span class="line">ok  gopl.io/ch9/memo1   1.257s</span><br></pre></td></tr></table></figure>

<p>这个测试是顺序地去做所有的调用的。</p>
<p>由于这种彼此独立的HTTP请求可以很好地并发，我们可以把这个测试改成并发形式。可以使用<code>sync.WaitGroup</code>来等待所有的请求都完成之后再返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := memo.New(httpGetBody)</span><br><span class="line"><span class="keyword">var</span> n sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> url := <span class="keyword">range</span> incomingURLs() &#123;</span><br><span class="line">    n.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        start := time.Now()</span><br><span class="line">        value, err := m.Get(url)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Print(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s, %s, %d bytes\n&quot;</span>,</span><br><span class="line">        url, time.Since(start), <span class="built_in">len</span>(value.([]<span class="type">byte</span>)))</span><br><span class="line">        n.Done()</span><br><span class="line">    &#125;(url)</span><br><span class="line">&#125;</span><br><span class="line">n.Wait()</span><br></pre></td></tr></table></figure>

<p>这次测试跑起来更快了，然而不幸的是貌似这个测试不是每次都能够正常工作。我们注意到有一些意料之外的cache miss（缓存未命中），或者命中了缓存但却返回了错误的值，或者甚至会直接崩溃。</p>
<p>但更糟糕的是，有时候这个程序还是能正确的运行（译：也就是最让人崩溃的偶发bug），所以我们甚至可能都不会意识到这个程序有bug。但是我们可以使用<code>-race</code>这个命令行标志参数来运行程序，竞争检测器（§9.6）会打印像下面这样的报告：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test -run=TestConcurrent -race -v gopl.io/ch9/memo1</span><br><span class="line">=== RUN   TestConcurrent</span><br><span class="line">...</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Write by goroutine 36:</span><br><span class="line">  runtime.mapassign1()</span><br><span class="line">      ~/go/src/runtime/hashmap.go:411 +0x0</span><br><span class="line">  gopl.io/ch9/memo1.(*Memo).Get()</span><br><span class="line">      ~/gobook2/src/gopl.io/ch9/memo1/memo.go:32 +0x205</span><br><span class="line">  ...</span><br><span class="line">Previous write by goroutine 35:</span><br><span class="line">  runtime.mapassign1()</span><br><span class="line">      ~/go/src/runtime/hashmap.go:411 +0x0</span><br><span class="line">  gopl.io/ch9/memo1.(*Memo).Get()</span><br><span class="line">      ~/gobook2/src/gopl.io/ch9/memo1/memo.go:32 +0x205</span><br><span class="line">...</span><br><span class="line">Found 1 data race(s)</span><br><span class="line">FAIL    gopl.io/ch9/memo1   2.393s</span><br></pre></td></tr></table></figure>

<p>memo.go的32行出现了两次，说明有两个goroutine在没有同步干预的情况下更新了cache map。这表明<code>Get</code>方法不是并发安全的，存在数据竞争。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">28</span>  <span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span></span> Get(key <span class="type">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="number">29</span>      res, ok := memo.cache(key)</span><br><span class="line"><span class="number">30</span>      <span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="number">31</span>          res.value, res.err = memo.f(key)</span><br><span class="line"><span class="number">32</span>          memo.cache[key] = res</span><br><span class="line"><span class="number">33</span>      &#125;</span><br><span class="line"><span class="number">34</span>      <span class="keyword">return</span> res.value, res.err</span><br><span class="line"><span class="number">35</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>最简单的使cache并发安全的方式是使用基于监控的同步。只要给Memo加上一个mutex，在Get的一开始获取互斥锁，return的时候释放锁，就可以让cache的操作发生在临界区内了：</p>
<p><em>gopl.io&#x2F;ch9&#x2F;memo2</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Memo <span class="keyword">struct</span> &#123;</span><br><span class="line">    f     Func</span><br><span class="line">    mu    sync.Mutex <span class="comment">// guards cache</span></span><br><span class="line">    cache <span class="keyword">map</span>[<span class="type">string</span>]result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get is concurrency-safe.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span></span> Get(key <span class="type">string</span>) (value <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">    memo.mu.Lock()</span><br><span class="line">    res, ok := memo.cache[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        res.value, res.err = memo.f(key)</span><br><span class="line">        memo.cache[key] = res</span><br><span class="line">    &#125;</span><br><span class="line">    memo.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> res.value, res.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试依然并发进行，但这回竞争检查器“沉默”了。不幸的是对于Memo的这一点改变使我们完全丧失了并发的性能优点。每次对<code>f</code>的调用期间都会持有锁，<code>Get</code>将本来可以并行运行的I&#x2F;O操作串行化了。我们本章的目的是完成一个无锁缓存，而不是现在这样的将所有请求串行化的函数的缓存。</p>
<p>下一个<code>Get</code>的实现，调用<code>Get</code>的goroutine会两次获取锁：查找阶段获取一次，如果查找没有返回任何内容，那么进入更新阶段会再次获取。在这两次获取锁的中间阶段，其它goroutine可以随意使用cache。</p>
<p><em>gopl.io&#x2F;ch9&#x2F;memo3</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span></span> Get(key <span class="type">string</span>) (value <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">    memo.mu.Lock()</span><br><span class="line">    res, ok := memo.cache[key]</span><br><span class="line">    memo.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        res.value, res.err = memo.f(key)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Between the two critical sections, several goroutines</span></span><br><span class="line">        <span class="comment">// may race to compute f(key) and update the map.</span></span><br><span class="line">        memo.mu.Lock()</span><br><span class="line">        memo.cache[key] = res</span><br><span class="line">        memo.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.value, res.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些修改使性能再次得到了提升，但有一些URL被获取了两次。这种情况在两个以上的goroutine同一时刻调用<code>Get</code>来请求同样的URL时会发生。多个goroutine一起查询cache，发现没有值，然后一起调用<code>f</code>这个慢不拉叽的函数。在得到结果后，也都会去更新map。其中一个获得的结果会覆盖掉另一个的结果。</p>
<p>理想情况下是应该避免掉多余的工作的。而这种“避免”工作一般被称为duplicate suppression（重复抑制&#x2F;避免）。下面版本的Memo每一个map元素都是指向一个条目的指针。每一个条目包含对函数<code>f</code>调用结果的内容缓存。与之前不同的是这次<code>entry</code>还包含了一个叫<code>ready</code>的channel。在条目的结果被设置之后，这个channel就会被关闭，以向其它goroutine广播（§8.9）去读取该条目内的结果是安全的了。</p>
<p><em>gopl.io&#x2F;ch9&#x2F;memo4</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    res   result</span><br><span class="line">    ready <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed when res is ready</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(f Func)</span></span> *Memo &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Memo&#123;f: f, cache: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*entry)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Memo <span class="keyword">struct</span> &#123;</span><br><span class="line">    f     Func</span><br><span class="line">    mu    sync.Mutex <span class="comment">// guards cache</span></span><br><span class="line">    cache <span class="keyword">map</span>[<span class="type">string</span>]*entry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span></span> Get(key <span class="type">string</span>) (value <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">    memo.mu.Lock()</span><br><span class="line">    e := memo.cache[key]</span><br><span class="line">    <span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// This is the first request for this key.</span></span><br><span class="line">        <span class="comment">// This goroutine becomes responsible for computing</span></span><br><span class="line">        <span class="comment">// the value and broadcasting the ready condition.</span></span><br><span class="line">        e = &amp;entry&#123;ready: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)&#125;</span><br><span class="line">        memo.cache[key] = e</span><br><span class="line">        memo.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        e.res.value, e.res.err = memo.f(key)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(e.ready) <span class="comment">// broadcast ready condition</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This is a repeat request for this key.</span></span><br><span class="line">        memo.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        &lt;-e.ready <span class="comment">// wait for ready condition</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.res.value, e.res.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在Get函数包括下面这些步骤了：获取互斥锁来保护共享变量cache map，查询map中是否存在指定条目，如果没有找到那么分配空间插入一个新条目，释放互斥锁。如果存在条目的话且其值没有写入完成（也就是有其它的goroutine在调用<code>f</code>这个慢函数）时，goroutine必须等待值<code>ready</code>之后才能读到条目的结果。而想知道是否<code>ready</code>的话，可以直接从ready channel中读取，由于这个读取操作在channel关闭之前一直是阻塞。</p>
<p>如果没有条目的话，需要向map中插入一个没有准备好的条目，当前正在调用的goroutine就需要负责调用慢函数、更新条目以及向其它所有goroutine广播条目已经<code>ready</code>可读的消息了。</p>
<p>条目中的<code>e.res.value</code>和<code>e.res.err</code>变量是在多个goroutine之间共享的。创建条目的goroutine同时也会设置条目的值，其它goroutine在收到”ready”的广播消息之后立刻会去读取条目的值。尽管会被多个goroutine同时访问，但却并不需要互斥锁。ready channel的关闭一定会发生在其它goroutine接收到广播事件之前，因此第一个goroutine对这些变量的写操作是一定发生在这些读操作之前的。不会发生数据竞争。</p>
<p>这样并发、不重复、无阻塞的cache就完成了。</p>
<p>上面这样Memo的实现使用了一个互斥量来保护多个goroutine调用<code>Get</code>时的共享map变量。不妨把这种设计和前面提到的把map变量限制在一个单独的monitor goroutine的方案做一些对比，后者在调用<code>Get</code>时需要发消息。</p>
<p><code>Func</code>、<code>result</code>和<code>entry</code>的声明和之前保持一致：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Func is the type of the function to memoize.</span></span><br><span class="line"><span class="keyword">type</span> Func <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// A result is the result of calling a Func.</span></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err   <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    res   result</span><br><span class="line">    ready <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed when res is ready</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而Memo类型现在包含了一个叫做requests的channel，Get的调用方用这个channel来和monitor goroutine来通信。requests channel中的元素类型是request。Get的调用方会把这个结构中的两组key都填充好，实际上用这两个变量来对函数进行缓存的。另一个叫response的channel会被拿来发送响应结果。这个channel只会传回一个单独的值。</p>
<p><em>gopl.io&#x2F;ch9&#x2F;memo5</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A request is a message requesting that the Func be applied to key.</span></span><br><span class="line"><span class="keyword">type</span> request <span class="keyword">struct</span> &#123;</span><br><span class="line">    key      <span class="type">string</span></span><br><span class="line">    response <span class="keyword">chan</span>&lt;- result <span class="comment">// the client wants a single result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Memo <span class="keyword">struct</span>&#123; requests <span class="keyword">chan</span> request &#125;</span><br><span class="line"><span class="comment">// New returns a memoization of f.  Clients must subsequently call Close.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(f Func)</span></span> *Memo &#123;</span><br><span class="line">    memo := &amp;Memo&#123;requests: <span class="built_in">make</span>(<span class="keyword">chan</span> request)&#125;</span><br><span class="line">    <span class="keyword">go</span> memo.server(f)</span><br><span class="line">    <span class="keyword">return</span> memo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span></span> Get(key <span class="type">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">    response := <span class="built_in">make</span>(<span class="keyword">chan</span> result)</span><br><span class="line">    memo.requests &lt;- request&#123;key, response&#125;</span><br><span class="line">    res := &lt;-response</span><br><span class="line">    <span class="keyword">return</span> res.value, res.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span></span> Close() &#123; <span class="built_in">close</span>(memo.requests) &#125;</span><br></pre></td></tr></table></figure>

<p>上面的Get方法，会创建一个response channel，把它放进request结构中，然后发送给monitor goroutine，然后马上又会接收它。</p>
<p>cache变量被限制在了monitor goroutine &#96;&#96;(*Memo).server&#96;中，下面会看到。monitor会在循环中一直读取请求，直到request channel被Close方法关闭。每一个请求都会去查询cache，如果没有找到条目的话，那么就会创建&#x2F;插入一个新的条目。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span></span> server(f Func) &#123;</span><br><span class="line">    cache := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*entry)</span><br><span class="line">    <span class="keyword">for</span> req := <span class="keyword">range</span> memo.requests &#123;</span><br><span class="line">        e := cache[req.key]</span><br><span class="line">        <span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// This is the first request for this key.</span></span><br><span class="line">            e = &amp;entry&#123;ready: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)&#125;</span><br><span class="line">            cache[req.key] = e</span><br><span class="line">            <span class="keyword">go</span> e.call(f, req.key) <span class="comment">// call f(key)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> e.deliver(req.response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> call(f Func, key <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="comment">// Evaluate the function.</span></span><br><span class="line">    e.res.value, e.res.err = f(key)</span><br><span class="line">    <span class="comment">// Broadcast the ready condition.</span></span><br><span class="line">    <span class="built_in">close</span>(e.ready)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> deliver(response <span class="keyword">chan</span>&lt;- result) &#123;</span><br><span class="line">    <span class="comment">// Wait for the ready condition.</span></span><br><span class="line">    &lt;-e.ready</span><br><span class="line">    <span class="comment">// Send the result to the client.</span></span><br><span class="line">    response &lt;- e.res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和基于互斥量的版本类似，第一个对某个key的请求需要负责去调用函数<code>f</code>并传入这个key，将结果存在条目里，并关闭ready channel来广播条目的ready消息。使用<code>(*entry).call</code>来完成上述工作。</p>
<p>紧接着对同一个key的请求会发现map中已经有了存在的条目，然后会等待结果变为ready，并将结果从response发送给客户端的goroutien。上述工作是用<code>(*entry).deliver</code>来完成的。对call和deliver方法的调用必须让它们在自己的goroutine中进行以确保monitor goroutines不会因此而被阻塞住而没法处理新的请求。</p>
<p>这个例子说明我们无论用上锁，还是通信来建立并发程序都是可行的。</p>
<p>上面的两种方案并不好说特定情境下哪种更好，不过了解他们还是有价值的。有时候从一种方式切换到另一种可以使你的代码更为简洁。</p>
<h2 id="Goroutines和线程"><a href="#Goroutines和线程" class="headerlink" title="Goroutines和线程"></a>Goroutines和线程</h2><p>在上一章中我们说goroutine和操作系统的线程区别可以先忽略。尽管两者的区别实际上只是一个量的区别，但量变会引起质变的道理同样适用于goroutine和线程。现在正是我们来区分开两者的最佳时机。</p>
<h3 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h3><p>每个OS 线程都有一个固定大小的栈内存(通常为 2MB)，栈内存区域用于保存在其他函数调用期间那些正在执行或临时暂停的函数中的局部变量。这个固定的栈大小既太大又太小。对于一个小的goroutine，2MB 的栈是一个巨大的浪费，比如有的 goroutine 仅仅等待一个<code>waitGroup</code> 再关闭一个通道。在 Go程序中，一次创建十万左右的 goroutine 也不罕见，对于这种情况，栈就太大了。另外，对于最复杂和深度递归的函数，固定大小的栈始终不够大。改变这个固定大小可以提高空间效率并允许创建更多的线程，或者也可以容许更深的递归函数，但无法同时做到上面的两点。</p>
<p>作为对比，一个goroutine 在生命周期开始时只有一个很小的栈，典型情况下为2KB与OS 线程类似，goroutine 的栈也用于存放那些正在执行或临时暂停的函数中的局部变量但与OS 线程不同的是，goroutine 的栈不是固定大小的，它可以按需增大和缩小。goroutine的栈大小限制可以达到 1GB，比线程典型的固定大小栈高几个数量级。当然，只有极少的goroutine会使用这么大的栈。</p>
<p>练习9.4：使用通道构造一个把任意多个 goroutine 串联在一起的流水线程序。在内存耗尽之前你能创建的最大流水线级数是多少?一个值穿过整个流水线需要多久?</p>
<h3 id="Goroutine调度"><a href="#Goroutine调度" class="headerlink" title="Goroutine调度"></a>Goroutine调度</h3><p>OS 线程由 OS 内核来调度。每隔几毫秒，一个硬件时钟中断发到 CPU，CPU 调用一个叫调度器的内核函数。这个函数暂停当前正在运行的线程，把它的寄存器信息保存到内存查看线程列表并决定接下来运行哪一个线程，再从内存恢复线程的注册表信息，最后继续执行选中的线程。因为OS 线程由内核来调度，所以控制权限从一个线程到另外一个线程需要个完整的上下文切换(context switch):即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。考虑这个操作涉及的内存局域性以及涉及的内存访问数量，还有访问内存所需的 CPU 周期数量的增加，这个操作其实是很慢的。</p>
<p>Go运行时包含一个自己的调度器，这个调度器使用一个称为 <strong>m:n 调度</strong>的技术(因为它可以复用&#x2F;调度 m个goroutine 到n个OS 线程)。Go调度器与内核调度器的工作类似，但Go调度器只需关心单个 Go序的 goroutine 调度问题。</p>
<p>与操作系统的线程调度器不同的是，Go 调度器不是由硬件时钟来定期触发的，而是由特定的Go语言结构来触发的。比如当一个goroutine 调用 time.sleep 或被通道阻塞或对互斥量操作时，调度器就会将这个 goroutine 设为休眠模式，并运行其他 goroutine 直到前一个可重新唤醒为止。因为它不需要切换到内核语境，所以调用一个goroutine 比调度一个线程成本低很多。</p>
<p><strong>练习 9.5:</strong> 写一个有两个goroutine的程序，两个goroutine会向两个无buffer channel反复地发送ping-pong消息。这样的程序每秒可以支持多少次通信？</p>
<h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h3><p>Go调度器使用<code>GOMAXPROCS</code> 参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的 CPU数量，所以在一个有8个CPU的机器上，调度器会把 Go代码同时调度到8个OS线程上。(<code>GOMAXPROCS</code> 是 m:n 调度中的 n。) 正在休眠或者正被通道通信阻塞的goroutine 不需要占用线程。阻塞在I&#x2F;O和其他系统调用中或调用非Go语言写的函数的goroutine需要一个独立的OS线程，但这个线程不计算在 <code>GOMAXPROCS</code> 内。</p>
<p>可以用<code>GOMAXPROCS</code>环境变量或者 <code>runtime.GOMAXPROCS</code> 函数来显式控制这个参数。可以用个小程序来看看 <code>GOMAXPROCS</code> 的效果，这个程序无止境地输出0和1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">go</span> fmt.Print(<span class="number">0</span>)</span><br><span class="line">    fmt.Print(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ GOMAXPROCS=<span class="number">1</span> <span class="keyword">go</span> run hacker-cliché.<span class="keyword">go</span></span><br><span class="line"><span class="number">111111111111111111110000000000000000000011111.</span>..</span><br><span class="line"></span><br><span class="line">$ GOMAXPROCS=<span class="number">2</span> <span class="keyword">go</span> run hacker-cliché.<span class="keyword">go</span></span><br><span class="line"><span class="number">010101010101010101011001100101011010010100110.</span>..</span><br></pre></td></tr></table></figure>

<p>在第一次运行时，每次最多只能有一个 goroutine 运行。最开始是main goroutine，它输出1。在一段时间以后，Go 调度器让main goroutine 休眠，并且唤醒另一个输出0的goroutine，让它有机会执行。在第二次运行时，这里有两个可用的OS线程，所以两个 goroutine 可以同时运行，以一个差不多的速率输出两个数字。我们必须强调影响 goroutine 调度的因素很多，运行时也在不断演化，所以你的结果可能与上面展示的结果会有所不同。</p>
<p><strong>练习9.6:</strong> 测试一下计算密集型的并发程序（练习8.5那样的）会被GOMAXPROCS怎样影响到。在你的电脑上最佳的值是多少？你的电脑CPU有多少个核心？</p>
<h3 id="Goroutine-没有标识（Identity）"><a href="#Goroutine-没有标识（Identity）" class="headerlink" title="Goroutine 没有标识（Identity）"></a>Goroutine 没有标识（Identity）</h3><p>在大部分支持多线程的操作系统和编程语言里，当前线程都有一个独特的标识（ID），它通常可以取一个整数或者指针。这个特性让我们可以轻松构建一个线程的局部存储，它本质上就是一个全局的 map，以线程的标识（ID）作为键，这样每个线程都可以独立地用这个 map 存储和获取值，而不受其他线程干扰。</p>
<p>goroutine 没有可供程序员访问的标识。这个是由设计来决定的，因为线程局部存储有种被滥用的倾向。比如，当一个 Web 服务器用一个支持线程局部存储的语言来实现时很多函数都会通过访问这个存储来查找关于 HTTP 请求的信息。但就像那些过度依赖于全局变量的程序一样，这也会导致一种不健康的“超距作用”，即函数的行为不仅取决于它的参数，还取决于运行它的线程标识。因此，在线程的标识需要改变的场景(比如需要使用工作线程时)，这些函数的行为就会变得诡异莫测。</p>
<p>Go语言鼓励一种更简单的编程风格，其中，能影响一个函数行为的参数应当是显式指定的。这不仅让程序更易阅读，还让我们能自由地把一个函数的子任务分发到多个不同的 goroutine 而无需担心这些 goroutine 的标识。</p>
<h1 id="包和工具"><a href="#包和工具" class="headerlink" title="包和工具"></a>包和工具</h1><h2 id="包简介"><a href="#包简介" class="headerlink" title="包简介"></a>包简介</h2><p>任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。</p>
<p>每个包一般都定义了一个不同的名字空间用于它内部的每个标识符的访问。每个名字空间关联到一个特定的包，让我们给类型、函数等选择简短明了的名字，这样可以在使用它们的时候减少和其它部分名字的冲突。</p>
<p>每个包还通过控制包内名字的可见性和是否导出来实现封装特性。通过限制包成员的可见性并隐藏包API的具体实现，将允许包的维护者在不影响外部包用户的前提下调整包的内部实现。通过限制包内变量的可见性，还可以强制用户通过某些特定函数来访问和更新内部变量，这样可以保证内部变量的一致性和并发时的互斥约束。</p>
<p>当我们修改了一个源文件，我们必须重新编译该源文件对应的包和所有依赖该包的其他包。即使是从头构建，Go语言编译器的编译速度也明显快于其它编译语言。Go语言的闪电般的编译速度主要得益于三个语言特性。</p>
<ul>
<li>第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。</li>
<li>第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。</li>
<li>第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件（译注：很多都是重复的间接依赖）。</li>
</ul>
<h2 id="导入路径"><a href="#导入路径" class="headerlink" title="导入路径"></a>导入路径</h2><p>每个包是由一个全局唯一的字符串所标识的导入路径定位。出现在import语句中的导入路径也是字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;golang.org/x/net/html&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>就像我们在2.6.1节提到过的，Go语言的规范并没有指明包的导入路径字符串的具体含义，导入路径的具体含义是由构建工具来解释的。在本章，我们将深入讨论Go语言工具箱的功能，包括大家经常使用的构建测试等功能。当然，也有第三方扩展的工具箱存在。例如，Google公司内部的Go语言码农，他们就使用内部的多语言构建系统（译注：Google公司使用的是类似<a href="http://bazel.io/">Bazel</a>的构建系统，支持多种编程语言，目前该构件系统还不能完整支持Windows环境），用不同的规则来处理包名字和定位包，用不同的规则来处理单元测试等等，因为这样可以更紧密适配他们内部环境。</p>
<p>如果你计划分享或发布包，那么导入路径最好是全球唯一的。为了避免冲突，所有非标准库包的导入路径建议以所在组织的互联网域名为前缀；而且这样也有利于包的检索。例如，上面的import语句导入了Go团队维护的HTML解析器和一个流行的第三方维护的MySQL驱动。</p>
<h2 id="包声明"><a href="#包声明" class="headerlink" title="包声明"></a>包声明</h2><p>在每个Go语言源文件的开头都必须有包声明语句。包声明语句的主要目的是确定当前包被其它包导入时默认的标识符（也称为包名）。</p>
<p>例如，<code>math/rand</code>包的每个源文件的开头都包含<code>package rand</code>包声明语句，所以当你导入这个包，你就可以用<code>rand.Int</code>、<code>rand.Float64</code>类似的方式访问包的成员。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，默认的包名就是包导入路径名的最后一段，因此即使两个包的导入路径不同，它们依然可能有一个相同的包名。例如，<code>math/rand</code>包和<code>crypto/rand</code>包的包名都是<code>rand</code>。稍后我们将看到如何同时导入两个有相同包名的包。</p>
<p>关于默认包名一般采用导入路径名的最后一段的约定也有三种例外情况。</p>
<ul>
<li><p>第一个例外，包对应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。名字为main的包是给<code>go build</code>（§10.7.3）构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。</p>
</li>
<li><p>第二个例外，包所在的目录中可能有一些文件名是以<code>_test.go</code>为后缀的Go源文件（译注：前面必须有其它的字符，因为以<code>_</code>或<code>.</code>开头的源文件会被构建工具忽略），并且这些源文件声明的包名也是以<code>_test</code>为后缀名的。这种目录可以包含两种包：一种是普通包，另一种则是测试的外部扩展包。所有以<code>_test</code>为后缀包名的测试外部扩展包都由<code>go test</code>命令独立编译，普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循环导入依赖，具体细节我们将在11.2.4节中介绍。</p>
</li>
<li><p>第三个例外，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如<code>gopkg.in/yaml.v2</code>。这种情况下包的名字并不包含版本号后缀，而是<code>yaml</code>。</p>
</li>
</ul>
<h2 id="导入声明"><a href="#导入声明" class="headerlink" title="导入声明"></a>导入声明</h2><p>可以在一个Go语言源文件包声明语句之后，其它非导入声明语句之前，包含零到多个导入包声明语句。每个导入声明可以单独指定一个导入路径，也可以通过圆括号同时导入多个导入路径。下面两个导入形式是等价的，但是第二种形式更为常见。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>导入的包之间可以通过添加空行来分组；通常将来自不同组织的包独自分组。包的导入顺序无关紧要，但是在每个分组中一般会根据字符串顺序排列。（<code>gofmt</code>和<code>goimports</code>工具都可以将不同分组导入的包独立排序。）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;html/template&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;golang.org/x/net/html&quot;</span></span><br><span class="line">    <span class="string">&quot;golang.org/x/net/ipv4&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果我们想同时导入两个有着名字相同的包，例如<code>math/rand</code>包和<code>crypto/rand</code>包，那么导入声明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">    mrand <span class="string">&quot;math/rand&quot;</span> <span class="comment">// alternative name mrand avoids conflict</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字。</p>
<p>导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。例如，如果文件中已经有了一个名为<code>path</code>的变量，那么我们可以将<code>path</code>标准包重命名为<code>pathpkg</code>。</p>
<p>每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误。</p>
<h2 id="空导入"><a href="#空导入" class="headerlink" title="空导入"></a>空导入</h2><p>如果导入的包的名字没有在文件中引用，就会产生一个编译错误。但是，有时候，我们必须导入一个包，这仅仅是为了利用其副作用：对包级别的变量执行初始化表达式求值，并执行它的 <code>init</code> 函数(见2.6.2 节)。为了防止“未使用的导入”错误，我们必须使用一个重命名导人，它使用一个替代的名字<code>_</code>，这表示导入的内容为空白标识符。通常情况下，空白标识不可能被引用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;image/png&quot;</span> <span class="comment">// register PNG decoder</span></span><br></pre></td></tr></table></figure>

<p>这称为<strong>空白导入</strong>。多数情况下，它用来实现一个编译时的机制，使用空白引用导入额外的包，来开启主程序中可选的特性。首先我们来看如何使用它，然后看它是如何工作的。</p>
<p>标准库的 <code>image</code> 包导出了 <code>Decode</code> 函数，它从 <code>io.Reader</code> 读取数据，并且识别使用哪一种图像格式来编码数据，调用适当的解码器，返回 <code>image.Image</code> 对象作为结果。使用<code>image.Decode</code>可以构建一个简单的图像转换器，读取某一种格式的图像，然后输出为另外一个格式。</p>
<p><em>gopl.io&#x2F;ch10&#x2F;jpeg</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The jpeg command reads a PNG image from the standard input</span></span><br><span class="line"><span class="comment">// and writes it as a JPEG image to the standard output.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;image&quot;</span></span><br><span class="line">    <span class="string">&quot;image/jpeg&quot;</span></span><br><span class="line">    _ <span class="string">&quot;image/png&quot;</span> <span class="comment">// register PNG decoder</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := toJPEG(os.Stdin, os.Stdout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;jpeg: %v\n&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toJPEG</span><span class="params">(in io.Reader, out io.Writer)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    img, kind, err := image.Decode(in)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintln(os.Stderr, <span class="string">&quot;Input format =&quot;</span>, kind)</span><br><span class="line">    <span class="keyword">return</span> jpeg.Encode(out, img, &amp;jpeg.Options&#123;Quality: <span class="number">95</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们将<code>gopl.io/ch3/mandelbrot</code>（§3.3）的输出导入到这个程序的标准输入，它将解码输入的PNG格式图像，然后转换为JPEG格式的图像输出（图3.3）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch3/mandelbrot</span><br><span class="line">$ go build gopl.io/ch10/jpeg</span><br><span class="line">$ ./mandelbrot | ./jpeg &gt;mandelbrot.jpg</span><br><span class="line">Input format = png</span><br></pre></td></tr></table></figure>

<p>要注意<code>image/png</code>包的匿名导入语句。如果没有这一行语句，程序依然可以编译和运行，但是它将不能正确识别和解码PNG格式的图像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch10/jpeg</span><br><span class="line">$ ./mandelbrot | ./jpeg &gt;mandelbrot.jpg</span><br><span class="line">jpeg: image: unknown format</span><br></pre></td></tr></table></figure>

<p>这里解释它是如何工作的。标准库提供 GIF、PNG、JPEG 等格式的解码库，用户自己可以提供其他格式的，但是为了使可执行程序简短，除非明确需要，否则解码器不会被包含进应用程序。<code>image.Decode</code> 函数查阅一个关于支持格式的表格。每一个表项由4个部分组成：格式的名字；某种格式中所使用的相同的前缀字符串，用来识别编码格式；一个用来解码被编码图像的函数 <code>Decode</code>；以及另一个函数 <code>DecodeConfig</code>，它仅仅解码图像的元数据比如尺寸和色域。对于每一种格式，通常通过在其支持的包的初始化函数中来调用 <code>image.RegisterFormat</code> 来向表格添加项，例如<code>image/png</code> 中的实现如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> png <span class="comment">// image/png</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(r io.Reader)</span></span> (image.Image, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeConfig</span><span class="params">(r io.Reader)</span></span> (image.Config, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> pngHeader = <span class="string">&quot;\x89PNG\r\n\x1a\n&quot;</span></span><br><span class="line">    image.RegisterFormat(<span class="string">&quot;png&quot;</span>, pngHeader, Decode, DecodeConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个效果就是，一个应用只需要空白导人格式化所需的包，就可以让 <code>image.Decode</code> 函数具备应对格式的解码能力。</p>
<p><code>database/sq1</code>包使用类似的机制让用户按需加人想要的数据库驱动程序。例如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/lib/pq&quot;</span>              <span class="comment">// enable support for Postgres</span></span><br><span class="line">    _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span> <span class="comment">// enable support for MySQL</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db, err = sql.Open(<span class="string">&quot;postgres&quot;</span>, dbname) <span class="comment">// OK</span></span><br><span class="line">db, err = sql.Open(<span class="string">&quot;mysql&quot;</span>, dbname)    <span class="comment">// OK</span></span><br><span class="line">db, err = sql.Open(<span class="string">&quot;sqlite3&quot;</span>, dbname)  <span class="comment">// returns error: unknown driver &quot;sqlite3&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="包和命名"><a href="#包和命名" class="headerlink" title="包和命名"></a>包和命名</h2><p>在本节中，我们将提供一些关于Go语言独特的包和成员命名的约定。</p>
<p>当创建一个包，一般要用短小的包名，但也不能太短导致难以理解。标准库中最常用的包有<code>bufio</code>、<code>bytes</code>、<code>flag</code>、<code>fmt</code>、<code>http</code>、<code>io</code>、<code>json</code>、<code>os</code>、<code>sort</code>、<code>sync</code>和<code>time</code>等包。</p>
<p>尽可能让命名有描述性且无歧义。例如，类似<code>imageutil</code>或<code>ioutilis</code>的工具包命名已经足够简洁了，就无须再命名为<code>util</code>了。要尽量避免包名使用可能被经常用于局部变量的名字，这样可能导致用户重命名导入包，例如前面看到的<code>path</code>包。</p>
<p>包名一般采用单数的形式。标准库的<code>bytes</code>、<code>errors</code>和<code>strings</code>使用了复数形式，这是为了避免和预定义的类型冲突，同样还有<code>go/types</code>是为了避免和<code>type</code>关键字冲突。</p>
<p>要避免包名有其它的含义。例如，2.5节中我们的温度转换包最初使用了<code>temp</code>包名，虽然并没有持续多久。但这是一个糟糕的尝试，因为<code>temp</code>几乎是临时变量的同义词。然后我们有一段时间使用了<code>temperature</code>作为包名，显然名字并没有表达包的真实用途。最后我们改成了和<code>strconv</code>标准包类似的<code>tempconv</code>包名，这个名字比之前的就好多了。</p>
<p>现在让我们看看如何命名包的成员。由于是通过包的导入名字引入包里面的成员，例如<code>fmt.Println</code>，同时包含了包名和成员名信息。因此，我们一般并不需要关注<code>Println</code>的具体内容，因为<code>fmt</code>包名已经包含了这个信息。当设计一个包的时候，需要考虑包名和成员名两个部分如何很好地配合。下面有一些例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes.Equal    flag.Int    http.Get    json.Marshal</span><br></pre></td></tr></table></figure>

<p>我们可以看到一些常用的命名模式。<code>strings</code>包提供了和字符串相关的诸多操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> strings</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(needle, haystack <span class="type">string</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Replacer <span class="keyword">struct</span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReplacer</span><span class="params">(oldnew ...<span class="type">string</span>)</span></span> *Replacer</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(s <span class="type">string</span>)</span></span> *Reader</span><br></pre></td></tr></table></figure>

<p><code>strings</code>这个词不会出现在任何成员名字中。用户会通过<code>strings.Index</code>、<code>strings.Replacer</code>等引用这些成员。</p>
<p>其它一些包，可能只描述了单一的数据类型，例如<code>html/template</code>和<code>math/rand</code>等，只暴露一个主要的数据结构和与它相关的方法，还有一个以<code>New</code>命名的函数用于创建实例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> rand <span class="comment">// &quot;math/rand&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rand <span class="keyword">struct</span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(source Source)</span></span> *Rand</span><br></pre></td></tr></table></figure>

<p>这可能导致一些名字重复，例如<code>template.Template</code>或<code>rand.Rand</code>，这就是为什么这些种类的包名往往特别短的原因之一。</p>
<p>在另一个极端，还有像<code>net/http</code>包那样含有非常多的名字和种类不多的数据类型，因为它们都是要执行一个复杂的复合任务。尽管有将近二十种类型和更多的函数，但是包中最重要的成员名字却是简单明了的：Get、Post、Handle、Error、Client、Server等。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>本章剩下的部分将讨论Go语言工具箱的具体功能，包括如何下载、格式化、构建、测试和安装Go语言编写的程序。</p>
<p>Go语言的工具箱集合了一系列功能的命令集。它可以看作是一个包管理器（类似于Linux中的apt和rpm工具），用于包的查询、计算包的依赖关系、从远程版本控制系统下载它们等任务。它也是一个构建系统，计算文件的依赖关系，然后调用编译器、汇编器和链接器构建程序，虽然它故意被设计成没有标准的make命令那么复杂。它也是一个单元测试和基准测试的驱动程序，我们将在第11章讨论测试话题。</p>
<p>Go语言工具箱的命令有着类似“瑞士军刀”的风格，带着一打的子命令，有一些我们经常用到，例如<code>get</code>、<code>run</code>、<code>build</code>和<code>fmt</code>等。你可以运行<code>go</code>或<code>go help</code>命令查看内置的帮助文档，为了查询方便，我们列出了最常用的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go</span><br><span class="line">...</span><br><span class="line">    build            compile packages and dependencies</span><br><span class="line">    clean            remove object files</span><br><span class="line">    doc              show documentation for package or symbol</span><br><span class="line">    env              print Go environment information</span><br><span class="line">    fmt              run gofmt on package sources</span><br><span class="line">    get              download and install packages and dependencies</span><br><span class="line">    install          compile and install packages and dependencies</span><br><span class="line">    list             list packages</span><br><span class="line">    run              compile and run Go program</span><br><span class="line">    test             test packages</span><br><span class="line">    version          print Go version</span><br><span class="line">    vet              run go tool vet on packages</span><br><span class="line"></span><br><span class="line">Use &quot;go help [command]&quot; for more information about a command.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>为了达到零配置的设计目标，Go语言的工具箱很多地方都依赖各种约定。例如，根据给定的源文件的名称，Go语言的工具可以找到源文件对应的包，因为每个目录只包含了单一的包，并且包的导入路径和工作区的目录结构是对应的。给定一个包的导入路径，Go语言的工具可以找到与之对应的存储着实体文件的目录。它还可以根据导入路径找到存储代码的仓库的远程服务器URL。</p>
<h3 id="工作区结构"><a href="#工作区结构" class="headerlink" title="工作区结构"></a>工作区结构</h3><p>对于大多数的Go语言用户，只需要配置一个名叫<code>GOPATH</code>的环境变量，用来指定当前工作目录即可。当需要切换到不同工作区的时候，只要更新<code>GOPATH</code>就可以了。例如，我们在编写本书时将<code>GOPATH</code>设置为<code>$HOME/gobook</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ export GOPATH=$HOME/gobook</span><br><span class="line">$ go get gopl.io/...</span><br></pre></td></tr></table></figure>

<p>当你用前面介绍的命令下载本书全部的例子源码之后，你的当前工作区的目录结构应该是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOPATH/</span><br><span class="line">    src/</span><br><span class="line">        gopl.io/</span><br><span class="line">            .git/</span><br><span class="line">            ch1/</span><br><span class="line">                helloworld/</span><br><span class="line">                    main.go</span><br><span class="line">                dup/</span><br><span class="line">                    main.go</span><br><span class="line">                ...</span><br><span class="line">        golang.org/x/net/</span><br><span class="line">            .git/</span><br><span class="line">            html/</span><br><span class="line">                parse.go</span><br><span class="line">                node.go</span><br><span class="line">                ...</span><br><span class="line">    bin/</span><br><span class="line">        helloworld</span><br><span class="line">        dup</span><br><span class="line">    pkg/</span><br><span class="line">        darwin_amd64/</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p><code>GOPATH</code>对应的工作区目录有三个子目录。其中<code>src</code>子目录用于存储源代码。每个包被保存在与<code>$GOPATH/src</code>的相对路径为包导入路径的子目录中，例如<code>gopl.io/ch1/helloworld</code>相对应的路径目录。我们看到，一个<code>GOPATH</code>工作区的<code>src</code>目录中可能有多个独立的版本控制系统，例如<code>gopl.io</code>和<code>golang.org</code>分别对应不同的Git仓库。其中<code>pkg</code>子目录用于保存编译后的包的目标文件，<code>bin</code>子目录用于保存编译后的可执行程序，例如<code>helloworld</code>可执行程序。</p>
<p>第二个环境变量<code>GOROOT</code>用来指定Go的安装目录，还有它自带的标准库包的位置。<code>GOROOT</code>的目录结构和<code>GOPATH</code>类似，因此存放<code>fmt</code>包的源代码对应目录应该为<code>$GOROOT/src/fmt</code>。用户一般不需要设置<code>GOROOT</code>，默认情况下Go语言安装工具会将其设置为安装的目录路径。</p>
<p>其中<code>go env</code>命令用于查看Go语言工具涉及的所有环境变量的值，包括未设置环境变量的默认值。<code>GOOS</code>环境变量用于指定目标操作系统（例如android、linux、darwin或windows），<code>GOARCH</code>环境变量用于指定处理器的类型，例如amd64、386或arm等。虽然<code>GOPATH</code>环境变量是唯一必须要设置的，但是其它环境变量也会偶尔用到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go env</span><br><span class="line">GOPATH=&quot;/home/gopher/gobook&quot;</span><br><span class="line">GOROOT=&quot;/usr/local/go&quot;</span><br><span class="line">GOARCH=&quot;amd64&quot;</span><br><span class="line">GOOS=&quot;darwin&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="下载包"><a href="#下载包" class="headerlink" title="下载包"></a>下载包</h3><p>使用Go语言工具箱的go命令，不仅可以根据包导入路径找到本地工作区的包，甚至可以从互联网上找到和更新包。</p>
<p>使用命令<code>go get</code>可以下载一个单一的包或者用<code>...</code>下载整个子目录里面的每个包。Go语言工具箱的go命令同时计算并下载所依赖的每个包，这也是前一个例子中<code>golang.org/x/net/html</code>自动出现在本地工作区目录的原因。</p>
<p>一旦<code>go get</code>命令下载了包，然后就是安装包或包对应的可执行的程序。我们将在下一节再关注它的细节，现在只是展示整个下载过程是如何的简单。第一个命令是获取golint工具，它用于检测Go源代码的编程风格是否有问题。第二个命令是用golint命令对2.6.2节的<code>gopl.io/ch2/popcount</code>包代码进行编码风格检查。它友好地报告了忘记了包的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go get github.com/golang/lint/golint</span><br><span class="line">$ $GOPATH/bin/golint gopl.io/ch2/popcount</span><br><span class="line">src/gopl.io/ch2/popcount/main.go:1:1:</span><br><span class="line">  package comment should be of the form &quot;Package popcount ...&quot;</span><br></pre></td></tr></table></figure>

<p><code>go get</code>命令支持当前流行的托管网站GitHub、Bitbucket和Launchpad，可以直接向它们的版本控制系统请求代码。对于其它的网站，你可能需要指定版本控制系统的具体路径和协议，例如 Git或Mercurial。运行<code>go help importpath</code>获取相关的信息。</p>
<p><code>go get</code>命令获取的代码是真实的本地存储仓库，而不仅仅只是复制源文件，因此你依然可以使用版本管理工具比较本地代码的变更或者切换到其它的版本。例如<code>golang.org/x/net</code>包目录对应一个Git仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd $GOPATH/src/golang.org/x/net</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://go.googlesource.com/net (fetch)</span><br><span class="line">origin  https://go.googlesource.com/net (push)</span><br></pre></td></tr></table></figure>

<p>需要注意的是导入路径含有的网站域名和本地Git仓库对应远程服务地址并不相同，真实的Git地址是go.googlesource.com。这其实是Go语言工具的一个特性，可以让包用一个自定义的导入路径，但是真实的代码却是由更通用的服务提供，例如googlesource.com或github.com。因为页面 <a href="https://golang.org/x/net/html">https://golang.org/x/net/html</a> 包含了如下的元数据，它告诉Go语言的工具当前包真实的Git仓库托管地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch1/fetch</span><br><span class="line">$ ./fetch https://golang.org/x/net/html | grep go-import</span><br><span class="line">&lt;meta name=&quot;go-import&quot;</span><br><span class="line">      content=&quot;golang.org/x/net git https://go.googlesource.com/net&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>如果指定<code>-u</code>命令行标志参数，<code>go get</code>命令将确保所有的包和依赖的包的版本都是最新的，然后重新编译和安装它们。如果不包含该标志参数的话，而且如果包已经在本地存在，那么代码将不会被自动更新。</p>
<p><code>go get -u</code>命令只是简单地保证每个包是最新版本，如果是第一次下载包则是比较方便的；但是对于发布程序则可能是不合适的，因为本地程序可能需要对依赖的包做精确的版本依赖管理。通常的解决方案是使用vendor的目录用于存储依赖包的固定版本的源代码，对本地依赖的包的版本更新也是谨慎和持续可控的。在Go1.5之前，一般需要修改包的导入路径，所以复制后golang.org&#x2F;x&#x2F;net&#x2F;html导入路径可能会变为gopl.io&#x2F;vendor&#x2F;golang.org&#x2F;x&#x2F;net&#x2F;html。最新的Go语言命令已经支持vendor特性，但限于篇幅这里并不讨论vendor的具体细节。不过可以通过<code>go help gopath</code>命令查看Vendor的帮助文档。</p>
<p>(译注：墙内用户在上面这些命令的基础上，还需要学习用翻墙来go get。)</p>
<p><strong>练习 10.3:</strong> 从 <a href="http://gopl.io/ch1/helloworld?go-get=1">http://gopl.io/ch1/helloworld?go-get=1</a> 获取内容，查看本书的代码的真实托管的网址（<code>go get</code>请求HTML页面时包含了<code>go-get</code>参数，以区别普通的浏览器请求）。</p>
<h3 id="构建包"><a href="#构建包" class="headerlink" title="构建包"></a>构建包</h3><p><code>go build</code>命令编译命令行参数指定的每个包。如果包是一个库，则忽略输出结果；这可以用于检测包是可以正确编译的。如果包的名字是main，<code>go build</code>将调用链接器在当前目录创建一个可执行程序；以导入路径的最后一段作为可执行程序的名字。</p>
<p>由于每个目录只包含一个包，因此每个对应可执行程序或者叫Unix术语中的命令的包，会要求放到一个独立的目录中。这些目录有时候会放在名叫cmd目录的子目录下面，例如用于提供Go文档服务的golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;godoc命令就是放在cmd子目录（§10.7.4）。</p>
<p>每个包可以由它们的导入路径指定，就像前面看到的那样，或者用一个相对目录的路径名指定，相对路径必须以<code>.</code>或<code>..</code>开头。如果没有指定参数，那么默认指定为当前目录对应的包。下面的命令用于构建同一个包，虽然它们的写法各不相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd $GOPATH/src/gopl.io/ch1/helloworld</span><br><span class="line">$ go build</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd anywhere</span><br><span class="line">$ go build gopl.io/ch1/helloworld</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd $GOPATH</span><br><span class="line">$ go build ./src/gopl.io/ch1/helloworld</span><br></pre></td></tr></table></figure>

<p>但不能这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd $GOPATH</span><br><span class="line">$ go build src/gopl.io/ch1/helloworld</span><br><span class="line">Error: cannot find package &quot;src/gopl.io/ch1/helloworld&quot;.</span><br></pre></td></tr></table></figure>

<p>也可以指定包的源文件列表，这一般只用于构建一些小程序或做一些临时性的实验。如果是main包，将会以第一个Go源文件的基础文件名作为最终的可执行程序的名字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat quoteargs.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Printf(&quot;%q\n&quot;, os.Args[1:])</span><br><span class="line">&#125;</span><br><span class="line">$ go build quoteargs.go</span><br><span class="line">$ ./quoteargs one &quot;two three&quot; four\ five</span><br><span class="line">[&quot;one&quot; &quot;two three&quot; &quot;four five&quot;]</span><br></pre></td></tr></table></figure>

<p>特别是对于这类一次性运行的程序，我们希望尽快的构建并运行它。<code>go run</code>命令实际上是结合了构建和运行的两个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go run quoteargs.go one &quot;two three&quot; four\ five</span><br><span class="line">[&quot;one&quot; &quot;two three&quot; &quot;four five&quot;]</span><br></pre></td></tr></table></figure>

<p>(译注：其实也可以偷懒，直接<code>go run *.go</code>)</p>
<p>第一行的参数列表中，第一个不是以<code>.go</code>结尾的将作为可执行程序的参数运行。</p>
<p>默认情况下，<code>go build</code>命令构建指定的包和它依赖的包，然后丢弃除了最后的可执行文件之外所有的中间编译结果。依赖分析和编译过程虽然都是很快的，但是随着项目增加到几十个包和成千上万行代码，依赖关系分析和编译时间的消耗将变的可观，有时候可能需要几秒种，即使这些依赖项没有改变。</p>
<p><code>go install</code>命令和<code>go build</code>命令很相似，但是它会保存每个包的编译成果，而不是将它们都丢弃。被编译的包会被保存到<code>$GOPATH/pkg</code>目录下，目录路径和 <code>src</code>目录路径对应，可执行程序被保存到<code>$GOPATH/bin</code>目录。（很多用户会将<code>$GOPATH/bin</code>添加到可执行程序的搜索列表中。）还有，<code>go install</code>命令和<code>go build</code>命令都不会重新编译没有发生变化的包，这可以使后续构建更快捷。为了方便编译依赖的包，<code>go build -i</code>命令将安装每个目标所依赖的包。</p>
<p>因为编译对应不同的操作系统平台和CPU架构，<code>go install</code>命令会将编译结果安装到<code>GOOS</code>和<code>GOARCH</code>对应的目录。例如，在Mac系统，<code>golang.org/x/net/html</code>包将被安装到<code>$GOPATH/pkg/darwin_amd64</code>目录下的<code>golang.org/x/net/html.a</code>文件。</p>
<p>针对不同操作系统或CPU的交叉构建也是很简单的。只需要设置好目标对应的<code>GOOS</code>和<code>GOARCH</code>，然后运行构建命令即可。下面交叉编译的程序将输出它在编译时的操作系统和CPU类型：</p>
<p><em>gopl.io&#x2F;ch10&#x2F;cross</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(runtime.GOOS, runtime.GOARCH)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面以64位和32位环境分别编译和执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch10/cross</span><br><span class="line">$ ./cross</span><br><span class="line">darwin amd64</span><br><span class="line">$ GOARCH=386 go build gopl.io/ch10/cross</span><br><span class="line">$ ./cross</span><br><span class="line">darwin 386</span><br></pre></td></tr></table></figure>

<p>有些包可能需要针对不同平台和处理器类型使用不同版本的代码文件，以便于处理底层的可移植性问题或为一些特定代码提供优化。如果一个文件名包含了一个操作系统或处理器类型名字，例如net_linux.go或asm_amd64.s，Go语言的构建工具将只在对应的平台编译这些文件。还有一个特别的构建注释参数可以提供更多的构建过程控制。例如，文件中可能包含下面的注释：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +build linux darwin</span></span><br></pre></td></tr></table></figure>

<p>在包声明和包注释的前面，该构建注释参数告诉<code>go build</code>只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件。下面的构建注释则表示不编译这个文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +build ignore</span></span><br></pre></td></tr></table></figure>

<p>更多细节，可以参考go&#x2F;build包的构建约束部分的文档。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go doc go/build</span><br></pre></td></tr></table></figure>

<h3 id="包文档"><a href="#包文档" class="headerlink" title="包文档"></a>包文档</h3><p>Go语言的编码风格鼓励为每个包提供良好的文档。包中每个导出的成员和包声明前都应该包含目的和用法说明的注释。</p>
<p>Go语言中的文档注释一般是完整的句子，第一行通常是摘要说明，以被注释者的名字开头。注释中函数的参数或其它的标识符并不需要额外的引号或其它标记注明。例如，下面是<code>fmt.Fprintf</code>的文档注释。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fprintf formats according to a format specifier and writes to w.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes written and any write error encountered.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><code>Fprintf</code>函数格式化的细节在<code>fmt</code>包文档中描述。如果注释后紧跟着包声明语句，那注释对应整个包的文档。包文档对应的注释只能有一个（译注：其实可以有多个，它们会组合成一个包文档注释），包注释可以出现在任何一个源文件中。如果包的注释内容比较长，一般会放到一个独立的源文件中；<code>fmt</code>包注释就有300行之多。这个专门用于保存包文档的源文件通常叫<code>doc.go</code>。</p>
<p>好的文档并不需要面面俱到，文档本身应该是简洁但不可忽略的。事实上，Go语言的风格更喜欢简洁的文档，并且文档也是需要像代码一样维护的。对于一组声明语句，可以用一个精炼的句子描述，如果是显而易见的功能则并不需要注释。</p>
<p>在本书中，只要空间允许，我们之前很多包声明都包含了注释文档，但你可以从标准库中发现很多更好的例子。有两个工具可以帮到你。</p>
<p>首先是<code>go doc</code>命令，该命令打印其后所指定的实体的声明与文档注释，该实体可能是一个包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go doc time</span><br><span class="line">package time // import &quot;time&quot;</span><br><span class="line"></span><br><span class="line">Package time provides functionality for measuring and displaying time.</span><br><span class="line"></span><br><span class="line">const Nanosecond Duration = 1 ...</span><br><span class="line">func After(d Duration) &lt;-chan Time</span><br><span class="line">func Sleep(d Duration)</span><br><span class="line">func Since(t Time) Duration</span><br><span class="line">func Now() Time</span><br><span class="line">type Duration int64</span><br><span class="line">type Time struct &#123; ... &#125;</span><br><span class="line">...many more...</span><br></pre></td></tr></table></figure>

<p>或者是某个具体的包成员：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go doc time.Since</span><br><span class="line">func Since(t Time) Duration</span><br><span class="line"></span><br><span class="line">    Since returns the time elapsed since t.</span><br><span class="line">    It is shorthand for time.Now().Sub(t).</span><br></pre></td></tr></table></figure>

<p>或者是一个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go doc time.Duration.Seconds</span><br><span class="line">func (d Duration) Seconds() float64</span><br><span class="line"></span><br><span class="line">    Seconds returns the duration as a floating-point number of seconds.</span><br></pre></td></tr></table></figure>

<p>该命令并不需要输入完整的包导入路径或正确的大小写。下面的命令将打印<code>encoding/json</code>包的<code>(*json.Decoder).Decode</code>方法的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go doc json.decode</span><br><span class="line">func (dec *Decoder) Decode(v interface&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">    Decode reads the next JSON-encoded value from its input and stores</span><br><span class="line">    it in the value pointed to by v.</span><br></pre></td></tr></table></figure>

<p>第二个工具，名字也叫<code>godoc</code>，它提供可以相互交叉引用的HTML页面，但是包含和<code>go doc</code>命令相同以及更多的信息。图10.1演示了<code>time</code>包的文档，11.6节将看到<code>godoc</code>演示可以交互的示例程序。<code>godoc</code>的在线服务 <a href="https://godoc.org/">https://godoc.org</a> ，包含了成千上万的开源包的检索工具。</p>
<p><img src="/2022/notes-of-gopl/ch10-01.png" alt="img"></p>
<p>你也可以在自己的工作区目录运行<code>godoc</code>服务。运行下面的命令，然后在浏览器查看 <a href="http://localhost:8000/pkg">http://localhost:8000/pkg</a> 页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ godoc -http :8000</span><br></pre></td></tr></table></figure>

<p>其中<code>-analysis=type</code>和<code>-analysis=pointer</code>命令行标志参数用于打开文档和代码中关于静态分析的结果。</p>
<h3 id="内部包"><a href="#内部包" class="headerlink" title="内部包"></a>内部包</h3><p>在Go语言程序中，包是最重要的封装机制。没有导出的标识符只在同一个包内部可以访问，而导出的标识符则是面向全宇宙都是可见的。</p>
<p>有时候，一个中间的状态可能也是有用的，标识符对于一小部分信任的包是可见的，但并不是对所有调用者都可见。例如，当我们计划将一个大的包拆分为很多小的更容易维护的子包，但是我们并不想将内部的子包结构也完全暴露出去。同时，我们可能还希望在内部子包之间共享一些通用的处理包，或者我们只是想实验一个新包的还并不稳定的接口，暂时只暴露给一些受限制的用户使用。</p>
<p>为了满足这些需求，Go语言的构建工具对包含<code>internal</code>名字的路径段的包导入路径做了特殊处理。这种包叫<code>internal</code>包，一个<code>internal</code>包只能被和<code>internal</code>目录有同一个父目录的包所导入。例如，<code>net/http/internal/chunked</code>内部包只能被<code>net/http/httputil</code>或<code>net/http</code>包导入，但是不能被<code>net/url</code>包导入。不过<code>net/url</code>包却可以导入<code>net/http/httputil</code>包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net/http</span><br><span class="line">net/http/internal/chunked</span><br><span class="line">net/http/httputil</span><br><span class="line">net/url</span><br></pre></td></tr></table></figure>

<h3 id="查询包"><a href="#查询包" class="headerlink" title="查询包"></a>查询包</h3><p><code>go list</code>命令可以查询可用包的信息。其最简单的形式，可以测试包是否在工作区并打印它的导入路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go list github.com/go-sql-driver/mysql</span><br><span class="line">github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure>

<p><code>go list</code>命令的参数还可以用<code>&quot;...&quot;</code>表示匹配任意的包的导入路径。我们可以用它来列出工作区中的所有包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go list ...</span><br><span class="line">archive/tar</span><br><span class="line">archive/zip</span><br><span class="line">bufio</span><br><span class="line">bytes</span><br><span class="line">cmd/addr2line</span><br><span class="line">cmd/api</span><br><span class="line">...many more...</span><br></pre></td></tr></table></figure>

<p>或者是特定子目录下的所有包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go list gopl.io/ch3/...</span><br><span class="line">gopl.io/ch3/basename1</span><br><span class="line">gopl.io/ch3/basename2</span><br><span class="line">gopl.io/ch3/comma</span><br><span class="line">gopl.io/ch3/mandelbrot</span><br><span class="line">gopl.io/ch3/netflag</span><br><span class="line">gopl.io/ch3/printints</span><br><span class="line">gopl.io/ch3/surface</span><br></pre></td></tr></table></figure>

<p>或者是和某个主题相关的所有包:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go list ...xml...</span><br><span class="line">encoding/xml</span><br><span class="line">gopl.io/ch7/xmlselect</span><br></pre></td></tr></table></figure>

<p><code>go list</code>命令还可以获取每个包完整的元信息，而不仅仅只是导入路径，这些元信息可以以不同格式提供给用户。其中<code>-json</code>命令行参数表示用JSON格式打印每个包的元信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go list -json hash</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Dir&quot;: &quot;/home/gopher/go/src/hash&quot;,</span><br><span class="line">    &quot;ImportPath&quot;: &quot;hash&quot;,</span><br><span class="line">    &quot;Name&quot;: &quot;hash&quot;,</span><br><span class="line">    &quot;Doc&quot;: &quot;Package hash provides interfaces for hash functions.&quot;,</span><br><span class="line">    &quot;Target&quot;: &quot;/home/gopher/go/pkg/darwin_amd64/hash.a&quot;,</span><br><span class="line">    &quot;Goroot&quot;: true,</span><br><span class="line">    &quot;Standard&quot;: true,</span><br><span class="line">    &quot;Root&quot;: &quot;/home/gopher/go&quot;,</span><br><span class="line">    &quot;GoFiles&quot;: [</span><br><span class="line">            &quot;hash.go&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;Imports&quot;: [</span><br><span class="line">        &quot;io&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;Deps&quot;: [</span><br><span class="line">        &quot;errors&quot;,</span><br><span class="line">        &quot;io&quot;,</span><br><span class="line">        &quot;runtime&quot;,</span><br><span class="line">        &quot;sync&quot;,</span><br><span class="line">        &quot;sync/atomic&quot;,</span><br><span class="line">        &quot;unsafe&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令行参数<code>-f</code>则允许用户使用<code>text/template</code>包（§4.6）的模板语言定义输出文本的格式。下面的命令将打印<code>strconv</code>包的依赖的包，然后用<code>join</code>模板函数将结果链接为一行，连接时每个结果之间用一个空格分隔：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go list -f &#x27;&#123;&#123;join .Deps &quot; &quot;&#125;&#125;&#x27; strconv</span><br><span class="line">errors math runtime unicode/utf8 unsafe</span><br></pre></td></tr></table></figure>

<p>译注：上面的命令在Windows的命令行运行会遇到<code>template: main:1: unclosed action</code>的错误。产生这个错误的原因是因为命令行对命令中的<code>&quot; &quot;</code>参数进行了转义处理。可以按照下面的方法解决转义字符串的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go list -f &quot;&#123;&#123;join .Deps \&quot; \&quot;&#125;&#125;&quot; strconv</span><br></pre></td></tr></table></figure>

<p>下面的命令打印<code>compress</code>子目录下所有包的导入包列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go list -f &#x27;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports &quot; &quot;&#125;&#125;&#x27; compress/...</span><br><span class="line">compress/bzip2 -&gt; bufio io sort</span><br><span class="line">compress/flate -&gt; bufio fmt io math sort strconv</span><br><span class="line">compress/gzip -&gt; bufio compress/flate errors fmt hash hash/crc32 io time</span><br><span class="line">compress/lzw -&gt; bufio errors fmt io</span><br><span class="line">compress/zlib -&gt; bufio compress/flate errors fmt hash hash/adler32 io</span><br></pre></td></tr></table></figure>

<p>译注：Windows下有同样有问题，要避免转义字符串的干扰：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go list -f &quot;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports \&quot; \&quot;&#125;&#125;&quot; compress/...</span><br></pre></td></tr></table></figure>

<p><code>go list</code>命令对于一次性的交互式查询或自动化构建或测试脚本都很有帮助。我们将在11.2.4节中再次使用它。每个子命令的更多信息，包括可设置的字段和意义，可以用<code>go help list</code>命令查看。</p>
<p>在本章，我们解释了Go语言工具中除了测试命令之外的所有重要的子命令。在下一章，我们将看到如何用<code>go test</code>命令去运行Go语言程序中的测试代码。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a>go test</h2><p><code>go test</code>命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以<code>_test.go</code>为后缀名的源文件在执行<code>go build</code>时不会被构建成包的一部分，它们是<code>go test</code>测试的一部分。</p>
<p>在<code>*_test.go</code>文件中，有三种类型的函数：测试函数、基准测试（benchmark）函数、示例函数。一个测试函数是以<code>Test</code>为函数名前缀的函数，用于测试程序的一些逻辑行为是否正确；<code>go test</code>命令会调用这些测试函数并报告测试结果是PASS或FAIL。基准测试函数是以<code>Benchmark</code>为函数名前缀的函数，它们用于衡量一些函数的性能；<code>go test</code>命令会多次运行基准测试函数以计算一个平均的执行时间。示例函数是以<code>Example</code>为函数名前缀的函数，提供一个由编译器保证正确性的示例文档。我们将在11.2节讨论测试函数的所有细节，并在11.4节讨论基准测试函数的细节，然后在11.6节讨论示例函数的细节。</p>
<p><code>go test</code>命令会遍历所有的<code>*_test.go</code>文件中符合上述命名规则的函数，生成一个临时的main包用于调用相应的测试函数，接着构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p>
<h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><p>每个测试函数必须导入<code>testing</code>包。测试函数有如下的签名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestName</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试函数的名字必须以<code>Test</code>开头，可选的后缀名必须以大写字母开头：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSin</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCos</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLog</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>t</code>参数用于报告测试失败和附加的日志信息。让我们定义一个实例包<code>gopl.io/ch11/word1</code>，其中只有一个函数<code>IsPalindrome</code>用于检查一个字符串是否从前向后和从后向前读都是一样的。（下面这个实现对于一个字符串是否是回文字符串前后重复测试了两次；我们稍后会再讨论这个问题。）</p>
<p><em>gopl.io&#x2F;ch11&#x2F;word1</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package word provides utilities for word games.</span></span><br><span class="line"><span class="keyword">package</span> word</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsPalindrome reports whether s reads the same forward and backward.</span></span><br><span class="line"><span class="comment">// (Our first attempt.)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] != s[<span class="built_in">len</span>(s)<span class="number">-1</span>-i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在相同的目录下，<code>word_test.go</code>测试文件中包含了<code>TestPalindrome</code>和<code>TestNonPalindrome</code>两个测试函数。每一个都是测试<code>IsPalindrome</code>是否给出正确的结果，并使用<code>t.Error</code>报告失败信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> word</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPalindrome</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !IsPalindrome(<span class="string">&quot;detartrated&quot;</span>) &#123;</span><br><span class="line">        t.Error(<span class="string">`IsPalindrome(&quot;detartrated&quot;) = false`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !IsPalindrome(<span class="string">&quot;kayak&quot;</span>) &#123;</span><br><span class="line">        t.Error(<span class="string">`IsPalindrome(&quot;kayak&quot;) = false`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNonPalindrome</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> IsPalindrome(<span class="string">&quot;palindrome&quot;</span>) &#123;</span><br><span class="line">        t.Error(<span class="string">`IsPalindrome(&quot;palindrome&quot;) = true`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>go test</code>命令如果没有参数指定包那么将默认采用当前目录对应的包（和<code>go build</code>命令一样）。我们可以用下面的命令构建和运行测试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd $GOPATH/src/gopl.io/ch11/word1</span><br><span class="line">$ go test</span><br><span class="line">ok   gopl.io/ch11/word1  0.008s</span><br></pre></td></tr></table></figure>

<p>结果还比较满意，我们运行了这个程序， 不过没有提前退出是因为还没有遇到BUG报告。不过一个法国名为“Noelle Eve Elleon”的用户会抱怨<code>IsPalindrome</code>函数不能识别<code>&quot;été&quot;</code>。另外一个来自美国中部用户的抱怨则是不能识别“A man, a plan, a canal: Panama.”。执行特殊和小的BUG报告为我们提供了新的更自然的测试用例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFrenchPalindrome</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !IsPalindrome(<span class="string">&quot;été&quot;</span>) &#123;</span><br><span class="line">        t.Error(<span class="string">`IsPalindrome(&quot;été&quot;) = false`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCanalPalindrome</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    input := <span class="string">&quot;A man, a plan, a canal: Panama&quot;</span></span><br><span class="line">    <span class="keyword">if</span> !IsPalindrome(input) &#123;</span><br><span class="line">        t.Errorf(<span class="string">`IsPalindrome(%q) = false`</span>, input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免两次输入较长的字符串，我们使用了有类似<code>Printf</code>格式化功能的 <code>Errorf</code>函数来汇报错误结果。</p>
<p>当添加了这两个测试用例之后，<code>go test</code>返回了测试失败的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test</span><br><span class="line">--- FAIL: TestFrenchPalindrome (0.00s)</span><br><span class="line">    word_test.go:28: IsPalindrome(&quot;été&quot;) = false</span><br><span class="line">--- FAIL: TestCanalPalindrome (0.00s)</span><br><span class="line">    word_test.go:35: IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;) = false</span><br><span class="line">FAIL</span><br><span class="line">FAIL    gopl.io/ch11/word1  0.014s</span><br></pre></td></tr></table></figure>

<p>先编写测试用例并观察到测试用例触发了和用户报告的错误相同的描述是一个好的测试习惯。只有这样，我们才能定位我们要真正解决的问题。</p>
<p>先写测试用例的另外的好处是，运行测试通常会比手工描述报告的处理更快，这让我们可以进行快速地迭代。如果测试集有很多运行缓慢的测试，我们可以通过只选择运行某些特定的测试来加快测试速度。</p>
<p>参数<code>-v</code>可用于打印每个测试函数的名字和运行时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test -v</span><br><span class="line">=== RUN TestPalindrome</span><br><span class="line">--- PASS: TestPalindrome (0.00s)</span><br><span class="line">=== RUN TestNonPalindrome</span><br><span class="line">--- PASS: TestNonPalindrome (0.00s)</span><br><span class="line">=== RUN TestFrenchPalindrome</span><br><span class="line">--- FAIL: TestFrenchPalindrome (0.00s)</span><br><span class="line">    word_test.go:28: IsPalindrome(&quot;été&quot;) = false</span><br><span class="line">=== RUN TestCanalPalindrome</span><br><span class="line">--- FAIL: TestCanalPalindrome (0.00s)</span><br><span class="line">    word_test.go:35: IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;) = false</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    gopl.io/ch11/word1  0.017s</span><br></pre></td></tr></table></figure>

<p>参数<code>-run</code>对应一个正则表达式，只有测试函数名被它正确匹配的测试函数才会被<code>go test</code>测试命令运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test -v -run=&quot;French|Canal&quot;</span><br><span class="line">=== RUN TestFrenchPalindrome</span><br><span class="line">--- FAIL: TestFrenchPalindrome (0.00s)</span><br><span class="line">    word_test.go:28: IsPalindrome(&quot;été&quot;) = false</span><br><span class="line">=== RUN TestCanalPalindrome</span><br><span class="line">--- FAIL: TestCanalPalindrome (0.00s)</span><br><span class="line">    word_test.go:35: IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;) = false</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    gopl.io/ch11/word1  0.014s</span><br></pre></td></tr></table></figure>

<p>当然，一旦我们已经修复了失败的测试用例，在我们提交代码更新之前，我们应该以不带参数的<code>go test</code>命令运行全部的测试用例，以确保修复失败测试的同时没有引入新的问题。</p>
<p>我们现在的任务就是修复这些错误。简要分析后发现第一个BUG的原因是我们采用了 byte而不是rune序列，所以像<code>&quot;été&quot;</code>中的<code>é</code>等非ASCII字符不能正确处理。第二个BUG是因为没有忽略空格和字母的大小写导致的。</p>
<p>针对上述两个BUG，我们仔细重写了函数：</p>
<p><em>gopl.io&#x2F;ch11&#x2F;word2</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package word provides utilities for word games.</span></span><br><span class="line"><span class="keyword">package</span> word</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unicode&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsPalindrome reports whether s reads the same forward and backward.</span></span><br><span class="line"><span class="comment">// Letter case is ignored, as are non-letters.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> letters []<span class="type">rune</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsLetter(r) &#123;</span><br><span class="line">            letters = <span class="built_in">append</span>(letters, unicode.ToLower(r))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> letters &#123;</span><br><span class="line">        <span class="keyword">if</span> letters[i] != letters[<span class="built_in">len</span>(letters)<span class="number">-1</span>-i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时我们也将之前的所有测试数据合并到了一个测试中的表格中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIsPalindrome</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</span><br><span class="line">        input <span class="type">string</span></span><br><span class="line">        want  <span class="type">bool</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;a&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;aa&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;ab&quot;</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;kayak&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;detartrated&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;A man, a plan, a canal: Panama&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Evil I did dwell; lewd did I live.&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Able was I ere I saw Elba&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;été&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Et se resservir, ivresse reste.&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;palindrome&quot;</span>, <span class="literal">false</span>&#125;, <span class="comment">// non-palindrome</span></span><br><span class="line">        &#123;<span class="string">&quot;desserts&quot;</span>, <span class="literal">false</span>&#125;,   <span class="comment">// semi-palindrome</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        <span class="keyword">if</span> got := IsPalindrome(test.input); got != test.want &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;IsPalindrome(%q) = %v&quot;</span>, test.input, got)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们的新测试都通过了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test gopl.io/ch11/word2</span><br><span class="line">ok      gopl.io/ch11/word2      0.015s</span><br></pre></td></tr></table></figure>

<p>这种表格驱动的测试在Go语言中很常见。我们可以很容易地向表格添加新的测试数据，并且后面的测试逻辑也没有冗余，这样我们可以有更多的精力去完善错误信息。</p>
<p><strong>失败测试的输出并不包括调用<code>t.Errorf</code>时刻的堆栈调用信息。和其他编程语言或测试框架的assert断言不同，<code>t.Errorf</code>调用也没有引起panic异常或停止测试的执行。即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息。</strong></p>
<p><strong>如果我们真的需要停止测试，或许是因为初始化失败或可能是早先的错误导致了后续错误等原因，我们可以使用<code>t.Fatal</code>或<code>t.Fatalf</code>停止当前测试函数。它们必须在和测试函数同一个goroutine内调用。</strong></p>
<p>测试失败的信息一般的形式是<code>f(x) = y, want z</code>，其中<code>f(x)</code>解释了失败的操作和对应的输入，<code>y</code>是实际的运行结果，<code>z</code>是期望的正确的结果。就像前面检查回文字符串的例子，实际的函数用于<code>f(x)</code>部分。显示<code>x</code>是表格驱动型测试中比较重要的部分，因为同一个断言可能对应不同的表格项执行多次。要避免无用和冗余的信息。在测试类似<code>IsPalindrome</code>返回布尔类型的函数时，可以忽略并没有额外信息的<code>z</code>部分。如果<code>x</code>、<code>y</code>或<code>z</code>是<code>y</code>的长度，输出一个相关部分的简明总结即可。测试的作者应该要努力帮助程序员诊断测试失败的原因。</p>
<p><strong>练习 11.1:</strong> 为4.3节中的charcount程序编写测试。</p>
<p><strong>练习 11.2:</strong> 为（§6.5）的IntSet编写一组测试，用于检查每个操作后的行为和基于内置map的集合等价，后面练习11.7将会用到。</p>
<h3 id="随机测试"><a href="#随机测试" class="headerlink" title="随机测试"></a>随机测试</h3><p>表格驱动的测试便于构造基于精心挑选的测试数据的测试用例。另一种测试思路是随机测试，也就是通过构造更广泛的随机输入来测试探索函数的行为。</p>
<p>那么对于一个随机的输入，我们如何能知道希望的输出结果呢？这里有两种处理策略。第一个是编写另一个对照函数，使用简单和清晰的算法，虽然效率较低但是行为和要测试的函数是一致的，然后针对相同的随机输入检查两者的输出结果。第二种是生成的随机输入的数据遵循特定的模式，这样我们就可以知道期望的输出的模式。</p>
<p>下面的例子使用的是第二种方法：<code>randomPalindrome</code>函数用于随机生成回文字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// randomPalindrome returns a palindrome whose length and contents</span></span><br><span class="line"><span class="comment">// are derived from the pseudo-random number generator rng.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomPalindrome</span><span class="params">(rng *rand.Rand)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    n := rng.Intn(<span class="number">25</span>) <span class="comment">// random length up to 24</span></span><br><span class="line">    runes := <span class="built_in">make</span>([]<span class="type">rune</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; (n+<span class="number">1</span>)/<span class="number">2</span>; i++ &#123;</span><br><span class="line">        r := <span class="type">rune</span>(rng.Intn(<span class="number">0x1000</span>)) <span class="comment">// random rune up to &#x27;\u0999&#x27;</span></span><br><span class="line">        runes[i] = r</span><br><span class="line">        runes[n<span class="number">-1</span>-i] = r</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(runes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRandomPalindromes</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Initialize a pseudo-random number generator.</span></span><br><span class="line">    seed := time.Now().UTC().UnixNano()</span><br><span class="line">    t.Logf(<span class="string">&quot;Random seed: %d&quot;</span>, seed)</span><br><span class="line">    rng := rand.New(rand.NewSource(seed))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        p := randomPalindrome(rng)</span><br><span class="line">        <span class="keyword">if</span> !IsPalindrome(p) &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;IsPalindrome(%q) = false&quot;</span>, p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然随机测试会有不确定因素，但是它也是至关重要的，我们可以从失败测试的日志获取足够的信息。在我们的例子中，输入<code>IsPalindrome</code>的<code>p</code>参数将告诉我们真实的数据，但是对于函数将接受更复杂的输入，不需要保存所有的输入，只要日志中简单地记录随机数种子即可（像上面的方式）。有了这些随机数初始化种子，我们可以很容易修改测试代码以重现失败的随机测试。</p>
<p>通过使用当前时间作为随机种子，在整个过程中的每次运行测试命令时都将探索新的随机数据。如果你使用的是定期运行的自动化测试集成系统，随机测试将特别有价值。</p>
<p><strong>练习 11.3:</strong> TestRandomPalindromes测试函数只测试了回文字符串。编写新的随机测试生成器，用于测试随机生成的非回文字符串。</p>
<p><strong>练习 11.4:</strong> 修改randomPalindrome函数，以探索<code>IsPalindrome</code>是否对标点和空格做了正确处理。</p>
<p>译者注：<strong>拓展阅读</strong>感兴趣的读者可以再了解一下go-fuzz</p>
<h3 id="测试一个命令"><a href="#测试一个命令" class="headerlink" title="测试一个命令"></a>测试一个命令</h3><p>对于测试包<code>go test</code>是一个有用的工具，但是稍加努力我们也可以用它来测试可执行程序。如果一个包的名字是 main，那么在构建时会生成一个可执行程序，不过main包可以作为一个包被测试器代码导入。</p>
<p>让我们为2.3.2节的echo程序编写一个测试。我们先将程序拆分为两个函数：echo函数完成真正的工作，main函数用于处理命令行输入参数和echo可能返回的错误。</p>
<p><em>gopl.io&#x2F;ch11&#x2F;echo</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Echo prints its command-line arguments.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    n = flag.Bool(<span class="string">&quot;n&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;omit trailing newline&quot;</span>)</span><br><span class="line">    s = flag.String(<span class="string">&quot;s&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;separator&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> out io.Writer = os.Stdout <span class="comment">// modified during testing</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="keyword">if</span> err := echo(!*n, *s, flag.Args()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;echo: %v\n&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(newline <span class="type">bool</span>, sep <span class="type">string</span>, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    fmt.Fprint(out, strings.Join(args, sep))</span><br><span class="line">    <span class="keyword">if</span> newline &#123;</span><br><span class="line">        fmt.Fprintln(out)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试中我们可以用各种参数和标志调用echo函数，然后检测它的输出是否正确，我们通过增加参数来减少echo函数对全局变量的依赖。我们还增加了一个全局名为<code>out</code>的变量来替代直接使用<code>os.Stdout</code>，这样测试代码可以根据需要将<code>out</code>修改为不同的对象以便于检查。下面就是echo_test.go文件中的测试代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEcho</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</span><br><span class="line">        newline <span class="type">bool</span></span><br><span class="line">        sep     <span class="type">string</span></span><br><span class="line">        args    []<span class="type">string</span></span><br><span class="line">        want    <span class="type">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="literal">true</span>, <span class="string">&quot;&quot;</span>, []<span class="type">string</span>&#123;&#125;, <span class="string">&quot;\n&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">false</span>, <span class="string">&quot;&quot;</span>, []<span class="type">string</span>&#123;&#125;, <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">true</span>, <span class="string">&quot;\t&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;, <span class="string">&quot;one\ttwo\tthree\n&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">true</span>, <span class="string">&quot;,&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;, <span class="string">&quot;a,b,c\n&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">false</span>, <span class="string">&quot;:&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;, <span class="string">&quot;1:2:3&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        descr := fmt.Sprintf(<span class="string">&quot;echo(%v, %q, %q)&quot;</span>,</span><br><span class="line">            test.newline, test.sep, test.args)</span><br><span class="line"></span><br><span class="line">        out = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// captured output</span></span><br><span class="line">        <span class="keyword">if</span> err := echo(test.newline, test.sep, test.args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;%s failed: %v&quot;</span>, descr, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        got := out.(*bytes.Buffer).String()</span><br><span class="line">        <span class="keyword">if</span> got != test.want &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;%s = %q, want %q&quot;</span>, descr, got, test.want)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>要注意的是测试代码和产品代码在同一个包。虽然是main包，也有对应的main入口函数，但是在测试的时候main包只是<code>TestEcho</code>测试函数导入的一个普通包，里面main函数并没有被导出，而是被忽略的。</strong></p>
<p>通过将测试放到表格中，我们很容易添加新的测试用例。让我通过增加下面的测试用例来看看失败的情况是怎么样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;<span class="literal">true</span>, <span class="string">&quot;,&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;, <span class="string">&quot;a b c\n&quot;</span>&#125;, <span class="comment">// <span class="doctag">NOTE:</span> wrong expectation!</span></span><br></pre></td></tr></table></figure>

<p><code>go test</code>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test gopl.io/ch11/echo</span><br><span class="line">--- FAIL: TestEcho (0.00s)</span><br><span class="line">    echo_test.go:31: echo(true, &quot;,&quot;, [&quot;a&quot; &quot;b&quot; &quot;c&quot;]) = &quot;a,b,c&quot;, want &quot;a b c\n&quot;</span><br><span class="line">FAIL</span><br><span class="line">FAIL        gopl.io/ch11/echo         0.006s</span><br></pre></td></tr></table></figure>

<p>错误信息描述了尝试的操作（使用Go类似语法），实际的结果和期望的结果。通过这样的错误信息，你可以在检视代码之前就很容易定位错误的原因。</p>
<p>**要注意的是在测试代码中并没有调用<code>log.Fatal</code>或<code>os.Exit</code>，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理。如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理。**幸运的是（上面的意外只是一个插曲），我们的echo示例是比较简单的也没有需要返回非空error的情况。</p>
<h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>一种测试分类的方法是基于测试者是否需要了解被测试对象的内部工作原理。<strong>黑盒测试</strong>只需要测试包公开的文档和API行为，内部实现对测试代码是透明的。相反，<strong>白盒测试</strong>有访问包内部函数和数据结构的权限，因此可以做到一些普通客户端无法实现的测试。例如，一个白盒测试可以在每个操作之后检测不变量的数据类型。（白盒测试只是一个传统的名称，其实称为clear box测试会更准确。）</p>
<p>黑盒和白盒这两种测试方法是互补的。黑盒测试一般更健壮，随着软件实现的完善测试代码很少需要更新。它们可以帮助测试者了解真实客户的需求，也可以帮助发现API设计的一些不足之处。相反，白盒测试则可以对内部一些棘手的实现提供更多的测试覆盖。</p>
<p>我们已经看到两种测试的例子。<code>TestIsPalindrome</code>测试仅仅使用导出的<code>IsPalindrome</code>函数，因此这是一个黑盒测试。<code>TestEcho</code>测试则调用了内部的<code>echo</code>函数，并且更新了内部的<code>out</code>包级变量，这两个都是未导出的，因此这是白盒测试。</p>
<p>当我们准备<code>TestEcho</code>测试的时候，我们修改了<code>echo</code>函数使用包级的<code>out</code>变量作为输出对象，因此测试代码可以用另一个实现代替标准输出，这样可以方便对比<code>echo</code>输出的数据。使用类似的技术，我们可以将产品代码的其他部分也替换为一个容易测试的伪对象。使用伪对象的好处是我们可以方便配置，容易预测，更可靠，也更容易观察。同时也可以避免一些不良的副作用，例如更新生产数据库或信用卡消费行为。</p>
<p>下面的代码演示了为用户提供网络存储的web服务中的配额检测逻辑。当用户使用了超过90%的存储配额之后将发送提醒邮件。（译注：一般在实现业务机器监控，包括磁盘、cpu、网络等的时候，需要类似的到达阈值&#x3D;&gt;触发报警的逻辑，所以是很实用的案例。）</p>
<p><em>gopl.io&#x2F;ch11&#x2F;storage1</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> storage</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/smtp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytesInUse</span><span class="params">(username <span class="type">string</span>)</span></span> <span class="type">int64</span> &#123; <span class="keyword">return</span> <span class="number">0</span> <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Email sender configuration.</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> never put passwords in source code!</span></span><br><span class="line"><span class="keyword">const</span> sender = <span class="string">&quot;notifications@example.com&quot;</span></span><br><span class="line"><span class="keyword">const</span> password = <span class="string">&quot;correcthorsebatterystaple&quot;</span></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">&quot;smtp.example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> template = <span class="string">`Warning: you are using %d bytes of storage,</span></span><br><span class="line"><span class="string">%d%% of your quota.`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckQuota</span><span class="params">(username <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    used := bytesInUse(username)</span><br><span class="line">    <span class="keyword">const</span> quota = <span class="number">1000000000</span> <span class="comment">// 1GB</span></span><br><span class="line">    percent := <span class="number">100</span> * used / quota</span><br><span class="line">    <span class="keyword">if</span> percent &lt; <span class="number">90</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">    msg := fmt.Sprintf(template, used, percent)</span><br><span class="line">    auth := smtp.PlainAuth(<span class="string">&quot;&quot;</span>, sender, password, hostname)</span><br><span class="line">    err := smtp.SendMail(hostname+<span class="string">&quot;:587&quot;</span>, auth, sender,</span><br><span class="line">        []<span class="type">string</span>&#123;username&#125;, []<span class="type">byte</span>(msg))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;smtp.SendMail(%s) failed: %s&quot;</span>, username, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想测试这段代码，但是我们并不希望发送真实的邮件。因此我们将邮件处理逻辑放到一个私有的<code>notifyUser</code>函数中。</p>
<p><em>gopl.io&#x2F;ch11&#x2F;storage2</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> notifyUser = <span class="function"><span class="keyword">func</span><span class="params">(username, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    auth := smtp.PlainAuth(<span class="string">&quot;&quot;</span>, sender, password, hostname)</span><br><span class="line">    err := smtp.SendMail(hostname+<span class="string">&quot;:587&quot;</span>, auth, sender,</span><br><span class="line">        []<span class="type">string</span>&#123;username&#125;, []<span class="type">byte</span>(msg))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;smtp.SendEmail(%s) failed: %s&quot;</span>, username, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckQuota</span><span class="params">(username <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    used := bytesInUse(username)</span><br><span class="line">    <span class="keyword">const</span> quota = <span class="number">1000000000</span> <span class="comment">// 1GB</span></span><br><span class="line">    percent := <span class="number">100</span> * used / quota</span><br><span class="line">    <span class="keyword">if</span> percent &lt; <span class="number">90</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">    msg := fmt.Sprintf(template, used, percent)</span><br><span class="line">    notifyUser(username, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以在测试中用伪邮件发送函数替代真实的邮件发送函数。它只是简单记录要通知的用户和邮件的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> storage</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCheckQuotaNotifiesUser</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> notifiedUser, notifiedMsg <span class="type">string</span></span><br><span class="line">    notifyUser = <span class="function"><span class="keyword">func</span><span class="params">(user, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        notifiedUser, notifiedMsg = user, msg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...simulate a 980MB-used condition...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> user = <span class="string">&quot;joe@example.org&quot;</span></span><br><span class="line">    CheckQuota(user)</span><br><span class="line">    <span class="keyword">if</span> notifiedUser == <span class="string">&quot;&quot;</span> &amp;&amp; notifiedMsg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        t.Fatalf(<span class="string">&quot;notifyUser not called&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> notifiedUser != user &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;wrong user (%s) notified, want %s&quot;</span>,</span><br><span class="line">            notifiedUser, user)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> wantSubstring = <span class="string">&quot;98% of your quota&quot;</span></span><br><span class="line">    <span class="keyword">if</span> !strings.Contains(notifiedMsg, wantSubstring) &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;unexpected notification message &lt;&lt;%s&gt;&gt;, &quot;</span>+</span><br><span class="line">            <span class="string">&quot;want substring %q&quot;</span>, notifiedMsg, wantSubstring)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个问题：当测试函数返回后，<code>CheckQuota</code>将不能正常工作，因为<code>notifyUsers</code>依然使用的是测试函数的伪发送邮件函数（当更新全局对象的时候总会有这种风险）。 我们必须修改测试代码恢复<code>notifyUsers</code>原先的状态以便后续其他的测试没有影响，要确保所有的执行路径后都能恢复，包括测试失败或panic异常的情形。在这种情况下，我们建议使用defer语句来延后执行处理恢复的代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCheckQuotaNotifiesUser</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Save and restore original notifyUser.</span></span><br><span class="line">    saved := notifyUser</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; notifyUser = saved &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install the test&#x27;s fake notifyUser.</span></span><br><span class="line">    <span class="keyword">var</span> notifiedUser, notifiedMsg <span class="type">string</span></span><br><span class="line">    notifyUser = <span class="function"><span class="keyword">func</span><span class="params">(user, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        notifiedUser, notifiedMsg = user, msg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...rest of test...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种处理模式可以用来暂时保存和恢复所有的全局变量，包括命令行标志参数、调试选项和优化参数；安装和移除导致生产代码产生一些调试信息的钩子函数；还有有些诱导生产代码进入某些重要状态的改变，比如超时、错误，甚至是一些刻意制造的并发行为等因素。</p>
<p>以这种方式使用全局变量是安全的，因为<code>go test</code>命令并不会同时并发地执行多个测试。</p>
<h3 id="外部测试包"><a href="#外部测试包" class="headerlink" title="外部测试包"></a>外部测试包</h3><p>考虑下这两个包：<code>net/url</code>包，提供了URL解析的功能；<code>net/http</code>包，提供了web服务和HTTP客户端的功能。如我们所料，上层的<code>net/http</code>包依赖下层的<code>net/url</code>包。然后，<code>net/url</code>包中的一个测试是演示不同URL和HTTP客户端的交互行为。也就是说，一个下层包的测试代码导入了上层的包。</p>
<p><img src="/2022/notes-of-gopl/ch11-01.png" alt="img"></p>
<p>这样的行为在<code>net/url</code>包的测试代码中会导致包的循环依赖，正如图11.1中向上箭头所示，同时正如我们在10.1节所讲的，Go语言规范是禁止包的循环依赖的。</p>
<p>不过我们可以通过外部测试包的方式解决循环依赖的问题，也就是在<code>net/url</code>包所在的目录声明一个独立的<code>url_test</code>测试包。其中包名的<code>_test</code>后缀告诉<code>go test</code>工具它应该建立一个额外的包来运行测试。我们将这个外部测试包的导入路径视作是<code>net/url_test</code>会更容易理解，但实际上它并不能被其他任何包导入。</p>
<p>因为外部测试包是一个独立的包，所以能够导入那些依赖待测代码本身的其他辅助包；包内的测试代码就无法做到这点。在设计层面，外部测试包是在所有它依赖的包的上层，正如图11.2所示。</p>
<p><img src="/2022/notes-of-gopl/ch11-02.png" alt="img"></p>
<p>通过避免循环的导入依赖，外部测试包可以更灵活地编写测试，特别是集成测试（需要测试多个组件之间的交互），可以像普通应用程序那样自由地导入其他包。</p>
<p>我们可以用<code>go list</code>命令查看包对应目录中哪些Go源文件是产品代码，哪些是包内测试，还有哪些是外部测试包。我们以<code>fmt</code>包作为一个例子：<code>GoFiles</code>表示产品代码对应的Go源文件列表；也就是<code>go build</code>命令要编译的部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go list -f=&#123;&#123;.GoFiles&#125;&#125; fmt</span><br><span class="line">[doc.go format.go print.go scan.go]</span><br></pre></td></tr></table></figure>

<p><code>TestGoFiles</code>表示的是<code>fmt</code>包内部测试代码，以<code>_test.go</code>为后缀文件名，不过只在测试时被构建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go list -f=&#123;&#123;.TestGoFiles&#125;&#125; fmt</span><br><span class="line">[export_test.go]</span><br></pre></td></tr></table></figure>

<p>包的测试代码通常都在这些文件中，不过<code>fmt</code>包并非如此；稍后我们再解释<code>export_test.go</code>文件的作用。</p>
<p><code>XTestGoFiles</code>表示的是属于外部测试包的测试代码，也就是<code>fmt_test</code>包，因此它们必须先导入<code>fmt</code>包。同样，这些文件也只是在测试时被构建运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go list -f=&#123;&#123;.XTestGoFiles&#125;&#125; fmt</span><br><span class="line">[fmt_test.go scan_test.go stringer_test.go]</span><br></pre></td></tr></table></figure>

<p>有时候外部测试包也需要访问被测试包内部的代码，例如在一个为了避免循环导入而被独立到外部测试包的白盒测试。在这种情况下，我们可以通过一些技巧解决：我们在包内的一个<code>_test.go</code>文件中导出一个内部的实现给外部测试包。因为这些代码只有在测试时才需要，因此一般会放在<code>export_test.go</code>文件中。</p>
<p>例如，<code>fmt</code>包的<code>fmt.Scanf</code>函数需要<code>unicode.IsSpace</code>函数提供的功能。但是为了避免太多的依赖，<code>fmt</code>包并没有导入包含巨大表格数据的<code>unicode</code>包；相反<code>fmt</code>包有一个叫<code>isSpace</code>内部的简易实现。</p>
<p>为了确保<code>fmt.isSpace</code>和<code>unicode.IsSpace</code>函数的行为保持一致，<code>fmt</code>包谨慎地包含了一个测试。一个在外部测试包内的白盒测试，是无法直接访问到<code>isSpace</code>内部函数的，因此<code>fmt</code>通过一个后门导出了<code>isSpace</code>函数。<code>export_test.go</code>文件就是专门用于外部测试包的后门。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> IsSpace = isSpace</span><br></pre></td></tr></table></figure>

<p>这个测试文件并没有定义测试代码；它只是通过<code>fmt.IsSpace</code>简单导出了内部的<code>isSpace</code>函数，提供给外部测试包使用。这个技巧可以广泛用于位于外部测试包的白盒测试。</p>
<h3 id="编写有效的测试"><a href="#编写有效的测试" class="headerlink" title="编写有效的测试"></a>编写有效的测试</h3><p>许多Go语言新人会惊异于Go语言极简的测试框架。很多其它语言的测试框架都提供了识别测试函数的机制（通常使用反射或元数据），通过设置一些“setup”和“teardown”的钩子函数来执行测试用例运行的初始化和之后的清理操作，同时测试工具箱还提供了很多类似assert断言、值比较函数、格式化输出错误信息和停止一个失败的测试等辅助函数（通常使用异常机制）。虽然这些机制可以使得测试非常简洁，但是测试输出的日志却会像火星文一般难以理解。此外，虽然测试最终也会输出PASS或FAIL的报告，但是它们提供的信息格式却非常不利于代码维护者快速定位问题，因为失败信息的具体含义非常隐晦，比如“assert: 0 &#x3D;&#x3D; 1”或成页的海量跟踪日志。</p>
<p>Go语言的测试风格则形成鲜明对比。它期望测试者自己完成大部分的工作，定义函数避免重复，就像普通编程那样。编写测试并不是一个机械的填空过程；一个测试也有自己的接口，尽管它的维护者也是测试仅有的一个用户。一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息。在理想情况下，维护者可以在不看代码的情况下就能根据错误信息定位错误产生的原因。一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律。</p>
<p>下面的断言函数比较两个值，然后生成一个通用的错误信息，并停止程序。它很好用也确实有效，但是当测试失败的时候，打印的错误信息却几乎是没有价值的。它并没有为快速解决问题提供一个很好的入口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// A poor assertion function.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertEqual</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x != y &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%d != %d&quot;</span>, x, y))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    words := strings.Split(<span class="string">&quot;a:b:c&quot;</span>, <span class="string">&quot;:&quot;</span>)</span><br><span class="line">    assertEqual(<span class="built_in">len</span>(words), <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个意义上说，断言函数犯了过早抽象的错误：仅仅测试两个整数是否相同，而没能根据上下文提供更有意义的错误信息。我们可以根据具体的错误打印一个更有价值的错误信息，就像下面例子那样。只有在测试中出现重复模式时才采用抽象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    s, sep := <span class="string">&quot;a:b:c&quot;</span>, <span class="string">&quot;:&quot;</span></span><br><span class="line">    words := strings.Split(s, sep)</span><br><span class="line">    <span class="keyword">if</span> got, want := <span class="built_in">len</span>(words), <span class="number">3</span>; got != want &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Split(%q, %q) returned %d words, want %d&quot;</span>,</span><br><span class="line">            s, sep, got, want)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试。一旦我们写了这样结构的测试，下一步自然不是用更多的if语句来扩展测试用例，我们可以用像<code>IsPalindrome</code>的表驱动测试那样来准备更多的<code>s</code>和<code>sep</code>测试用例。</p>
<p>前面的例子并不需要额外的辅助函数，如果有可以使测试代码更简单的方法我们也乐意接受。（我们将在13.3节看到一个类似<code>reflect.DeepEqual</code>辅助函数。）一个好的测试的关键是首先实现你期望的具体行为，然后才是考虑简化测试代码、避免重复。如果直接从抽象、通用的测试库着手，很难取得良好结果。</p>
<p><strong>练习11.5:</strong> 用表格驱动的技术扩展<code>TestSplit</code>测试，并打印期望的输出结果。</p>
<h3 id="避免脆弱的测试"><a href="#避免脆弱的测试" class="headerlink" title="避免脆弱的测试"></a>避免脆弱的测试</h3><p>如果一个应用程序对于新出现的但有效的输入经常失败说明程序容易出bug（不够稳健）；同样，如果一个测试仅仅对程序做了微小变化就失败则称为脆弱。就像一个不够稳健的程序会挫败它的用户一样，一个脆弱的测试同样会激怒它的维护者。最脆弱的测试代码会在程序没有任何变化的时候产生不同的结果，时好时坏，处理它们会耗费大量的时间但是并不会得到任何好处。</p>
<p>当一个测试函数会产生一个复杂的输出如一个很长的字符串、一个精心设计的数据结构或一个文件时，人们很容易想预先写下一系列固定的用于对比的标杆数据。但是随着项目的发展，有些输出可能会发生变化，尽管很可能是一个改进的实现导致的。而且不仅仅是输出部分，函数复杂的输入部分可能也跟着变化了，因此测试使用的输入也就不再有效了。</p>
<p>避免脆弱测试代码的方法是只检测你真正关心的属性。保持测试代码的简洁和内部结构的稳定。特别是对断言部分要有所选择。不要对字符串进行全字匹配，而是针对那些在项目的发展中是比较稳定不变的子串。很多时候值得花力气来编写一个从复杂输出中提取用于断言的必要信息的函数，虽然这可能会带来很多前期的工作，但是它可以帮助迅速及时修复因为项目演化而导致的不合逻辑的失败测试。</p>
<h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><p>就其性质而言，测试不可能是完整的。计算机科学家Edsger Dijkstra曾说过：“测试能证明缺陷存在，而无法证明没有缺陷。”再多的测试也不能证明一个程序没有BUG。在最好的情况下，测试可以增强我们的信心：代码在很多重要场景下是可以正常工作的。</p>
<p>一个测试套件覆盖待测试包的比例称为测试的<strong>覆盖率</strong>。覆盖率无法直接通过数量来衡量，任何事情都是动态的，即使最微小的程序都无法精确地测量。但还是有办法帮助我们将测试精力放到最有潜力的地方</p>
<p>语句覆盖率是一种最简单的且广泛使用的方法之一。一个测试套件的语句覆盖率是指部分语句在一次执行中至少执行一次。本节将使用 Go 的 cover 工具，这个工具被集成到了 <code>go test</code> 中，用来衡量语句覆盖率并帮助识别测试之间的明显差别。</p>
<p>下面的代码是一个表格驱动的测试，用于测试第七章的表达式求值程序：</p>
<p><em>gopl.io&#x2F;ch7&#x2F;eval</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCoverage</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</span><br><span class="line">        input <span class="type">string</span></span><br><span class="line">        env   Env</span><br><span class="line">        want  <span class="type">string</span> <span class="comment">// expected error from Parse/Check or result from Eval</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;x % 2&quot;</span>, <span class="literal">nil</span>, <span class="string">&quot;unexpected &#x27;%&#x27;&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;!true&quot;</span>, <span class="literal">nil</span>, <span class="string">&quot;unexpected &#x27;!&#x27;&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;log(10)&quot;</span>, <span class="literal">nil</span>, <span class="string">`unknown function &quot;log&quot;`</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;sqrt(1, 2)&quot;</span>, <span class="literal">nil</span>, <span class="string">&quot;call to sqrt has 2 args, want 1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;sqrt(A / pi)&quot;</span>, Env&#123;<span class="string">&quot;A&quot;</span>: <span class="number">87616</span>, <span class="string">&quot;pi&quot;</span>: math.Pi&#125;, <span class="string">&quot;167&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;pow(x, 3) + pow(y, 3)&quot;</span>, Env&#123;<span class="string">&quot;x&quot;</span>: <span class="number">9</span>, <span class="string">&quot;y&quot;</span>: <span class="number">10</span>&#125;, <span class="string">&quot;1729&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="string">&quot;F&quot;</span>: <span class="number">-40</span>&#125;, <span class="string">&quot;-40&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        expr, err := Parse(test.input)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            err = expr.Check(<span class="keyword">map</span>[Var]<span class="type">bool</span>&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err.Error() != test.want &#123;</span><br><span class="line">                t.Errorf(<span class="string">&quot;%s: got %q, want %q&quot;</span>, test.input, err, test.want)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        got := fmt.Sprintf(<span class="string">&quot;%.6g&quot;</span>, expr.Eval(test.env))</span><br><span class="line">        <span class="keyword">if</span> got != test.want &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;%s: %v =&gt; %s, want %s&quot;</span>,</span><br><span class="line">                test.input, test.env, got, test.want)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们要确保所有的测试都正常通过：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test -v -run=Coverage gopl.io/ch7/eval</span><br><span class="line">=== RUN TestCoverage</span><br><span class="line">--- PASS: TestCoverage (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      gopl.io/ch7/eval         0.011s</span><br></pre></td></tr></table></figure>

<p>下面这个命令可以显示测试覆盖率工具的使用用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go tool cover</span><br><span class="line">Usage of &#x27;go tool cover&#x27;:</span><br><span class="line">Given a coverage profile produced by &#x27;go test&#x27;:</span><br><span class="line">    go test -coverprofile=c.out</span><br><span class="line"></span><br><span class="line">Open a web browser displaying annotated source code:</span><br><span class="line">    go tool cover -html=c.out</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>go tool</code>命令运行Go工具链的底层可执行程序。这些底层可执行程序放在<code>$GOROOT/pkg/tool/$&#123;GOOS&#125;_$&#123;GOARCH&#125;</code>目录。因为有<code>go build</code>命令的原因，我们很少直接调用这些底层工具。</p>
<p>现在我们可以用<code>-coverprofile</code>标志参数重新运行测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test -run=Coverage -coverprofile=c.out gopl.io/ch7/eval</span><br><span class="line">ok      gopl.io/ch7/eval         0.032s      coverage: 68.5% of statements</span><br></pre></td></tr></table></figure>

<p>这个标志参数通过在测试代码中插入生成钩子来统计覆盖率数据。也就是说，在运行每个测试前，它将待测代码拷贝一份并做修改，在每个词法块都会设置一个布尔标志变量。当被修改后的被测试代码运行退出时，将统计日志数据写入<code>c.out</code>文件，并打印一部分执行的语句的一个总结。（如果你需要的是摘要，使用<code>go test -cover</code>。）</p>
<p>如果使用了<code>-covermode=count</code>标志参数，那么将在每个代码块插入一个计数器而不是布尔标志量。在统计结果中记录了每个块的执行次数，这可以用于衡量哪些是被频繁执行的热点代码。</p>
<p>为了收集数据，我们运行了测试覆盖率工具，打印了测试日志，生成一个HTML报告，然后在浏览器中打开（图11.3）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go tool cover -html=c.out</span><br></pre></td></tr></table></figure>

<p><img src="/2022/notes-of-gopl/ch11-03.png" alt="img"></p>
<p>界面中，每个用绿色(图中显示为浅灰色)标记的语句块表示它被覆盖了，而红色(图中为加阴影的深灰色)的则表示它没有被覆盖。为了清晰起见，我们给红色的文字加了阴影。我们可以立即看到，这里的输入都没有执行一元操作符 <code>Eval</code>方法。如果添加一个新的测试用例到表格中并且重新运行前面的两条命令，一元表达式代码将变成绿色。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;-x * -x&quot;, eval.Env&#123;&quot;x&quot;: 2&#125;, &quot;4&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>然而，两行 panic 语句仍然是红色。这个并不奇怪，因为这些代码不应该执行到。</p>
<p>实现语句的 100%覆盖听上去很宏伟，但是在实际情况下这并不可行，也不会行之有效。因为语句得以执行并不意味着这是没有 bug 的，拥有复杂表达式的语句块必须使用不同的输入执行多次来覆盖相关用例。有一些语句(如上面的 panic 语句)就永远不会被执行到。其他的 (比如处理少见错误的代码)也很难检测并且实际上也很少会执行。测试基本上是实用主义行为，在编写测试的代价和本可以通过测试避免的错误造成的代价之间进行平衡。覆盖工具可以帮助识别最薄弱的点，但是和编程一样，设计好的测试用例通常需要一丝不苟的精神。</p>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>基准测试是测量一个程序在固定工作负载下的性能。在Go语言中，基准测试函数和普通测试函数写法类似，但是以<code>Benchmark</code>为前缀名，并且带有一个<code>*testing.B</code>类型的参数；<code>*testing.B</code>参数除了提供和<code>*testing.T</code>类似的方法，还有额外一些和性能测量相关的方法。它还提供了一个整数<code>N</code>，用于指定操作执行的循环次数。</p>
<p>下面是<code>IsPalindrome</code>函数的基准测试，其中循环将执行<code>N</code>次。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkIsPalindrome</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        IsPalindrome(<span class="string">&quot;A man, a plan, a canal: Panama&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用下面的命令运行基准测试。和普通测试不同的是，默认情况下不运行任何基准测试。我们需要通过<code>-bench</code>命令行标志参数手工指定要运行的基准测试函数。该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，默认值是空的。其中<code>.</code>模式将可以匹配所有基准测试函数，但因为这里只有一个基准测试函数，因此和<code>-bench=IsPalindrome</code>参数是等价的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd $GOPATH/src/gopl.io/ch11/word2</span><br><span class="line">$ go test -bench=.</span><br><span class="line">PASS</span><br><span class="line">BenchmarkIsPalindrome-8 1000000                1035 ns/op</span><br><span class="line">ok      gopl.io/ch11/word2      2.179s</span><br></pre></td></tr></table></figure>

<p>结果中基准测试名的数字后缀部分，这里是8，表示运行时对应的<code>GOMAXPROCS</code>的值，这对于一些与并发相关的基准测试是重要的信息。</p>
<p>报告显示每次调用<code>IsPalindrome</code>函数花费1.035微秒，是执行1,000,000次的平均时间。因为基准测试驱动器开始时并不知道每个基准测试函数运行所花的时间，它会尝试在真正运行基准测试前先尝试用较小的<code>N</code>运行测试来估算基准测试函数所需要的时间，然后推断一个较大的时间保证稳定的测量结果。</p>
<p>循环在基准测试函数内实现，而不是放在基准测试框架内实现，这样可以让每个基准测试函数有机会在循环启动前执行初始化代码，这样并不会显著影响每次迭代的平均运行时间。如果还是担心初始化代码部分对测量时间带来干扰，那么可以通过<code>testing.B</code>参数提供的方法来临时关闭或重置计时器，不过这些一般很少会用到。</p>
<p>现在我们有了一个基准测试和普通测试，我们可以很容易测试改进程序运行速度的想法。也许最明显的优化是在<code>IsPalindrome</code>函数中第二个循环的停止检查，这样可以避免每个比较都做两次：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="built_in">len</span>(letters)/<span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> letters[i] != letters[<span class="built_in">len</span>(letters)<span class="number">-1</span>-i] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>不过很多情况下，一个显而易见的优化未必能带来预期的效果。这个改进在基准测试中只带来了4%的性能提升。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test -bench=.</span><br><span class="line">PASS</span><br><span class="line">BenchmarkIsPalindrome-8 1000000              992 ns/op</span><br><span class="line">ok      gopl.io/ch11/word2      2.093s</span><br></pre></td></tr></table></figure>

<p>另一个改进想法是在开始为每个字符预先分配一个足够大的数组，这样就可以避免在<code>append</code>调用时可能会导致内存的多次重新分配。声明一个<code>letters</code>数组变量，并指定合适的大小，像下面这样，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">letters := <span class="built_in">make</span>([]<span class="type">rune</span>, <span class="number">0</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">    <span class="keyword">if</span> unicode.IsLetter(r) &#123;</span><br><span class="line">        letters = <span class="built_in">append</span>(letters, unicode.ToLower(r))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个改进提升性能约35%，报告结果是基于2,000,000次迭代的平均运行时间统计。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test -bench=.</span><br><span class="line">PASS</span><br><span class="line">BenchmarkIsPalindrome-8 2000000                      697 ns/op</span><br><span class="line">ok      gopl.io/ch11/word2      1.468s</span><br></pre></td></tr></table></figure>

<p>如这个例子所示，快的程序往往是伴随着较少的内存分配。<code>-benchmem</code>命令行标志参数将在报告中包含内存的分配数据统计。我们可以比较优化前后内存的分配情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test -bench=. -benchmem</span><br><span class="line">PASS</span><br><span class="line">BenchmarkIsPalindrome    1000000   1026 ns/op    304 B/op  4 allocs/op</span><br></pre></td></tr></table></figure>

<p>这是优化之后的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test -bench=. -benchmem</span><br><span class="line">PASS</span><br><span class="line">BenchmarkIsPalindrome    2000000    807 ns/op    128 B/op  1 allocs/op</span><br></pre></td></tr></table></figure>

<p>用一次内存分配代替多次的内存分配节省了75%的分配调用次数和减少近一半的内存需求。</p>
<p>这个基准测试告诉了我们某个具体操作所需的绝对时间，但我们往往想知道的是两个不同的操作的时间对比。例如，如果一个函数需要1ms处理1,000个元素，那么处理10000或1百万将需要多少时间呢？这样的比较揭示了渐近增长函数的运行时间。另一个例子：I&#x2F;O缓存该设置为多大呢？基准测试可以帮助我们选择在性能达标情况下所需的最小内存。第三个例子：对于一个确定的工作哪种算法更好？基准测试可以评估两种不同算法对于相同的输入在不同的场景和负载下的优缺点。</p>
<p>比较型的基准测试就是普通程序代码。它们通常是单参数的函数，由几个不同数量级的基准测试函数调用，就像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmark</span><span class="params">(b *testing.B, size <span class="type">int</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark10</span><span class="params">(b *testing.B)</span></span>         &#123; benchmark(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark100</span><span class="params">(b *testing.B)</span></span>        &#123; benchmark(b, <span class="number">100</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark1000</span><span class="params">(b *testing.B)</span></span>       &#123; benchmark(b, <span class="number">1000</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改<code>b.N</code>来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。</p>
<p>比较型的基准测试反映出的模式在程序设计阶段是很有帮助的，但是即使程序完工了也应当保留基准测试代码。因为随着项目的发展，或者是输入的增加，或者是部署到新的操作系统或不同的处理器，我们可以再次用基准测试来帮助我们改进设计。</p>
<h2 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h2><p>基准测试（Benchmark）对于衡量特定操作的性能是有帮助的，但是当我们试图让程序跑的更快的时候，我们通常并不知道从哪里开始优化。每个码农都应该知道Donald Knuth在1974年的“Structured Programming with go to Statements”上所说的格言。虽然经常被解读为不重视性能的意思，但是从原文我们可以看到不同的含义：</p>
<blockquote>
<p>毫无疑问，对效率的片面追求会导致各种滥用。程序员会浪费大量的时间在非关键程序的速度上，实际上这些尝试提升效率的行为反倒可能产生很大的负面影响，特别是当调试和维护的时候。我们不应该过度纠结于细节的优化，应该说约97%的场景：过早的优化是万恶之源。</p>
<p>当然我们也不应该放弃对那关键3%的优化。一个好的程序员不会因为这个比例小就裹足不前，他们会明智地观察和识别哪些是关键的代码；但是仅当关键代码已经被确认的前提下才会进行优化。对于很多程序员来说，判断哪部分是关键的性能瓶颈，是很容易犯经验上的错误的，因此一般应该借助测量工具来证明。</p>
</blockquote>
<p>当我们想仔细观察我们程序的运行速度的时候，最好的方法是性能剖析。剖析技术是基于程序执行期间一些自动抽样，然后在收尾时进行推断；最后产生的统计结果就称为剖析数据。</p>
<p>Go语言支持多种类型的剖析性能分析，每一种关注不同的方面，但它们都涉及到每个采样记录的感兴趣的一系列事件消息，每个事件都包含函数调用时函数调用堆栈的信息。内建的<code>go test</code>工具对几种分析方式都提供了支持：</p>
<ul>
<li><p><strong>CPU剖析</strong>数据标识了最耗CPU时间的函数。在每个CPU上运行的线程在每隔几毫秒都会遇到操作系统的中断事件，每次中断时都会记录一个剖析数据然后恢复正常的运行。</p>
</li>
<li><p><strong>堆剖析</strong>则标识了最耗内存的语句。剖析库会记录调用内部内存分配的操作，平均每512KB的内存申请会触发一个剖析数据。</p>
</li>
<li><p><strong>阻塞剖析</strong>则记录阻塞goroutine最久的操作，例如系统调用、管道发送和接收，还有获取锁等。每当goroutine被这些操作阻塞时，剖析库都会记录相应的事件。</p>
</li>
</ul>
<p>只需要开启下面其中一个标志参数就可以生成各种分析文件。当同时使用多个标志参数时需要当心，因为一项分析操作可能会影响其他项的分析结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test -cpuprofile=cpu.out</span><br><span class="line">$ go test -blockprofile=block.out</span><br><span class="line">$ go test -memprofile=mem.out</span><br></pre></td></tr></table></figure>

<p>对于一些非测试程序也很容易进行剖析，具体的实现方式，与程序是短时间运行的小工具还是长时间运行的服务会有很大不同。剖析对于长期运行的程序尤其有用，因此可以通过调用Go的runtime API来启用运行时剖析。</p>
<p>一旦我们已经收集到了用于分析的采样数据，我们就可以使用pprof来分析这些数据。这是Go工具箱自带的一个工具，但并不是一个日常工具，它对应<code>go tool pprof</code>命令。该命令有许多特性和选项，但是最基本的是两个参数：生成这个概要文件的可执行程序和对应的剖析数据。</p>
<p>为了提高分析效率和减少空间，分析日志本身并不包含函数的名字；它只包含函数对应的地址。也就是说pprof需要对应的可执行程序来解读剖析数据。虽然<code>go test</code>通常在测试完成后就丢弃临时用的测试程序，但是在启用分析的时候会将测试程序保存为<code>foo.test</code>文件，其中<code>foo</code>部分对应待测包的名字。</p>
<p>下面的命令演示了如何收集并展示一个CPU分析文件。我们选择<code>net/http</code>包的一个基准测试为例。通常最好是对业务关键代码的部分设计专门的基准测试。因为简单的基准测试几乎没法代表业务场景，因此我们用<code>-run=NONE</code>参数禁止那些简单测试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test -run=NONE -bench=ClientServerParallelTLS64 \</span><br><span class="line">    -cpuprofile=cpu.log net/http</span><br><span class="line"> PASS</span><br><span class="line"> BenchmarkClientServerParallelTLS64-8  1000</span><br><span class="line">    3141325 ns/op  143010 B/op  1747 allocs/op</span><br><span class="line">ok       net/http       3.395s</span><br><span class="line"></span><br><span class="line">$ go tool pprof -text -nodecount=10 ./http.test cpu.log</span><br><span class="line">2570ms of 3590ms total (71.59%)</span><br><span class="line">Dropped 129 nodes (cum &lt;= 17.95ms)</span><br><span class="line">Showing top 10 nodes out of 166 (cum &gt;= 60ms)</span><br><span class="line">    flat  flat%   sum%     cum   cum%</span><br><span class="line">  1730ms 48.19% 48.19%  1750ms 48.75%  crypto/elliptic.p256ReduceDegree</span><br><span class="line">   230ms  6.41% 54.60%   250ms  6.96%  crypto/elliptic.p256Diff</span><br><span class="line">   120ms  3.34% 57.94%   120ms  3.34%  math/big.addMulVVW</span><br><span class="line">   110ms  3.06% 61.00%   110ms  3.06%  syscall.Syscall</span><br><span class="line">    90ms  2.51% 63.51%  1130ms 31.48%  crypto/elliptic.p256Square</span><br><span class="line">    70ms  1.95% 65.46%   120ms  3.34%  runtime.scanobject</span><br><span class="line">    60ms  1.67% 67.13%   830ms 23.12%  crypto/elliptic.p256Mul</span><br><span class="line">    60ms  1.67% 68.80%   190ms  5.29%  math/big.nat.montgomery</span><br><span class="line">    50ms  1.39% 70.19%    50ms  1.39%  crypto/elliptic.p256ReduceCarry</span><br><span class="line">    50ms  1.39% 71.59%    60ms  1.67%  crypto/elliptic.p256Sum</span><br></pre></td></tr></table></figure>

<p>参数<code>-text</code>用于指定输出格式，在这里每行是一个函数，根据使用CPU的时间长短来排序。其中<code>-nodecount=10</code>参数限制了只输出前10行的结果。对于严重的性能问题，这个文本格式基本可以帮助查明原因了。</p>
<p>这个概要文件告诉我们，HTTPS基准测试中<code>crypto/elliptic.p256ReduceDegree</code>函数占用了将近一半的CPU资源，对性能占很大比重。相比之下，如果一个概要文件中主要是runtime包的内存分配的函数，那么减少内存消耗可能是一个值得尝试的优化策略。</p>
<p>对于一些更微妙的问题，你可能需要使用pprof的图形显示功能。这个需要安装GraphViz工具，可以从 <a href="http://www.graphviz.org/">http://www.graphviz.org</a> 下载。参数<code>-web</code>用于生成函数的有向图，标注有CPU的使用和最热点的函数等信息。</p>
<p>这一节我们只是简单看了下Go语言的数据分析工具。如果想了解更多，可以阅读Go官方博客的“Profiling Go Programs”一文。</p>
<h2 id="示例函数"><a href="#示例函数" class="headerlink" title="示例函数"></a>示例函数</h2><p>第三种被<code>go test</code>特别对待的函数是示例函数，以Example为函数名开头。示例函数没有函数参数和返回值。下面是<code>IsPalindrome</code>函数对应的示例函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleIsPalindrome</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(IsPalindrome(<span class="string">&quot;A man, a plan, a canal: Panama&quot;</span>))</span><br><span class="line">    fmt.Println(IsPalindrome(<span class="string">&quot;palindrome&quot;</span>))</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例函数有三个用处。最主要的一个是作为文档：一个包的例子可以更简洁直观的方式来演示函数的用法，比文字描述更直接易懂，特别是作为一个提醒或快速参考时。一个示例函数也可以方便展示属于同一个接口的几种类型或函数之间的关系，所有的文档都必须关联到一个地方，就像一个类型或函数声明都统一到包一样。同时，示例函数和注释并不一样，示例函数是真实的Go代码，需要接受编译器的编译时检查，这样可以保证源代码更新时，示例代码不会脱节。</p>
<p>根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，因此<code>ExampleIsPalindrome</code>示例函数将是<code>IsPalindrome</code>函数文档的一部分，Example示例函数将是包文档的一部分。</p>
<p>示例函数的第二个用处是，在<code>go test</code>执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的<code>// Output:</code>格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配。</p>
<p>示例函数的第三个目的提供一个真实的演练场。 <a href="http://golang.org/">http://golang.org</a> 就是由godoc提供的文档服务，它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数，就像图11.4所示的那样。这通常是学习函数使用或Go语言特性最快捷的方式。</p>
<p><img src="/2022/notes-of-gopl/ch11-04.png" alt="img"></p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Go语言提供了一种机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道这些变量的具体类型。这种机制被称为<strong>反射</strong>。反射也可以让我们将类型本身作为第一类的值类型处理。</p>
<p>在本章，我们将探讨Go语言的反射特性，看看它可以给语言增加哪些表达能力，以及在两个至关重要的API是如何使用反射机制的：一个是<code>fmt</code>包提供的字符串格式化功能，另一个是类似<code>encoding/json</code>和<code>encoding/xml</code>提供的针对特定协议的编解码功能。对于我们在4.6节中看到过的<code>text/template</code>和<code>html/template</code>包，它们的实现也是依赖反射技术的。然后，反射是一个复杂的内省技术，不应该随意使用，因此，尽管上面这些包内部都是用反射技术实现的，但是它们自己的API都没有公开反射相关的接口。</p>
<h2 id="为何需要反射"><a href="#为何需要反射" class="headerlink" title="为何需要反射?"></a>为何需要反射?</h2><p>有时候我们需要编写一个函数能够处理一类并不满足普通公共接口的类型的值，也可能是因为它们并没有确定的表示方式，或者是在我们设计该函数的时候这些类型可能还不存在。</p>
<p>一个大家熟悉的例子是<code>fmt.Fprintf</code>函数提供的字符串格式化处理逻辑，它可以用来对任意类型的值格式化并打印，甚至支持用户自定义的类型。让我们也来尝试实现一个类似功能的函数。为了简单起见，我们的函数只接收一个参数，然后返回和<code>fmt.Sprint</code>类似的格式化后的字符串。我们实现的函数名也叫<code>Sprint</code>。</p>
<p>我们首先用switch类型分支来测试输入参数是否实现了<code>String</code>方法，如果是的话就调用该方法。然后继续增加类型测试分支，检查这个值的动态类型是否是string、int、bool等基础类型，并在每种情况下执行相应的格式化操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">        String() <span class="type">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> x := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> stringer:</span><br><span class="line">        <span class="keyword">return</span> x.String()</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        <span class="keyword">return</span> strconv.Itoa(x)</span><br><span class="line">    <span class="comment">// ...similar cases for int16, uint32, and so on...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> x &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// array, chan, func, map, pointer, slice, struct</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;???&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们如何处理其它类似<code>[]float64</code>、<code>map[string][]string</code>等类型呢？我们当然可以添加更多的测试分支，但是这些组合类型的数目基本是无穷的。还有如何处理类似<code>url.Values</code>这样的具名类型呢？即使类型分支可以识别出底层的基础类型是<code>map[string][]string</code>，但是它并不匹配<code>url.Values</code>类型，因为它们是两种不同的类型，而且switch类型分支也不可能包含每个类似<code>url.Values</code>的类型，这会导致对这些库的依赖。</p>
<p>没有办法来检查未知类型的表示方式，我们被卡住了。这就是我们为何需要反射的原因。</p>
<h2 id="reflect-Type-和-reflect-Value"><a href="#reflect-Type-和-reflect-Value" class="headerlink" title="reflect.Type 和 reflect.Value"></a><code>reflect.Type</code> 和 <code>reflect.Value</code></h2><p><strong>反射是由 <code>reflect</code> 包提供的。它定义了两个重要的类型，<code>Type</code> 和 <code>Value</code>。一个 <code>Type</code> 表示一个Go类型。它是一个接口，有许多方法来区分类型以及检查它们的组成部分，例如一个结构体的成员或一个函数的参数等。 <code>reflect.Type</code> 实现的是接口的类型描述信息（§7.5），也正是这个实体标识了接口值的动态类型。<code>reflect.Type</code> 接口只有一个实现，即类型描述符（见7.5 节），也正是类型描述符标识了接口值的动态类型。</strong></p>
<p><strong>函数 <code>reflect.TypeOf</code> 接受任意的 <code>interface&#123;&#125;</code> 类型，并以 <code>reflect.Type</code> 形式返回其动态类型：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := reflect.TypeOf(<span class="number">3</span>)  <span class="comment">// a reflect.Type</span></span><br><span class="line">fmt.Println(t.String()) <span class="comment">// &quot;int&quot;</span></span><br><span class="line">fmt.Println(t)          <span class="comment">// &quot;int&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>其中 <code>TypeOf(3)</code> 调用将值 <code>3</code> 传给 <code>interface&#123;&#125;</code> 参数。回到 7.5节 的将一个具体的值转为接口类型会有一个隐式的接口转换操作，它会创建一个包含两个信息的接口值：操作数的动态类型（这里是 int）和它的动态的值（这里是 3）。</strong></p>
<p>因为 <code>reflect.TypeOf</code> 返回的是一个动态类型的接口值，它总是返回具体的类型。因此，下面的代码将打印 <code>&quot;*os.File&quot;</code> 而不是 <code>&quot;io.Writer&quot;</code>。稍后，我们将看到能够表达接口类型的 <code>reflect.Type</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer = os.Stdout</span><br><span class="line">fmt.Println(reflect.TypeOf(w)) <span class="comment">// &quot;*os.File&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>要注意的是 <code>reflect.Type</code> 接口是满足 <code>fmt.Stringer</code> 接口的。因为打印一个接口的动态类型对于调试和日志是有帮助的， <code>fmt.Printf</code> 提供了一个缩写 <code>%T</code> 参数，内部使用 <code>reflect.TypeOf</code> 来输出：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="number">3</span>) <span class="comment">// &quot;int&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>reflect</code> 包中另一个重要的类型是 <code>Value</code>。一个 <code>reflect.Value</code> 可以装载任意类型的值。函数 <code>reflect.ValueOf</code> 接受任意的 <code>interface&#123;&#125;</code> 类型，并返回一个装载着其动态值的 <code>reflect.Value</code>。和 <code>reflect.TypeOf</code> 类似，<code>reflect.ValueOf</code> 返回的结果也是具体的类型，但是 <code>reflect.Value</code> 也可以持有一个接口值。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">3</span>) <span class="comment">// a reflect.Value</span></span><br><span class="line">fmt.Println(v)          <span class="comment">// &quot;3&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, v)   <span class="comment">// &quot;3&quot;</span></span><br><span class="line">fmt.Println(v.String()) <span class="comment">// <span class="doctag">NOTE:</span> &quot;&lt;int Value&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>和 <code>reflect.Type</code> 类似，<code>reflect.Value</code> 也满足 <code>fmt.Stringer</code> 接口，但是除非 <code>Value</code> 持有的是字符串，否则 <code>Value.String</code> 方法只返回其类型。而使用 <code>fmt</code> 包的 <code>%v</code> 标志参数会对 <code>reflect.Value</code> 进行特殊处理。</strong></p>
<p><strong>调用 <code>Value</code> 的 <code>Type</code> 方法会把它的类型以 <code>reflect.Type</code> 方式返回：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := v.Type()           <span class="comment">// a reflect.Type</span></span><br><span class="line">fmt.Println(t.String()) <span class="comment">// &quot;int&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>reflect.ValueOf</code> 的逆操作是 <code>reflect.Value.Interface</code> 方法。它返回一个 <code>interface&#123;&#125;</code> 类型，装载着与 <code>reflect.Value</code> 相同的具体值：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">3</span>) <span class="comment">// a reflect.Value</span></span><br><span class="line">x := v.Interface()      <span class="comment">// an interface&#123;&#125;</span></span><br><span class="line">i := x.(<span class="type">int</span>)            <span class="comment">// an int</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, i)   <span class="comment">// &quot;3&quot;</span></span><br></pre></td></tr></table></figure>

<p>**<code>reflect.Value</code> 和 <code>interface&#123;&#125;</code> 都可以包含任意的值。二者的区别是空接口 （<code>interface&#123;&#125;</code>）隐藏了值的布局信息、内置操作和相关方法，所以除非我们知道它的动态类型，并用一个类型断言来渗透进去（上面的代码就用了类型断言），否则我们对所包含值能做的事情很少。作为对比，<code>Value</code> 有很多方法可以用来分析所包含的值，而不用知道它的类型。**使用这些技术，我们可以第二次尝试写一个通用的格式化函数，它称为 <code>format.Any</code>。</p>
<p><strong>不用类型分支，我们用 <code>reflect.Value</code> 的 <code>Kind</code> 方法来区分不同的类型。尽管有无限种类型，但类型的分类（kind）只有少数几种：基础类型 <code>Bool</code>、<code>String</code> 以及各种数字类型；聚合类型 <code>Array</code> 和 <code>Struct</code>； 引用类型 <code>Chan</code>、<code>Func</code>、<code>Ptr</code>、<code>Slice</code> 和 <code>Map</code>、接口类型<code>Interface</code>；最后还有 <code>Invalid</code> 类型，表示它们还没有任何值。（<code>reflect.Value</code> 的零值就属于 <code>Invalid</code> 类型。）</strong></p>
<p><em>gopl.io&#x2F;ch12&#x2F;format</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> format</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Any formats any value as a string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Any</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> formatAtom(reflect.ValueOf(value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// formatAtom formats a value without inspecting its internal structure.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatAtom</span><span class="params">(v reflect.Value)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Invalid:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;invalid&quot;</span></span><br><span class="line">    <span class="keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16,</span><br><span class="line">        reflect.Int32, reflect.Int64:</span><br><span class="line">        <span class="keyword">return</span> strconv.FormatInt(v.Int(), <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16,</span><br><span class="line">        reflect.Uint32, reflect.Uint64, reflect.Uintptr:</span><br><span class="line">        <span class="keyword">return</span> strconv.FormatUint(v.Uint(), <span class="number">10</span>)</span><br><span class="line">    <span class="comment">// ...floating-point and complex cases omitted for brevity...</span></span><br><span class="line">    <span class="keyword">case</span> reflect.Bool:</span><br><span class="line">        <span class="keyword">return</span> strconv.FormatBool(v.Bool())</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        <span class="keyword">return</span> strconv.Quote(v.String())</span><br><span class="line">    <span class="keyword">case</span> reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map:</span><br><span class="line">        <span class="keyword">return</span> v.Type().String() + <span class="string">&quot; 0x&quot;</span> +</span><br><span class="line">            strconv.FormatUint(<span class="type">uint64</span>(v.Pointer()), <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// reflect.Array, reflect.Struct, reflect.Interface</span></span><br><span class="line">        <span class="keyword">return</span> v.Type().String() + <span class="string">&quot; value&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到现在为止，该函数把每个值当做一个没有内部结构且不可分割的物体（所以才叫<code>formatAtom</code>）。对于聚合类型（结构体和数组）以及接口，它只输出了值的类型；对于引用类型（通道、函数、指针、slice 和 map），它输出了类型和以十六进制表示的引用地址。这个结果仍然不够理想，但确实是一个很大的进步。因为 <code>Kind</code> 只关心底层实现，所以 <code>format.Any</code> 对命名类型的效果也很好。比如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int64</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> d time.Duration = <span class="number">1</span> * time.Nanosecond</span><br><span class="line">fmt.Println(format.Any(x))                  <span class="comment">// &quot;1&quot;</span></span><br><span class="line">fmt.Println(format.Any(d))                  <span class="comment">// &quot;1&quot;</span></span><br><span class="line">fmt.Println(format.Any([]<span class="type">int64</span>&#123;x&#125;))         <span class="comment">// &quot;[]int64 0x8202b87b0&quot;</span></span><br><span class="line">fmt.Println(format.Any([]time.Duration&#123;d&#125;)) <span class="comment">// &quot;[]time.Duration 0x8202b87e0&quot;</span></span><br><span class="line">fmt.Println(format.Any(<span class="keyword">struct</span> &#123;</span><br><span class="line">		Name <span class="type">string</span></span><br><span class="line">		Age  <span class="type">int</span></span><br><span class="line">&#125;&#123;<span class="string">&quot;Peter&quot;</span>, <span class="number">12</span>&#125;)) <span class="comment">// &quot;struct &#123; Name string; Age int &#125; value&quot;</span></span><br><span class="line">fmt.Println(Any(<span class="keyword">struct</span> &#123;</span><br><span class="line">		Name <span class="type">string</span></span><br><span class="line">		Age  <span class="type">int</span></span><br><span class="line">		Pet  <span class="keyword">struct</span> &#123;</span><br><span class="line">			Name <span class="type">string</span></span><br><span class="line">			Age  <span class="type">int</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&#123;<span class="string">&quot;Peter&quot;</span>, <span class="number">12</span>, <span class="keyword">struct</span> &#123;</span><br><span class="line">		Name <span class="type">string</span></span><br><span class="line">		Age  <span class="type">int</span></span><br><span class="line">	&#125;&#123;<span class="string">&quot;wangcai&quot;</span>, <span class="number">2</span>&#125;&#125;)) <span class="comment">// &quot;struct &#123; Name string; Age int; Pet struct &#123; Name string; Age int &#125; &#125; value&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Display，一个递归的值打印器"><a href="#Display，一个递归的值打印器" class="headerlink" title="Display，一个递归的值打印器"></a>Display，一个递归的值打印器</h2><p>接下来，让我们看看如何改善聚合数据类型的显示。我们并不想完全克隆一个<code>fmt.Sprint</code>函数，我们只是构建一个用于调试用的<code>Display</code>函数：给定任意一个复杂类型 <code>x</code>，打印这个值对应的完整结构，同时标记每个元素的发现路径。让我们从一个例子开始。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">e, _ := eval.Parse(<span class="string">&quot;sqrt(A / pi)&quot;</span>)</span><br><span class="line">Display(<span class="string">&quot;e&quot;</span>, e)</span><br></pre></td></tr></table></figure>

<p>在上面的调用中，传入<code>Display</code>函数的参数是在7.9节一个表达式求值函数返回的语法树。<code>Display</code>函数的输出如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Display e (eval.call):</span><br><span class="line">e.fn = <span class="string">&quot;sqrt&quot;</span></span><br><span class="line">e.args[<span class="number">0</span>].<span class="keyword">type</span> = eval.binary</span><br><span class="line">e.args[<span class="number">0</span>].value.op = <span class="number">47</span></span><br><span class="line">e.args[<span class="number">0</span>].value.x.<span class="keyword">type</span> = eval.Var</span><br><span class="line">e.args[<span class="number">0</span>].value.x.value = <span class="string">&quot;A&quot;</span></span><br><span class="line">e.args[<span class="number">0</span>].value.y.<span class="keyword">type</span> = eval.Var</span><br><span class="line">e.args[<span class="number">0</span>].value.y.value = <span class="string">&quot;pi&quot;</span></span><br></pre></td></tr></table></figure>

<p>你应该尽量避免在一个包的API中暴露涉及反射的接口。我们将定义一个未导出的<code>display</code>函数用于递归处理工作，导出的是<code>Display</code>函数，它只是<code>display</code>函数简单的包装以接受<code>interface&#123;&#125;</code>类型的参数：</p>
<p><em>gopl.io&#x2F;ch12&#x2F;display</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Display</span><span class="params">(name <span class="type">string</span>, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Display %s (%T):\n&quot;</span>, name, x)</span><br><span class="line">    display(name, reflect.ValueOf(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>display</code>函数中，我们使用了前面定义的打印基础类型——基本类型、函数和<code>chan</code>等——元素值的<code>formatAtom</code>函数，但是我们会使用<code>reflect.Value</code>的方法来递归显示复杂类型的每一个成员。在递归下降过程中，<code>path</code>字符串，从最开始传入的起始值（这里是<code>e</code>），将逐步增长来表示是如何达到当前值（例如<code>e.args[0].value</code>）的。</p>
<p>在 <code>display</code> 函数中，我们使用之前定义的 <code>formatAtom</code> 函数来输出基础值（基础类型、函数和通道），使用 <code>reflect.value</code> 的一些方法来递归展示复杂类型的每个组成部分。当递归深入时，<code>path</code> 字符串（之前用来表示起始值，比如<code>e</code>）会增长，以表示如何找到当前值（比如<code>e.args[@].value</code>）</p>
<p>因为我们不再模拟<code>fmt.Sprint</code>函数，我们将直接使用<code>fmt</code>包来简化我们的例子实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(path <span class="type">string</span>, v reflect.Value)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Invalid:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s = invalid\n&quot;</span>, path)</span><br><span class="line">    <span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.Len(); i++ &#123;</span><br><span class="line">            display(fmt.Sprintf(<span class="string">&quot;%s[%d]&quot;</span>, path, i), v.Index(i))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">            fieldPath := fmt.Sprintf(<span class="string">&quot;%s.%s&quot;</span>, path, v.Type().Field(i).Name)</span><br><span class="line">            display(fieldPath, v.Field(i))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Map:</span><br><span class="line">        <span class="keyword">for</span> _, key := <span class="keyword">range</span> v.MapKeys() &#123;</span><br><span class="line">            display(fmt.Sprintf(<span class="string">&quot;%s[%s]&quot;</span>, path,</span><br><span class="line">                formatAtom(key)), v.MapIndex(key))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Ptr:</span><br><span class="line">        <span class="keyword">if</span> v.IsNil() &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s = nil\n&quot;</span>, path)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            display(fmt.Sprintf(<span class="string">&quot;(*%s)&quot;</span>, path), v.Elem())</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Interface:</span><br><span class="line">        <span class="keyword">if</span> v.IsNil() &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s = nil\n&quot;</span>, path)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s.type = %s\n&quot;</span>, path, v.Elem().Type())</span><br><span class="line">            display(path+<span class="string">&quot;.value&quot;</span>, v.Elem())</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// basic types, channels, funcs</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s = %s\n&quot;</span>, path, formatAtom(v))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们针对不同类型分别讨论。</p>
<p><strong>Slice和数组：</strong> 两种的处理逻辑是一样的。<code>Len</code>方法返回slice或数组值中的元素个数，<code>Index(i)</code>获得索引<code>i</code>对应的元素，返回的也是一个<code>reflect.Value</code>；如果索引<code>i</code>超出范围的话将导致panic异常，这与数组或slice类型内建的<code>len(a)</code>和<code>a[i]</code>操作类似。<code>display</code>针对序列中的每个元素递归调用自身处理，我们通过在递归处理时向<code>path</code>附加<code>[i]</code>来表示访问路径。</p>
<p>虽然<code>reflect.Value</code>类型带有很多方法，但是只有少数的方法能对任意值都安全调用。例如，<code>Index</code>方法只能对Slice、数组或字符串类型的值调用，如果对其它类型调用则会导致panic异常。</p>
<p><strong>结构体：</strong> <code>NumField</code> 方法返回结构体中的字段数量，<code>Field(i)</code> 会返回第<code>i</code>个字段，返回的字段类型为 <code>reflect.Value</code>。字段列表包括了从匿名字段中做了类型提升的字段。要追加一个类似<code>.f</code>的字段选择标记到路径中，我们必须先获得结构体的 <code>reflect.Type</code> 才能获到第<code>i</code>个字段的名称。</p>
<p><strong>map：</strong> <code>MapKeys</code>方法返回一个元素类型为 <code>reflect.Value</code> 的slice，每个元素都是一个map的键。与平常遍历 map 的结果类似，顺序是不固定的。<code>MapIndex(key)</code> 返回 key 对应的值。我们追加下标记号<code>[key]</code>到路径中。（此处忽略了一些情形。map 的键类型有可能超出<code>formatAtom</code> 能处理好的类型，比如数组、结构体、接口都可以是合法的字典键。在练习12.1中会有输出完整键的内容。）</p>
<p><strong>指针：</strong> <code>Elem</code> 方法返回指针指向的变量，同样也是以<code>reflect.Value</code> 类型返回。这个方法在指针是<code>nil</code> 时也能正确处理，但返回的结果属于 <code>Invalid</code> 类型，所以我们用<code>IsNil</code> 来显式检测空指针，方便输出一条更合适的消息。为了避免二义性，在路径前加了一个<code>&quot;*&quot;</code>，外边再加上一对圆括号。</p>
<p>**接口：**我们再次使用 <code>IsNil</code> 来判断接口是否为空，如果非空，我们通过 <code>v.Elem()</code> 来获取动态值，进一步输出它的类型和值。</p>
<p>既然 <code>Display</code> 函数完成了，接下来我们就实际使用一下。下面的 <code>Movie</code> 类型引自4.5节但略有修改：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title, Subtitle <span class="type">string</span></span><br><span class="line">    Year            <span class="type">int</span></span><br><span class="line">    Color           <span class="type">bool</span></span><br><span class="line">    Actor           <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">    Oscars          []<span class="type">string</span></span><br><span class="line">    Sequel          *<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们声明一个该类型的变量，然后看看<code>Display</code>函数如何显示它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strangelove := Movie&#123;</span><br><span class="line">    Title:    <span class="string">&quot;Dr. Strangelove&quot;</span>,</span><br><span class="line">    Subtitle: <span class="string">&quot;How I Learned to Stop Worrying and Love the Bomb&quot;</span>,</span><br><span class="line">    Year:     <span class="number">1964</span>,</span><br><span class="line">    Color:    <span class="literal">false</span>,</span><br><span class="line">    Actor: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;Dr. Strangelove&quot;</span>:            <span class="string">&quot;Peter Sellers&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Grp. Capt. Lionel Mandrake&quot;</span>: <span class="string">&quot;Peter Sellers&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Pres. Merkin Muffley&quot;</span>:       <span class="string">&quot;Peter Sellers&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Gen. Buck Turgidson&quot;</span>:        <span class="string">&quot;George C. Scott&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Brig. Gen. Jack D. Ripper&quot;</span>:  <span class="string">&quot;Sterling Hayden&quot;</span>,</span><br><span class="line">        <span class="string">`Maj. T.J. &quot;King&quot; Kong`</span>:      <span class="string">&quot;Slim Pickens&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    Oscars: []<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;Best Actor (Nomin.)&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Best Adapted Screenplay (Nomin.)&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Best Director (Nomin.)&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Best Picture (Nomin.)&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Display(&quot;strangelove&quot;, strangelove)</code>调用将显示（<code>strangelove</code>电影对应的中文名是《奇爱博士》）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Display strangelove (display.Movie):</span><br><span class="line">strangelove.Title = <span class="string">&quot;Dr. Strangelove&quot;</span></span><br><span class="line">strangelove.Subtitle = <span class="string">&quot;How I Learned to Stop Worrying and Love the Bomb&quot;</span></span><br><span class="line">strangelove.Year = <span class="number">1964</span></span><br><span class="line">strangelove.Color = <span class="literal">false</span></span><br><span class="line">strangelove.Actor[<span class="string">&quot;Gen. Buck Turgidson&quot;</span>] = <span class="string">&quot;George C. Scott&quot;</span></span><br><span class="line">strangelove.Actor[<span class="string">&quot;Brig. Gen. Jack D. Ripper&quot;</span>] = <span class="string">&quot;Sterling Hayden&quot;</span></span><br><span class="line">strangelove.Actor[<span class="string">&quot;Maj. T.J. \&quot;King\&quot; Kong&quot;</span>] = <span class="string">&quot;Slim Pickens&quot;</span></span><br><span class="line">strangelove.Actor[<span class="string">&quot;Dr. Strangelove&quot;</span>] = <span class="string">&quot;Peter Sellers&quot;</span></span><br><span class="line">strangelove.Actor[<span class="string">&quot;Grp. Capt. Lionel Mandrake&quot;</span>] = <span class="string">&quot;Peter Sellers&quot;</span></span><br><span class="line">strangelove.Actor[<span class="string">&quot;Pres. Merkin Muffley&quot;</span>] = <span class="string">&quot;Peter Sellers&quot;</span></span><br><span class="line">strangelove.Oscars[<span class="number">0</span>] = <span class="string">&quot;Best Actor (Nomin.)&quot;</span></span><br><span class="line">strangelove.Oscars[<span class="number">1</span>] = <span class="string">&quot;Best Adapted Screenplay (Nomin.)&quot;</span></span><br><span class="line">strangelove.Oscars[<span class="number">2</span>] = <span class="string">&quot;Best Director (Nomin.)&quot;</span></span><br><span class="line">strangelove.Oscars[<span class="number">3</span>] = <span class="string">&quot;Best Picture (Nomin.)&quot;</span></span><br><span class="line">strangelove.Sequel = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>我们也可以使用<code>Display</code>函数来显示标准库中类型的内部结构，例如<code>*os.File</code>类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Display(<span class="string">&quot;os.Stderr&quot;</span>, os.Stderr)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Display os.Stderr (*os.File):</span></span><br><span class="line"><span class="comment">// (*(*os.Stderr).file).fd = 2</span></span><br><span class="line"><span class="comment">// (*(*os.Stderr).file).name = &quot;/dev/stderr&quot;</span></span><br><span class="line"><span class="comment">// (*(*os.Stderr).file).nepipe = 0</span></span><br></pre></td></tr></table></figure>

<p>**可以看出，反射能够访问到结构体中未导出的成员。需要当心的是这个例子的输出在不同操作系统上可能是不同的，并且随着标准库的发展也可能导致结果不同。（这也是将这些成员定义为私有成员的原因之一！）**我们甚至可以用<code>Display</code>函数来显示<code>reflect.Value</code>的内部构造（在这里设置为<code>*os.File</code>的类型描述体）。<code>Display(&quot;rV&quot;, reflect.ValueOf(os.Stderr))</code>调用的输出如下，当然不同环境得到的结果可能有差异：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Display rV (reflect.Value):</span><br><span class="line">(*rV.typ).size = <span class="number">8</span></span><br><span class="line">(*rV.typ).hash = <span class="number">871609668</span></span><br><span class="line">(*rV.typ).align = <span class="number">8</span></span><br><span class="line">(*rV.typ).fieldAlign = <span class="number">8</span></span><br><span class="line">(*rV.typ).kind = <span class="number">22</span></span><br><span class="line">(*(*rV.typ).<span class="type">string</span>) = <span class="string">&quot;*os.File&quot;</span></span><br><span class="line"></span><br><span class="line">(*(*(*rV.typ).uncommonType).methods[<span class="number">0</span>].name) = <span class="string">&quot;Chdir&quot;</span></span><br><span class="line">(*(*(*(*rV.typ).uncommonType).methods[<span class="number">0</span>].mtyp).<span class="type">string</span>) = <span class="string">&quot;func() error&quot;</span></span><br><span class="line">(*(*(*(*rV.typ).uncommonType).methods[<span class="number">0</span>].typ).<span class="type">string</span>) = <span class="string">&quot;func(*os.File) error&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>观察下面两个例子的区别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Display(<span class="string">&quot;i&quot;</span>, i)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Display i (int):</span></span><br><span class="line"><span class="comment">// i = 3</span></span><br><span class="line"></span><br><span class="line">Display(<span class="string">&quot;&amp;i&quot;</span>, &amp;i)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Display &amp;i (*interface &#123;&#125;):</span></span><br><span class="line"><span class="comment">// (*&amp;i).type = int</span></span><br><span class="line"><span class="comment">// (*&amp;i).value = 3</span></span><br></pre></td></tr></table></figure>

<p>在第一个例子中，<code>Display</code>函数调用<code>reflect.ValueOf(i)</code>，它返回一个<code>Int</code>类型的值。正如我们在12.2节中提到的，<code>reflect.ValueOf</code>总是返回一个具体类型的 <code>Value</code>，因为它是从一个接口值提取的内容。</p>
<p>在第二个例子中，<code>Display</code>函数调用的是<code>reflect.ValueOf(&amp;i)</code>，它返回一个指向<code>i</code>的指针，对应<code>Ptr</code>类型。在switch的<code>Ptr</code>分支中，对这个值调用 <code>Elem</code> 方法，返回一个<code>Value</code>来表示变量 <code>i</code> 本身，对应<code>Interface</code>类型。像这样一个间接获得的<code>Value</code>，可能代表任意类型的值，包括接口类型。<code>display</code>函数递归调用自身，这次它分别打印了这个接口的动态类型和值。</p>
<p>对于目前的实现，如果遇到对象图中含有回环，<code>Display</code>将会陷入死循环，例如下面这个首尾相连的链表：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a struct that points to itself</span></span><br><span class="line"><span class="keyword">type</span> Cycle <span class="keyword">struct</span>&#123; Value <span class="type">int</span>; Tail *Cycle &#125;</span><br><span class="line"><span class="keyword">var</span> c Cycle</span><br><span class="line">c = Cycle&#123;<span class="number">42</span>, &amp;c&#125;</span><br><span class="line">Display(<span class="string">&quot;c&quot;</span>, c)</span><br></pre></td></tr></table></figure>

<p><code>Display</code>会永远不停地进行深度递归打印：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Display c (display.Cycle):</span><br><span class="line">c.Value = <span class="number">42</span></span><br><span class="line">(*c.Tail).Value = <span class="number">42</span></span><br><span class="line">(*(*c.Tail).Tail).Value = <span class="number">42</span></span><br><span class="line">(*(*(*c.Tail).Tail).Tail).Value = <span class="number">42</span></span><br><span class="line">...ad infinitum...</span><br></pre></td></tr></table></figure>

<p>许多Go语言程序都包含了一些循环的数据。让<code>Display</code>支持这类带环的数据结构需要些技巧，需要额外记录迄今访问的路径；相应会带来成本。通用的解决方案是采用 unsafe 的语言特性，我们将在13.3节看到具体的解决方案。</p>
<p>带环的数据结构很少会对<code>fmt.Sprint</code>函数造成问题，因为它很少尝试打印完整的数据结构。例如，当它遇到一个指针的时候，它只是简单地打印指针的数字值。在打印包含自身的slice或map时可能卡住，但是这种情况很罕见，不值得付出为了处理回环所需的开销。</p>
<h2 id="示例-编码为S表达式"><a href="#示例-编码为S表达式" class="headerlink" title="示例: 编码为S表达式"></a>示例: 编码为S表达式</h2><p><code>Display</code>是一个用于显示结构化数据的调试工具，但是它并不能将任意的Go语言对象编码为通用消息然后用于进程间通信。</p>
<p>正如我们在4.5节中中看到的，Go语言的标准库支持了包括JSON、XML和ASN.1等多种编码格式。还有另一种依然被广泛使用的格式是S表达式格式，采用Lisp语言的语法。但是和其他编码格式不同的是，Go语言自带的标准库并不支持S表达式，主要是因为它没有一个公认的标准规范。</p>
<p>在本节中，我们将定义一个包用于将任意的Go语言对象编码为S表达式格式，它支持以下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">42          integer</span><br><span class="line">&quot;hello&quot;     string（带有Go风格的引号）</span><br><span class="line">foo         symbol（未用引号括起来的名字）</span><br><span class="line">(1 2 3)     list  （括号包起来的0个或多个元素）</span><br></pre></td></tr></table></figure>

<p>布尔型习惯上使用<code>t</code>符号表示<code>true</code>，空列表或<code>nil</code>符号表示<code>false</code>，但是为了简单起见，我们暂时忽略布尔类型。同时忽略的还有chan管道和函数，因为通过反射并无法知道它们的确切状态。我们忽略的还有浮点数、复数和interface。支持它们是练习12.3的任务。</p>
<p>我们将Go语言的类型编码为S表达式的方法如下。整数和字符串以显而易见的方式编码。空值编码为nil符号。数组和slice被编码为列表。</p>
<p>结构体被编码为成员对象的列表，每个成员对象对应一个有两个元素的子列表，子列表的第一个元素是成员的名字，第二个元素是成员的值。Map被编码为键值对的列表。传统上，S表达式使用点状符号列表(key . value)结构来表示key&#x2F;value对，而不是用一个含双元素的列表，不过为了简单我们忽略了点状符号列表。</p>
<p>编码是由一个<code>encode</code>递归函数完成，如下所示。它的结构本质上和前面的<code>Display</code>函数类似：</p>
<p><em>gopl.io&#x2F;ch12&#x2F;sexpr</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(buf *bytes.Buffer, v reflect.Value)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Invalid:</span><br><span class="line">        buf.WriteString(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16,</span><br><span class="line">        reflect.Int32, reflect.Int64:</span><br><span class="line">        fmt.Fprintf(buf, <span class="string">&quot;%d&quot;</span>, v.Int())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16,</span><br><span class="line">        reflect.Uint32, reflect.Uint64, reflect.Uintptr:</span><br><span class="line">        fmt.Fprintf(buf, <span class="string">&quot;%d&quot;</span>, v.Uint())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        fmt.Fprintf(buf, <span class="string">&quot;%q&quot;</span>, v.String())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> reflect.Ptr:</span><br><span class="line">        <span class="keyword">return</span> encode(buf, v.Elem())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> reflect.Array, reflect.Slice: <span class="comment">// (value ...)</span></span><br><span class="line">        buf.WriteByte(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.Len(); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">                buf.WriteByte(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> err := encode(buf, v.Index(i)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buf.WriteByte(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> reflect.Struct: <span class="comment">// ((name value) ...)</span></span><br><span class="line">        buf.WriteByte(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">                buf.WriteByte(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Fprintf(buf, <span class="string">&quot;(%s &quot;</span>, v.Type().Field(i).Name)</span><br><span class="line">            <span class="keyword">if</span> err := encode(buf, v.Field(i)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            buf.WriteByte(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        buf.WriteByte(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> reflect.Map: <span class="comment">// ((key value) ...)</span></span><br><span class="line">        buf.WriteByte(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i, key := <span class="keyword">range</span> v.MapKeys() &#123;</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">                buf.WriteByte(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            buf.WriteByte(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> err := encode(buf, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            buf.WriteByte(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> err := encode(buf, v.MapIndex(key)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            buf.WriteByte(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        buf.WriteByte(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// float, complex, bool, chan, func, interface</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unsupported type: %s&quot;</span>, v.Type())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Marshal</code>函数是对<code>encode</code>的包装，以保持和 encoding&#x2F;… 下其它包有着相似的API：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Marshal encodes a Go value in S-expression form.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    <span class="keyword">if</span> err := encode(&amp;buf, reflect.ValueOf(v)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是Marshal对12.3节的strangelove变量编码后的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((Title &quot;Dr. Strangelove&quot;) (Subtitle &quot;How I Learned to Stop Worrying and Lo</span><br><span class="line">ve the Bomb&quot;) (Year 1964) (Actor ((&quot;Grp. Capt. Lionel Mandrake&quot; &quot;Peter Sell</span><br><span class="line">ers&quot;) (&quot;Pres. Merkin Muffley&quot; &quot;Peter Sellers&quot;) (&quot;Gen. Buck Turgidson&quot; &quot;Geor</span><br><span class="line">ge C. Scott&quot;) (&quot;Brig. Gen. Jack D. Ripper&quot; &quot;Sterling Hayden&quot;) (&quot;Maj. T.J. \</span><br><span class="line">&quot;King\&quot; Kong&quot; &quot;Slim Pickens&quot;) (&quot;Dr. Strangelove&quot; &quot;Peter Sellers&quot;))) (Oscars</span><br><span class="line">(&quot;Best Actor (Nomin.)&quot; &quot;Best Adapted Screenplay (Nomin.)&quot; &quot;Best Director (N</span><br><span class="line">omin.)&quot; &quot;Best Picture (Nomin.)&quot;)) (Sequel nil))</span><br></pre></td></tr></table></figure>

<p>整个输出编码为一行中以减少输出的大小，但是也很难阅读。下面是对S表达式手动格式化的结果。编写一个S表达式的美化格式化函数将作为一个具有挑战性的练习任务；不过 <a href="http://gopl.io/">http://gopl.io</a> 也提供了一个简单的版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((Title &quot;Dr. Strangelove&quot;)</span><br><span class="line"> (Subtitle &quot;How I Learned to Stop Worrying and Love the Bomb&quot;)</span><br><span class="line"> (Year 1964)</span><br><span class="line"> (Actor ((&quot;Grp. Capt. Lionel Mandrake&quot; &quot;Peter Sellers&quot;)</span><br><span class="line">         (&quot;Pres. Merkin Muffley&quot; &quot;Peter Sellers&quot;)</span><br><span class="line">         (&quot;Gen. Buck Turgidson&quot; &quot;George C. Scott&quot;)</span><br><span class="line">         (&quot;Brig. Gen. Jack D. Ripper&quot; &quot;Sterling Hayden&quot;)</span><br><span class="line">         (&quot;Maj. T.J. \&quot;King\&quot; Kong&quot; &quot;Slim Pickens&quot;)</span><br><span class="line">         (&quot;Dr. Strangelove&quot; &quot;Peter Sellers&quot;)))</span><br><span class="line"> (Oscars (&quot;Best Actor (Nomin.)&quot;</span><br><span class="line">          &quot;Best Adapted Screenplay (Nomin.)&quot;</span><br><span class="line">          &quot;Best Director (Nomin.)&quot;</span><br><span class="line">          &quot;Best Picture (Nomin.)&quot;))</span><br><span class="line"> (Sequel nil))</span><br></pre></td></tr></table></figure>

<p>和<code>fmt.Print</code>、<code>json.Marshal</code>、<code>Display</code>函数类似，<code>sexpr.Marshal</code>函数处理带环的数据结构也会陷入死循环。</p>
<p>在12.6节中，我们将给出S表达式解码器的实现步骤，但是在那之前，我们还需要先了解如何通过反射技术来更新程序的变量。</p>
<h2 id="通过reflect-Value修改值"><a href="#通过reflect-Value修改值" class="headerlink" title="通过reflect.Value修改值"></a>通过<code>reflect.Value</code>修改值</h2><p>到目前为止，反射还只是程序中变量的另一种读取方式。然而，在本节中我们将重点讨论如何通过反射机制来修改变量。</p>
<p>回想一下，<strong>Go语言中类似<code>x</code>、<code>x.f[1]</code>和<code>*p</code>形式的表达式都可以表示变量，但是其它如<code>x + 1</code>和<code>f(2)</code>则不是变量。一个变量就是一个可寻址的内存空间，里面存储了一个值，并且存储的值可以通过内存地址来更新。</strong></p>
<p>对于<code>reflect.Value</code>也有类似的区别。<strong>有一些<code>reflect.Value</code>是可取地址的；其它一些则不可以。考虑以下的声明语句：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">2</span>                   <span class="comment">// value   type    variable?</span></span><br><span class="line">a := reflect.ValueOf(<span class="number">2</span>)  <span class="comment">// 2       int     no</span></span><br><span class="line">b := reflect.ValueOf(x)  <span class="comment">// 2       int     no</span></span><br><span class="line">c := reflect.ValueOf(&amp;x) <span class="comment">// &amp;x      *int    no</span></span><br><span class="line">d := c.Elem()            <span class="comment">// 2       int     yes (x)</span></span><br></pre></td></tr></table></figure>

<p>其中<code>a</code>对应的变量不可取地址。因为<code>a</code>中的值仅仅是整数<code>2</code>的拷贝副本。<code>b</code>中的值也同样不可取地址。<code>c</code>中的值还是不可取地址，它只是一个指针<code>&amp;x</code>的拷贝。实际上，所有通过<code>reflect.ValueOf(x)</code>返回的<code>reflect.Value</code>都是不可取地址的。但是对于<code>d</code>，它是<code>c</code>的解引用方式生成的，指向另一个变量，因此是可取地址的。我们可以通过调用<code>reflect.ValueOf(&amp;x).Elem()</code>，来获取任意变量<code>x</code>对应的可取地址的<code>Value</code>值。</p>
<p><strong>我们可以通过调用<code>reflect.Value</code>的<code>CanAddr</code>方法来判断其是否可以被取地址：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(a.CanAddr()) <span class="comment">// &quot;false&quot;</span></span><br><span class="line">fmt.Println(b.CanAddr()) <span class="comment">// &quot;false&quot;</span></span><br><span class="line">fmt.Println(c.CanAddr()) <span class="comment">// &quot;false&quot;</span></span><br><span class="line">fmt.Println(d.CanAddr()) <span class="comment">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们可以通过一个指针来间接获取一个可寻址的 <code>reflect.Value</code>，即使这个指针是不可寻址的。可寻址的常见规则都在反射包里边有对应项。比如，slice 的脚标表达式 <code>e[i]</code> 隐式地做了指针去引用，所以即使 <code>e</code> 是不可寻址的，这个表达式仍然是可寻址的。类似地<code>reflect.ValueOf(e).Index(i)</code> 代表一个变量，尽管 <code>reflect.ValueOf(e)</code>不是可寻址的，这个变量也是可寻址的。</strong></p>
<p><strong>从一个可寻址的 <code>reflect.Value()</code> 获取变量需要三步。首先，调用<code>Addr()</code>，返回一个<code>Value</code>，其中包含一个指向变量的指针，接下来，在这个 <code>Value</code> 上调用<code>Interface()</code>，会返回一个包含这个指针的 <code>interface&#123;&#125;</code> 值。最后，如果我们知道变量的类型，我们可以使用类型断言来把接口内容转换为一个普通指针。之后就可以通过这个指针来更新变量了：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">2</span></span><br><span class="line">d := reflect.ValueOf(&amp;x).Elem()   <span class="comment">// d refers to the variable x</span></span><br><span class="line">px := d.Addr().Interface().(*<span class="type">int</span>) <span class="comment">// px := &amp;x</span></span><br><span class="line">*px = <span class="number">3</span>                           <span class="comment">// x = 3</span></span><br><span class="line">fmt.Println(x)                    <span class="comment">// &quot;3&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>还可以直接通过可寻址的 <code>reflect.Value</code> 来更新变量，不用通过指针，而是直接调用 <code>reflect.Value.Set</code> 方法：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">d.Set(reflect.ValueOf(<span class="number">4</span>))</span><br><span class="line">fmt.Println(x) <span class="comment">// &quot;4&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Set</code>方法将在运行时执行和编译时进行类似的可赋值性约束的检查。以上代码，变量和值都是<code>int</code>类型，但是如果变量是<code>int64</code>类型，那么程序将抛出一个<code>panic</code>异常，所以关键问题是要确保改类型的变量可以接受对应的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">d.Set(reflect.ValueOf(<span class="type">int64</span>(<span class="number">5</span>))) <span class="comment">// panic: int64 is not assignable to int</span></span><br></pre></td></tr></table></figure>

<p>同样，对一个不可取地址的<code>reflect.Value</code>调用<code>Set</code>方法也会导致panic异常：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">2</span></span><br><span class="line">b := reflect.ValueOf(x)</span><br><span class="line">b.Set(reflect.ValueOf(<span class="number">3</span>)) <span class="comment">// panic: Set using unaddressable value</span></span><br></pre></td></tr></table></figure>

<p>这里有很多用于基本数据类型的<code>Set</code>方法：<code>SetInt</code>、<code>SetUint</code>、<code>SetString</code>和<code>SetFloat</code>等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">d := reflect.ValueOf(&amp;x).Elem()</span><br><span class="line">d.SetInt(<span class="number">3</span>)</span><br><span class="line">fmt.Println(x) <span class="comment">// &quot;3&quot;</span></span><br></pre></td></tr></table></figure>

<p>这些方法还有一定程度的容错性。只要变量类型是某种带符号的整数，比如 <code>SetInt</code>，甚至可以是底层类型为带符号整数的命名类型，都可以成功。如果值太大了还会无提示地截断它。但需要注意的是，在指向 <code>interface&#123;&#125;</code> 变量的 <code>reflect.Value</code> 上调用 <code>SetInt</code> 会 panic（尽管使用 <code>Set</code> 就没有问题）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">rx := reflect.ValueOf(&amp;x).Elem()</span><br><span class="line">rx.SetInt(<span class="number">2</span>)                     <span class="comment">// OK, x = 2</span></span><br><span class="line">rx.Set(reflect.ValueOf(<span class="number">3</span>))       <span class="comment">// OK, x = 3</span></span><br><span class="line">rx.SetString(<span class="string">&quot;hello&quot;</span>)            <span class="comment">// panic: string is not assignable to int</span></span><br><span class="line">rx.Set(reflect.ValueOf(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// panic: string is not assignable to int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">ry := reflect.ValueOf(&amp;y).Elem()</span><br><span class="line">ry.SetInt(<span class="number">2</span>)                     <span class="comment">// panic: SetInt called on interface Value</span></span><br><span class="line">ry.Set(reflect.ValueOf(<span class="number">3</span>))       <span class="comment">// OK, y = int(3)</span></span><br><span class="line">ry.SetString(<span class="string">&quot;hello&quot;</span>)            <span class="comment">// panic: SetString called on interface Value</span></span><br><span class="line">ry.Set(reflect.ValueOf(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// OK, y = &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>在把 <code>Display</code> 作用于 <code>os.Stdout</code> 时，<strong>我们发现反射可以读取到未导出结构字段的值，通过Go语言的常规方法这些值是无法读取的。比如 <code>os.File</code> 结构在类 UNIX平台上的<code>fd int</code>字段。但反射不能更新这些值：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stdout := reflect.ValueOf(os.Stdout).Elem() <span class="comment">// *os.Stdout, an os.File var</span></span><br><span class="line">fmt.Println(stdout.Type())                  <span class="comment">// &quot;os.File&quot;</span></span><br><span class="line">fd := stdout.FieldByName(<span class="string">&quot;fd&quot;</span>)</span><br><span class="line">fmt.Println(fd.Int()) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">fd.SetInt(<span class="number">2</span>)          <span class="comment">// panic: unexported field</span></span><br></pre></td></tr></table></figure>

<p><strong>一个可寻址的 <code>reflect.Value</code> 会记录它是否是通过遍历一个未导出字段来获得的，如果是这样，则不允许修改。所以，在更新变量前用 <code>CanAddr</code> 来检查并不能保证正确。<code>CanSet</code> 方法才能正确地报告一个 <code>reflect.Value</code> 是否可寻址且可更改：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(fd.CanAddr(), fd.CanSet()) <span class="comment">// &quot;true false&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="示例-解码S表达式"><a href="#示例-解码S表达式" class="headerlink" title="示例: 解码S表达式"></a>示例: 解码S表达式</h2><p>标准库中 <code>encoding/...</code> 下每个包中提供的<code>Marshal</code>编码函数都有一个对应的<code>Unmarshal</code>函数用于解码。例如，我们在4.5节中看到的，要将包含 JSON 编码格式的字节slice数据解码为我们自己的<code>Movie</code>类型（§12.3），我们可以这样做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data := []<span class="type">byte</span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line"><span class="keyword">var</span> movie Movie</span><br><span class="line">err := json.Unmarshal(data, &amp;movie)</span><br></pre></td></tr></table></figure>

<p><code>Unmarshal</code>函数使用了反射机制类修改<code>movie</code>变量的每个成员，根据输入的内容为<code>Movie</code>成员创建对应的map、结构体和slice。</p>
<p>现在让我们为S表达式编码实现一个简易的<code>Unmarshal</code>，类似于前面的<code>json.Unmarshal</code>标准库函数，对应我们之前实现的<code>sexpr.Marshal</code>函数的逆操作。我们必须提醒一下，一个健壮的和通用的实现通常需要比例子更多的代码，为了便于演示我们采用了精简的实现。我们只支持S表达式有限的子集，同时处理错误的方式也比较粗暴，代码的目的是为了演示反射的用法，而不是构造一个实用的S表达式的解码器。</p>
<p>词法分析程序使用 <code>text/scanner</code> 包提供的扫描器 <code>Scanner</code> 类型来把输入流分解成一系列的标记 (token)，包括注释、标识符、字符串字面量和数字字面量。扫描器的 <code>Scan</code> 方法向前推进扫描位置并且返回下一个标记（类型为 <code>rune</code>）。大部分标记（比如<code>(</code>）都只包含单个<code>rune</code>，但 <code>text/scanner</code> 包则用<code>rune</code>类型的小负数区域来表示那些多字符的标记，比如 <code>Ident</code>、<code>String</code>、<code>Int</code>。调用 <code>Scan</code> 会返回标记的类型，调用 <code>TokenText</code> 则会返回标记对应的文本。</p>
<p>因为一个典型的分析器需要多次分析当前的标记，但 <code>Scan</code> 方法会一直推进扫描位置所以我们把扫描器封装到一个 lexer 辅助类型中，其中保存了 <code>Scan</code> 最近返回的标记。</p>
<p><em>gopl.io&#x2F;ch12&#x2F;sexpr</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> lexer <span class="keyword">struct</span> &#123;</span><br><span class="line">    scan  scanner.Scanner</span><br><span class="line">    token <span class="type">rune</span> <span class="comment">// the current token</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lex *lexer)</span></span> next()        &#123; lex.token = lex.scan.Scan() &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lex *lexer)</span></span> text() <span class="type">string</span> &#123; <span class="keyword">return</span> lex.scan.TokenText() &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lex *lexer)</span></span> consume(want <span class="type">rune</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> lex.token != want &#123; <span class="comment">// <span class="doctag">NOTE:</span> Not an example of good error handling.</span></span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;got %q, want %q&quot;</span>, lex.text(), want))</span><br><span class="line">    &#125;</span><br><span class="line">    lex.next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们转到语法解析器。它主要包含两个功能。第一个是<code>read</code>函数，用于读取S表达式的当前标记，然后根据S表达式的当前标记更新可取地址的<code>reflect.Value</code>对应的变量<code>v</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(lex *lexer, v reflect.Value)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> lex.token &#123;</span><br><span class="line">    <span class="keyword">case</span> scanner.Ident:</span><br><span class="line">        <span class="comment">// The only valid identifiers are</span></span><br><span class="line">        <span class="comment">// &quot;nil&quot; and struct field names.</span></span><br><span class="line">        <span class="keyword">if</span> lex.text() == <span class="string">&quot;nil&quot;</span> &#123;</span><br><span class="line">            v.Set(reflect.Zero(v.Type()))</span><br><span class="line">            lex.next()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> scanner.String:</span><br><span class="line">        s, _ := strconv.Unquote(lex.text()) <span class="comment">// <span class="doctag">NOTE:</span> ignoring errors</span></span><br><span class="line">        v.SetString(s)</span><br><span class="line">        lex.next()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> scanner.Int:</span><br><span class="line">        i, _ := strconv.Atoi(lex.text()) <span class="comment">// <span class="doctag">NOTE:</span> ignoring errors</span></span><br><span class="line">        v.SetInt(<span class="type">int64</span>(i))</span><br><span class="line">        lex.next()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">        lex.next()</span><br><span class="line">        readList(lex, v)</span><br><span class="line">        lex.next() <span class="comment">// consume &#x27;)&#x27;</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unexpected token %q&quot;</span>, lex.text()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的S表达式使用标识符区分两个不同类型，结构体成员名和<code>nil</code>值的指针。<code>read</code>函数值处理<code>nil</code>类型的标识符。当遇到<code>scanner.Ident</code>为<code>nil</code>时，使用<code>reflect.Zero</code>函数将变量<code>v</code>设置为零值。而其它任何类型的标识符，我们都作为错误处理。后面的<code>readList</code>函数将处理结构体的成员名。</p>
<p>一个<code>(</code>标记对应一个列表的开始。第二个函数<code>readList</code>，将一个列表解码到一个聚合类型中（map、结构体、slice或数组），具体类型依然于传入待填充变量的类型。每次遇到这种情况，循环继续解析每个元素直到遇到于开始标记匹配的结束标记<code>)</code>，<code>endList</code>函数用于检测结束标记。</p>
<p>最有趣的部分是递归。最简单的是对数组类型的处理。直到遇到<code>)</code>结束标记，我们使用Index函数来获取数组每个元素的地址，然后递归调用read函数处理。和其它错误类似，如果输入数据导致解码器的引用超出了数组的范围，解码器将抛出panic异常。slice也采用类似方法解析，不同的是我们将为每个元素创建新的变量，然后将元素添加到slice的末尾。</p>
<p>在循环处理结构体和map每个元素时必须解码一个(key value)格式的对应子列表。对于结构体，key部分对于成员的名字。和数组类似，我们使用FieldByName找到结构体对应成员的变量，然后递归调用read函数处理。对于map，key可能是任意类型，对元素的处理方式和slice类似，我们创建一个新的变量，然后递归填充它，最后将新解析到的key&#x2F;value对添加到map。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readList</span><span class="params">(lex *lexer, v reflect.Value)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Array: <span class="comment">// (item ...)</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; !endList(lex); i++ &#123;</span><br><span class="line">            read(lex, v.Index(i))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> reflect.Slice: <span class="comment">// (item ...)</span></span><br><span class="line">        <span class="keyword">for</span> !endList(lex) &#123;</span><br><span class="line">            item := reflect.New(v.Type().Elem()).Elem()</span><br><span class="line">            read(lex, item)</span><br><span class="line">            v.Set(reflect.Append(v, item))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> reflect.Struct: <span class="comment">// ((name value) ...)</span></span><br><span class="line">        <span class="keyword">for</span> !endList(lex) &#123;</span><br><span class="line">            lex.consume(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> lex.token != scanner.Ident &#123;</span><br><span class="line">                <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;got token %q, want field name&quot;</span>, lex.text()))</span><br><span class="line">            &#125;</span><br><span class="line">            name := lex.text()</span><br><span class="line">            lex.next()</span><br><span class="line">            read(lex, v.FieldByName(name))</span><br><span class="line">            lex.consume(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> reflect.Map: <span class="comment">// ((key value) ...)</span></span><br><span class="line">        v.Set(reflect.MakeMap(v.Type()))</span><br><span class="line">        <span class="keyword">for</span> !endList(lex) &#123;</span><br><span class="line">            lex.consume(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            key := reflect.New(v.Type().Key()).Elem()</span><br><span class="line">            read(lex, key)</span><br><span class="line">            value := reflect.New(v.Type().Elem()).Elem()</span><br><span class="line">            read(lex, value)</span><br><span class="line">            v.SetMapIndex(key, value)</span><br><span class="line">            lex.consume(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;cannot decode list into %v&quot;</span>, v.Type()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endList</span><span class="params">(lex *lexer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> lex.token &#123;</span><br><span class="line">    <span class="keyword">case</span> scanner.EOF:</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;end of file&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们将解析器包装为导出的<code>Unmarshal</code>解码函数，隐藏了一些初始化和清理等边缘处理。内部解析器以panic的方式抛出错误，但是<code>Unmarshal</code>函数通过在<code>defer</code>语句调用<code>recover</code>函数来捕获内部panic（§5.10），然后返回一个对panic对应的错误信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unmarshal parses S-expression data and populates the variable</span></span><br><span class="line"><span class="comment">// whose address is in the non-nil pointer out.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="type">byte</span>, out <span class="keyword">interface</span>&#123;&#125;)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">    lex := &amp;lexer&#123;scan: scanner.Scanner&#123;Mode: scanner.GoTokens&#125;&#125;</span><br><span class="line">    lex.scan.Init(bytes.NewReader(data))</span><br><span class="line">    lex.next() <span class="comment">// get the first token</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> this is not an example of ideal error handling.</span></span><br><span class="line">        <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">&quot;error at %s: %v&quot;</span>, lex.scan.Position, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    read(lex, reflect.ValueOf(out).Elem())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产实现不应该对任何输入问题都用panic形式报告，而且应该报告一些错误相关的信息，例如出现错误输入的行号和位置等。尽管如此，我们希望通过这个例子来展示类似<code>encoding/json</code>等包底层代码的实现思路，以及如何使用反射机制来填充数据结构。</p>
<h2 id="获取结构体字段标签"><a href="#获取结构体字段标签" class="headerlink" title="获取结构体字段标签"></a>获取结构体字段标签</h2><p>在4.5节我们使用构体成员标签用于设置对应JSON对应的名字。其中json成员标签让我们可以选择成员的名字和抑制零值成员的输出。在本节，我们将看到如何通过反射机制类获取成员标签。</p>
<p>对于一个web服务，大部分HTTP处理函数要做的第一件事情就是展开请求中的参数到本地变量中。我们定义了一个工具函数，叫<code>params.Unpack</code>，通过使用结构体成员标签机制来让HTTP处理函数解析请求参数更方便。</p>
<p>首先，我们看看如何使用它。下面的<code>search</code>函数是一个HTTP请求处理函数。它定义了一个匿名结构体类型的变量，用结构体的每个成员表示HTTP请求的参数。其中结构体成员标签指明了对于请求参数的名字，为了减少URL的长度这些参数名通常都是神秘的缩略词。<code>Unpack</code>将请求参数填充到合适的结构体成员中，这样我们可以方便地通过合适的类型类来访问这些参数。</p>
<p><em>gopl.io&#x2F;ch12&#x2F;search</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;gopl.io/ch12/params&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// search implements the /search URL endpoint.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">        Labels     []<span class="type">string</span> <span class="string">`http:&quot;l&quot;`</span></span><br><span class="line">        MaxResults <span class="type">int</span>      <span class="string">`http:&quot;max&quot;`</span></span><br><span class="line">        Exact      <span class="type">bool</span>     <span class="string">`http:&quot;x&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line">    data.MaxResults = <span class="number">10</span> <span class="comment">// set default</span></span><br><span class="line">    <span class="keyword">if</span> err := params.Unpack(req, &amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(resp, err.Error(), http.StatusBadRequest) <span class="comment">// 400</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...rest of handler...</span></span><br><span class="line">    fmt.Fprintf(resp, <span class="string">&quot;Search: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的<code>Unpack</code>函数主要完成三件事情。第一，它调用<code>req.ParseForm()</code>来解析HTTP请求。然后，<code>req.Form</code>将包含所有的请求参数，不管HTTP客户端使用的是GET还是POST请求方法。</p>
<p>下一步，<code>Unpack</code>函数将构建每个结构体成员有效参数名字到成员变量的映射。如果结构体成员有成员标签的话，有效参数名字可能和实际的成员名字不相同。<code>reflect.Type</code>的<code>Field</code>方法将返回一个<code>reflect.StructField</code>，里面含有每个成员的名字、类型和可选的成员标签等信息。其中成员标签信息对应<code>reflect.StructTag</code>类型的字符串，并且提供了<code>Get</code>方法用于解析和根据特定key提取的子串，例如这里的<code>http:&quot;...&quot;</code>形式的子串。</p>
<p><em>gopl.io&#x2F;ch12&#x2F;params</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unpack populates the fields of the struct pointed to by ptr</span></span><br><span class="line"><span class="comment">// from the HTTP request parameters in req.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unpack</span><span class="params">(req *http.Request, ptr <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := req.ParseForm(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build map of fields keyed by effective name.</span></span><br><span class="line">    fields := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]reflect.Value)</span><br><span class="line">    v := reflect.ValueOf(ptr).Elem() <span class="comment">// the struct variable</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">        fieldInfo := v.Type().Field(i) <span class="comment">// a reflect.StructField</span></span><br><span class="line">        tag := fieldInfo.Tag           <span class="comment">// a reflect.StructTag</span></span><br><span class="line">        name := tag.Get(<span class="string">&quot;http&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            name = strings.ToLower(fieldInfo.Name)</span><br><span class="line">        &#125;</span><br><span class="line">        fields[name] = v.Field(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update struct field for each parameter in the request.</span></span><br><span class="line">    <span class="keyword">for</span> name, values := <span class="keyword">range</span> req.Form &#123;</span><br><span class="line">        f := fields[name]</span><br><span class="line">        <span class="keyword">if</span> !f.IsValid() &#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// ignore unrecognized HTTP parameters</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">            <span class="keyword">if</span> f.Kind() == reflect.Slice &#123;</span><br><span class="line">                elem := reflect.New(f.Type().Elem()).Elem()</span><br><span class="line">                <span class="keyword">if</span> err := populate(elem, value); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s: %v&quot;</span>, name, err)</span><br><span class="line">                &#125;</span><br><span class="line">                f.Set(reflect.Append(f, elem))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err := populate(f, value); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s: %v&quot;</span>, name, err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，<code>Unpack</code>遍历HTTP请求的name&#x2F;value参数键值对，并且根据更新相应的结构体成员。回想一下，同一个名字的参数可能出现多次。如果发生这种情况，并且对应的结构体成员是一个slice，那么就将所有的参数添加到slice中。其它情况，对应的成员值将被覆盖，只有最后一次出现的参数值才是起作用的。</p>
<p><code>populate</code>函数小心用请求的字符串类型参数值来填充单一的成员<code>v</code>（或者是slice类型成员中的单一的元素）。目前，它仅支持字符串、有符号整数和布尔型。其中其它的类型将留做练习任务。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">populate</span><span class="params">(v reflect.Value, value <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        v.SetString(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> reflect.Int:</span><br><span class="line">        i, err := strconv.ParseInt(value, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        v.SetInt(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> reflect.Bool:</span><br><span class="line">        b, err := strconv.ParseBool(value)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        v.SetBool(b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unsupported kind %s&quot;</span>, v.Type())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们上上面的处理程序添加到一个web服务器，则可以产生以下的会话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch12/search</span><br><span class="line">$ ./search &amp;</span><br><span class="line">$ ./fetch &#x27;http://localhost:12345/search&#x27;</span><br><span class="line">Search: &#123;Labels:[] MaxResults:10 Exact:false&#125;</span><br><span class="line">$ ./fetch &#x27;http://localhost:12345/search?l=golang&amp;l=programming&#x27;</span><br><span class="line">Search: &#123;Labels:[golang programming] MaxResults:10 Exact:false&#125;</span><br><span class="line">$ ./fetch &#x27;http://localhost:12345/search?l=golang&amp;l=programming&amp;max=100&#x27;</span><br><span class="line">Search: &#123;Labels:[golang programming] MaxResults:100 Exact:false&#125;</span><br><span class="line">$ ./fetch &#x27;http://localhost:12345/search?x=true&amp;l=golang&amp;l=programming&#x27;</span><br><span class="line">Search: &#123;Labels:[golang programming] MaxResults:10 Exact:true&#125;</span><br><span class="line">$ ./fetch &#x27;http://localhost:12345/search?q=hello&amp;x=123&#x27;</span><br><span class="line">x: strconv.ParseBool: parsing &quot;123&quot;: invalid syntax</span><br><span class="line">$ ./fetch &#x27;http://localhost:12345/search?q=hello&amp;max=lots&#x27;</span><br><span class="line">max: strconv.ParseInt: parsing &quot;lots&quot;: invalid syntax</span><br></pre></td></tr></table></figure>



<h2 id="显示一个类型的方法集"><a href="#显示一个类型的方法集" class="headerlink" title="显示一个类型的方法集"></a>显示一个类型的方法集</h2><p>我们的最后一个例子是使用<code>reflect.Type</code>来打印任意值的类型和枚举它的方法：</p>
<p><em>gopl.io&#x2F;ch12&#x2F;methods</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Print prints the method set of the value x.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    t := v.Type()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type %s\n&quot;</span>, t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">        methType := v.Method(i).Type()</span><br><span class="line">        fmt.Printf(<span class="string">&quot;func (%s) %s%s\n&quot;</span>, t, t.Method(i).Name,</span><br><span class="line">            strings.TrimPrefix(methType.String(), <span class="string">&quot;func&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>reflect.Type</code>和<code>reflect.Value</code>都提供了一个<code>Method</code>方法。每次<code>t.Method(i)</code>调用将一个<code>reflect.Method</code>的实例，对应一个用于描述一个方法的名称和类型的结构体。每次<code>v.Method(i)</code>方法调用都返回一个<code>reflect.Value</code>以表示对应的值（§6.4），也就是一个方法是帮到它的接收者的。使用<code>reflect.Value.Call</code>方法（我们这里没有演示），将可以调用一个<code>Func</code>类型的<code>Value</code>，但是这个例子中只用到了它的类型。</p>
<p>这是属于<code>time.Duration</code>和<code>*strings.Replacer</code>两个类型的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">methods.Print(time.Hour)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// type time.Duration</span></span><br><span class="line"><span class="comment">// func (time.Duration) Hours() float64</span></span><br><span class="line"><span class="comment">// func (time.Duration) Minutes() float64</span></span><br><span class="line"><span class="comment">// func (time.Duration) Nanoseconds() int64</span></span><br><span class="line"><span class="comment">// func (time.Duration) Seconds() float64</span></span><br><span class="line"><span class="comment">// func (time.Duration) String() string</span></span><br><span class="line"></span><br><span class="line">methods.Print(<span class="built_in">new</span>(strings.Replacer))</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// type *strings.Replacer</span></span><br><span class="line"><span class="comment">// func (*strings.Replacer) Replace(string) string</span></span><br><span class="line"><span class="comment">// func (*strings.Replacer) WriteString(io.Writer, string) (int, error)</span></span><br></pre></td></tr></table></figure>



<h2 id="几点忠告"><a href="#几点忠告" class="headerlink" title="几点忠告"></a>几点忠告</h2><p>虽然反射提供的API远多于我们讲到的，我们前面的例子主要是给出了一个方向，通过反射可以实现哪些功能。反射是一个强大并富有表达力的工具，但是它应该被小心地使用，原因有三。</p>
<p>第一个原因是，基于反射的代码是比较脆弱的。对于每一个会导致编译器报告类型错误的问题，在反射中都有与之相对应的误用问题，不同的是编译器会在构建时马上报告错误，而反射则是在真正运行到的时候才会抛出panic异常，可能是写完代码很久之后了，而且程序也可能运行了很长的时间。</p>
<p>以前面的<code>readList</code>函数（§12.6）为例，为了从输入读取字符串并填充int类型的变量而调用的<code>reflect.Value.SetString</code>方法可能导致panic异常。绝大多数使用反射的程序都有类似的风险，需要非常小心地检查每个<code>reflect.Value</code>的对应值的类型、是否可取地址，还有是否可以被修改等。</p>
<p>避免这种因反射而导致的脆弱性的问题的最好方法，是将所有的反射相关的使用控制在包的内部，如果可能的话避免在包的API中直接暴露<code>reflect.Value</code>类型，这样可以限制一些非法输入。如果无法做到这一点，在每个有风险的操作前指向额外的类型检查。以标准库中的代码为例，当<code>fmt.Printf</code>收到一个非法的操作数时，它并不会抛出panic异常，而是打印相关的错误信息。程序虽然还有BUG，但是会更加容易诊断。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%d %s\n&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">42</span>) <span class="comment">// &quot;%!d(string=hello) %!s(int=42)&quot;</span></span><br></pre></td></tr></table></figure>

<p>反射同样降低了程序的安全性，还影响了自动化重构和分析工具的准确性，因为它们无法识别运行时才能确认的类型信息。</p>
<p>避免使用反射的第二个原因是，即使对应类型提供了相同文档，但是反射的操作不能做静态类型检查，而且大量反射的代码通常难以理解。总是需要小心翼翼地为每个导出的类型和其它接受<code>interface&#123;&#125;</code>或<code>reflect.Value</code>类型参数的函数维护说明文档。</p>
<p>第三个原因，基于反射的代码通常比正常的代码运行速度慢一到两个数量级。对于一个典型的项目，大部分函数的性能和程序的整体性能关系不大，所以当反射能使程序更加清晰的时候可以考虑使用。测试是一个特别适合使用反射的场景，因为每个测试的数据集都很小。但是对于性能关键路径的函数，最好避免使用反射。</p>
<h1 id="底层编程"><a href="#底层编程" class="headerlink" title="底层编程"></a>底层编程</h1><p>Go语言的设计包含了诸多安全策略，限制了可能导致程序运行出错的用法。编译时类型检查可以发现大多数类型不匹配的操作，例如两个字符串做减法的错误。字符串、map、slice和chan等所有的内置类型，都有严格的类型转换规则。</p>
<p>对于无法静态检测到的错误，例如数组访问越界或使用空指针，运行时动态检测可以保证程序在遇到问题的时候立即终止并打印相关的错误信息。自动内存管理（垃圾内存自动回收）可以消除大部分野指针和内存泄漏相关的问题。</p>
<p>Go语言的实现刻意隐藏了很多底层细节。我们无法知道一个结构体真实的内存布局，也无法获取一个运行时函数对应的机器码，也无法知道当前的goroutine是运行在哪个操作系统线程之上。事实上，Go语言的调度器会自己决定是否需要将某个goroutine从一个操作系统线程转移到另一个操作系统线程。一个指向变量的指针也并没有展示变量真实的地址。因为垃圾回收器可能会根据需要移动变量的内存位置，当然变量对应的地址也会被自动更新。</p>
<p>总的来说，Go语言的这些特性使得Go程序相比较低级的C语言来说更容易预测和理解，程序也不容易崩溃。通过隐藏底层的实现细节，也使得Go语言编写的程序具有高度的可移植性，因为语言的语义在很大程度上是独立于任何编译器实现、操作系统和CPU系统结构的（当然也不是完全绝对独立：例如int等类型就依赖于CPU机器字的大小，某些表达式求值的具体顺序，还有编译器实现的一些额外的限制等）。</p>
<p>有时候我们可能会放弃使用部分语言特性而优先选择具有更好性能的方法，例如需要与其他语言编写的库进行互操作，或者用纯Go语言无法实现的某些函数。</p>
<p>在本章，我们将展示如何使用<code>unsafe</code>包来摆脱Go语言规则带来的限制，讲述如何创建C语言函数库的绑定，以及如何进行系统调用。</p>
<p>本章提供的方法不应该轻易使用（译注：属于黑魔法，虽然功能很强大，但是也容易误伤到自己）。如果没有处理好细节，它们可能导致各种不可预测的并且隐晦的错误，甚至连有经验的C语言程序员也无法理解这些错误。使用<code>unsafe</code>包的同时也放弃了Go语言保证与未来版本的兼容性的承诺，因为它必然会有意无意中使用很多非公开的实现细节，而这些实现的细节在未来的Go语言中很可能会被改变。</p>
<p>要注意的是，unsafe包是一个采用特殊方式实现的包。虽然它可以和普通包一样的导入和使用，但它实际上是由编译器实现的。它提供了一些访问语言内部特性的方法，特别是内存布局相关的细节。将这些特性封装到一个独立的包中，是为在极少数情况下需要使用的时候，同时引起人们的注意（译注：因为看包的名字就知道使用unsafe包是不安全的）。此外，有一些环境因为安全的因素可能限制这个包的使用。</p>
<p>不过<code>unsafe</code>包被广泛地用于比较低级的包，例如<code>runtime</code>、<code>os</code>、<code>syscall</code>还有<code>net</code>包等，因为它们需要和操作系统密切配合，但是对于普通的程序一般是不需要使用<code>unsafe</code>包的。</p>
<h2 id="unsafe-Sizeof-unsafe-Alignof-和-unsafe-Offsetof"><a href="#unsafe-Sizeof-unsafe-Alignof-和-unsafe-Offsetof" class="headerlink" title="unsafe.Sizeof, unsafe.Alignof 和 unsafe.Offsetof"></a><code>unsafe.Sizeof</code>, <code>unsafe.Alignof</code> 和 <code>unsafe.Offsetof</code></h2><p><code>unsafe.Sizeof</code>函数返回操作数在内存中的字节大小，参数可以是任意类型的表达式，但是它并不会对表达式进行求值。一个<code> Sizeof</code>函数调用是一个对应<code>uintptr</code>类型的常量表达式，因此返回的结果可以用作数组类型的长度大小，或者用作计算其他的常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(<span class="type">float64</span>(<span class="number">0</span>))) <span class="comment">// &quot;8&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Sizeof</code>函数返回的大小只包括数据结构中固定的部分，例如字符串对应结构体中的指针和字符串长度部分，但是并不包含指针指向的字符串的内容。Go语言中非聚合类型通常有一个固定的大小，尽管在不同工具链下生成的实际大小可能会有所不同。考虑到可移植性，引用类型或包含引用类型的大小在32位平台上是4个字节，在64位平台上是8个字节。</p>
<p>计算机在加载和保存数据时，如果内存地址合理地对齐的将会更有效率。例如2字节大小的int16类型的变量地址应该是偶数，一个4字节大小的rune类型变量的地址应该是4的倍数，一个8字节大小的float64、uint64或64-bit指针类型变量的地址应该是8字节对齐的。但是对于再大的地址对齐倍数则是不需要的，即使是complex128等较大的数据类型最多也只是8字节对齐。</p>
<p>由于地址对齐这个因素，一个聚合类型（结构体或数组）的大小至少是所有字段或元素大小的总和，或者更大因为可能存在内存空洞。内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐（译注：内存空洞可能会存在一些随机数据，可能会对用<code>unsafe</code>包直接操作内存的处理产生影响）。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td><code>bool</code></td>
<td>1个字节</td>
</tr>
<tr>
<td><code>intN, uintN, floatN, complexN</code></td>
<td>N&#x2F;8个字节（例如float64是8个字节）</td>
</tr>
<tr>
<td><code>int, uint, uintptr</code></td>
<td>1 word</td>
</tr>
<tr>
<td><code>*T</code></td>
<td>1 word</td>
</tr>
<tr>
<td><code>string</code></td>
<td>2 words (data, len)</td>
</tr>
<tr>
<td><code>[]T</code></td>
<td>3 words (data, len, cap)</td>
</tr>
<tr>
<td><code>map</code></td>
<td>1 word</td>
</tr>
<tr>
<td><code>func</code></td>
<td>1 word</td>
</tr>
<tr>
<td><code>chan</code></td>
<td>1 word</td>
</tr>
<tr>
<td><code>interface</code></td>
<td>2 words (type, value)</td>
</tr>
</tbody></table>
<p>Go语言的规范并没有要求一个字段的声明顺序和内存中的顺序是一致的，所以理论上一个编译器可以随意地重新排列每个字段的内存位置，虽然在写作本书的时候编译器还没有这么做。下面的三个结构体虽然有着相同的字段，但是第一种写法比另外的两个需要多50%的内存。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">                               <span class="comment">// 64-bit  32-bit</span></span><br><span class="line"><span class="keyword">struct</span>&#123; <span class="type">bool</span>; <span class="type">float64</span>; <span class="type">int16</span> &#125; <span class="comment">// 3 words 4words</span></span><br><span class="line"><span class="keyword">struct</span>&#123; <span class="type">float64</span>; <span class="type">int16</span>; <span class="type">bool</span> &#125; <span class="comment">// 2 words 3words</span></span><br><span class="line"><span class="keyword">struct</span>&#123; <span class="type">bool</span>; <span class="type">int16</span>; <span class="type">float64</span> &#125; <span class="comment">// 2 words 3words</span></span><br></pre></td></tr></table></figure>

<p>关于内存地址对齐算法的细节超出了本书的范围，也不是每一个结构体都需要担心这个问题，不过有效的包装可以使数据结构更加紧凑（译注：未来的Go语言编译器应该会默认优化结构体的顺序，当然应该也能够指定具体的内存布局，相同讨论请参考 <a href="https://github.com/golang/go/issues/10014">Issue10014</a> ），内存使用率和性能都可能会受益。</p>
<p><code>unsafe.Alignof</code> 函数报告它参数类型所要求的对齐方式。和 <code>Sizeof</code> 一样，它的参数可以是任意类型的表达式，并且返回一个常量。典型地，布尔类型和数值类型对齐到它们的长度（最大8字节），而其他的类型则按字对齐。</p>
<p><code>unsafe.Offsetof</code> 函数的参数必须是一个字段 <code>x.f</code>，然后返回 <code>f</code> 字段相对于 <code>x</code> 起始地址的偏移量，包括可能的空洞（内存空位）。</p>
<p>图 13.1 显示了一个结构体变量 <code>x</code> 以及其在32位和64位机器上的典型的内存。灰色区域是空洞（内存空位）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">bool</span></span><br><span class="line">    b <span class="type">int16</span></span><br><span class="line">    c []<span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面显示了对<code>x</code>和它的三个字段调用<code>unsafe</code>包相关函数的计算结果：</p>
<p><img src="/notes-of-gopl/ch13-01.png" alt="img"></p>
<p>32位系统：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sizeof(x)   = 16  Alignof(x)   = 4</span><br><span class="line">Sizeof(x.a) = 1   Alignof(x.a) = 1 Offsetof(x.a) = 0</span><br><span class="line">Sizeof(x.b) = 2   Alignof(x.b) = 2 Offsetof(x.b) = 2</span><br><span class="line">Sizeof(x.c) = 12  Alignof(x.c) = 4 Offsetof(x.c) = 4</span><br></pre></td></tr></table></figure>

<p>64位系统：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sizeof(x)   = 32  Alignof(x)   = 8</span><br><span class="line">Sizeof(x.a) = 1   Alignof(x.a) = 1 Offsetof(x.a) = 0</span><br><span class="line">Sizeof(x.b) = 2   Alignof(x.b) = 2 Offsetof(x.b) = 2</span><br><span class="line">Sizeof(x.c) = 24  Alignof(x.c) = 8 Offsetof(x.c) = 8</span><br></pre></td></tr></table></figure>

<p>虽然这几个函数在不安全的<code>unsafe</code>包，但是这几个函数调用并不是真的不安全，特别在需要优化内存空间时它们返回的结果对于理解原生的内存布局很有帮助。</p>
<h2 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h2><p>大多数指针类型会写成<code>*T</code>，表示是“一个指向T类型变量的指针”。<code>unsafe.Pointer</code>是特别定义的一种指针类型（译注：类似C语言中的<code>void*</code>类型的指针），它可以包含任意类型变量的地址。当然，我们不可以直接通过<code>*p</code>来获取<code>unsafe.Pointer</code>指针指向的真实变量的值，因为我们并不知道变量的具体类型。和普通指针一样，<code>unsafe.Pointer</code>指针也是可以比较的，并且支持和<code>nil</code>常量比较判断是否为空指针。</p>
<p>一个普通的<code>*T</code>类型指针可以被转化为<code>unsafe.Pointer</code>类型指针，并且一个<code>unsafe.Pointer</code>类型指针也可以被转回普通的指针，被转回普通的指针类型并不需要和原始的<code>*T</code>类型相同。通过将<code>*float64</code>类型指针转化为<code>*uint64</code>类型指针，我们可以查看一个浮点数变量的位模式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64bits</span><span class="params">(f <span class="type">float64</span>)</span></span> <span class="type">uint64</span> &#123; <span class="keyword">return</span> *(*<span class="type">uint64</span>)(unsafe.Pointer(&amp;f)) &#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#016x\n&quot;</span>, Float64bits(<span class="number">1.0</span>)) <span class="comment">// &quot;0x3ff0000000000000&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过转为新类型指针，我们可以更新浮点数的位模式。通过位模式操作浮点数是可以的，但是更重要的意义是指针转换语法让我们可以在不破坏类型系统的前提下向内存写入任意的值。</p>
<p><strong>一个<code>unsafe.Pointer</code>指针也可以被转化为<code>uintptr</code>类型，然后保存到指针型数值变量中（译注：这只是和当前指针相同的一个数字值，并不是一个指针），然后用以做必要的指针数值运算。（第三章内容，<code>uintptr</code>是一个无符号的整型数，足以保存一个地址）这种转换虽然也是可逆的，但是将<code>uintptr</code>转为<code>unsafe.Pointer</code>指针可能会破坏类型系统，因为并不是所有的数字都是有效的内存地址。</strong></p>
<p>**许多将<code>unsafe.Pointer</code>指针转为原生数字，然后再转回为<code>unsafe.Pointer</code>类型指针的操作也是不安全的。**比如下面的例子需要将变量<code>x</code>的地址加上<code>b</code>字段地址偏移量转化为<code>*int16</code>类型指针，然后通过该指针更新<code>x.b</code>：</p>
<p><em>gopl.io&#x2F;ch13&#x2F;unsafeptr</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">bool</span></span><br><span class="line">    b <span class="type">int16</span></span><br><span class="line">    c []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 pb := &amp;x.b 等价</span></span><br><span class="line">pb := (*<span class="type">int16</span>)(unsafe.Pointer(</span><br><span class="line">    <span class="type">uintptr</span>(unsafe.Pointer(&amp;x)) + unsafe.Offsetof(x.b)))</span><br><span class="line">*pb = <span class="number">42</span></span><br><span class="line">fmt.Println(x.b) <span class="comment">// &quot;42&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>上面的写法尽管很繁琐，但在这里并不是一件坏事，因为这些功能应该很谨慎地使用。不要试图引入一个<code>uintptr</code>类型的临时变量，因为它可能会破坏代码的安全性</strong>（译注：这是真正可以体会<code>unsafe</code>包为何不安全的例子）。下面段代码是错误的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> subtly incorrect!</span></span><br><span class="line">tmp := <span class="type">uintptr</span>(unsafe.Pointer(&amp;x)) + unsafe.Offsetof(x.b)</span><br><span class="line">pb := (*<span class="type">int16</span>)(unsafe.Pointer(tmp))</span><br><span class="line">*pb = <span class="number">42</span></span><br></pre></td></tr></table></figure>

<p><strong>产生错误的原因很微妙。有时候垃圾回收器会移动一些变量以降低内存碎片等问题。这类垃圾回收器被称为移动GC (moving<br>GCs)。当一个变量被移动，所有的保存该变量旧地址的指针必须同时被更新为变量移动后的新地址。从垃圾收集器的视角来看，一个<code>unsafe.Pointer</code>是一个指向变量的指针，因此当变量被移动时对应的指针也必须被更新；但是<code>uintptr</code>类型的临时变量只是一个普通的数字，所以其值不应该被改变。上面错误的代码因为引入一个非指针的临时变量<code>tmp</code>，导致垃圾收集器无法正确识别这个是一个指向变量<code>x</code>的指针。当第二个语句执行时，变量<code>x</code>可能已经被转移，这时候临时变量<code>tmp</code>也就不再是现在的<code>&amp;x.b</code>地址。第三个向之前无效地址空间的赋值语句将彻底摧毁整个程序！</strong></p>
<p>还有很多类似原因导致的错误。例如这条语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pT := <span class="type">uintptr</span>(unsafe.Pointer(<span class="built_in">new</span>(T))) <span class="comment">// 提示: 错误!</span></span><br></pre></td></tr></table></figure>

<p>这里并没有指针引用<code>new</code>新创建的变量，因此该语句执行完成之后，垃圾收集器有权马上回收其内存空间，所以返回的<code>pT</code>将是无效的地址。</p>
<p>虽然目前的Go语言实现还没有使用移动GC（译注：未来可能实现），但这不该是编写错误代码侥幸的理由：当前的Go语言实现已经有移动变量的场景。在5.2节我们提到goroutine的栈是根据需要动态增长的。当发生栈动态增长的时候，原来栈中的所有变量可能需要被移动到新的更大的栈中，所以我们并不能确保变量的地址在整个使用周期内是不变的。</p>
<p>在编写本文时，还没有清晰的原则来指引Go程序员，什么样的<code>unsafe.Pointer</code>和<code>uintptr</code>的转换是不安全的（参考 <a href="https://github.com/golang/go/issues/7192">Issue7192</a> ）. 译注: 该问题已经关闭），因此我们强烈建议按照最坏的方式处理。将所有包含变量地址的<code>uintptr</code>类型变量当作BUG处理，同时减少不必要的<code>unsafe.Pointer</code>类型到<code>uintptr</code>类型的转换。在第一个例子中，有三个转换——字段偏移量到<code>uintptr</code>的转换和转回<code>unsafe.Pointer</code>类型的操作——所有的转换全在一个表达式完成。</p>
<p>当调用一个库函数，并且返回的是<code>uintptr</code>类型地址时（译注：普通方法实现的函数尽量不要返回该类型。下面例子是<code>reflect</code>包的函数，<code>reflect</code>包和<code>unsafe</code>包一样都是采用特殊技术实现的，编译器可能给它们开了后门），比如下面反射包中的相关函数，返回的结果应该立即转换为<code>unsafe.Pointer</code>以确保指针指向的是相同的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Value)</span></span> Pointer() <span class="type">uintptr</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Value)</span></span> UnsafeAddr() <span class="type">uintptr</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Value)</span></span> InterfaceData() [<span class="number">2</span>]<span class="type">uintptr</span> <span class="comment">// (index 1)</span></span><br></pre></td></tr></table></figure>



<h2 id="示例-深度相等判断"><a href="#示例-深度相等判断" class="headerlink" title="示例: 深度相等判断"></a>示例: 深度相等判断</h2><p>来自<code>reflect</code>包的<code>DeepEqual</code>函数可以对两个值进行深度相等判断。<code>DeepEqual</code>函数使用内建的<code>==</code>比较操作符对基础类型进行相等判断，对于复合类型则递归该变量的每个基础类型然后做类似的比较判断。因为它可以工作在任意的类型上，甚至对于一些不支持<code>==</code>操作运算符的类型也可以工作，因此在一些测试代码中广泛地使用该函数。比如下面的代码是用<code>DeepEqual</code>函数比较两个字符串slice是否相等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    got := strings.Split(<span class="string">&quot;a:b:c&quot;</span>, <span class="string">&quot;:&quot;</span>)</span><br><span class="line">    want := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> !reflect.DeepEqual(got, want) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管<code>DeepEqual</code>函数很方便，而且可以支持任意的数据类型，但是它也有不足之处。例如，它将一个<code>nil</code>值的map和非<code>nil</code>值但是空的map视作不相等，同样nil值的slice 和非nil但是空的slice也视作不相等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b []<span class="type">string</span> = <span class="literal">nil</span>, []<span class="type">string</span>&#123;&#125;</span><br><span class="line">fmt.Println(reflect.DeepEqual(a, b)) <span class="comment">// &quot;false&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, d <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> = <span class="literal">nil</span>, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">fmt.Println(reflect.DeepEqual(c, d)) <span class="comment">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们希望在这里实现一个自己的<code>Equal</code>函数，用于比较类型的值。和<code>DeepEqual</code>函数类似的地方是它也是基于slice和map的每个元素进行递归比较，不同之处是它将nil值的slice（map类似）和非nil值但是空的slice视作相等的值。基础部分的比较可以基于<code>reflect</code>包完成，和12.3章的<code>Display</code>函数的实现方法类似。同样，我们也定义了一个内部函数<code>equal</code>，用于内部的递归比较。读者目前不用关心<code>seen</code>参数的具体含义。对于每一对需要比较的<code>x</code>和<code>y</code>，<code>equal</code>函数首先检测它们是否都有效（或都无效），然后检测它们是否是相同的类型。剩下的部分是一个巨大的switch分支，用于相同基础类型的元素比较。因为页面空间的限制，我们省略了一些相似的分支。</p>
<p><em>gopl.io&#x2F;ch13&#x2F;equal</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">equal</span><span class="params">(x, y reflect.Value, seen <span class="keyword">map</span>[comparison]<span class="type">bool</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !x.IsValid() || !y.IsValid() &#123;</span><br><span class="line">        <span class="keyword">return</span> x.IsValid() == y.IsValid()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> x.Type() != y.Type() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...cycle check omitted (shown later)...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> x.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Bool:</span><br><span class="line">        <span class="keyword">return</span> x.Bool() == y.Bool()</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        <span class="keyword">return</span> x.String() == y.String()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...numeric cases omitted for brevity...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> reflect.Chan, reflect.UnsafePointer, reflect.Func:</span><br><span class="line">        <span class="keyword">return</span> x.Pointer() == y.Pointer()</span><br><span class="line">    <span class="keyword">case</span> reflect.Ptr, reflect.Interface:</span><br><span class="line">        <span class="keyword">return</span> equal(x.Elem(), y.Elem(), seen)</span><br><span class="line">    <span class="keyword">case</span> reflect.Array, reflect.Slice:</span><br><span class="line">        <span class="keyword">if</span> x.Len() != y.Len() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; x.Len(); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> !equal(x.Index(i), y.Index(i), seen) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...struct and map cases omitted for brevity...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和前面的建议一样，我们并不公开<code>reflect</code>包相关的接口，所以导出的函数需要在内部自己将变量转为<code>reflect.Value</code>类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Equal reports whether x and y are deeply equal.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Equal</span><span class="params">(x, y <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    seen := <span class="built_in">make</span>(<span class="keyword">map</span>[comparison]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">return</span> equal(reflect.ValueOf(x), reflect.ValueOf(y), seen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> comparison <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y unsafe.Pointer</span><br><span class="line">    treflect.Type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了确保算法对于有环的数据结构也能正常退出，我们必须记录每次已经比较的变量，从而避免进入第二次的比较。<code>Equal</code>函数分配了一组用于比较的结构体，包含每对比较对象的地址（<code>unsafe.Pointer</code>形式保存）和类型。我们要记录类型的原因是，有些不同的变量可能对应相同的地址。例如，如果<code>x</code>和<code>y</code>都是数组类型，那么<code>x</code>和<code>x[0]</code>将对应相同的地址，<code>y</code>和<code>y[0]</code>也是对应相同的地址，这可以用于区分<code>x</code>与<code>y</code>之间的比较或<code>x[0]</code>与<code>y[0]</code>之间的比较是否进行过了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cycle check</span></span><br><span class="line"><span class="keyword">if</span> x.CanAddr() &amp;&amp; y.CanAddr() &#123;</span><br><span class="line">    xptr := unsafe.Pointer(x.UnsafeAddr())</span><br><span class="line">    yptr := unsafe.Pointer(y.UnsafeAddr())</span><br><span class="line">    <span class="keyword">if</span> xptr == yptr &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// identical references</span></span><br><span class="line">    &#125;</span><br><span class="line">    c := comparison&#123;xptr, yptr, x.Type()&#125;</span><br><span class="line">    <span class="keyword">if</span> seen[c] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// already seen</span></span><br><span class="line">    &#125;</span><br><span class="line">    seen[c] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是<code>Equal</code>函数用法的例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(Equal([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;))        <span class="comment">// &quot;true&quot;</span></span><br><span class="line">fmt.Println(Equal([]<span class="type">string</span>&#123;<span class="string">&quot;foo&quot;</span>&#125;, []<span class="type">string</span>&#123;<span class="string">&quot;bar&quot;</span>&#125;))      <span class="comment">// &quot;false&quot;</span></span><br><span class="line">fmt.Println(Equal([]<span class="type">string</span>(<span class="literal">nil</span>), []<span class="type">string</span>&#123;&#125;))             <span class="comment">// &quot;true&quot;</span></span><br><span class="line">fmt.Println(Equal(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>(<span class="literal">nil</span>), <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;)) <span class="comment">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Equal</code>函数甚至可以处理类似12.3章中导致<code>Display</code>陷入死循环的带有环的数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Circular linked lists a -&gt; b -&gt; a and c -&gt; c.</span></span><br><span class="line"><span class="keyword">type</span> link <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="type">string</span></span><br><span class="line">    tail *link</span><br><span class="line">&#125;</span><br><span class="line">a, b, c := &amp;link&#123;value: <span class="string">&quot;a&quot;</span>&#125;, &amp;link&#123;value: <span class="string">&quot;b&quot;</span>&#125;, &amp;link&#123;value: <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">a.tail, b.tail, c.tail = b, a, c</span><br><span class="line">fmt.Println(Equal(a, a)) <span class="comment">// &quot;true&quot;</span></span><br><span class="line">fmt.Println(Equal(b, b)) <span class="comment">// &quot;true&quot;</span></span><br><span class="line">fmt.Println(Equal(c, c)) <span class="comment">// &quot;true&quot;</span></span><br><span class="line">fmt.Println(Equal(a, b)) <span class="comment">// &quot;false&quot;</span></span><br><span class="line">fmt.Println(Equal(a, c)) <span class="comment">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="通过cgo调用C代码"><a href="#通过cgo调用C代码" class="headerlink" title="通过cgo调用C代码"></a>通过cgo调用C代码</h2><p>Go程序可能会遇到要访问C语言的某些硬件驱动函数的场景，或者是从一个C++语言实现的嵌入式数据库查询记录的场景，或者是使用Fortran语言实现的一些线性代数库的场景。C语言作为一个通用语言，很多库会选择提供一个C兼容的API，然后用其他不同的编程语言实现（译者：Go语言需要也应该拥抱这些巨大的代码遗产）。</p>
<p>在本节中，我们将构建一个简易的数据压缩程序，使用了一个Go语言自带的叫cgo的用于支援C语言函数调用的工具。这类工具一般被称为 <em>foreign-function interfaces</em> （简称ffi），并且在类似工具中cgo也不是唯一的。SWIG（<a href="http://swig.org/">http://swig.org</a>）是另一个类似的且被广泛使用的工具，SWIG提供了很多复杂特性以支援C++的特性，但SWIG并不是我们要讨论的主题。</p>
<p>在标准库的<code>compress/...</code>子包有很多流行的压缩算法的编码和解码实现，包括流行的LZW压缩算法（Unix的compress命令用的算法）和DEFLATE压缩算法（GNU gzip命令用的算法）。这些包的API的细节虽然有些差异，但是它们都提供了针对 <code>io.Writer</code>类型输出的压缩接口和提供了针对<code>io.Reader</code>类型输入的解压缩接口。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> gzip <span class="comment">// compress/gzip</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span></span> io.WriteCloser</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(r io.Reader)</span></span> (io.ReadCloser, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>bzip2压缩算法，是基于优雅的Burrows-Wheeler变换算法，运行速度比gzip要慢，但是可以提供更高的压缩比。标准库的<code>compress/bzip2</code>包目前还没有提供bzip2压缩算法的实现。完全从头开始实现一个压缩算法是一件繁琐的工作，而且 <a href="http://bzip.org/">http://bzip.org</a> 已经有现成的libbzip2的开源实现，不仅文档齐全而且性能又好。</p>
<p>如果是比较小的C语言库，我们完全可以用纯Go语言重新实现一遍。如果我们对性能也没有特殊要求的话，我们还可以用<code>os/exec</code>包的方法将C编写的应用程序作为一个子进程运行。只有当你需要使用复杂而且性能更高的底层C接口时，就是使用cgo的场景了（译注：用<code>os/exec</code>包调用子进程的方法会导致程序运行时依赖那个应用程序）。下面我们将通过一个例子讲述cgo的具体用法。</p>
<p>译注：本章采用的代码都是最新的。因为之前已经出版的书中包含的代码只能在Go1.5之前使用。从Go1.6开始，Go语言已经明确规定了哪些Go语言指针可以直接传入C语言函数。新代码重点是增加了<code>bz2alloc</code>和<code>bz2free</code>的两个函数，用于<code>bz_stream</code>对象空间的申请和释放操作。下面是新代码中增加的注释，说明这个问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The version of this program that appeared in the first and second</span></span><br><span class="line"><span class="comment">// printings did not comply with the proposed rules for passing</span></span><br><span class="line"><span class="comment">// pointers between Go and C, described here:</span></span><br><span class="line"><span class="comment">// https://github.com/golang/proposal/blob/master/design/12416-cgo-pointers.md</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The rules forbid a C function like bz2compress from storing &#x27;in&#x27;</span></span><br><span class="line"><span class="comment">// and &#x27;out&#x27; (pointers to variables allocated by Go) into the Go</span></span><br><span class="line"><span class="comment">// variable &#x27;s&#x27;, even temporarily.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The version below, which appears in the third printing, has been</span></span><br><span class="line"><span class="comment">// corrected.  To comply with the rules, the bz_stream variable must</span></span><br><span class="line"><span class="comment">// be allocated by C code.  We have introduced two C functions,</span></span><br><span class="line"><span class="comment">// bz2alloc and bz2free, to allocate and free instances of the</span></span><br><span class="line"><span class="comment">// bz_stream type.  Also, we have changed bz2compress so that before</span></span><br><span class="line"><span class="comment">// it returns, it clears the fields of the bz_stream that contain</span></span><br><span class="line"><span class="comment">// pointers to Go variables.</span></span><br></pre></td></tr></table></figure>

<p>要使用libbzip2，我们需要先构建一个<code>bz_stream</code>结构体，用于保持输入和输出缓存。然后有三个函数：<code>BZ2_bzCompressInit</code>用于初始化缓存，<code>BZ2_bzCompress</code>用于将输入缓存的数据压缩到输出缓存，<code>BZ2_bzCompressEnd</code>用于释放不需要的缓存。（目前不要担心包的具体结构，这个例子的目的就是演示各个部分如何组合在一起的。）</p>
<p>我们可以在Go代码中直接调用<code>BZ2_bzCompressInit</code>和<code>BZ2_bzCompressEnd</code>，但是对于<code>BZ2_bzCompress</code>，我们将定义一个C语言的包装函数，用它完成真正的工作。下面是C代码，对应一个独立的文件。</p>
<p><em>gopl.io&#x2F;ch13&#x2F;bzip</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This file is gopl.io/ch13/bzip/bzip2.c,         */</span></span><br><span class="line"><span class="comment">/* a simple wrapper for libbzip2 suitable for cgo. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bzlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bz2compress</span><span class="params">(bz_stream *s, <span class="type">int</span> action,</span></span><br><span class="line"><span class="params">                <span class="type">char</span> *in, <span class="type">unsigned</span> *inlen, <span class="type">char</span> *out, <span class="type">unsigned</span> *outlen)</span> &#123;</span><br><span class="line">    s-&gt;next_in = in;</span><br><span class="line">    s-&gt;avail_in = *inlen;</span><br><span class="line">    s-&gt;next_out = out;</span><br><span class="line">    s-&gt;avail_out = *outlen;</span><br><span class="line">    <span class="type">int</span> r = BZ2_bzCompress(s, action);</span><br><span class="line">    *inlen -= s-&gt;avail_in;</span><br><span class="line">    *outlen -= s-&gt;avail_out;</span><br><span class="line">    s-&gt;next_in = s-&gt;next_out = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们转到Go语言部分，第一部分如下所示。其中<code>import &quot;C&quot;</code>的语句是比较特别的。其实并没有一个叫C的包，但是这行语句会让Go编译程序在编译之前先运行cgo工具。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package bzip provides a writer that uses bzip2 compression (bzip.org).</span></span><br><span class="line"><span class="keyword">package</span> bzip</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#cgo CFLAGS: -I/usr/include</span></span><br><span class="line"><span class="comment">#cgo LDFLAGS: -L/usr/lib -lbz2</span></span><br><span class="line"><span class="comment">#include &lt;bzlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">bz_stream* bz2alloc() &#123; return calloc(1, sizeof(bz_stream)); &#125;</span></span><br><span class="line"><span class="comment">int bz2compress(bz_stream *s, int action,</span></span><br><span class="line"><span class="comment">                char *in, unsigned *inlen, char *out, unsigned *outlen);</span></span><br><span class="line"><span class="comment">void bz2free(bz_stream* s) &#123; free(s); &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> writer <span class="keyword">struct</span> &#123;</span><br><span class="line">    w      io.Writer <span class="comment">// underlying output stream</span></span><br><span class="line">    stream *C.bz_stream</span><br><span class="line">    outbuf [<span class="number">64</span> * <span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewWriter returns a writer for bzip2-compressed streams.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(out io.Writer)</span></span> io.WriteCloser &#123;</span><br><span class="line">    <span class="keyword">const</span> blockSize = <span class="number">9</span></span><br><span class="line">    <span class="keyword">const</span> verbosity = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> workFactor = <span class="number">30</span></span><br><span class="line">    w := &amp;writer&#123;w: out, stream: C.bz2alloc()&#125;</span><br><span class="line">    C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor)</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在预处理过程中，cgo工具生成一个临时包用于包含所有在Go语言中访问的C语言的函数或类型。例如<code>C.bz_stream</code>和<code>C.BZ2_bzCompressInit</code>。cgo工具通过以某种特殊的方式调用本地的C编译器来发现在Go源文件导入声明前的注释中包含的C头文件中的内容（译注：<code>import &quot;C&quot;</code>语句前紧挨着的注释是对应cgo的特殊语法，对应必要的构建参数选项和C语言代码）。</p>
<p>在cgo注释中还可以包含<code>#cgo</code>指令，用于给C语言工具链指定特殊的参数。例如<code>CFLAGS</code>和<code>LDFLAGS</code>分别对应传给C语言编译器的编译参数和链接器参数，使它们可以从特定目录找到<code>bzlib.h</code>头文件和<code>libbz2.a</code>库文件。这个例子假设你已经在<code>/usr</code>目录成功安装了<code>bzip2</code>库。如果<code>bzip2</code>库是安装在不同的位置，你需要更新这些参数（译注：这里有一个从纯C代码生成的cgo绑定，不依赖<code>bzip2</code>静态库和操作系统的具体环境，具体请访问 <a href="https://github.com/chai2010/bzip2">https://github.com/chai2010/bzip2</a> ）。</p>
<p><code>NewWriter</code>函数通过调用C语言的<code>BZ2_bzCompressInit</code>函数来初始化<code>stream</code>中的缓存。在<code>writer</code>结构中还包括了另一个<code>buffer</code>，用于输出缓存。</p>
<p>下面是<code>Write</code>方法的实现，返回成功压缩数据的大小，主体是一个循环中调用C语言的<code>bz2compress</code>函数实现的。从代码可以看到，Go程序可以访问C语言的<code>bz_stream</code>、<code>char</code>和<code>uint</code>类型，还可以访问<code>bz2compress</code>等函数，甚至可以访问C语言中像<code>BZ_RUN</code>那样的宏定义，全部都是以<code>C.x</code>语法访问。其中<code>C.uint</code>类型和Go语言的<code>uint</code>类型并不相同，即使它们具有相同的大小也是不同的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *writer)</span></span> Write(data []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> w.stream == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;closed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> total <span class="type">int</span> <span class="comment">// uncompressed bytes written</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(data) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        inlen, outlen := C.<span class="type">uint</span>(<span class="built_in">len</span>(data)), C.<span class="type">uint</span>(<span class="built_in">cap</span>(w.outbuf))</span><br><span class="line">        C.bz2compress(w.stream, C.BZ_RUN,</span><br><span class="line">            (*C.char)(unsafe.Pointer(&amp;data[<span class="number">0</span>])), &amp;inlen,</span><br><span class="line">            (*C.char)(unsafe.Pointer(&amp;w.outbuf)), &amp;outlen)</span><br><span class="line">        total += <span class="type">int</span>(inlen)</span><br><span class="line">        data = data[inlen:]</span><br><span class="line">        <span class="keyword">if</span> _, err := w.w.Write(w.outbuf[:outlen]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> total, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在循环的每次迭代中，向<code>bz2compress</code>传入数据的地址和剩余部分的长度，还有输出缓存<code>w.outbuf</code>的地址和容量。这两个长度信息通过它们的地址传入而不是值传入，因为<code>bz2compress</code>函数可能会根据已经压缩的数据和压缩后数据的大小来更新这两个值。每个块压缩后的数据被写入到底层的<code>io.Writer</code>。</p>
<p><code>Close</code>方法和<code>Write</code>方法有着类似的结构，通过一个循环将剩余的压缩数据刷新到输出缓存。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Close flushes the compressed data and closes the stream.</span></span><br><span class="line"><span class="comment">// It does not close the underlying io.Writer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *writer)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> w.stream == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;closed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        C.BZ2_bzCompressEnd(w.stream)</span><br><span class="line">        C.bz2free(w.stream)</span><br><span class="line">        w.stream = <span class="literal">nil</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        inlen, outlen := C.<span class="type">uint</span>(<span class="number">0</span>), C.<span class="type">uint</span>(<span class="built_in">cap</span>(w.outbuf))</span><br><span class="line">        r := C.bz2compress(w.stream, C.BZ_FINISH, <span class="literal">nil</span>, &amp;inlen,</span><br><span class="line">            (*C.char)(unsafe.Pointer(&amp;w.outbuf)), &amp;outlen)</span><br><span class="line">        <span class="keyword">if</span> _, err := w.w.Write(w.outbuf[:outlen]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r == C.BZ_STREAM_END &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>压缩完成后，<code>Close</code>方法用了defer函数确保函数退出前调用<code>C.BZ2_bzCompressEnd</code>和<code>C.bz2free</code>释放相关的C语言运行时资源。此刻<code>w.stream</code>指针将不再有效，我们将它设置为<code>nil</code>以保证安全，然后在每个方法中增加了nil检测，以防止用户在关闭后依然错误使用相关方法。</p>
<p>上面的实现中，不但<code>writer</code>不是并发安全的，甚至并发调用<code>Close</code>和<code>Write</code>方法也可能导致程序的的崩溃。修复这个问题是练习13.3的内容。</p>
<p>下面的bzipper程序，使用我们自己包实现的bzip2压缩命令。它的行为和许多Unix系统的bzip2命令类似。</p>
<p><em>gopl.io&#x2F;ch13&#x2F;bzipper</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bzipper reads input, bzip2-compresses it, and writes it out.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;gopl.io/ch13/bzip&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    w := bzip.NewWriter(os.Stdout)</span><br><span class="line">    <span class="keyword">if</span> _, err := io.Copy(w, os.Stdin); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;bzipper: %v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := w.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;bzipper: close: %v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的场景中，我们使用bzipper压缩了&#x2F;usr&#x2F;share&#x2F;dict&#x2F;words系统自带的词典，从938,848字节压缩到335,405字节。大约是原始数据大小的三分之一。然后使用系统自带的bunzip2命令进行解压。压缩前后文件的SHA256哈希码是相同了，这也说明了我们的压缩工具是正确的。（如果你的系统没有sha256sum命令，那么请先按照练习4.2实现一个类似的工具）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go build gopl.io/ch13/bzipper</span><br><span class="line">$ wc -c &lt; /usr/share/dict/words</span><br><span class="line">938848</span><br><span class="line">$ sha256sum &lt; /usr/share/dict/words</span><br><span class="line">126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed -</span><br><span class="line">$ ./bzipper &lt; /usr/share/dict/words | wc -c</span><br><span class="line">335405</span><br><span class="line">$ ./bzipper &lt; /usr/share/dict/words | bunzip2 | sha256sum</span><br><span class="line">126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed -</span><br></pre></td></tr></table></figure>

<p>我们演示了如何将一个C语言库链接到Go语言程序。相反，<strong>将Go编译为静态库然后链接到C程序，或者将Go程序编译为动态库然后在C程序中动态加载也都是可行的</strong>（译注：在Go1.5中，Windows系统的Go语言实现并不支持生成C语言动态库或静态库的特性。不过好消息是，目前已经有人在尝试解决这个问题，具体请访问 <a href="https://github.com/golang/go/issues/11058">Issue11058</a> ）。这里我们只展示的cgo很小的一些方面，更多的关于内存管理、指针、回调函数、中断信号处理、字符串、errno处理、终结器，以及goroutines和系统线程的关系等，有很多细节可以讨论。特别是如何将Go语言的指针传入C函数的规则也是异常复杂的（译注：简单来说，要传入C函数的Go指针指向的数据本身不能包含指针或其他引用类型；并且C函数在返回后不能继续持有Go指针；并且在C函数返回之前，Go指针是被锁定的，不能导致对应指针数据被移动或栈的调整），部分的原因在13.2节有讨论到，但是在Go1.5中还没有被明确（译注：Go1.6将会明确cgo中的指针使用规则）。如果要进一步阅读，可以从 <a href="https://golang.org/cmd/cgo">https://golang.org/cmd/cgo</a> 开始。</p>
<h2 id="几点忠告-1"><a href="#几点忠告-1" class="headerlink" title="几点忠告"></a>几点忠告</h2><p>我们在前一章结尾的时候，我们警告要谨慎使用<code>reflect</code>包。那些警告同样适用于本章的<code>unsafe</code>包。</p>
<p>高级语言使得程序员不用再关心真正运行程序的指令细节，同时也不再需要关注许多如内存布局之类的实现细节。因为高级语言这个绝缘的抽象层，我们可以编写安全健壮的，并且可以运行在不同操作系统上的具有高度可移植性的程序。</p>
<p>但是<code>unsafe</code>包，它让程序员可以透过这个绝缘的抽象层直接使用一些必要的功能，虽然可能是为了获得更好的性能。但是代价就是牺牲了可移植性和程序安全，因此使用<code>unsafe</code>包是一个危险的行为。我们对何时以及如何使用<code>unsafe</code>包的建议和我们在11.5节提到的Knuth对过早优化的建议类似。大多数Go程序员可能永远不会需要直接使用<code>unsafe</code>包。当然，也永远都会有一些需要使用<code>unsafe</code>包实现会更简单的场景。如果确实认为使用<code>unsafe</code>包是最理想的方式，那么应该尽可能将它限制在较小的范围，这样其它代码就可以忽略<code>unsafe</code>的影响。</p>
<p>现在，赶紧将最后两章抛入脑后吧。编写一些实实在在的应用是真理。请远离<code>reflect</code>和<code>unsafe</code>包，除非你确实需要它们。</p>
<p>最后，用Go快乐地编程。我们希望你能像我们一样喜欢Go语言。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
</search>
