<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ifelif.cn","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.14.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.14.0/source/js/config.min.js"></script>

    <meta name="description" content="本文为《The Go Programming Language》学习笔记，内容主要为https:&#x2F;&#x2F;books.studygolang.com&#x2F;gopl-zh&#x2F;的翻译版，并在此翻译版基础上调整格式或添加注释，以方便学习和记忆。部分难理解的内容，会对照英文版重新翻译。  前言Go语言起源下图展示了有哪些早期的编程语言对Go语言的设计产生了重要影响。  Go语言项目Go项目包括编程语言本身，附带了相">
<meta property="og:type" content="article">
<meta property="og:title" content="《The Go Programming Language》学习笔记">
<meta property="og:url" content="https://ifelif.cn/2022/notes-of-gopl/index.html">
<meta property="og:site_name" content="正经人谁写日记">
<meta property="og:description" content="本文为《The Go Programming Language》学习笔记，内容主要为https:&#x2F;&#x2F;books.studygolang.com&#x2F;gopl-zh&#x2F;的翻译版，并在此翻译版基础上调整格式或添加注释，以方便学习和记忆。部分难理解的内容，会对照英文版重新翻译。  前言Go语言起源下图展示了有哪些早期的编程语言对Go语言的设计产生了重要影响。  Go语言项目Go项目包括编程语言本身，附带了相">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ifelif.cn/2022/notes-of-gopl/ch0-01.png">
<meta property="og:image" content="https://ifelif.cn/2022/notes-of-gopl/ch1-01.png">
<meta property="og:image" content="https://ifelif.cn/2022/notes-of-gopl/ch1-01.gif">
<meta property="og:image" content="https://ifelif.cn/2022/notes-of-gopl/ch1-02.png">
<meta property="og:image" content="https://ifelif.cn/2022/notes-of-gopl/ch1-03.png">
<meta property="og:image" content="https://ifelif.cn/2022/notes-of-gopl/ch3-04.png">
<meta property="og:image" content="https://ifelif.cn/2022/notes-of-gopl/ch3-05.png">
<meta property="og:image" content="https://ifelif.cn/2022/notes-of-gopl/ch4-01.png">
<meta property="og:image" content="https://ifelif.cn/2022/notes-of-gopl/ch4-06.png">
<meta property="og:image" content="https://ifelif.cn/2022/notes-of-gopl/ch7-01.png">
<meta property="og:image" content="https://ifelif.cn/2022/notes-of-gopl/ch7-02.png">
<meta property="og:image" content="https://ifelif.cn/2022/notes-of-gopl/ch7-03.png">
<meta property="og:image" content="https://ifelif.cn/2022/notes-of-gopl/ch7-04.png">
<meta property="og:image" content="https://ifelif.cn/2022/notes-of-gopl/ch7-05.png">
<meta property="article:published_time" content="2022-09-30T06:24:21.000Z">
<meta property="article:modified_time" content="2022-09-30T06:24:21.000Z">
<meta property="article:author" content="filefi">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ifelif.cn/2022/notes-of-gopl/ch0-01.png">


<link rel="canonical" href="https://ifelif.cn/2022/notes-of-gopl/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ifelif.cn/2022/notes-of-gopl/","path":"2022/notes-of-gopl/","title":"《The Go Programming Language》学习笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《The Go Programming Language》学习笔记 | 正经人谁写日记</title>
  

  <script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.14.0/source/js/third-party/analytics/baidu-analytics.min.js"></script>
  <script async src="https://hm.baidu.com/hm.js?3f08a6c1407c206aa070325c05c2844d"></script>





  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="正经人谁写日记" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">正经人谁写日记</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-专题"><a href="/topics/" rel="section"><i class="fa fa-book fa-fw"></i>专题</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80%E8%B5%B7%E6%BA%90"><span class="nav-number">1.1.</span> <span class="nav-text">Go语言起源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.2.</span> <span class="nav-text">Go语言项目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A5%E9%97%A8"><span class="nav-number">2.</span> <span class="nav-text">入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Hello-World"><span class="nav-number">2.1.</span> <span class="nav-text">Hello, World</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">2.1.1.</span> <span class="nav-text">Go 源文件的组成部分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">命令行参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E8%A1%8C"><span class="nav-number">2.3.</span> <span class="nav-text">查找重复的行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GIF-%E5%8A%A8%E7%94%BB"><span class="nav-number">2.4.</span> <span class="nav-text">GIF 动画</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-URL"><span class="nav-number">2.5.</span> <span class="nav-text">获取 URL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AA-URL"><span class="nav-number">2.6.</span> <span class="nav-text">并发获取多个 URL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.7.</span> <span class="nav-text">Web服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E8%A6%81%E7%82%B9"><span class="nav-number">2.8.</span> <span class="nav-text">本章要点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">程序结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D"><span class="nav-number">3.1.</span> <span class="nav-text">命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E"><span class="nav-number">3.2.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">3.3.1.</span> <span class="nav-text">简短变量声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">3.3.2.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.3.</span> <span class="nav-text">new函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.3.4.</span> <span class="nav-text">变量的生命周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC"><span class="nav-number">3.4.</span> <span class="nav-text">赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%BB%84%E8%B5%8B%E5%80%BC"><span class="nav-number">3.4.1.</span> <span class="nav-text">元组赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%B5%8B%E5%80%BC%E6%80%A7"><span class="nav-number">3.4.2.</span> <span class="nav-text">可赋值性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.5.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E5%92%8C%E6%96%87%E4%BB%B6"><span class="nav-number">3.6.</span> <span class="nav-text">包和文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E5%8C%85"><span class="nav-number">3.6.1.</span> <span class="nav-text">导入包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.6.2.</span> <span class="nav-text">包的初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">3.7.</span> <span class="nav-text">作用域</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">整型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">浮点数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">复数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="nav-number">4.4.</span> <span class="nav-text">布尔型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.5.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">4.5.1.</span> <span class="nav-text">字符串字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unicode"><span class="nav-number">4.5.2.</span> <span class="nav-text">Unicode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UTF-8"><span class="nav-number">4.5.3.</span> <span class="nav-text">UTF-8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8CByte%E5%88%87%E7%89%87"><span class="nav-number">4.5.4.</span> <span class="nav-text">字符串和Byte切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.5.5.</span> <span class="nav-text">字符串和数字的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">4.6.</span> <span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#iota-%E5%B8%B8%E9%87%8F%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-number">4.6.1.</span> <span class="nav-text">iota 常量生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F"><span class="nav-number">4.6.2.</span> <span class="nav-text">无类型常量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">复合数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">5.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slice"><span class="nav-number">5.2.</span> <span class="nav-text">Slice</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#append%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.1.</span> <span class="nav-text">append函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Slice%E5%86%85%E5%AD%98%E6%8A%80%E5%B7%A7"><span class="nav-number">5.2.2.</span> <span class="nav-text">Slice内存技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">5.3.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">5.4.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="nav-number">5.4.1.</span> <span class="nav-text">结构体字面值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83"><span class="nav-number">5.4.2.</span> <span class="nav-text">结构体比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5%E5%92%8C%E5%8C%BF%E5%90%8D%E6%88%90%E5%91%98"><span class="nav-number">5.4.3.</span> <span class="nav-text">结构体嵌入和匿名成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON"><span class="nav-number">5.5.</span> <span class="nav-text">JSON</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%92%8CHTML%E6%A8%A1%E6%9D%BF"><span class="nav-number">5.6.</span> <span class="nav-text">文本和HTML模板</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">6.1.</span> <span class="nav-text">函数声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">6.2.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">6.3.</span> <span class="nav-text">多返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF"><span class="nav-number">6.4.</span> <span class="nav-text">错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-number">6.4.1.</span> <span class="nav-text">错误处理策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E5%B0%BE%E9%94%99%E8%AF%AF%EF%BC%88EOF%EF%BC%89"><span class="nav-number">6.4.2.</span> <span class="nav-text">文件结尾错误（EOF）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%80%BC"><span class="nav-number">6.5.</span> <span class="nav-text">函数值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">6.6.</span> <span class="nav-text">匿名函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AD%A6%E5%91%8A%EF%BC%9A%E6%8D%95%E8%8E%B7%E8%BF%AD%E4%BB%A3%E5%8F%98%E9%87%8F"><span class="nav-number">6.6.1.</span> <span class="nav-text">警告：捕获迭代变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-number">6.7.</span> <span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deferred%E5%87%BD%E6%95%B0"><span class="nav-number">6.8.</span> <span class="nav-text">Deferred函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Panic%E5%BC%82%E5%B8%B8"><span class="nav-number">6.9.</span> <span class="nav-text">Panic异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Recover%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-number">6.10.</span> <span class="nav-text">Recover捕获异常</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E"><span class="nav-number">7.1.</span> <span class="nav-text">方法声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">基于指针对象的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#nil%E4%B9%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%88%E6%B3%95%E7%9A%84%E6%8E%A5%E6%94%B6%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.2.1.</span> <span class="nav-text">nil也是一个合法的接收器类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%B5%8C%E5%85%A5%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.</span> <span class="nav-text">通过嵌入结构体来扩展类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%80%BC%E5%92%8C%E6%96%B9%E6%B3%95%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">7.4.</span> <span class="nav-text">方法值和方法表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-Bit%E6%95%B0%E7%BB%84"><span class="nav-number">7.5.</span> <span class="nav-text">示例: Bit数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">7.6.</span> <span class="nav-text">封装</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A"><span class="nav-number">8.1.</span> <span class="nav-text">接口约定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.2.</span> <span class="nav-text">接口类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">8.3.</span> <span class="nav-text">实现接口的条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flag-Value%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.4.</span> <span class="nav-text">flag.Value接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="nav-number">8.5.</span> <span class="nav-text">接口值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AD%A6%E5%91%8A%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%ABnil%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8D%E6%98%AFnil%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.5.1.</span> <span class="nav-text">警告：一个包含nil指针的接口不是nil接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sort-Interface%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.6.</span> <span class="nav-text">sort.Interface接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-Handler%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.7.</span> <span class="nav-text">http.Handler接口</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="filefi"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">filefi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/filefi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;filefi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://filefi.github.io/" title="https:&#x2F;&#x2F;filefi.github.io" rel="noopener" target="_blank">github home page</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ifelif.cn/2022/notes-of-gopl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="filefi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="正经人谁写日记">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《The Go Programming Language》学习笔记 | 正经人谁写日记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《The Go Programming Language》学习笔记<a href="https://github.com/filefi/MyHexoBlog/tree/master/source/_posts/2022/notes-of-gopl.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-30 14:24:21" itemprop="dateCreated datePublished" datetime="2022-09-30T14:24:21+08:00">2022-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>本文为《The Go Programming Language》学习笔记，内容主要为<a target="_blank" rel="noopener" href="https://books.studygolang.com/gopl-zh/%E7%9A%84%E7%BF%BB%E8%AF%91%E7%89%88%EF%BC%8C%E5%B9%B6%E5%9C%A8%E6%AD%A4%E7%BF%BB%E8%AF%91%E7%89%88%E5%9F%BA%E7%A1%80%E4%B8%8A%E8%B0%83%E6%95%B4%E6%A0%BC%E5%BC%8F%E6%88%96%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%EF%BC%8C%E4%BB%A5%E6%96%B9%E4%BE%BF%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%AE%B0%E5%BF%86%E3%80%82%E9%83%A8%E5%88%86%E9%9A%BE%E7%90%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E4%BC%9A%E5%AF%B9%E7%85%A7%E8%8B%B1%E6%96%87%E7%89%88%E9%87%8D%E6%96%B0%E7%BF%BB%E8%AF%91%E3%80%82">https://books.studygolang.com/gopl-zh/的翻译版，并在此翻译版基础上调整格式或添加注释，以方便学习和记忆。部分难理解的内容，会对照英文版重新翻译。</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="Go语言起源"><a href="#Go语言起源" class="headerlink" title="Go语言起源"></a><a target="_blank" rel="noopener" href="https://gopl-zh.github.io/preface.html#go%E8%AF%AD%E8%A8%80%E8%B5%B7%E6%BA%90">Go语言起源</a></h2><p>下图展示了有哪些早期的编程语言对Go语言的设计产生了重要影响。</p>
<p><img src="/2022/notes-of-gopl/ch0-01.png" alt="img"></p>
<h2 id="Go语言项目"><a href="#Go语言项目" class="headerlink" title="Go语言项目"></a><a target="_blank" rel="noopener" href="https://gopl-zh.github.io/preface.html#go%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE">Go语言项目</a></h2><p>Go项目包括编程语言本身，附带了相关的工具和标准库，最后但并非代表不重要的是，关于简洁编程哲学的宣言。</p>
<p>Go语言的这些地方都做的还不错：</p>
<ul>
<li><p>拥有自动垃圾回收</p>
</li>
<li><p>一个包系统</p>
</li>
<li><p>函数作为一等公民</p>
</li>
<li><p>词法作用域</p>
</li>
<li><p>系统调用接口</p>
</li>
<li><p>只读的UTF8字符串等</p>
</li>
</ul>
<p>但是Go语言本身只有很少的特性：</p>
<ul>
<li>没有隐式的数值转换</li>
<li>没有构造函数和析构函数</li>
<li>没有运算符重载</li>
<li>没有默认参数</li>
<li>没有继承</li>
<li><del>没有泛型</del></li>
<li>没有异常</li>
<li>没有宏</li>
<li>没有函数修饰</li>
<li>没有线程局部存储</li>
</ul>
<p>在实践中，Go语言简洁的类型系统给程序员带来了更多的安全性和更好的运行时性能。</p>
<p>Go语言提供了基于<code>CSP</code>的并发特性支持。Go语言的动态栈使得轻量级线程<code>goroutine</code>的初始栈可以很小，因此，创建一个<code>goroutine</code>的代价很小，创建百万级的<code>goroutine</code>完全是可行的。</p>
<p>Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I&#x2F;O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。</p>
<span id="more"></span>

<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World"></a><a target="_blank" rel="noopener" href="https://gopl-zh.github.io/ch1/ch1-01.html#11-hello-world">Hello, World</a></h2><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello, 世界"</span><span class="token punctuation">)</span> <span class="token comment">// Println 函数可以打印以空格间隔的一个或多个值，并在最后添加一个换行符</span>
<span class="token punctuation">&#125;</span>
</code></pre>

<p>Go 是一门编译型语言，Go 语言的工具链将源代码及其依赖转换成计算机的机器指令（译注：静态编译）。</p>
<p>Go 语言提供的工具都通过一个单独的命令 <code>go</code> 调用，<code>go</code> 命令有一系列子命令。</p>
<p><code>run</code> 子命令编译一个或多个以<code>.go</code> 结尾的源文件，链接库文件，并运行最终生成的可执行文件。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go run helloworld.go
Hello, 世界</code></pre>

<p> <code>build</code> 子命令能够编译这个程序，保存编译后的可执行文件：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go build helloworld.go</code></pre>

<p>这个命令生成一个与源代码同名的可执行二进制文件，之后你可以随时运行它。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ ./helloworld
Hello, 世界</code></pre>

<h3 id="Go-源文件的组成部分"><a href="#Go-源文件的组成部分" class="headerlink" title="Go 源文件的组成部分"></a>Go 源文件的组成部分</h3><p><strong>包（package）</strong></p>
<p>Go 语言的代码通过<strong>包</strong>（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个 <code>.go</code> 源代码文件组成，目录定义包的作用。</p>
<p> <strong><code>package</code> 声明</strong></p>
<p>每个源文件都以一条 <code>package</code> 声明语句开始，这个例子里就是 <code>package main</code>，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。</p>
<p><code>main</code> 包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在 <code>main</code> 里的 <code>main</code> <em>函数</em> 也很特殊，它是整个程序执行时的入口。<code>main</code> 函数一般调用其它包里的函数完成很多工作（如：<code>fmt.Println</code>）。</p>
<p><strong><code>import</code> 声明</strong></p>
<p><code>import</code> 声明必须跟在文件的 <code>package</code> 声明之后，它告诉编译器源文件需要导入哪些包。<code>hello world</code> 例子只用到了一个包，大多数程序需要导入多个包。缺少了必要的包或者导入了不需要的包，程序都无法编译通过。</p>
<p>Go 的标准库提供了 100 多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如 <code>fmt</code> 包，就含有格式化输出、接收输入的函数。<code>Println</code> 是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符。</p>
<p><strong>程序语句</strong></p>
<p>紧跟在<code>import</code>声明之后的，则是组成程序的函数、变量、常量、类型的声明语句（分别由关键字 <code>func</code>、<code>var</code>、<code>const</code>、<code>type</code> 定义），以及其他程序语句。</p>
<p>Go 语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。</p>
<p>Go 语言在代码格式上采取了很强硬的态度。<code>gofmt</code>工具把代码格式化为标准格式，并且 <code>go</code> 工具中的 <code>fmt</code> 子命令会对指定包，否则默认为当前目录中所有。</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>大多数的程序都是处理输入，产生输出；这也正是“计算”的定义。命令行参数就是最主要的输入源之一。</p>
<p><code>os</code> 包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从 <code>os</code> 包的 <code>Args</code> 变量获取；<code>os</code> 包外部使用 <code>os.Args</code> 访问该变量。</p>
<p><code>os.Args</code> 变量是一个字符串（string）的 <em>切片</em>（slice）。现在先把切片 <code>s</code> 当作数组元素序列，序列的长度动态变化，用 <code>s[i]</code> 访问单个元素，用 <code>s[m:n]</code> 获取子序列。序列的元素数目为 <code>len(s)</code>。和大多数编程语言类似，区间索引时，Go 语言里也采用左闭右开形式，即，区间包括第一个索引元素，不包括最后一个，比如 <code>a=[1,2,3,4,5]</code>, <code>a[0:3]=[1,2,3]</code>，不包含索引为3的元素；比如 <code>s[m:n]</code> 这个切片，<code>0≤m≤n≤len(s)</code>，包含 <code>n-m</code> 个元素。如果省略切片表达式的 <code>m</code> 或 <code>n</code>，会默认传入 <code>0</code> 或 <code>len(s)</code>，即<code>s[:]</code>等同于<code>s[0:len(s)]</code>。</p>
<p><code>os.Args</code> 的第一个元素：<code>os.Args[0]</code>，是命令本身的名字；其它的元素则是程序启动时传给它的参数。</p>
<p>下面是 Unix 里 <code>echo</code> 命令的一份实现，<code>echo</code> 把它的命令行参数打印成一行。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Echo1 prints its command-line arguments.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> s<span class="token punctuation">,</span> sep <span class="token builtin">string</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
        s <span class="token operator">+=</span> sep <span class="token operator">+</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        sep <span class="token operator">=</span> <span class="token string">" "</span>
    <span class="token punctuation">&#125;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>注释语句以 <code>//</code> 开头。</p>
<p><code>var</code> 声明定义了两个 <code>string</code> 类型的变量 <code>s</code> 和 <code>sep</code>。变量会在声明时直接初始化。如果变量没有显式初始化，则被隐式地赋予其类型的 <em>零值</em>（zero value），数值类型是 <code>0</code>，字符串类型是空字符串 <code>&quot;&quot;</code>。</p>
<p>运算符 <code>+=</code> 是赋值运算符（assignment operator），每种数值运算符或逻辑运算符，如 <code>+</code> 或 <code>*</code>，都有对应的赋值运算符。</p>
<p>循环索引变量 <code>i</code> 在 <code>for</code> 循环的第一部分中定义。符号 <code>:=</code> 是 <em>短变量声明</em>（short variable declaration）的一部分，这是定义一个或多个变量并根据它们的初始值为这些变量赋予适当类型的语句。</p>
<p>自增语句 <code>i++</code> 给 <code>i</code> 加 <code>1</code>；这和 <code>i+=1</code> 以及 <code>i=i+1</code> 都是等价的。对应的还有 <code>i--</code> 给 <code>i</code> 减 <code>1</code>。它们是语句，而不像 C 系的其它语言那样是表达式，所以 <code>j=i++</code> 非法。</p>
<p>Go 语言只有 <code>for</code> 循环这一种循环语句。<code>for</code> 循环有多种形式，其中一种如下所示：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> initialization<span class="token punctuation">;</span> condition<span class="token punctuation">;</span> post <span class="token punctuation">&#123;</span>
    <span class="token comment">// zero or more statements</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><code>for</code> 循环三个部分不需括号包围。大括号强制要求，左大括号必须和 <em><code>post</code></em> 语句在同一行。</p>
<ul>
<li><em><code>initialization</code></em> 语句是可选的，在循环开始前执行。*<code>initalization</code>* 如果存在，必须是一条 <em>简单语句</em>（simple statement），即，短变量声明、自增语句、赋值语句或函数调用。</li>
<li><code>condition</code> 是一个布尔表达式（boolean expression），其值在每次循环迭代开始时计算。如果为 <code>true</code> 则执行循环体语句。</li>
<li><code>post</code> 语句在循环体执行结束后执行，之后再次对 <code>condition</code> 求值。<code>condition</code> 值为 <code>false</code> 时，循环结束。</li>
</ul>
<p>for 循环的这三个部分每个都可以省略，如果省略 <code>initialization</code> 和 <code>post</code>，分号也可以省略：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// a traditional "while" loop</span>
<span class="token keyword">for</span> condition <span class="token punctuation">&#123;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>如果连 <code>condition</code> 也省略了，像下面这样：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// a traditional infinite loop</span>
<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>for 循环的另一种形式，在某种数据类型的区间（range）上遍历，如字符串或切片。以下 echo 的第二版本展示了这种形式：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Echo2 prints its command-line arguments.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    s<span class="token punctuation">,</span> sep <span class="token operator">:=</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> arg <span class="token operator">:=</span> <span class="token keyword">range</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
        s <span class="token operator">+=</span> sep <span class="token operator">+</span> arg
        sep <span class="token operator">=</span> <span class="token string">" "</span>
    <span class="token punctuation">&#125;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>每次循环迭代，<code>range</code> 产生一对值；索引以及在该索引处的元素值。这个例子不需要索引，但 <code>range</code> 的语法要求，要处理元素，必须处理索引。并且 Go 语言不允许使用无用的局部变量（local variables）。这种情况适用于 <em>空标识符</em>（blank identifier），即 <code>_</code>（也就是下划线）。<em>空标识符</em> 可用于在任何语法需要变量名但程序逻辑不需要的时候（如：在循环里）丢弃不需要的循环索引，并保留元素值。</p>
<p>声明一个变量有好几种方式，下面这些都等价：</p>
<pre class="language-go" data-language="go"><code class="language-go">s <span class="token operator">:=</span> <span class="token string">""</span>  <span class="token comment">// 短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。</span>
<span class="token keyword">var</span> s <span class="token builtin">string</span> <span class="token comment">// 依赖于字符串的默认初始化零值机制，被初始化为 ""。</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">""</span>
<span class="token keyword">var</span> s <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">""</span></code></pre>

<p>如果连接涉及的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使用 <code>strings</code> 包的 <code>Join</code> 函数：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="查找重复的行"><a href="#查找重复的行" class="headerlink" title="查找重复的行"></a><a target="_blank" rel="noopener" href="https://gopl-zh.github.io/ch1/ch1-03.html#13-%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E8%A1%8C">查找重复的行</a></h2><p>本节会实现一个名为 <code>dup</code> 的程序的三个版本；灵感来自于 Unix 的 <code>uniq</code> 命令，其寻找相邻的重复行。</p>
<p><code>dup</code> 的第一个版本打印标准输入中多次出现的行，以重复次数开头。该程序将引入 <code>if</code> 语句，<code>map</code> 数据类型以及 <code>bufio</code> 包。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Dup1 prints the text of each line that appears more than</span>
<span class="token comment">// once in the standard input, preceded by its count.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"bufio"</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    counts <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
    input <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewScanner</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span>
    <span class="token keyword">for</span> input<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        counts<span class="token punctuation">[</span>input<span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// NOTE: ignoring potential errors from input.Err()</span>
    <span class="token keyword">for</span> line<span class="token punctuation">,</span> n <span class="token operator">:=</span> <span class="token keyword">range</span> counts <span class="token punctuation">&#123;</span> <span class="token comment">// line 为 key, n 为 value</span>
        <span class="token keyword">if</span> n <span class="token operator">></span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>
            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d\t%s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> line<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>正如 <code>for</code> 循环一样，<code>if</code> 语句条件两边也不加括号，但是主体部分需要加。<code>if</code> 语句的 <code>else</code> 部分是可选的，在 <code>if</code> 的条件为 <code>false</code> 时执行。</p>
<p><strong>map</strong> 存储了键&#x2F;值（key&#x2F;value）的集合，对集合元素，提供常数时间的存、取或测试操作。键可以是任意类型，只要其值能用 <code>==</code> 运算符比较，最常见的例子是字符串；值则可以是任意类型。这个例子中的键是字符串，值是整数。</p>
<p>每次 <code>dup</code> 读取一行输入，该行被当做键存入 <code>map</code>，其对应的值递增。<code>counts[input.Text()]++</code> 语句等价下面两句：</p>
<pre class="language-go" data-language="go"><code class="language-go">line <span class="token operator">:=</span> input<span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
counts<span class="token punctuation">[</span>line<span class="token punctuation">]</span> <span class="token operator">=</span> counts<span class="token punctuation">[</span>line<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span></code></pre>

<p><code>map</code> 中不含某个键时不用担心，首次读到新行时，等号右边的表达式 <code>counts[line]</code> 的值将被计算为其类型的零值，对于 <code>int</code> 即 <code>0</code>。</p>
<p>为了打印结果，我们使用了基于 <code>range</code> 的循环，以迭代 <code>counts</code>。与迭代 slice 类似，迭代 map 每次得到两个结果：键和键的值。</p>
<blockquote>
<p><strong>注意： map 的迭代顺序被有意设计成不确定的、随机的，每次运行迭代，其顺序都会变化。</strong></p>
</blockquote>
<p><code>bufio</code> 包使处理输入和输出方便又高效。<code>Scanner</code> 类型是该包最有用的特性之一，它读取输入并将其拆成行或单词；通常是处理行形式的输入最简单的方法。</p>
<p>程序使用短变量声明创建 <code>bufio.Scanner</code> 类型的变量 <code>input</code>。</p>
<pre class="language-go" data-language="go"><code class="language-go">input <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewScanner</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span></code></pre>

<p>该变量从程序的标准输入中读取内容。每次调用 <code>input.Scan()</code>，即读入下一行，并移除行末的换行符；读取的内容可以调用 <code>input.Text()</code> 得到。<code>Scan</code> 函数在读到一行时返回 <code>true</code>，不再有输入时返回 <code>false</code>。</p>
<p>类似于 C 或其它语言里的 <code>printf</code> 函数，<code>fmt.Printf</code> 函数对一些表达式产生格式化输出。该函数的首个参数是个格式字符串，指定后续参数被如何格式化。各个参数的格式取决于“转换字符”（conversion character），形式为百分号后跟一个字母。</p>
<p><code>Printf</code> 有一大堆这种转换字符，Go程序员称之为<em>动词（verb）</em>。下表展示了常用的几个：</p>
<pre class="language-text" data-language="text"><code class="language-text">%d          十进制整数
%x, %o, %b  十六进制，八进制，二进制整数。
%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00
%t          布尔：true或false
%c          字符（rune） (Unicode码点)
%s          字符串
%q          带双引号的字符串"abc"或带单引号的字符'c'
%v          变量的自然形式（natural format）
%T          变量的类型
%%          字面上的百分号标志（无操作数）</code></pre>

<p>默认情况下，<code>Printf</code> 不会换行，除非格式字符串中存在换行符<code>\n</code>。</p>
<p>按照惯例，以字母 <code>f</code> 结尾的格式化函数，如 <code>log.Printf</code> 和 <code>fmt.Errorf</code>，都采用 <code>fmt.Printf</code> 的格式化准则。而以 <code>ln</code> 结尾的格式化函数，则遵循 <code>Println</code> 的方式，以跟 <code>%v</code> 差不多的方式格式化参数，并在最后添加一个换行符。（译注：后缀 <code>f</code> 指 <code>format</code>，<code>ln</code> 指 <code>line</code>。）</p>
<p><code>dup</code> 程序的下个版本读取标准输入或是使用 <code>os.Open</code> 打开各个具名文件，并操作它们。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Dup2 prints the count and text of lines that appear more than once</span>
<span class="token comment">// in the input.  It reads from stdin or from a list of named files.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"bufio"</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    counts <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
    files <span class="token operator">:=</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        <span class="token function">countLines</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">,</span> counts<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> arg <span class="token operator">:=</span> <span class="token keyword">range</span> files <span class="token punctuation">&#123;</span>
            <span class="token comment">// 打开文件</span>
            f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token comment">// os.Open 返回 *os.File 和 error</span>
            <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果 err 等于内置值nil（相当于其它语言里的 NULL），那么文件被成功打开。</span>
                fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"dup2: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
                <span class="token keyword">continue</span>
            <span class="token punctuation">&#125;</span>
            <span class="token function">countLines</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> counts<span class="token punctuation">)</span>
            f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 关闭文件f</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> line<span class="token punctuation">,</span> n <span class="token operator">:=</span> <span class="token keyword">range</span> counts <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> n <span class="token operator">></span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>
            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d\t%s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> line<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">countLines</span><span class="token punctuation">(</span>f <span class="token operator">*</span>os<span class="token punctuation">.</span>File<span class="token punctuation">,</span> counts <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    input <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewScanner</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
    <span class="token keyword">for</span> input<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        counts<span class="token punctuation">[</span>input<span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// NOTE: ignoring potential errors from input.Err()</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>注意 <code>countLines</code> 函数在其声明前被调用。函数和包级别的变量（package-level entities）可以任意顺序声明，并不影响其被调用。</p>
<p><code>map</code> 是一个由 <code>make</code> 函数创建的数据结构的引用。<code>map</code> 作为参数传递给某函数时，该函数接收这个引用的一份拷贝（copy，或译为副本），被调用函数对 <code>map</code> 底层数据结构的任何修改，调用者函数都可以通过持有的 <code>map</code> 引用看到。在我们的例子中，<code>countLines</code> 函数向 <code>counts</code> 插入的值，也会被 <code>main</code> 函数看到。（译注：类似于 C++ 里的引用传递，实际上指针是另一个指针了，但内部存的值指向同一块内存）</p>
<blockquote>
<p><strong>注意：Go 语言只有按值传递，传递的都是变量的一个副本，一个拷贝。只不过拷贝的内容，可能是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；可能是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。</strong></p>
</blockquote>
<p><code>dup</code> 的前两个版本以”流”模式读取输入，并根据需要拆分成多个行。理论上，这些程序可以处理任意数量的输入数据。下面这个版本<code>dup3</code>则是一口气把文件的数据全部读到内存中，一次分割为多行，然后处理它们：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"io"</span>
    <span class="token string">"os"</span>
    <span class="token string">"strings"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    counts <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> filename <span class="token operator">:=</span> <span class="token keyword">range</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
        data<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
            fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"dup3: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
            <span class="token keyword">continue</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> line <span class="token operator">:=</span> <span class="token keyword">range</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            counts<span class="token punctuation">[</span>line<span class="token punctuation">]</span><span class="token operator">++</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> line<span class="token punctuation">,</span> n <span class="token operator">:=</span> <span class="token keyword">range</span> counts <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> n <span class="token operator">></span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>
            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d\t%s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> line<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>这个例子中， <code>os.ReadFile</code> 函数，其读取指定文件的全部内容。<code>strings.Split</code> 函数的作用与前文提到的 <code>strings.Join</code> 相反，把字符串分割成子串的切片。</p>
<blockquote>
<p>包 <code>io/ioutil</code> 已被弃用， 新代码推荐使用包 <code>io</code> 和 <code>os</code>中的实现。如：<code>ioutil.ReadFile()</code>变为<code>os.ReadFile()</code>，<code>ioutil.ReadAll()</code>变为<code>io.ReadAll()</code>。</p>
</blockquote>
<p><code>os.ReadFile</code> 函数返回一个字节切片（byte slice），必须把它转换为 <code>string</code>，才能用 <code>strings.Split</code> 分割。</p>
<p>实现上，<code>bufio.Scanner</code>、<code>ioutil.ReadFile</code> 和 <code>ioutil.WriteFile</code> 都使用 <code>*os.File</code> 的 <code>Read</code> 和 <code>Write</code> 方法，但是，大多数程序员很少需要直接调用那些低级（lower-level）函数。像 <code>bufio</code> 和 <code>io/ioutil</code> 包中所提供的那些高级（higher-level）函数，用起来要容易点。</p>
<h2 id="GIF-动画"><a href="#GIF-动画" class="headerlink" title="GIF 动画"></a><a target="_blank" rel="noopener" href="https://gopl-zh.github.io/ch1/ch1-04.html#14-gif%E5%8A%A8%E7%94%BB">GIF 动画</a></h2><p>下面的程序会演示Go语言标准库里的image这个package的用法，我们会用这个包来生成一系列的bit-mapped图，然后将这些图片编码为一个GIF动画。我们生成的图形名字叫利萨如图形（Lissajous figures），这种效果是在1960年代的老电影里出现的一种视觉特效。它们是协振子在两个纬度上振动所产生的曲线，比如两个sin正弦波分别在x轴和y轴输入会产生的曲线。图1.1是这样的一个例子：</p>
<p><img src="/2022/notes-of-gopl/ch1-01.png" alt="img"></p>
<p>译注：要看这个程序的结果，需要将标准输出重定向到一个GIF图像文件（使用 <code>./lissajous &gt; output.gif</code> 命令）。下面是GIF图像动画效果：</p>
<p><img src="/2022/notes-of-gopl/ch1-01.gif" alt="img"></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Lissajous generates GIF animations of random Lissajous figures.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"image"</span>
    <span class="token string">"image/color"</span>
    <span class="token string">"image/gif"</span>
    <span class="token string">"io"</span>
    <span class="token string">"math"</span>
    <span class="token string">"math/rand"</span>
    <span class="token string">"os"</span>
    <span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token comment">// 常量声明和变量声明在包级别，在整个包中都是可以共享的。</span>
<span class="token comment">// 变量的字面量定义</span>
<span class="token keyword">var</span> palette <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>color<span class="token punctuation">.</span>Color<span class="token punctuation">&#123;</span>color<span class="token punctuation">.</span>White<span class="token punctuation">,</span> color<span class="token punctuation">.</span>Black<span class="token punctuation">&#125;</span>

<span class="token comment">// 常量声明</span>
<span class="token keyword">const</span> <span class="token punctuation">(</span>
    whiteIndex <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// first color in palette</span>
    blackIndex <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// next color in palette</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// The sequence of images is deterministic unless we seed</span>
    <span class="token comment">// the pseudo-random number generator using the current time.</span>
    <span class="token comment">// Thanks to Randall McPherson for pointing out the omission.</span>
    rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UTC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">lissajous</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">lissajous</span><span class="token punctuation">(</span>out io<span class="token punctuation">.</span>Writer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 把常量声明定义在函数体内部，那么这种常量就只能在函数体内用。</span>
    <span class="token keyword">const</span> <span class="token punctuation">(</span>
        cycles  <span class="token operator">=</span> <span class="token number">5</span>     <span class="token comment">// number of complete x oscillator revolutions</span>
        res     <span class="token operator">=</span> <span class="token number">0.001</span> <span class="token comment">// angular resolution</span>
        size    <span class="token operator">=</span> <span class="token number">100</span>   <span class="token comment">// image canvas covers [-size..+size]</span>
        nframes <span class="token operator">=</span> <span class="token number">64</span>    <span class="token comment">// number of animation frames</span>
        delay   <span class="token operator">=</span> <span class="token number">8</span>     <span class="token comment">// delay between frames in 10ms units</span>
    <span class="token punctuation">)</span>

    freq <span class="token operator">:=</span> rand<span class="token punctuation">.</span><span class="token function">Float64</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">3.0</span> <span class="token comment">// relative frequency of y oscillator</span>
    anim <span class="token operator">:=</span> gif<span class="token punctuation">.</span>GIF<span class="token punctuation">&#123;</span>LoopCount<span class="token punctuation">:</span> nframes<span class="token punctuation">&#125;</span>
    phase <span class="token operator">:=</span> <span class="token number">0.0</span> <span class="token comment">// phase difference</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nframes<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
        rect <span class="token operator">:=</span> image<span class="token punctuation">.</span><span class="token function">Rect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>size<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>size<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        img <span class="token operator">:=</span> image<span class="token punctuation">.</span><span class="token function">NewPaletted</span><span class="token punctuation">(</span>rect<span class="token punctuation">,</span> palette<span class="token punctuation">)</span>
        <span class="token keyword">for</span> t <span class="token operator">:=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> cycles<span class="token operator">*</span><span class="token number">2</span><span class="token operator">*</span>math<span class="token punctuation">.</span>Pi<span class="token punctuation">;</span> t <span class="token operator">+=</span> res <span class="token punctuation">&#123;</span>
            x <span class="token operator">:=</span> math<span class="token punctuation">.</span><span class="token function">Sin</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
            y <span class="token operator">:=</span> math<span class="token punctuation">.</span><span class="token function">Sin</span><span class="token punctuation">(</span>t<span class="token operator">*</span>freq <span class="token operator">+</span> phase<span class="token punctuation">)</span>
            img<span class="token punctuation">.</span><span class="token function">SetColorIndex</span><span class="token punctuation">(</span>size<span class="token operator">+</span><span class="token function">int</span><span class="token punctuation">(</span>x<span class="token operator">*</span>size<span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token operator">+</span><span class="token function">int</span><span class="token punctuation">(</span>y<span class="token operator">*</span>size<span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                blackIndex<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
        phase <span class="token operator">+=</span> <span class="token number">0.1</span>
        anim<span class="token punctuation">.</span>Delay <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>anim<span class="token punctuation">.</span>Delay<span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
        anim<span class="token punctuation">.</span>Image <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>anim<span class="token punctuation">.</span>Image<span class="token punctuation">,</span> img<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    gif<span class="token punctuation">.</span><span class="token function">EncodeAll</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token operator">&amp;</span>anim<span class="token punctuation">)</span> <span class="token comment">// NOTE: ignoring encoding errors</span>
<span class="token punctuation">&#125;</span>
</code></pre>

<p>main函数调用lissajous函数，用它来向标准输出流打印信息，所以下面这个命令会像图1.1中产生一个GIF动画。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go build gopl.io/ch1/lissajous
$ ./lissajous <span class="token operator">></span>out.gif</code></pre>

<h2 id="获取-URL"><a href="#获取-URL" class="headerlink" title="获取 URL"></a><a target="_blank" rel="noopener" href="https://gopl-zh.github.io/ch1/ch1-05.html#15-%E8%8E%B7%E5%8F%96url">获取 URL</a></h2><p>利用Go语言的<code>net</code>包和其他建立在<code>net</code>包基础之上的一系列包，可以更简单地用网络收发信息，还可以建立更底层的网络连接，编写服务器程序。在这些情景下，Go语言原生的并发特性（在第八章中会介绍）显得尤其好用。</p>
<p>为了最简单地展示基于HTTP获取信息的方式，下面给出一个示例程序fetch，这个程序将获取对应的url，并将其源文本打印出来：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Fetch prints the content found at a URL.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"io"</span>
    <span class="token string">"net/http"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> url <span class="token operator">:=</span> <span class="token keyword">range</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
        resp<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token comment">// 创建HTTP请求的函数</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
            fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"fetch: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
            os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
        b<span class="token punctuation">,</span> err <span class="token operator">:=</span> io<span class="token punctuation">.</span><span class="token function">ReadAll</span><span class="token punctuation">(</span>resp<span class="token punctuation">.</span>Body<span class="token punctuation">)</span> <span class="token comment">// io.ReadAll函数从response中读取全部内容到b</span>
        resp<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 关闭resp的Body流，防止资源泄露</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
            fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"fetch: reading %s: %v\n"</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
            os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-go" data-language="go"><code class="language-go">$ <span class="token keyword">go</span> build gopl<span class="token punctuation">.</span>io<span class="token operator">/</span>ch1<span class="token operator">/</span>fetch
$ <span class="token punctuation">.</span><span class="token operator">/</span>fetch http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>gopl<span class="token punctuation">.</span>io
<span class="token operator">&lt;</span>html<span class="token operator">></span>
<span class="token operator">&lt;</span>head<span class="token operator">></span>
<span class="token operator">&lt;</span>title<span class="token operator">></span>The Go Programming Language<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>title<span class="token operator">></span>
<span class="token operator">...</span>
</code></pre>

<p>HTTP请求如果失败了的话，会得到下面这样的结果：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ ./fetch http://bad.gopl.io
fetch: Get http://bad.gopl.io: dial tcp: lookup bad.gopl.io: no such <span class="token function">host</span></code></pre>

<p>译注：在大天朝的网络环境下很容易重现这种错误，下面是Windows下运行得到的错误信息：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go run main.go http://gopl.io
fetch: Get http://gopl.io: dial tcp: lookup gopl.io: getaddrinfow: No such <span class="token function">host</span> is known.</code></pre>

<p>无论哪种失败原因，我们的程序都用了<code>os.Exit</code>函数来终止进程，并且返回一个status错误码，其值为1。</p>
<h2 id="并发获取多个-URL"><a href="#并发获取多个-URL" class="headerlink" title="并发获取多个 URL"></a><a target="_blank" rel="noopener" href="https://gopl-zh.github.io/ch1/ch1-06.html#16-%E5%B9%B6%E5%8F%91%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AAurl">并发获取多个 URL</a></h2><p>Go语言最有意思并且最新奇的特性就是对并发编程的支持。这里我们只浅尝辄止地来体验一下Go语言里的goroutine和channel。</p>
<p>下面的例子fetchall，和前面小节的fetch程序所要做的工作基本一致，fetchall的特别之处在于它会同时去获取所有的URL，所以这个程序的总执行时间不会超过执行时间最长的那一个任务，前面的fetch程序执行时间则是所有任务执行时间之和。fetchall程序只会打印获取的内容大小和经过的时间，不会像之前那样打印获取的内容。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Fetchall fetches URLs in parallel and reports their times and sizes.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"io"</span>
    <span class="token string">"net/http"</span>
    <span class="token string">"os"</span>
    <span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    start <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">// 创建一个传递string类型参数的channel</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> url <span class="token operator">:=</span> <span class="token keyword">range</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">go</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> ch<span class="token punctuation">)</span> <span class="token comment">// start a goroutine</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 注意 for range 不一定非得使用短变量声明接收迭代中每一项的值</span>
    <span class="token keyword">for</span> <span class="token keyword">range</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>ch<span class="token punctuation">)</span> <span class="token comment">// receive from channel ch</span>
    <span class="token punctuation">&#125;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%.2fs elapsed\n"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Seconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">,</span> ch <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    start <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    resp<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        ch <span class="token operator">&lt;-</span> fmt<span class="token punctuation">.</span><span class="token function">Sprint</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token comment">// send to channel ch</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 因为我们需要这个方法返回的字节数，但是又不想要其内容。</span>
    <span class="token comment">// io.Copy把响应的Body拷贝到io.Discard输出流中丢弃</span>
    nbytes<span class="token punctuation">,</span> err <span class="token operator">:=</span> io<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>Discard<span class="token punctuation">,</span> resp<span class="token punctuation">.</span>Body<span class="token punctuation">)</span>
    resp<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// don't leak resources</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        ch <span class="token operator">&lt;-</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"while reading %s: %v"</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">&#125;</span>
    secs <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Seconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    ch <span class="token operator">&lt;-</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%.2fs  %7d  %s"</span><span class="token punctuation">,</span> secs<span class="token punctuation">,</span> nbytes<span class="token punctuation">,</span> url<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>下面使用fetchall来请求几个地址：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go build gopl.io/ch1/fetchall
$ ./fetchall https://golang.org http://gopl.io https://godoc.org
<span class="token number">0</span>.14s     <span class="token number">6852</span>  https://godoc.org
<span class="token number">0</span>.16s     <span class="token number">7261</span>  https://golang.org
<span class="token number">0</span>.48s     <span class="token number">2475</span>  http://gopl.io
<span class="token number">0</span>.48s elapsed</code></pre>

<p>goroutine是一种函数的并发执行方式，而channel是用来在goroutine之间进行参数传递。main函数本身也运行在一个goroutine中，而go function则表示创建一个新的goroutine，并在这个新的goroutine中执行这个函数。</p>
<p>当一个goroutine尝试在一个channel上做send或者receive操作时，这个goroutine会阻塞在调用处，直到另一个goroutine从这个channel里接收或者写入值，这样两个goroutine才会继续执行channel操作之后的逻辑。在这个例子中，每一个fetch函数在执行时都会往channel里发送一个值（<code>ch &lt;- expression</code>），主函数负责接收这些值（<code>&lt;-ch</code>）。</p>
<p>这个程序中我们用main函数来完整地处理&#x2F;接收所有fetch函数传回的字符串，可以避免因为有两个goroutine同时完成而使得其输出交错在一起的危险。</p>
<h2 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a><a target="_blank" rel="noopener" href="https://gopl-zh.github.io/ch1/ch1-07.html#17-web%E6%9C%8D%E5%8A%A1">Web服务</a></h2><p>在本节中，我们会展示一个微型服务器，这个服务器的功能是返回当前用户正在访问的URL。比如用户访问的是 <a target="_blank" rel="noopener" href="http://localhost:8000/hello">http://localhost:8000/hello</a> ，那么响应是 <code>URL.Path = &quot;hello&quot;</code>。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Server1 is a minimal "echo" server.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"log"</span>
    <span class="token string">"net/http"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span> <span class="token comment">// each request calls handler</span>
    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"localhost:8000"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// handler echoes the Path component of the request URL r.</span>
<span class="token keyword">func</span> <span class="token function">handler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"URL.Path = %q\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>让我们在后台运行这个服务程序。如果你的操作系统是Mac OS X或者Linux，那么在运行命令的末尾加上一个&amp;符号，即可让程序简单地跑在后台，windows下可以在另外一个命令行窗口去运行这个程序。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go run src/gopl.io/ch1/server1/main.go <span class="token operator">&amp;</span></code></pre>

<p>现在可以通过命令行来发送客户端请求了：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go build gopl.io/ch1/fetch
$ ./fetch http://localhost:8000
URL.Path <span class="token operator">=</span> <span class="token string">"/"</span>
$ ./fetch http://localhost:8000/help
URL.Path <span class="token operator">=</span> <span class="token string">"/help"</span></code></pre>

<p>还可以直接在浏览器里访问这个URL，然后得到返回结果，如图1.2：</p>
<p><img src="/2022/notes-of-gopl/ch1-02.png"></p>
<p>在这个服务的基础上叠加特性是很容易的。一种比较实用的修改是为访问的url添加某种状态。比如，下面这个版本输出了同样的内容，但是会对请求的次数进行计算，访问<code>/count</code>这个URL返回访问的次数。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Server2 is a minimal "echo" and counter server.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"log"</span>
    <span class="token string">"net/http"</span>
    <span class="token string">"sync"</span>
<span class="token punctuation">)</span>

<span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex
<span class="token keyword">var</span> count <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果请求pattern是以/结尾，那么所有以该url为前缀的url都会被这条规则匹配。</span>
    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/count"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span> <span class="token comment">// 对/count这个url的请求会调用到counter这个函数</span>
    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"localhost:8000"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// handler echoes the Path component of the requested URL.</span>
<span class="token keyword">func</span> <span class="token function">handler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    count<span class="token operator">++</span>
    mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"URL.Path = %q\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// counter echoes the number of calls so far.</span>
<span class="token keyword">func</span> <span class="token function">counter</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Count %d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span>
    mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>在这些代码的背后，服务器每一次接收请求处理时都会另起一个goroutine，这样服务器就可以同一时间处理多个请求。然而在并发情况下，假如真的有两个请求同一时刻去更新<code>count</code>，那么这个值可能并不会被正确地增加；这个程序可能会引发一个严重的bug：竞态条件（参见9.1）。为了避免这个问题，我们必须保证每次修改变量的最多只能有一个goroutine，这也就是代码里的<code>mu.Lock()</code>和<code>mu.Unlock()</code>调用将修改<code>count</code>的所有行为包在中间的目的。</p>
<p>下面是一个更为丰富的例子，handler函数会把请求的http头和请求的form数据都打印出来，这样可以使检查和调试这个服务更为方便：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// handler echoes the HTTP request.</span>
<span class="token keyword">func</span> <span class="token function">handler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"%s %s %s\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>Method<span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">,</span> r<span class="token punctuation">.</span>Proto<span class="token punctuation">)</span>
    <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> r<span class="token punctuation">.</span>Header <span class="token punctuation">&#123;</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Header[%q] = %q\n"</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Host = %q\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>Host<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"RemoteAddr = %q\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>RemoteAddr<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        log<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> r<span class="token punctuation">.</span>Form <span class="token punctuation">&#123;</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Form[%q] = %q\n"</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>我们用<code>http.Request</code>这个struct里的字段来输出下面这样的内容：</p>
<pre class="language-none"><code class="language-none">GET &#x2F;?q&#x3D;query HTTP&#x2F;1.1
Header[&quot;Accept-Encoding&quot;] &#x3D; [&quot;gzip, deflate, sdch&quot;]
Header[&quot;Accept-Language&quot;] &#x3D; [&quot;en-US,en;q&#x3D;0.8&quot;]
Header[&quot;Connection&quot;] &#x3D; [&quot;keep-alive&quot;]
Header[&quot;Accept&quot;] &#x3D; [&quot;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;...&quot;]
Header[&quot;User-Agent&quot;] &#x3D; [&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_7_5)...&quot;]
Host &#x3D; &quot;localhost:8000&quot;
RemoteAddr &#x3D; &quot;127.0.0.1:59911&quot;
Form[&quot;q&quot;] &#x3D; [&quot;query&quot;]</code></pre>

<p>可以看到这里的 <code>ParseForm</code> 被嵌套在了if语句中。Go语言允许这样的一个简单的语句结果作为局部的变量声明出现在 if 语句的最前面，这一点对错误处理很有用处。等同于下面这样写：</p>
<pre class="language-go" data-language="go"><code class="language-go">err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
    log<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>用 if 和<code>ParseForm</code>结合可以让代码更加简单，并且可以限制<code>err</code>变量的作用域。</p>
<p>在这些程序中，我们看到了很多不同的类型被输出到标准输出流中。比如前面的fetch程序，把HTTP的响应数据拷贝到了os.Stdout，lissajous程序里我们输出的是一个文件。fetchall程序则完全忽略到了HTTP的响应Body，只是计算了一下响应Body的大小，这个程序中把响应Body拷贝到了<code>io.Discard</code>。在本节的web服务器程序中则是用<code>fmt.Fprintf</code>直接写到了<code>http.ResponseWriter</code>中。</p>
<p>尽管三种具体的实现流程并不太一样，但它们都实现<code>io.Writer</code>接口，即当它们被调用需要一个标准流输出时都可以满足。</p>
<p>让我们简单地将这里的web服务器和之前写的 lissajous 函数结合起来，这样GIF动画可以被写到HTTP的客户端，而不是之前的标准输出流。只要在web服务器的代码里加入下面这几行。</p>
<pre class="language-go" data-language="go"><code class="language-go">handler <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">lissajous</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span></code></pre>

<p>或者另一种等价形式：</p>
<pre class="language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">lissajous</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre>

<p><code>HandleFunc</code> 函数的第二个参数是一个函数的字面值，也就是一个在使用时定义的匿名函数。</p>
<p>做完这些修改之后，在浏览器里访问 <a target="_blank" rel="noopener" href="http://localhost:8000/">http://localhost:8000</a> 。每次你载入这个页面都可以看到一个像图1.3那样的动画。</p>
<p><img src="/2022/notes-of-gopl/ch1-03.png" alt="img"></p>
<h2 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h2><p><strong>控制流：</strong> 这里是一个简单的switch的例子：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">switch</span> <span class="token function">coinflip</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">case</span> <span class="token string">"heads"</span><span class="token punctuation">:</span>
    heads<span class="token operator">++</span>
<span class="token keyword">case</span> <span class="token string">"tails"</span><span class="token punctuation">:</span>
    tails<span class="token operator">++</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"landed on edge!"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>在翻转硬币的时候，例子里的<code>coinflip</code>函数返回几种不同的结果，每一个case都会对应一个返回结果，这里需要注意，Go语言并不需要显式地在每一个case后写break，语言默认执行完case后的逻辑语句会自动退出。</p>
<p>Go语言里的switch还可以不带操作对象，可以直接罗列多种条件，像其它语言里面的多个if else一样。这种形式叫做 <strong>无tag switch</strong> (tagless switch)；这和<code>switch true</code>是等价的。switch不带操作对象时默认用true值代替，然后将每个case的表达式和<code>true</code>值进行比较。像for和if控制语句一样，switch也可以紧跟一个简短的变量声明，一个自增表达式、赋值语句，或者一个函数调用。下面是一个例子：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Signum</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">+</span><span class="token number">1</span>
    <span class="token keyword">default</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token keyword">case</span> x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>break和continue语句会改变控制流。和其它语言中的break和continue一样，break会中断当前的循环，并开始执行循环之后的内容，而continue会跳过当前循环，并开始执行下一次循环。这两个语句除了可以控制for循环，还可以用来控制switch和select语句。如果我们想跳过的是更外层的循环的话，我们可以在相应的位置加上label，这样break和continue就可以根据我们的想法来continue和break任意循环。这看起来甚至有点像goto语句的作用了。当然，一般程序员也不会用到这种操作。这两种行为更多地被用到机器生成的代码中。</p>
<p><strong>命名类型：</strong> 类型声明使得我们可以很方便地给一个特殊类型一个名字。因为struct类型声明通常非常地长，所以我们总要给这种struct取一个名字。本章中就有这样一个例子，二维点类型：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Point <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    X<span class="token punctuation">,</span> Y <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> p Point</code></pre>

<p><strong>指针：</strong> Go语言提供了指针。指针是一种直接存储了变量的内存地址的数据类型。在其它语言中，比如C语言，指针操作是完全不受约束的。在另外一些语言中，指针一般被处理为“引用”，除了到处传递这些指针之外，并不能对这些指针做太多事情。Go语言在这两种范围中取了一种平衡。指针是可见的内存地址，<code>&amp;</code>操作符可以返回一个变量的内存地址，并且<code>*</code>操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作。</p>
<p><strong>方法和接口：</strong> <strong>方法</strong>是和命名类型关联的一类函数。Go语言里比较特殊的是方法可以被关联到任意一种命名类型。<strong>接口</strong>是一种抽象类型，这种类型可以让我们以同样的方式来处理不同的固有类型，不用关心它们的具体实现，而只需要关注它们提供的方法。</p>
<p><strong>包（packages）：</strong> Go语言提供了一些很好用的package，并且这些package是可以扩展的。</p>
<p>在你开始写一个新程序之前，最好先去检查一下是不是已经有了现成的库可以帮助你更高效地完成这件事情。你可以在 <a target="_blank" rel="noopener" href="https://golang.org/pkg">https://golang.org/pkg</a> 和 <a target="_blank" rel="noopener" href="https://godoc.org/">https://godoc.org</a> 中找到标准库和社区写的package。godoc 这个工具可以让你直接在本地命令行阅读标准库的文档。比如下面这个例子。</p>
<pre class="language-none"><code class="language-none">$ go doc http.ListenAndServe
package http &#x2F;&#x2F; import &quot;net&#x2F;http&quot;
func ListenAndServe(addr string, handler Handler) error
    ListenAndServe listens on the TCP network address addr and then
    calls Serve with handler to handle requests on incoming connections.
...</code></pre>

<p><strong>注释：</strong> 我们之前已经提到过了在源文件的开头写的注释是这个源文件的文档。在每一个函数之前写一个说明函数行为的注释也是一个好习惯。这些惯例很重要，因为这些内容会被像<code>godoc</code>这样的工具检测到，并且在执行命令时显示这些注释。</p>
<p>多行注释可以用 <code>/* ... */</code> 来包裹，和其它大多数语言一样。在文件一开头的注释一般都是这种形式，或者一大段的解释性的注释文字也会被这符号包住，来避免每一行都需要加<code>//</code>。在注释中<code>//</code>和<code>/*</code>是没什么意义的，所以不要在注释中再嵌入注释。</p>
<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：<strong>一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。</strong> </p>
<ul>
<li><p>大写字母和小写字母是不同的：<code>heapSort</code>和<code>Heapsort</code>是两个不同的名字。</p>
</li>
<li><p>如果一个名字是在函数内部定义，那么它就只在函数内部有效。</p>
</li>
<li><p>如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。</p>
</li>
<li><p>包级名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是包级名字，且以大写字母开头的，那么它将是导出的，也就是说可以被外部的包访问，例如<code>fmt</code>包的<code>Printf</code>函数就是导出的，可以在<code>fmt</code>包外部访问。包本身的名字一般总是用小写字母。</p>
</li>
<li><p>在习惯上，Go语言程序员推荐使用 <strong>驼峰式</strong> 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。</p>
</li>
</ul>
<p>Go语言中类似if和switch的关键字有25个；关键字不能用于自定义名字，只能在特定语法结构中使用。</p>
<pre class="language-none"><code class="language-none">break      default       func     interface   select
case       defer         go       map         struct
chan       else          goto     package     switch
const      fallthrough   if       range       type
continue   for           import   return      var</code></pre>

<p>此外，还有大约30多个预定义的名字，比如<code>int</code>和<code>true</code>等，主要对应内建的常量、类型和函数。这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。</p>
<pre class="language-none"><code class="language-none">内建常量: true false iota nil

内建类型: int int8 int16 int32 int64
          uint uint8 uint16 uint32 uint64 uintptr
          float32 float64 complex128 complex64
          bool byte rune string error

内建函数: make len cap new append copy close delete
          complex real imag
          panic recover</code></pre>



<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：<code>var</code>、<code>const</code>、<code>type</code>和<code>func</code>，分别对应变量、常量、类型和函数实体对象的声明。</p>
<p>一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。</p>
<p>每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。</p>
<p>包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要，函数内部的名字则必须先声明之后才能使用。</p>
<p>例如，下面的例子中声明了一个常量、一个函数和两个变量：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Boiling prints the boiling point of water.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">const</span> boilingF <span class="token operator">=</span> <span class="token number">212.0</span>  <span class="token comment">// 包级变量</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> f <span class="token operator">=</span> boilingF  <span class="token comment">// 局部变量</span>
    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>f <span class="token operator">-</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5</span> <span class="token operator">/</span> <span class="token number">9</span>  <span class="token comment">// 局部变量</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"boiling point = %g°F or %g°C\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">,</span> c<span class="token punctuation">)</span>
    <span class="token comment">// Output:</span>
    <span class="token comment">// boiling point = 212°F or 100°C</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问。相比之下，局部声明的名字就只能在函数内部很小的范围被访问。</p>
<p>一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。如果函数没有返回值，那么返回值列表是省略的。执行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>var声明语句用于声明变量，并设置变量初始值。其中<code>类型</code>或<code>= 表达式</code>两个部分可以省略其中的一个。变量声明的一般语法如下：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> 变量名字 类型 <span class="token operator">=</span> 表达式  <span class="token comment">//创建一个特定类型的变量，并设置变量的初始值。</span>
<span class="token keyword">var</span> 变量名字 <span class="token operator">=</span> 表达式 <span class="token comment">// 省略类型信息，将根据初始化表达式来推导变量的类型信息。</span>
<span class="token keyword">var</span> 变量名字 类型 <span class="token comment">// 初始化表达式被省略，那么将用零值初始化该变量。</span></code></pre>

<p>也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k <span class="token builtin">int</span>                 <span class="token comment">// int, int, int</span>
<span class="token keyword">var</span> b<span class="token punctuation">,</span> f<span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">2.3</span><span class="token punctuation">,</span> <span class="token string">"four"</span> <span class="token comment">// bool, float64, string</span></code></pre>

<p>一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> f<span class="token punctuation">,</span> err <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment">// os.Open returns a file and an error</span></code></pre>

<p>数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan 和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s <span class="token builtin">string</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token keyword">var</span> i <span class="token builtin">int</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token keyword">var</span> n <span class="token builtin">float64</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token keyword">var</span> b <span class="token builtin">bool</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token keyword">var</span> sli <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>sli <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token keyword">var</span> p <span class="token operator">*</span><span class="token builtin">int</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token keyword">var</span> c <span class="token keyword">chan</span> <span class="token builtin">string</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token keyword">var</span> f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token keyword">var</span> m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token keyword">var</span> arr <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">// [0 0 0]</span>

<span class="token keyword">type</span> T <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	name <span class="token builtin">string</span>
	age  <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> t T
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token comment">//&#123; 0&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>age <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// true</span></code></pre>

<p>零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态。</p>
<h3 id="简短变量声明"><a href="#简短变量声明" class="headerlink" title="简短变量声明"></a>简短变量声明</h3><p>在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 :&#x3D; 表达式”形式声明变量，变量的类型根据表达式来自动推导。</p>
<pre class="language-go" data-language="go"><code class="language-go">anim <span class="token operator">:=</span> gif<span class="token punctuation">.</span>GIF<span class="token punctuation">&#123;</span>LoopCount<span class="token punctuation">:</span> nframes<span class="token punctuation">&#125;</span>
freq <span class="token operator">:=</span> rand<span class="token punctuation">.</span><span class="token function">Float64</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">3.0</span>
t <span class="token operator">:=</span> <span class="token number">0.0</span></code></pre>

<p>var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p>
<pre class="language-go" data-language="go"><code class="language-go">i <span class="token operator">:=</span> <span class="token number">100</span>                  <span class="token comment">// an int</span>
<span class="token keyword">var</span> boiling <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">100</span> <span class="token comment">// a float64</span>
<span class="token keyword">var</span> names <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token keyword">var</span> err <span class="token builtin">error</span>
<span class="token keyword">var</span> p Point</code></pre>

<p>和var形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：</p>
<pre class="language-go" data-language="go"><code class="language-go">i<span class="token punctuation">,</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span></code></pre>

<p>但是这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用，比如for语句的循环的初始化语句部分。</p>
<p>请记住<code>:=</code>是一个变量声明语句，而<code>=</code>是一个变量赋值操作。也不要混淆多个变量的声明和元组的多重赋值，后者是将右边各个表达式的值赋值给左边对应位置的各个变量：</p>
<pre class="language-go" data-language="go"><code class="language-go">i<span class="token punctuation">,</span> j <span class="token operator">=</span> j<span class="token punctuation">,</span> i <span class="token comment">// 交换 i 和 j 的值</span></code></pre>

<p>和普通var形式的变量声明语句一样，简短变量声明语句也可以用函数的返回值来声明和初始化变量，像下面的<code>os.Open</code>函数调用将返回两个值：</p>
<pre class="language-go" data-language="go"><code class="language-go">f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> err
<span class="token punctuation">&#125;</span>
<span class="token comment">// ...use f...</span>
f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>

<p><strong>注意：简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的作用域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。</strong> 在下面的代码中，第一个语句声明了in和err两个变量。在第二个语句只声明了out一个变量，然后对已经声明的err进行了赋值操作。</p>
<pre class="language-go" data-language="go"><code class="language-go">in<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>infile<span class="token punctuation">)</span>
<span class="token comment">// ...</span>
out<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>outfile<span class="token punctuation">)</span></code></pre>

<p>简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：</p>
<pre class="language-go" data-language="go"><code class="language-go">f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>infile<span class="token punctuation">)</span>
<span class="token comment">// ...</span>
f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>outfile<span class="token punctuation">)</span> <span class="token comment">// compile error: no new variables</span></code></pre>

<p>解决的方法是第二个简短变量声明语句改用普通的多重赋值语句：</p>
<pre class="language-go" data-language="go"><code class="language-go">f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>infile<span class="token punctuation">)</span>
<span class="token comment">// ...</span>
f<span class="token punctuation">,</span> err <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>outfile<span class="token punctuation">)</span></code></pre>

<p>简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>一个变量对应一个保存了变量对应类型值的内存空间。普通变量在声明语句创建时被绑定到一个变量名，比如叫<code>x</code>的变量。</p>
<p>一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。</p>
<p>如果用<code>var x int</code>声明语句声明一个<code>x</code>变量，那么<code>&amp;x</code>表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是<code>*int</code>，指针被称之为“指向int类型的指针”。如果指针名字为<code>p</code>，那么可以说“<code>p</code>指针指向变量<code>x</code>”，或者说“<code>p</code>指针保存了x变量的内存地址”。同时<code>*p</code>表达式对应<code>p</code>指针指向的变量的值。一般<code>*p</code>表达式读取指针指向的变量的值，这里为int类型的值，同时因为<code>*p</code>对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。</p>
<pre class="language-go" data-language="go"><code class="language-go">x <span class="token operator">:=</span> <span class="token number">1</span>
p <span class="token operator">:=</span> <span class="token operator">&amp;</span>x         <span class="token comment">// p, of type *int, points to x</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token comment">// "1"</span>
<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">2</span>          <span class="token comment">// equivalent to x = 2</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment">// "2"</span></code></pre>

<p>对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
		name <span class="token builtin">string</span>
		age  <span class="token builtin">int</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">var</span> p Person <span class="token operator">=</span> Person<span class="token punctuation">&#123;</span>name<span class="token punctuation">:</span> <span class="token string">"Mike"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">,</span> p<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// Mike 12</span>
	
	<span class="token keyword">var</span> name <span class="token operator">*</span><span class="token builtin">string</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">.</span>name
	<span class="token keyword">var</span> age <span class="token operator">*</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">.</span>age
	<span class="token operator">*</span>name <span class="token operator">=</span> <span class="token string">"Micheal"</span>
	<span class="token operator">*</span>age <span class="token operator">=</span> <span class="token number">18</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>  <span class="token comment">// &#123;Micheal 18&#125;</span></code></pre>

<p>任何类型的指针的零值都是<code>nil</code>。如果p指向某个有效变量，那么<code>p != nil</code>测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是<code>nil</code>时才相等。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x<span class="token punctuation">,</span> y <span class="token builtin">int</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x <span class="token operator">==</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>x <span class="token operator">==</span> <span class="token operator">&amp;</span>y<span class="token punctuation">,</span> <span class="token operator">&amp;</span>x <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// "true false false"</span></code></pre>

<p>在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">var p &#x3D; f()

func f() *int &#123;
    v :&#x3D; 1
    return &amp;v
&#125;</code></pre>

<p>每次调用f函数都将返回不同的结果：</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "false"</span></code></pre>

<p>因为指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">incr</span><span class="token punctuation">(</span>p <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">*</span>p<span class="token operator">++</span> <span class="token comment">// 非常重要：只是增加p指向的变量的值，并不改变p指针！！！</span>
    <span class="token keyword">return</span> <span class="token operator">*</span>p
<span class="token punctuation">&#125;</span>

v <span class="token operator">:=</span> <span class="token number">1</span>
<span class="token function">incr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">)</span>              <span class="token comment">// side effect: v is now 2</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">incr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "3" (and v is 3)</span></code></pre>

<p>指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Echo4 prints its command-line arguments.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"flag"</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"strings"</span>
<span class="token punctuation">)</span>

<span class="token comment">// flag.Bool和flag.String函数的参数依次为命令行参数、默认值、参数描述信息</span>
<span class="token keyword">var</span> n <span class="token operator">=</span> flag<span class="token punctuation">.</span><span class="token function">Bool</span><span class="token punctuation">(</span><span class="token string">"n"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"omit trailing newline"</span><span class="token punctuation">)</span> <span class="token comment">// 变量n是一个bool类型的指针，指向命令行标志参数n的变量</span>
<span class="token keyword">var</span> sep <span class="token operator">=</span> flag<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token string">"s"</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">"separator"</span><span class="token punctuation">)</span> <span class="token comment">// 变量sep为一个字符串类型的指针，指向命令行标志参数sep的变量</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>flag<span class="token punctuation">.</span><span class="token function">Args</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>sep<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token operator">*</span>n <span class="token punctuation">&#123;</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>当程序运行时，必须在使用标志参数对应的变量之前先调用<code>flag.Parse</code>函数，用于更新每个标志参数对应变量的值（之前是默认值）。对于非标志参数的普通命令行参数可以通过调用<code>flag.Args()</code>函数来访问，返回值对应一个字符串类型的slice。如果在<code>flag.Parse</code>函数解析命令行参数时遇到错误，默认将打印相关的提示信息，然后调用<code>os.Exit(2)</code>终止程序。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">$ go build gopl.io/ch2/echo4
$ ./echo4 a <span class="token function">bc</span> def
a <span class="token function">bc</span> def
$ ./echo4 <span class="token parameter variable">-s</span> / a <span class="token function">bc</span> def
a/bc/def
$ ./echo4 <span class="token parameter variable">-n</span> a <span class="token function">bc</span> def
a <span class="token function">bc</span> def$
$ ./echo4 <span class="token parameter variable">-help</span>
Usage of ./echo4:
  <span class="token parameter variable">-n</span>    omit trailing newline
  <span class="token parameter variable">-s</span> string
        separator <span class="token punctuation">(</span>default <span class="token string">" "</span><span class="token punctuation">)</span></code></pre>



<h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><p>另一个创建变量的方法是调用内建的new函数。表达式<code>new(T)</code>将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>。</p>
<pre class="language-go" data-language="go"><code class="language-go">p <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>   <span class="token comment">// p, *int 类型, 指向匿名的 int 变量</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token comment">// "0"</span>
<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">2</span>          <span class="token comment">// 设置 int 匿名变量的值为 2</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token comment">// "2"</span></code></pre>

<p>用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用<code>new(T)</code>。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。</p>
<p>下面的两个newInt函数有着相同的行为：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">newInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">newInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> dummy <span class="token builtin">int</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>dummy
<span class="token punctuation">&#125;</span></code></pre>

<p>每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">p :&#x3D; new(int)
q :&#x3D; new(int)
fmt.Println(p &#x3D;&#x3D; q) &#x2F;&#x2F; &quot;false&quot;</code></pre>

<p>当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是0，例如<code>struct&#123;&#125;</code>和<code>[0]int</code>，有可能有相同的地址（依赖具体的语言实现）（译注：请谨慎使用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查看<code>runtime.SetFinalizer</code>函数相关文档）。</p>
<p>new函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活。</p>
<p>由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。例如下面的例子：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">func delta(old, new int) int &#123; return new - old &#125;</code></pre>

<p>由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的。</p>
<h3 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h3><p>变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在<em>包一级声明</em>的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，每次从创建一个<em>局部变量</em>的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。</p>
<p>那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。</p>
<p>因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</p>
<p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> global <span class="token operator">*</span><span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> x <span class="token builtin">int</span>
    x <span class="token operator">=</span> <span class="token number">1</span>
    global <span class="token operator">=</span> <span class="token operator">&amp;</span>x
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    y <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>
    <span class="token operator">*</span>y <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；<strong>用Go语言的术语说，这个x局部变量从函数f中逃逸了。</strong> 相反，当g函数返回时，变量<code>*y</code>将是不可达的，也就是说可以马上被回收的。因此，<code>*y</code>并没有从函数g中逃逸，编译器可以选择在栈上分配<code>*y</code>的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</p>
<p>Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>使用赋值语句可以更新一个变量的值：</p>
<pre class="language-go" data-language="go"><code class="language-go">x <span class="token operator">=</span> <span class="token number">1</span>                       <span class="token comment">// 命名变量的赋值</span>
<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token boolean">true</span>                   <span class="token comment">// 通过指针间接赋值</span>
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"bob"</span>         <span class="token comment">// 结构体字段赋值</span>
count<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">*</span> scale <span class="token comment">// 数组、slice或map的元素赋值</span></code></pre>

<p>定的二元算术运算符和赋值语句的复合操作有一个简洁形式，例如上面最后的语句可以重写为：</p>
<pre class="language-go" data-language="go"><code class="language-go">count<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">*=</span> scale</code></pre>

<p>数值变量也可以支持<code>++</code>递增和<code>--</code>递减语句：</p>
<pre class="language-go" data-language="go"><code class="language-go">v <span class="token operator">:=</span> <span class="token number">1</span>
v<span class="token operator">++</span>    <span class="token comment">// 等价方式 v = v + 1；v 变成 2</span>
v<span class="token operator">--</span>    <span class="token comment">// 等价方式 v = v - 1；v 变成 1</span></code></pre>

<blockquote>
<p>译注：自增和自减是语句，而不是表达式，因此<code>x = i++</code>之类的表达式是错误的。</p>
</blockquote>
<h3 id="元组赋值"><a href="#元组赋值" class="headerlink" title="元组赋值"></a>元组赋值</h3><p>元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。<strong>这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助</strong>，例如我们可以这样交换两个变量的值：</p>
<pre class="language-go" data-language="go"><code class="language-go">x<span class="token punctuation">,</span> y <span class="token operator">=</span> y<span class="token punctuation">,</span> x

a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span></code></pre>

<p>或者是计算两个整数值的的最大公约数（GCD, greatest common divisor）：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">gcd</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> y <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        x<span class="token punctuation">,</span> y <span class="token operator">=</span> y<span class="token punctuation">,</span> x<span class="token operator">%</span>y
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> x
<span class="token punctuation">&#125;</span></code></pre>

<p>或者是计算斐波纳契数列（Fibonacci）的第N个数：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    x<span class="token punctuation">,</span> y <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
        x<span class="token punctuation">,</span> y <span class="token operator">=</span> y<span class="token punctuation">,</span> x<span class="token operator">+</span>y
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> x
<span class="token punctuation">&#125;</span></code></pre>

<p>元组赋值也可以使一系列琐碎赋值更加紧凑（译注: 特别是在for循环的初始化部分），</p>
<pre class="language-go" data-language="go"><code class="language-go">i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span></code></pre>

<p>有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋值右边的表达式中时（译注：右边不能再有其它表达式），左边变量的数目必须和右边一致。</p>
<pre class="language-go" data-language="go"><code class="language-go">f<span class="token punctuation">,</span> err <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"foo.txt"</span><span class="token punctuation">)</span> <span class="token comment">// function call returns two values</span></code></pre>

<p>通常，这类函数会用额外的返回值来表达某种错误类型，例如<code>os.Open</code>是用额外的返回值返回一个error类型的错误，还有一些是用来返回布尔值，通常被称为<code>ok</code>。</p>
<p>和变量声明一样，我们可以用下划线空白标识符<code>_</code>来丢弃不需要的值。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> src<span class="token punctuation">)</span> <span class="token comment">// 丢弃字节数</span>
<span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span>              <span class="token comment">// 只检测类型，忽略具体值</span></code></pre>



<h3 id="可赋值性"><a href="#可赋值性" class="headerlink" title="可赋值性"></a>可赋值性</h3><p>赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。例如下面的语句：</p>
<pre class="language-go" data-language="go"><code class="language-go">medals <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"gold"</span><span class="token punctuation">,</span> <span class="token string">"silver"</span><span class="token punctuation">,</span> <span class="token string">"bronze"</span><span class="token punctuation">&#125;</span></code></pre>

<p>隐式地对slice的每个元素进行赋值操作，类似这样写的行为：</p>
<pre class="language-go" data-language="go"><code class="language-go">medals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"gold"</span>
medals<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"silver"</span>
medals<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"bronze"</span></code></pre>

<p>map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。</p>
<p>不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。</p>
<p>可赋值性的规则对于不同类型有着不同要求，对每个新类型特殊的地方我们会专门解释。对于目前我们已经讨论过的类型，它的规则是简单的：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。<em>常量</em>则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。</p>
<p>对于两个值是否可以用<code>==</code>或<code>!=</code>进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。和前面一样，我们会对每个新类型比较特殊的地方做专门的解释。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。</p>
<p><strong>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> 类型名字 底层类型</code></pre>

<p>类型声明语句一般出现在包一级，因此如果新创建的<strong>类型名字的首字符大写，则在包外部也可以使用</strong>。</p>
<p>为了说明类型声明，我们将不同温度单位分别定义为不同的类型：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; Package tempconv performs Celsius and Fahrenheit temperature computations.
package tempconv

import &quot;fmt&quot;

type Celsius float64    &#x2F;&#x2F; 摄氏温度
type Fahrenheit float64 &#x2F;&#x2F; 华氏温度

const (
    AbsoluteZeroC Celsius &#x3D; -273.15 &#x2F;&#x2F; 绝对零度
    FreezingC     Celsius &#x3D; 0       &#x2F;&#x2F; 结冰点温度
    BoilingC      Celsius &#x3D; 100     &#x2F;&#x2F; 沸水温度
)

func CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9&#x2F;5 + 32) &#125;

func FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32) * 5 &#x2F; 9) &#125;</code></pre>

<p>我们在这个包声明了两种类型：Celsius和Fahrenheit分别对应不同的温度单位。它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；因此需要一个类似Celsius(t)或Fahrenheit(t)形式的显式转型操作才能将float64转为对应的类型。Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。类型转换不会改变值本身，但是会使它们的语义发生变化。另一方面，CToF和FToC两个函数则是对不同温度单位下的温度进行换算，它们会返回不同的值。</p>
<p><strong>对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如<code>(*int)(0)</code>）。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型，但是一般没有这个必要。</strong></p>
<p><strong>数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的。这类转换可能改变值的表现。</strong>例如，将一个浮点数转为整数将丢弃小数部分，将一个字符串转为<code>[]byte</code>类型的slice将拷贝一个字符串数据的副本。在任何情况下，运行时不会发生转换失败的错误（译注: 错误只会发生在编译阶段）。</p>
<p>底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。这意味着，Celsius和Fahrenheit类型的算术运算行为和底层的float64类型是一样的，正如我们所期望的那样。</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%g\n"</span><span class="token punctuation">,</span> BoilingC<span class="token operator">-</span>FreezingC<span class="token punctuation">)</span> <span class="token comment">// "100" °C</span>
boilingF <span class="token operator">:=</span> <span class="token function">CToF</span><span class="token punctuation">(</span>BoilingC<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%g\n"</span><span class="token punctuation">,</span> boilingF<span class="token operator">-</span><span class="token function">CToF</span><span class="token punctuation">(</span>FreezingC<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "180" °F</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%g\n"</span><span class="token punctuation">,</span> boilingF<span class="token operator">-</span>FreezingC<span class="token punctuation">)</span>       <span class="token comment">// compile error: type mismatch</span></code></pre>

<p>比较运算符<code>==</code>和<code>&lt;</code>也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但是<strong>如果两个值有着不同的类型，则不能直接进行比较</strong>：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> c Celsius
<span class="token keyword">var</span> f Fahrenheit
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>          <span class="token comment">// "true"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>f <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>          <span class="token comment">// "true"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> f<span class="token punctuation">)</span>          <span class="token comment">// compile error: type mismatch</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token function">Celsius</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "true"!</span></code></pre>

<p>注意最后那个语句。尽管看起来像函数调用，但是<code>Celsius(f)</code>是类型转换操作，它并不会改变值，仅仅是改变值的类型而已。测试为真的原因是因为c和g都是零值。</p>
<p>一个命名的类型可以提供书写方便，特别是可以避免一遍又一遍地书写复杂类型（译注：例如用匿名的结构体定义变量）。虽然对于像float64这种简单的底层类型没有简洁很多，但是如果是复杂的类型将会简洁很多，特别是我们即将讨论的结构体类型。</p>
<p>命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。</p>
<p>下面的声明语句，Celsius类型的参数c出现在了函数名的前面，表示声明的是Celsius类型的一个名叫String的方法，该方法返回该类型对象c带着°C温度单位的字符串：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c Celsius<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%g°C"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span></code></pre>

<h2 id="包和文件"><a href="#包和文件" class="headerlink" title="包和文件"></a>包和文件</h2><p>Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。一个包的源代码保存在一个或多个以<code>.go</code>为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；例如包<code>gopl.io/ch1/helloworld</code>对应的目录路径是<code>$GOPATH/src/gopl.io/ch1/helloworld</code>。</p>
<p>每个包都对应一个独立的名字空间。例如，在<code>image</code>包中的<code>Decode</code>函数和在<code>unicode/utf16</code>包中的 <code>Decode</code>函数是不同的。要在外部引用该函数，必须显式使用<code>image.Decode</code>或<code>utf16.Decode</code>形式访问。</p>
<p>包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。</p>
<p>让我们创建一个名为<code>gopl.io/ch2/tempconv</code>的包，包代码存储在两个源文件中，用来演示如何在一个源文件声明然后在其他的源文件访问。我们把变量的声明、对应的常量，还有方法都放到tempconv.go源文件中：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; Package tempconv performs Celsius and Fahrenheit conversions.
package tempconv

import &quot;fmt&quot;

type Celsius float64
type Fahrenheit float64

const (
    AbsoluteZeroC Celsius &#x3D; -273.15
    FreezingC     Celsius &#x3D; 0
    BoilingC      Celsius &#x3D; 100
)

func (c Celsius) String() string    &#123; return fmt.Sprintf(&quot;%g°C&quot;, c) &#125;
func (f Fahrenheit) String() string &#123; return fmt.Sprintf(&quot;%g°F&quot;, f) &#125;</code></pre>

<p>转换函数则放在另一个conv.go源文件中：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> tempconv

<span class="token comment">// CToF converts a Celsius temperature to Fahrenheit.</span>
<span class="token keyword">func</span> <span class="token function">CToF</span><span class="token punctuation">(</span>c Celsius<span class="token punctuation">)</span> Fahrenheit <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">Fahrenheit</span><span class="token punctuation">(</span>c<span class="token operator">*</span><span class="token number">9</span><span class="token operator">/</span><span class="token number">5</span> <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>

<span class="token comment">// FToC converts a Fahrenheit temperature to Celsius.</span>
<span class="token keyword">func</span> <span class="token function">FToC</span><span class="token punctuation">(</span>f Fahrenheit<span class="token punctuation">)</span> Celsius <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">Celsius</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">-</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5</span> <span class="token operator">/</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span></code></pre>



<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>在Go语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似<code>gopl.io/ch2/tempconv</code>的字符串对应包的导入路径。Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时，一个导入路径代表一个目录中的一个或多个Go源文件。</p>
<p>除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。导入语句将导入的包绑定到一个短小的名字，然后通过该短小的名字就可以引用包中导出的全部内容。</p>
<p>按照惯例，一个包的名字和包的导入路径的最后一个字段相同，例如<code>gopl.io/ch2/tempconv</code>包的名字一般是<code>tempconv</code>。在默认情况下，导入的包绑定到tempconv名字（译注：指包声明语句指定的名字），但是我们也可以绑定到另一个名称，以避免名字冲突。</p>
<p>如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。</p>
<p>要使用<code>gopl.io/ch2/tempconv</code>包，需要先导入：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Cf converts its numeric argument to Celsius and Fahrenheit.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>
    <span class="token string">"strconv"</span>

    <span class="token string">"gopl.io/ch2/tempconv"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> arg <span class="token operator">:=</span> <span class="token keyword">range</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
        t<span class="token punctuation">,</span> err <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">ParseFloat</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
            fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"cf: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
            os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
        f <span class="token operator">:=</span> tempconv<span class="token punctuation">.</span><span class="token function">Fahrenheit</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
        c <span class="token operator">:=</span> tempconv<span class="token punctuation">.</span><span class="token function">Celsius</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s = %s, %s = %s\n"</span><span class="token punctuation">,</span>
            f<span class="token punctuation">,</span> tempconv<span class="token punctuation">.</span><span class="token function">FToC</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> tempconv<span class="token punctuation">.</span><span class="token function">CToF</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>



<h3 id="包的初始化"><a href="#包的初始化" class="headerlink" title="包的初始化"></a>包的初始化</h3><p>包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">var a &#x3D; b + c &#x2F;&#x2F; a 第三个初始化, 为 3
var b &#x3D; f()   &#x2F;&#x2F; b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c &#x3D; 1     &#x2F;&#x2F; c 第一个初始化, 为 1

func f() int &#123; return c + 1 &#125;</code></pre>

<p>如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。</p>
<p>对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">func init() &#123; &#x2F;* ... *&#x2F; &#125;</code></pre>

<p>这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。</p>
<p>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。</p>
<p>下面的代码定义了一个PopCount函数，用于返回一个数字中含二进制1bit的个数。它使用init初始化函数来生成辅助表格pc，pc表格用于处理每个8bit宽度的数字含二进制的1bit的bit个数，这样的话在处理64bit宽度的数字时就没有必要循环64次，只需要8次查表就可以了。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> popcount

<span class="token comment">// pc[i] is the population count of i.</span>
<span class="token keyword">var</span> pc <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token builtin">byte</span>

<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> pc <span class="token punctuation">&#123;</span>
        pc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pc<span class="token punctuation">[</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">byte</span><span class="token punctuation">(</span>i<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// PopCount returns the population count (number of set bits) of x.</span>
<span class="token keyword">func</span> <span class="token function">PopCount</span><span class="token punctuation">(</span>x <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">int</span><span class="token punctuation">(</span>pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span>
        pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span>
        pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span>
        pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span>
        pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span>
        pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span>
        pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span>
        pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">7</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>译注：对于pc这类需要复杂处理的初始化，可以通过将初始化逻辑包装为一个匿名函数处理，像下面这样：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// pc[i] is the population count of i.</span>
<span class="token keyword">var</span> pc <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>pc <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> pc <span class="token punctuation">&#123;</span>
        pc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pc<span class="token punctuation">[</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">byte</span><span class="token punctuation">(</span>i<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>

<p>要注意的是在init函数中，range循环只使用了索引，省略了没有用到的值部分。循环也可以这样写：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token keyword">range</span> pc <span class="token punctuation">&#123;</span></code></pre>



<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。<strong>声明语句的 <em>作用域</em> 是指源代码中可以有效使用这个名字的范围。</strong></p>
<p>不要将作用域和生命周期混为一谈。声明语句的<strong>作用域</strong>对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的<strong>生命周期</strong>是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。</p>
<p><strong>句法块</strong>是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。<strong>句法块内部声明的名字是无法被外部块访问的。</strong>这个块决定了内部声明的名字的作用域范围。我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为<strong>词法块</strong>。对全局的源代码来说，存在一个整体的词法块，称为全局词法块；对于每个包；每个for、if和switch语句，也都有对应词法块；每个switch或select的分支也有独立的词法块；当然也包括显式书写的词法块（花括弧包含的语句）。</p>
<p>声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。还有许多声明语句，比如<code>tempconv.CToF</code>函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。</p>
<p>控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。</p>
<p>一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系。例如，你可以声明一个局部变量，和包级的变量同名。或者是像2.3.3节的例子那样，你可以将一个函数参数的名字声明为new，虽然内置的new是全局作用域的。但是物极必反，如果滥用不同词法域可重名的特性的话，可能导致程序很难阅读。</p>
<p>当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token string">"g"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    f <span class="token operator">:=</span> <span class="token string">"f"</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token comment">// "f"; local var f shadows package-level func f</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span> <span class="token comment">// "g"; package-level var</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token comment">// compile error: undefined: h</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>在函数中词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明。还有许多语法块是if或for等控制流语句构造的。下面的代码有三个不同的变量x，因为它们是定义在不同的词法域（这个例子只是为了演示作用域规则，但不是好的编程风格）。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">func main() &#123;
    x :&#x3D; &quot;hello!&quot;
    for i :&#x3D; 0; i &lt; len(x); i++ &#123;
        x :&#x3D; x[i]
        if x !&#x3D; &#39;!&#39; &#123;
            x :&#x3D; x + &#39;A&#39; - &#39;a&#39;
            fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (one letter per iteration)
        &#125;
    &#125;
&#125;</code></pre>

<p>在<code>x[i]</code>和<code>x + &#39;A&#39; - &#39;a&#39;</code>声明语句的初始化的表达式中都引用了外部作用域声明的x变量，稍后我们会解释这个。（注意，后面的表达式与<code>unicode.ToUpper</code>并不等价。）</p>
<p>正如上面例子所示，并不是所有的词法域都显式地对应到由花括弧包含的语句；还有一些隐含的规则。上面的for语句创建了两个词法域：花括弧包含的是显式的部分，是for的循环体部分词法域，另外一个隐式的部分则是循环的初始化部分，比如用于迭代变量i的初始化。隐式的词法域部分的作用域还包含条件测试部分和循环后的迭代部分（<code>i++</code>），当然也包含循环体词法域。</p>
<p>下面的例子同样有三个不同的x变量，每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化词法域，一个在for循环体词法域；只有两个块是显式创建的：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">func main() &#123;
    x :&#x3D; &quot;hello&quot;
    for _, x :&#x3D; range x &#123;
        x :&#x3D; x + &#39;A&#39; - &#39;a&#39;
        fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (one letter per iteration)
    &#125;
&#125;</code></pre>

<p>和for循环类似，if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域。下面的if-else测试链演示了x和y的有效作用域范围：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">if x :&#x3D; f(); x &#x3D;&#x3D; 0 &#123;
    fmt.Println(x)
&#125; else if y :&#x3D; g(x); x &#x3D;&#x3D; y &#123;
    fmt.Println(x, y)
&#125; else &#123;
    fmt.Println(x, y)
&#125;
fmt.Println(x, y) &#x2F;&#x2F; compile error: x and y are not visible here</code></pre>

<p>第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问。switch语句的每个分支也有类似的词法域规则：条件部分为一个隐式词法域，然后是每个分支的词法域。</p>
<p>在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。</p>
<p>在这个程序中：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">if f, err :&#x3D; os.Open(fname); err !&#x3D; nil &#123; &#x2F;&#x2F; compile error: unused: f
    return err
&#125;
f.ReadByte() &#x2F;&#x2F; compile error: undefined f
f.Close()    &#x2F;&#x2F; compile error: undefined f</code></pre>

<p>变量f的作用域只在if语句内，因此后面的语句将无法引入它，这将导致编译错误。你可能会收到一个局部变量f没有声明的错误提示，具体错误信息依赖编译器的实现。</p>
<p>通常需要在if之前声明变量，这样可以确保后面的语句依然可以访问变量：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">f, err :&#x3D; os.Open(fname)
if err !&#x3D; nil &#123;
    return err
&#125;
f.ReadByte()
f.Close()</code></pre>

<p>你可能会考虑通过将ReadByte和Close移动到if的else块来解决这个问题：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">if f, err :&#x3D; os.Open(fname); err !&#x3D; nil &#123;
    return err
&#125; else &#123;
    &#x2F;&#x2F; f and err are visible here too
    f.ReadByte()
    f.Close()
&#125;</code></pre>

<p>但这不是Go语言推荐的做法，Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进。</p>
<p>要特别注意短变量声明语句的作用域范围，考虑下面的程序，它的目的是获取当前的工作目录然后保存到一个包级的变量中。这本来可以通过直接调用<code>os.Getwd</code>完成，但是将这个从主逻辑中分离出来可能会更好，特别是在需要处理错误的时候。函数<code>log.Fatalf</code>用于打印日志信息，然后调用<code>os.Exit(1)</code>终止程序。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">var cwd string

func init() &#123;
    cwd, err :&#x3D; os.Getwd() &#x2F;&#x2F; compile error: unused: cwd
    if err !&#x3D; nil &#123;
        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)
    &#125;
&#125;</code></pre>

<p>虽然cwd在外部已经声明过，但是<code>:=</code>语句还是将cwd和err重新声明为新的局部变量。因为内部声明的cwd将屏蔽外部的声明，因此上面的代码并不会正确更新包级声明的cwd变量。</p>
<p>由于当前的编译器会检测到局部声明的cwd并没有使用，然后报告这可能是一个错误，但是这种检测并不可靠。因为一些小的代码变更，例如增加一个局部cwd的打印语句，就可能导致这种检测失效。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">var cwd string

func init() &#123;
    cwd, err :&#x3D; os.Getwd() &#x2F;&#x2F; NOTE: wrong!
    if err !&#x3D; nil &#123;
        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)
    &#125;
    log.Printf(&quot;Working directory &#x3D; %s&quot;, cwd)
&#125;</code></pre>

<p>全局的cwd变量依然是没有被正确初始化的，而且看似正常的日志输出更是让这个BUG更加隐晦。</p>
<p><strong>有许多方式可以避免出现类似潜在的问题。最直接的方法是通过单独声明err变量，来避免使用<code>:=</code>的简短声明方式：</strong></p>
<pre class="language-Go" data-language="Go"><code class="language-Go">var cwd string

func init() &#123;
    var err error
    cwd, err &#x3D; os.Getwd()
    if err !&#x3D; nil &#123;
        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)
    &#125;
&#125;</code></pre>



<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>Go语言同时提供了有符号和无符号类型的整数运算。这里有<code>int8</code>、<code>int16</code>、<code>int32</code>和<code>int64</code>四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是<code>uint8</code>、<code>uint16</code>、<code>uint32</code>和<code>uint64</code>四种无符号整数类型。</p>
<p>这里还有两种一般对应特定CPU平台机器字大小的有符号和无符号整数<code>int</code>和<code>uint</code>；其中<code>int</code>是应用最广泛的数值类型。这两种类型都有同样的大小，32或64bit。不同的编译器即使在相同的硬件平台上可能产生不同的大小。</p>
<p>Unicode字符<code>rune</code>类型是和<code>int32</code>等价的类型，通常用于表示一个Unicode码点。同样<code>byte</code>也是<code>uint8</code>类型的等价类型，<code>byte</code>类型一般用于强调数值是一个原始的数据而不是一个小的整数。</p>
<p>最后，还有一种无符号的整数类型<code>uintptr</code>，没有指定具体的bit大小但是足以容纳指针。<code>uintptr</code>类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。</p>
<p>下面是Go语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列：</p>
<pre class="language-none"><code class="language-none">*      &#x2F;      %      &lt;&lt;       &gt;&gt;     &amp;       &amp;^
+      -      |      ^
&#x3D;&#x3D;     !&#x3D;     &lt;      &lt;&#x3D;       &gt;      &gt;&#x3D;
&amp;&amp;
||</code></pre>

<p>算术运算符<code>+</code>、<code>-</code>、<code>*</code>和<code>/</code>可以适用于整数、浮点数和复数，但是取模运算符%仅用于整数间的运算。对于不同编程语言，%取模运算的行为可能并不相同。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此<code>-5%3</code>和<code>-5%-3</code>结果都是-2。除法运算符<code>/</code>的行为则依赖于操作数是否全为整数，比如<code>5.0/4.0</code>的结果是1.25，但是5&#x2F;4的结果是1，因为整数除法会向着0方向截断余数。</p>
<p>两个相同的整数类型可以使用下面的二元比较运算符进行比较；比较表达式的结果是布尔类型。</p>
<pre class="language-none"><code class="language-none">&#x3D;&#x3D;    等于
!&#x3D;    不等于
&lt;     小于
&lt;&#x3D;    小于等于
&gt;     大于
&gt;&#x3D;    大于等于</code></pre>



<p>尽管Go语言提供了无符号数的运算，但即使数值本身不可能出现负数，我们还是倾向于使用有符号的<code>int</code>类型。无符号数往往只有在位运算或其它特殊的运算场景才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。它们通常并不用于仅仅是表达非负数量的场合。</p>
<p>一般来说，需要一个显式的转换将一个值从一种类型转化为另一种类型，并且算术和逻辑运算的二元操作中必须是相同的类型。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> compote <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>apples<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">int</span><span class="token punctuation">(</span>oranges<span class="token punctuation">)</span></code></pre>

<p>任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666；或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。如今八进制数据通常用于POSIX操作系统上的文件访问权限标志，十六进制数字则更强调数字值的bit位模式。</p>
<p>当使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式，就像下面的例子：</p>
<pre class="language-go" data-language="go"><code class="language-go">o <span class="token operator">:=</span> <span class="token number">0666</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %[1]o %#[1]o\n"</span><span class="token punctuation">,</span> o<span class="token punctuation">)</span> <span class="token comment">// "438 666 0666"</span>
x <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %[1]x %#[1]x %#[1]X\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
<span class="token comment">// Output:</span>
<span class="token comment">// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF</span></code></pre>

<p>请注意fmt的两个使用技巧。通常<code>Printf</code>格式化字符串包含多个<code>%</code>参数时将会包含对应相同数量的额外操作数，但是<code>%</code>之后的<code>[1]</code>副词告诉<code>Printf</code>函数再次使用第一个操作数。第二，<code>%</code>后的<code>#</code>副词告诉<code>Printf</code>在用<code>%o</code>、<code>%x</code>或<code>%X</code>输出时生成<code>0</code>、<code>0x</code>或<code>0X</code>前缀。</p>
<p>字符面值通过一对单引号直接包含对应字符。最简单的例子是ASCII中类似’a’写法的字符面值，但是我们也可以通过转义的数值来表示任意的Unicode码点对应的字符，马上将会看到这样的例子。</p>
<p>字符使用<code>%c</code>参数打印，或者是用<code>%q</code>参数打印带单引号的字符：</p>
<pre class="language-go" data-language="go"><code class="language-go">ascii <span class="token operator">:=</span> <span class="token char">'a'</span>
unicode <span class="token operator">:=</span> <span class="token char">'国'</span>
newline <span class="token operator">:=</span> <span class="token char">'\n'</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %[1]c %[1]q\n"</span><span class="token punctuation">,</span> ascii<span class="token punctuation">)</span>   <span class="token comment">// "97 a 'a'"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %[1]c %[1]q\n"</span><span class="token punctuation">,</span> unicode<span class="token punctuation">)</span> <span class="token comment">// "22269 国 '国'"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %[1]q\n"</span><span class="token punctuation">,</span> newline<span class="token punctuation">)</span>       <span class="token comment">// "10 '\n'"</span></code></pre>

<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>Go语言提供了两种精度的浮点数，float32和float64。它们的算术规范由IEEE754浮点数国际标准定义，该浮点数规范被所有现代的CPU支持。</p>
<p>这些浮点数类型的取值范围可以从很微小到很巨大。浮点数的范围极限值可以在math包找到。常量<code>math.MaxFloat32</code>表示float32能表示的最大数值，大约是 <code>3.4e38</code>；对应的<code>math.MaxFloat64</code>常量大约是<code>1.8e308</code>。它们分别能表示的最小值近似为<code>1.4e-45</code>和<code>4.9e-324</code>。</p>
<p>通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> f <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token number">16777216</span> <span class="token comment">// 1 &lt;&lt; 24</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>f <span class="token operator">==</span> f<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">// "true"!</span></code></pre>

<p>浮点数的字面值可以直接写小数部分，像这样：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> e <span class="token operator">=</span> <span class="token number">2.71828</span> <span class="token comment">// (approximately)</span></code></pre>

<p>小数点前面或后面的数字都可能被省略（例如.707或1.）。很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> Avogadro <span class="token operator">=</span> <span class="token number">6.02214129e23</span>  <span class="token comment">// 阿伏伽德罗常数</span>
<span class="token keyword">const</span> Planck   <span class="token operator">=</span> <span class="token number">6.62606957e-34</span> <span class="token comment">// 普朗克常数</span></code></pre>

<p>用<code>Printf</code>函数的<code>%g</code>参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用<code>%e</code>（带指数）或<code>%f</code>的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> x <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> x<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"x = %d e^x = %8.3f\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> math<span class="token punctuation">.</span><span class="token function">Exp</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>上面代码打印e的幂，打印精度是小数点后三个小数精度和8个字符宽度：</p>
<pre class="language-none"><code class="language-none">x &#x3D; 0       e^x &#x3D;    1.000
x &#x3D; 1       e^x &#x3D;    2.718
x &#x3D; 2       e^x &#x3D;    7.389
x &#x3D; 3       e^x &#x3D;   20.086
x &#x3D; 4       e^x &#x3D;   54.598
x &#x3D; 5       e^x &#x3D;  148.413
x &#x3D; 6       e^x &#x3D;  403.429
x &#x3D; 7       e^x &#x3D; 1096.633</code></pre>

<p>math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0&#x2F;0或Sqrt(-1).</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> z <span class="token builtin">float64</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> <span class="token operator">-</span>z<span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span>z<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">/</span>z<span class="token punctuation">,</span> z<span class="token operator">/</span>z<span class="token punctuation">)</span> <span class="token comment">// "0 -0 +Inf -Inf NaN"</span></code></pre>

<p>函数<code>math.IsNaN</code>用于测试一个数是否是非数NaN，<code>math.NaN</code>则返回非数对应的值。虽然可以用<code>math.NaN</code>来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的（译注：在浮点数中，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示）：</p>
<pre class="language-go" data-language="go"><code class="language-go">nan <span class="token operator">:=</span> math<span class="token punctuation">.</span><span class="token function">NaN</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>nan <span class="token operator">==</span> nan<span class="token punctuation">,</span> nan <span class="token operator">&lt;</span> nan<span class="token punctuation">,</span> nan <span class="token operator">></span> nan<span class="token punctuation">)</span> <span class="token comment">// "false false false"</span></code></pre>

<p>如果一个函数返回的浮点数结果可能失败，最好的做法是用单独的标志报告失败，像这样：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>value <span class="token builtin">float64</span><span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">if</span> failed <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">,</span> <span class="token boolean">true</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">var x complex128 &#x3D; complex(1, 2) &#x2F;&#x2F; 1+2i
var y complex128 &#x3D; complex(3, 4) &#x2F;&#x2F; 3+4i
fmt.Println(x*y)                 &#x2F;&#x2F; &quot;(-5+10i)&quot;
fmt.Println(real(x*y))           &#x2F;&#x2F; &quot;-5&quot;
fmt.Println(imag(x*y))           &#x2F;&#x2F; &quot;10&quot;</code></pre>

<p>如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如3.141592i或2i，它将构成一个复数的虚部，复数的实部是0：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">fmt.Println(1i * 1i) &#x2F;&#x2F; &quot;(-1+0i)&quot;, i^2 &#x3D; -1</code></pre>

<p>在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），我们可以用自然的方式书写复数，就像<code>1+2i</code>或与之等价的写法<code>2i+1</code>。上面x和y的声明语句还可以简化：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">x :&#x3D; 1 + 2i
y :&#x3D; 3 + 4i</code></pre>

<p>复数也可以用<code>==</code>和<code>!=</code>进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的（译注：浮点数的相等比较是危险的，需要特别小心处理精度问题）。</p>
<p><code>math/cmplx</code>包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">fmt.Println(cmplx.Sqrt(-1)) &#x2F;&#x2F; &quot;(0+1i)&quot;</code></pre>



<h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>一个布尔类型的值只有2种：<code>true</code>和<code>false</code>。if和for语句的条件部分都是布尔类型的值，并且<code>==</code>和<code>&lt;</code>等比较操作也会产生布尔型的值。一元操作符<code>!</code>对应逻辑非操作，因此<code>!true</code>的值为<code>false</code>，更罗嗦的说法是<code>(!true==false)==true</code>，虽然表达方式不一样，不过我们一般会采用简洁的布尔表达式，就像用x来表示<code>x==true</code>。</p>
<p>布尔值可以和&amp;&amp;（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">s !&#x3D; &quot;&quot; &amp;&amp; s[0] &#x3D;&#x3D; &#39;x&#39;</code></pre>

<p>其中s[0]操作如果应用于空字符串将会导致panic异常。</p>
<p>因为<code>&amp;&amp;</code>的优先级比<code>||</code>高（助记：<code>&amp;&amp;</code>对应逻辑乘法，<code>||</code>对应逻辑加法，乘法比加法优先级要高），下面形式的布尔表达式是不需要加小括弧的：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> <span class="token char">'a'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token char">'z'</span> <span class="token operator">||</span>
    <span class="token char">'A'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token char">'Z'</span> <span class="token operator">||</span>
    <span class="token char">'0'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token char">'9'</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// ...ASCII letter or digit...</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">i <span class="token operator">:=</span> <span class="token number">0</span>
<span class="token keyword">if</span> b <span class="token punctuation">&#123;</span>
    i <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>如果需要经常做类似的转换，包装成一个函数会更方便：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// btoi returns 1 if b is true and 0 if false.</span>
<span class="token keyword">func</span> <span class="token function">btoi</span><span class="token punctuation">(</span>b <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> b <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>数字到布尔型的逆转换则非常简单，不过为了保持对称，我们也可以包装一个函数：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// itob reports whether i is non-zero.</span>
<span class="token keyword">func</span> <span class="token function">itob</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> i <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span></code></pre>



<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。</p>
<p><strong>内置的len函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作<code>s[i]</code>返回第<code>i</code>个字节的字节值，<code>i</code>必须满足<code>0 ≤ i&lt; len(s)</code>条件约束。</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">s <span class="token operator">:=</span> <span class="token string">"hello, world"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">// "12"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// "104 119" ('h' and 'w')</span></code></pre>

<p>如果试图访问超出字符串索引范围的字节将会导致panic异常：</p>
<pre class="language-go" data-language="go"><code class="language-go">c <span class="token operator">:=</span> s<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment">// panic: index out of range</span></code></pre>

<p><strong>第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节。</strong></p>
<p>子字符串操作<code>s[i:j]</code>基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。生成的新字符串将包含<code>j-i</code>个字节。</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// "hello"</span></code></pre>

<p>同样，如果索引超出字符串范围或者<code>j</code>小于<code>i</code>的话将导致panic异常。</p>
<p>不管i还是<code>j</code>都可能被忽略，当它们被忽略时将采用0作为开始位置，采用<code>len(s)</code>作为结束的位置。</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// "hello"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// "world"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// "hello, world"</span></code></pre>

<p>其中<code>+</code>操作符将两个字符串连接构造一个新字符串：</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"goodbye"</span> <span class="token operator">+</span> s<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// "goodbye, world"</span></code></pre>

<p>字符串可以用&#x3D;&#x3D;和&lt;进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。</p>
<p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值。可以像下面这样将一个字符串追加到另一个字符串：</p>
<pre class="language-go" data-language="go"><code class="language-go">s <span class="token operator">:=</span> <span class="token string">"left foot"</span>
t <span class="token operator">:=</span> s
s <span class="token operator">+=</span> <span class="token string">", right foot"</span></code></pre>

<p>这并不会导致原始的字符串值被改变，但是变量s将因为+&#x3D;语句持有一个新的字符串值，但是t依然是包含原先的字符串值。</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// "left foot, right foot"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token comment">// "left foot"</span></code></pre>

<p>因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：</p>
<pre class="language-go" data-language="go"><code class="language-go">s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'L'</span> <span class="token comment">// compile error: cannot assign to s[0]</span></code></pre>

<p>不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串<code>s</code>和对应的子字符串切片<code>s[7:]</code>的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。</p>
<p>下图演示了一个字符串和两个子串共享相同的底层数据：</p>
<p><img src="/2022/notes-of-gopl/ch3-04.png" alt="img"></p>
<h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>字符串值也可以用字符串面值方式编写，只要将一系列字节序列包含在双引号内即可：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token string">"Hello, 世界"</span></code></pre>

<p>因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将 <em>Unicode码点</em> 也写到字符串面值中。</p>
<p>在一个双引号包含的字符串面值中，可以用以反斜杠<code>\</code>开头的转义序列插入任意的数据。下面的换行、回车和制表符等是常见的ASCII控制代码的转义方式：</p>
<pre class="language-none"><code class="language-none">\a      响铃
\b      退格
\f      换页
\n      换行
\r      回车
\t      制表符
\v      垂直制表符
\&#39;      单引号（只用在 &#39;\&#39;&#39; 形式的rune符号面值中）
\&quot;      双引号（只用在 &quot;...&quot; 形式的字符串面值中）
\\      反斜杠</code></pre>

<p>一个原生的字符串面值形式是<code>...</code>，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行（译注：在原生字符串面值内部是无法直接写`字符的，可以用八进制或十六进制转义或+”`“连接字符串常量完成）。</p>
<p>原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> GoUsage <span class="token operator">=</span> <span class="token string">`Go is a tool for managing Go source code.

Usage:
    go command [arguments]
...`</span></code></pre>

<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Unicode（ <a target="_blank" rel="noopener" href="http://unicode.org/">http://unicode.org</a> ），它收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode码点，Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类型）。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF8是一个将Unicode码点编码为字节序列的变长编码。UTF8编码是由Go语言之父Ken Thompson和Rob Pike共同发明的，现在已经是Unicode的标准。UTF8编码使用1到4个字节来表示每个Unicode码点，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。</p>
<p>Go语言的源文件采用UTF8编码，并且Go语言处理UTF8编码的文本也很出色。unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等），<code>unicode/utf8</code>包则提供了用于rune字符序列的UTF8编码和解码的功能。</p>
<p>有很多Unicode字符很难直接从键盘输入，并且还有很多字符有着相似的结构；有一些甚至是不可见的字符（译注：中文和日文就有很多相似但不同的字）。Go语言字符串面值中的Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。有两种形式：<code>\uhhhh</code>对应16bit的码点值，<code>\Uhhhhhhhh</code>对应32bit的码点值，其中h是一个十六进制数字；一般很少需要使用32bit的形式。每一个对应码点的UTF8编码。例如：下面的字母串面值都表示相同的值：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token string">"世界"</span>
<span class="token string">"\xe4\xb8\x96\xe7\x95\x8c"</span>
<span class="token string">"\u4e16\u754c"</span>
<span class="token string">"\U00004e16\U0000754c"</span></code></pre>

<p>上面三个转义序列都为第一个字符串提供替代写法，但是它们的值都是相同的。</p>
<p>Unicode转义也可以使用在rune字符中。下面三个字符是等价的：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token char">'世'</span> <span class="token char">'\u4e16'</span> <span class="token char">'\U00004e16'</span></code></pre>

<p>对于小于256的码点值可以写在一个十六进制转义字节中，例如<code>\x41</code>对应字符’A’，但是对于更大的码点则必须使用<code>\u</code>或<code>\U</code>转义形式。因此，<code>\xe4\xb8\x96</code>并不是一个合法的rune字符，虽然这三个字节对应一个有效的UTF8编码的码点。</p>
<p>得益于UTF8编码优良的设计，诸多字符串操作都不需要解码操作。我们可以不用解码直接测试一个字符串是否是另一个字符串的前缀：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">HasPrefix</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> prefix <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token function">len</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">==</span> prefix
<span class="token punctuation">&#125;</span></code></pre>

<p>或者是后缀测试：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">HasSuffix</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> suffix <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token function">len</span><span class="token punctuation">(</span>suffix<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">len</span><span class="token punctuation">(</span>suffix<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">==</span> suffix
<span class="token punctuation">&#125;</span></code></pre>

<p>或者是包含子串测试：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Contains</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> substr <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token function">HasPrefix</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> substr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>对于UTF8编码后文本的处理和原始的字节处理逻辑是一样的。但是对应很多其它编码则并不是这样的。</p>
<p>另一方面，如果我们真的关心每个Unicode字符，我们可以使用其它处理方式。考虑前面的第一个例子中的字符串，它混合了中西两种字符。图3.5展示了它的内存表示形式。字符串包含13个字节，以UTF8形式编码，但是只对应9个Unicode字符：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"unicode/utf8"</span>

s <span class="token operator">:=</span> <span class="token string">"Hello, 世界"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// "13"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>utf8<span class="token punctuation">.</span><span class="token function">RuneCountInString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "9"</span></code></pre>

<p>为了处理这些真实的字符，我们需要一个UTF8解码器。unicode&#x2F;utf8包提供了该功能，我们可以这样使用：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#123;</span>
    r<span class="token punctuation">,</span> size <span class="token operator">:=</span> utf8<span class="token punctuation">.</span><span class="token function">DecodeRuneInString</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d\t%c\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
    i <span class="token operator">+=</span> size
<span class="token punctuation">&#125;</span></code></pre>

<p>每一次调用<code>DecodeRuneInString</code>函数都返回一个r和长度，r对应字符本身，长度对应r采用UTF8编码后的编码字节数目。长度可以用于更新第i个字符在字符串中的字节索引位置。但是这种编码方式是笨拙的，我们需要更简洁的语法。幸运的是，Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串。下面的循环运行如图3.5所示；需要注意的是对于非ASCII，索引更新的步长将超过1个字节。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i<span class="token punctuation">,</span> r <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token string">"Hello, 世界"</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d\t%q\t%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> r<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/*
0       'H'     72
1       'e'     101
2       'l'     108
3       'l'     108
4       'o'     111
5       ','     44
6       ' '     32
7       '世'    19990
10      '界'    30028
*/</span></code></pre>

<p><img src="/2022/notes-of-gopl/ch3-05.png" alt="图3.5"></p>
<p>我们可以使用一个简单的循环来统计字符串中字符的数目，像这样：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">n :&#x3D; 0
for _, _ &#x3D; range s &#123;
    n++
&#125;</code></pre>

<p>像其它形式的循环那样，我们也可以忽略不需要的变量：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">n :&#x3D; 0
for range s &#123;
    n++
&#125;</code></pre>

<p>或者我们可以直接调用<code>utf8.RuneCountInString(s)</code>函数。</p>
<p>每一个UTF8字符解码，不管是显式地调用<code>utf8.DecodeRuneInString</code>解码或是在range循环中隐式地解码，如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符<code>\uFFFD</code>，在印刷中这个符号通常是一个黑色六角或钻石形状，里面包含一个白色的问号”?”。当程序遇到这样的一个字符，通常是一个危险信号，说明输入并不是一个完美没有错误的UTF8字符串。</p>
<p>UTF8字符串作为交换格式是非常方便的，但是在程序内部采用rune序列可能更方便，因为rune大小一致，支持数组索引和方便切割。</p>
<p>将[]rune类型转换应用到UTF8编码的字符串，将返回字符串编码的Unicode码点序列：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// "program" in Japanese katakana</span>
s <span class="token operator">:=</span> <span class="token string">"プログラム"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"% x\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token comment">// "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0"</span>
r <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>  <span class="token comment">// "[30d7 30ed 30b0 30e9 30e0]"</span></code></pre>

<p>（在第一个<code>Printf</code>中的<code>% x</code>参数用于在每个十六进制数字前插入一个空格。）</p>
<p>如果是将一个<code>[]rune</code>类型的Unicode字符slice或数组转为string，则对它们进行UTF8编码：</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "プログラム"</span></code></pre>

<p>将一个整数转型为字符串意思是生成以只包含对应Unicode码点字符的UTF8字符串：</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">// "A", not "65"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token number">0x4eac</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "京"</span></code></pre>

<p>如果对应码点的字符是无效的，则用<code>\uFFFD</code>无效字符作为替换：</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token number">1234567</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "⶧"</span></code></pre>

<h3 id="字符串和Byte切片"><a href="#字符串和Byte切片" class="headerlink" title="字符串和Byte切片"></a>字符串和Byte切片</h3><p><strong>标准库中有4个包对字符串处理尤为重要：</strong></p>
<ul>
<li><p><code>strings</code>包：提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。</p>
</li>
<li><p><code>bytes</code>包：也提供了很多与<code>strings</code>包类似功能的函数，但是针对和字符串有着相同结构的<code>[]byte</code>类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用<code>bytes.Buffer</code>类型将会更有效。</p>
</li>
<li><p><code>strconv</code>包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</p>
</li>
<li><p><code>unicode</code>包：提供了<code>IsDigit</code>、<code>IsLetter</code>、<code>IsUpper</code>和<code>IsLower</code>等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像<code>ToUpper</code>和<code>ToLower</code>之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是<code>ToUpper</code>和<code>ToLower</code>，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。</p>
</li>
</ul>
<p>下面例子的basename函数灵感源于Unix shell的同名工具。在我们实现的版本中，<code>basename(s)</code>将看起来像是系统路径的前缀删除，同时将看似文件类型的后缀名部分删除：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">fmt.Println(basename(&quot;a&#x2F;b&#x2F;c.go&quot;)) &#x2F;&#x2F; &quot;c&quot;
fmt.Println(basename(&quot;c.d.go&quot;))   &#x2F;&#x2F; &quot;c.d&quot;
fmt.Println(basename(&quot;abc&quot;))      &#x2F;&#x2F; &quot;abc&quot;</code></pre>

<p>第一个版本并没有使用任何库，全部手工硬编码实现：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; basename removes directory components and a .suffix.
&#x2F;&#x2F; e.g., a &#x3D;&gt; a, a.go &#x3D;&gt; a, a&#x2F;b&#x2F;c.go &#x3D;&gt; c, a&#x2F;b.c.go &#x3D;&gt; b.c
func basename(s string) string &#123;
    &#x2F;&#x2F; Discard last &#39;&#x2F;&#39; and everything before.
    for i :&#x3D; len(s) - 1; i &gt;&#x3D; 0; i-- &#123;
        if s[i] &#x3D;&#x3D; &#39;&#x2F;&#39; &#123;
            s &#x3D; s[i+1:]
            break
        &#125;
    &#125;
    &#x2F;&#x2F; Preserve everything before last &#39;.&#39;.
    for i :&#x3D; len(s) - 1; i &gt;&#x3D; 0; i-- &#123;
        if s[i] &#x3D;&#x3D; &#39;.&#39; &#123;
            s &#x3D; s[:i]
            break
        &#125;
    &#125;
    return s
&#125;</code></pre>

<p>这个简化版本使用了<code>strings.LastIndex</code>库函数：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">func basename(s string) string &#123;
    slash :&#x3D; strings.LastIndex(s, &quot;&#x2F;&quot;) &#x2F;&#x2F; -1 if &quot;&#x2F;&quot; not found
    s &#x3D; s[slash+1:]
    if dot :&#x3D; strings.LastIndex(s, &quot;.&quot;); dot &gt;&#x3D; 0 &#123;
        s &#x3D; s[:dot]
    &#125;
    return s
&#125;</code></pre>

<p><code>path</code>和<code>path/filepath</code>包提供了关于文件路径名更一般的函数操作。使用斜杠分隔路径可以在任何操作系统上工作。斜杠本身不应该用于文件名，但是在其他一些领域可能会用于文件名，例如URL路径组件。相比之下，<code>path/filepath</code>包则使用操作系统本身的路径规则，例如POSIX系统使用<code>/foo/bar</code>，而Microsoft Windows使用<code>c:\foo\bar</code>等。</p>
<p>让我们继续另一个字符串的例子。函数的功能是将一个表示整数值的字符串，每隔三个字符插入一个逗号分隔符，例如“12345”处理后成为“12,345”。这个版本只适用于整数类型。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; comma inserts commas in a non-negative decimal integer string.
func comma(s string) string &#123;
    n :&#x3D; len(s)
    if n &lt;&#x3D; 3 &#123;
        return s
    &#125;
    return comma(s[:n-3]) + &quot;,&quot; + s[n-3:]
&#125;</code></pre>

<p>输入comma函数的参数是一个字符串。如果输入字符串的长度小于或等于3的话，则不需要插入逗号分隔符。否则，comma函数将在最后三个字符前的位置将字符串切割为两个子串并插入逗号分隔符，然后通过递归调用自身来得出前面的子串。</p>
<p><strong>一个字符串是包含只读字节的数组，一旦创建，是不可变的。相比之下，一个字节slice的元素则可以自由地修改。</strong></p>
<p><strong>字符串和字节slice之间可以相互转换：</strong></p>
<pre class="language-Go" data-language="Go"><code class="language-Go">s :&#x3D; &quot;abc&quot;
b :&#x3D; []byte(s)
s2 :&#x3D; string(b)</code></pre>

<p>从概念上讲，一个<code>[]byte(s)</code>转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量b被修改的情况下，原始的s字符串也不会改变。将一个<code>[]byte</code>字节slice转换到字符串的<code>string(b)</code>操作则是构造一个字符串拷贝，以确保<code>s2</code>字符串是只读的。</p>
<p><strong>为了避免转换中不必要的内存分配，<code>bytes</code>包和<code>strings</code>同时提供了许多实用函数。下面是<code>strings</code>包中的六个函数：</strong></p>
<pre class="language-Go" data-language="Go"><code class="language-Go">func Contains(s, substr string) bool
func Count(s, sep string) int
func Fields(s string) []string
func HasPrefix(s, prefix string) bool
func Index(s, sep string) int
func Join(a []string, sep string) string</code></pre>

<p><strong><code>bytes</code>包中也对应的六个函数：</strong></p>
<pre class="language-Go" data-language="Go"><code class="language-Go">func Contains(b, subslice []byte) bool
func Count(s, sep []byte) int
func Fields(s []byte) [][]byte
func HasPrefix(s, prefix []byte) bool
func Index(s, sep []byte) int
func Join(s [][]byte, sep []byte) []byte</code></pre>

<p><strong>它们之间唯一的区别是字符串类型参数被替换成了字节slice类型的参数。</strong></p>
<p><code>bytes</code>包还提供了<code>Buffer</code>类型用于字节slice的缓存。一个<code>Buffer</code>开始是空的，但是随着<code>string</code>、<code>byte</code>或<code>[]byte</code>等类型数据的写入可以动态增长，一个<code>bytes.Buffer</code>变量并不需要初始化，因为零值也是有效的：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; intsToString is like fmt.Sprint(values) but adds commas.
func intsToString(values []int) string &#123;
    var buf bytes.Buffer
    buf.WriteByte(&#39;[&#39;)
    for i, v :&#x3D; range values &#123;
        if i &gt; 0 &#123;
            buf.WriteString(&quot;, &quot;)
        &#125;
        fmt.Fprintf(&amp;buf, &quot;%d&quot;, v)
    &#125;
    buf.WriteByte(&#39;]&#39;)
    return buf.String()
&#125;

func main() &#123;
    fmt.Println(intsToString([]int&#123;1, 2, 3&#125;)) &#x2F;&#x2F; &quot;[1, 2, 3]&quot;
&#125;</code></pre>

<p>当向<code>bytes.Buffer</code>添加任意字符的UTF8编码时，最好使用<code>bytes.Buffer</code>的<code>WriteRune</code>方法，但是<code>WriteByte</code>方法对于写入类似<code>[</code>和<code>]</code>等ASCII字符则会更加有效。</p>
<p><code>bytes.Buffer</code>类型有着很多实用的功能，可以将它用作一个I&#x2F;O的输入和输出对象，例如当做<code>Fprintf</code>的<code>io.Writer</code>输出对象，或者当作<code>io.Reader</code>类型的输入源对象。</p>
<h3 id="字符串和数字的转换"><a href="#字符串和数字的转换" class="headerlink" title="字符串和数字的转换"></a>字符串和数字的转换</h3><p>除了字符串、字符、字节之间的转换，字符串和数值之间的转换也比较常见。由<code>strconv</code>包提供这类转换功能。</p>
<p>将一个整数转为字符串，一种方法是用<code>fmt.Sprintf</code>返回一个格式化的字符串；另一个方法是用<code>strconv.Itoa(&quot;整数到ASCII&quot;)</code>：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">x :&#x3D; 123
y :&#x3D; fmt.Sprintf(&quot;%d&quot;, x)
fmt.Println(y, strconv.Itoa(x)) &#x2F;&#x2F; &quot;123 123&quot;</code></pre>

<p><code>FormatInt</code>和<code>FormatUint</code>函数可以用不同的进制来格式化数字：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">fmt.Println(strconv.FormatInt(int64(x), 2)) &#x2F;&#x2F; &quot;1111011&quot;</code></pre>

<p><code>fmt.Printf</code>函数的<code>%b</code>、<code>%d</code>、<code>%o</code>和<code>%x</code>等参数提供功能往往比<code>strconv</code>包的<code>Format</code>函数方便很多，特别是在需要包含有附加额外信息的时候：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">s :&#x3D; fmt.Sprintf(&quot;x&#x3D;%b&quot;, x) &#x2F;&#x2F; &quot;x&#x3D;1111011&quot;</code></pre>

<p>如果要将一个字符串解析为整数，可以使用<code>strconv</code>包的<code>Atoi</code>或<code>ParseInt</code>函数，还有用于解析无符号整数的<code>ParseUint</code>函数：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">x, err :&#x3D; strconv.Atoi(&quot;123&quot;)             &#x2F;&#x2F; x is an int
y, err :&#x3D; strconv.ParseInt(&quot;123&quot;, 10, 64) &#x2F;&#x2F; base 10, up to 64 bits</code></pre>

<p><code>ParseInt</code>函数的第三个参数是用于指定整型数的大小；例如16表示<code>int16</code>，0则表示int。在任何情况下，返回的结果y总是<code>int64</code>类型，你可以通过强制类型转换将它转为更小的整数类型。</p>
<p>有时候也会使用<code>fmt.Scanf</code>来解析输入的字符串和数字，特别是当字符串和数字混合在一行的时候，它可以灵活处理不完整或不规则的输入。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string或数字。</p>
<p>一个常量的声明语句定义了常量的名字，和变量的声明语法类似，常量的值不可修改，这样可以防止在运行期被意外或恶意的修改。例如，常量比变量更适合用于表达像π之类的数学常数，因为它们的值不会发生变化：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> pi <span class="token operator">=</span> <span class="token number">3.14159</span> <span class="token comment">// approximately; math.Pi is a better approximation</span></code></pre>

<p>和变量声明一样，可以批量声明多个常量；这比较适合声明一组相关的常量：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>
    e  <span class="token operator">=</span> <span class="token number">2.71828182845904523536028747135266249775724709369995957496696763</span>
    pi <span class="token operator">=</span> <span class="token number">3.14159265358979323846264338327950288419716939937510582097494459</span>
<span class="token punctuation">)</span></code></pre>

<p>所有常量的运算都可以在编译期完成，这样可以减少运行时的工作，也方便其他编译优化。当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。</p>
<p>常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：<code>len</code>、<code>cap</code>、<code>real</code>、<code>imag</code>、<code>complex</code>和<code>unsafe.Sizeof</code>。</p>
<p>因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> IPv4Len <span class="token operator">=</span> <span class="token number">4</span>

<span class="token comment">// parseIPv4 parses an IPv4 address (d.d.d.d).</span>
<span class="token keyword">func</span> <span class="token function">parseIPv4</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> IP <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> p <span class="token punctuation">[</span>IPv4Len<span class="token punctuation">]</span><span class="token builtin">byte</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。在下面的代码中，<code>time.Duration</code>是一个命名类型，底层类型是int64，<code>time.Minute</code>是对应类型的常量。下面声明的两个常量都是<code>time.Duration</code>类型，可以通过%T参数打印类型信息：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> noDelay time<span class="token punctuation">.</span>Duration <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">const</span> timeout <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Minute
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T %[1]v\n"</span><span class="token punctuation">,</span> noDelay<span class="token punctuation">)</span>     <span class="token comment">// "time.Duration 0"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T %[1]v\n"</span><span class="token punctuation">,</span> timeout<span class="token punctuation">)</span>     <span class="token comment">// "time.Duration 5m0s"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T %[1]v\n"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>Minute<span class="token punctuation">)</span> <span class="token comment">// "time.Duration 1m0s"</span></code></pre>

<p>如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。例如：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>
    a <span class="token operator">=</span> <span class="token number">1</span>
    b
    c <span class="token operator">=</span> <span class="token number">2</span>
    d
<span class="token punctuation">)</span>

fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token comment">// "1 1 2 2"</span></code></pre>

<p>如果只是简单地复制右边的常量表达式，其实并没有太实用的价值。但是它可以带来其它的特性，那就是<code>iota</code>常量生成器语法。</p>
<h3 id="iota-常量生成器"><a href="#iota-常量生成器" class="headerlink" title="iota 常量生成器"></a>iota 常量生成器</h3><p>常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个<code>const</code>声明语句中，在第一个声明的常量所在的行，<code>iota</code>将会被置为0，然后在每一个有常量声明的行加一。</p>
<p>下面是来自time包的例子，它首先定义了一个Weekday命名类型，然后为一周的每天定义了一个常量，从周日0开始。在其它编程语言中，这种类型一般被称为枚举类型。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Weekday <span class="token builtin">int</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
    Sunday Weekday <span class="token operator">=</span> <span class="token boolean">iota</span>
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
<span class="token punctuation">)</span>

fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>Sunday<span class="token punctuation">,</span> Monday<span class="token punctuation">,</span> Tuesday<span class="token punctuation">,</span> Wednesday<span class="token punctuation">,</span> Thursday<span class="token punctuation">,</span> Friday<span class="token punctuation">,</span> Saturday<span class="token punctuation">)</span> <span class="token comment">// 0 1 2 3 4 5 6</span></code></pre>

<p>我们也可以在复杂的常量表达式中使用<code>iota</code>，下面是来自<code>net</code>包的例子，用于给一个无符号整数的最低5bit的每个bit指定一个名字：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Flags <span class="token builtin">uint</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
    FlagUp Flags <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">iota</span> <span class="token comment">// is up</span>
    FlagBroadcast            <span class="token comment">// supports broadcast access capability</span>
    FlagLoopback             <span class="token comment">// is a loopback interface</span>
    FlagPointToPoint         <span class="token comment">// belongs to a point-to-point link</span>
    FlagMulticast            <span class="token comment">// supports multicast access capability</span>
<span class="token punctuation">)</span></code></pre>

<p>随着<code>iota</code>的递增，每个常量对应表达式<code>1 &lt;&lt; iota</code>，是连续的2的幂，分别对应一个bit位置。使用这些常量可以用于测试、设置或清除对应的bit位的值：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">IsUp</span><span class="token punctuation">(</span>v Flags<span class="token punctuation">)</span> <span class="token builtin">bool</span>     <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> v<span class="token operator">&amp;</span>FlagUp <span class="token operator">==</span> FlagUp <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">TurnDown</span><span class="token punctuation">(</span>v <span class="token operator">*</span>Flags<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span> <span class="token operator">*</span>v <span class="token operator">&amp;^=</span> FlagUp <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">SetBroadcast</span><span class="token punctuation">(</span>v <span class="token operator">*</span>Flags<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token operator">*</span>v <span class="token operator">|=</span> FlagBroadcast <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">IsCast</span><span class="token punctuation">(</span>v Flags<span class="token punctuation">)</span> <span class="token builtin">bool</span>   <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> v<span class="token operator">&amp;</span><span class="token punctuation">(</span>FlagBroadcast<span class="token operator">|</span>FlagMulticast<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> v Flags <span class="token operator">=</span> FlagMulticast <span class="token operator">|</span> FlagUp
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%b %t\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">,</span> <span class="token function">IsUp</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "10001 true"</span>
    <span class="token function">TurnDown</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%b %t\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">,</span> <span class="token function">IsUp</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "10000 false"</span>
    <span class="token function">SetBroadcast</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%b %t\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">,</span> <span class="token function">IsUp</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// "10010 false"</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%b %t\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">,</span> <span class="token function">IsCast</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "10010 true"</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>下面是一个更复杂的例子，每个常量都是1024的幂：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>
    <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token boolean">iota</span><span class="token punctuation">)</span>
    KiB <span class="token comment">// 1024</span>
    MiB <span class="token comment">// 1048576</span>
    GiB <span class="token comment">// 1073741824</span>
    TiB <span class="token comment">// 1099511627776             (exceeds 1 &lt;&lt; 32)</span>
    PiB <span class="token comment">// 1125899906842624</span>
    EiB <span class="token comment">// 1152921504606846976</span>
    ZiB <span class="token comment">// 1180591620717411303424    (exceeds 1 &lt;&lt; 64)</span>
    YiB <span class="token comment">// 1208925819614629174706176</span>
<span class="token punctuation">)</span></code></pre>

<p>不过iota常量生成规则也有其局限性。例如，它并不能用于产生1000的幂（KB、MB等），因为Go语言并没有计算幂的运算符。</p>
<h3 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h3><p>Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如int或float64，或者是类似<code>time.Duration</code>这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有6种未明确类型的常量类型，分别是：</p>
<ul>
<li>无类型的布尔型</li>
<li>无类型的整数</li>
<li>无类型的字符</li>
<li>无类型的浮点数</li>
<li>无类型的复数</li>
<li>无类型的字符串</li>
</ul>
<p>通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。例如，例子中的ZiB和YiB的值已经超出任何Go语言中整数类型能表达的范围，但是它们依然是合法的常量，而且像下面的常量表达式依然有效（译注：YiB&#x2F;ZiB是在编译期计算出来的，并且结果常量是1024，是Go语言int变量能有效表示的）：</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>YiB<span class="token operator">/</span>ZiB<span class="token punctuation">)</span> <span class="token comment">// "1024"</span></code></pre>

<p>另一个例子，<code>math.Pi</code>无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">float32</span> <span class="token operator">=</span> math<span class="token punctuation">.</span>Pi
<span class="token keyword">var</span> y <span class="token builtin">float64</span> <span class="token operator">=</span> math<span class="token punctuation">.</span>Pi
<span class="token keyword">var</span> z <span class="token builtin">complex128</span> <span class="token operator">=</span> math<span class="token punctuation">.</span>Pi</code></pre>

<p>如果<code>math.Pi</code>被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> Pi64 <span class="token builtin">float64</span> <span class="token operator">=</span> math<span class="token punctuation">.</span>Pi

<span class="token keyword">var</span> x <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token function">float32</span><span class="token punctuation">(</span>Pi64<span class="token punctuation">)</span>
<span class="token keyword">var</span> y <span class="token builtin">float64</span> <span class="token operator">=</span> Pi64
<span class="token keyword">var</span> z <span class="token builtin">complex128</span> <span class="token operator">=</span> <span class="token function">complex128</span><span class="token punctuation">(</span>Pi64<span class="token punctuation">)</span></code></pre>

<p>对于常量面值，不同的写法可能会对应不同的类型。例如<code>0</code>、<code>0.0</code>、<code>0i</code>和<code>\u0000</code>虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，<code>true</code>和<code>false</code>也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。</p>
<p>前面说过除法运算符&#x2F;会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达式可能对应不同的结果：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> f <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">212</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">-</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5</span> <span class="token operator">/</span> <span class="token number">9</span><span class="token punctuation">)</span>     <span class="token comment">// "100"; (f - 32) * 5 is a float64</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">/</span> <span class="token number">9</span> <span class="token operator">*</span> <span class="token punctuation">(</span>f <span class="token operator">-</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">// "0";   5/9 is an untyped integer, 0</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">5.0</span> <span class="token operator">/</span> <span class="token number">9.0</span> <span class="token operator">*</span> <span class="token punctuation">(</span>f <span class="token operator">-</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "100"; 5.0/9.0 is an untyped float</span></code></pre>

<p>只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> f <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">0i</span> <span class="token comment">// untyped complex -> float64</span>
f <span class="token operator">=</span> <span class="token number">2</span>                  <span class="token comment">// untyped integer -> float64</span>
f <span class="token operator">=</span> <span class="token number">1e123</span>              <span class="token comment">// untyped floating-point -> float64</span>
f <span class="token operator">=</span> <span class="token char">'a'</span>                <span class="token comment">// untyped rune -> float64</span></code></pre>

<p>上面的语句相当于:</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> f <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token function">float64</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">0i</span><span class="token punctuation">)</span>
f <span class="token operator">=</span> <span class="token function">float64</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
f <span class="token operator">=</span> <span class="token function">float64</span><span class="token punctuation">(</span><span class="token number">1e123</span><span class="token punctuation">)</span>
f <span class="token operator">=</span> <span class="token function">float64</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span></code></pre>

<p>无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>
    deadbeef <span class="token operator">=</span> <span class="token number">0xdeadbeef</span> <span class="token comment">// untyped int with value 3735928559</span>
    a <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>deadbeef<span class="token punctuation">)</span>  <span class="token comment">// uint32 with value 3735928559</span>
    b <span class="token operator">=</span> <span class="token function">float32</span><span class="token punctuation">(</span>deadbeef<span class="token punctuation">)</span> <span class="token comment">// float32 with value 3735928576 (rounded up)</span>
    c <span class="token operator">=</span> <span class="token function">float64</span><span class="token punctuation">(</span>deadbeef<span class="token punctuation">)</span> <span class="token comment">// float64 with value 3735928559 (exact)</span>
    d <span class="token operator">=</span> <span class="token function">int32</span><span class="token punctuation">(</span>deadbeef<span class="token punctuation">)</span>   <span class="token comment">// compile error: constant overflows int32</span>
    e <span class="token operator">=</span> <span class="token function">float64</span><span class="token punctuation">(</span><span class="token number">1e309</span><span class="token punctuation">)</span>    <span class="token comment">// compile error: constant overflows float64</span>
    f <span class="token operator">=</span> <span class="token function">uint</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>          <span class="token comment">// compile error: constant underflows uint</span>
<span class="token punctuation">)</span></code></pre>

<p>对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子：</p>
<pre class="language-go" data-language="go"><code class="language-go">i <span class="token operator">:=</span> <span class="token number">0</span>      <span class="token comment">// untyped integer;        implicit int(0)</span>
r <span class="token operator">:=</span> <span class="token char">'\000'</span> <span class="token comment">// untyped rune;           implicit rune('\000')</span>
f <span class="token operator">:=</span> <span class="token number">0.0</span>    <span class="token comment">// untyped floating-point; implicit float64(0.0)</span>
c <span class="token operator">:=</span> <span class="token number">0i</span>     <span class="token comment">// untyped complex;        implicit complex128(0i)</span></code></pre>

<p>注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。 如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。</p>
<p>如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型，像下面例子这样：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token function">int8</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> i <span class="token builtin">int8</span> <span class="token operator">=</span> <span class="token number">0</span></code></pre>

<p>当尝试将这些无类型的常量转为一个接口值时，这些默认类型将显得尤为重要，因为要靠它们明确接口对应的动态类型。</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token comment">// "int"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span>    <span class="token comment">// "float64"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> <span class="token number">0i</span><span class="token punctuation">)</span>     <span class="token comment">// "complex128"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> <span class="token char">'\000'</span><span class="token punctuation">)</span> <span class="token comment">// "int32" (rune)</span></code></pre>



<h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在Go语言中很少直接使用数组。和数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列，slice功能也更灵活，但是要理解slice工作原理的话需要先理解数组。</p>
<p>数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的<code>len</code>函数将返回数组中元素的个数。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span>             <span class="token comment">// array of 3 integers</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment">// print the first element</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// print the last element, a[2]</span>

<span class="token comment">// Print the indices and elements.</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Print the elements only.</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。我们也可以使用数组字面值语法用一组值来初始化数组：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> q <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> r <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// "0"</span></code></pre>

<p>在数组字面值中，如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算。因此，上面q数组的定义可以简化为</p>
<pre class="language-go" data-language="go"><code class="language-go">q <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> q<span class="token punctuation">)</span> <span class="token comment">// "[3]int"</span></code></pre>

<p>数组的长度是数组类型的一个组成部分，因此<code>[3]int</code>和<code>[4]int</code>是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</p>
<pre class="language-go" data-language="go"><code class="language-go">q <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span>
q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span> <span class="token comment">// compile error: cannot assign [4]int to [3]int</span></code></pre>

<p>我们将会发现，数组、slice、map和结构体字面值的写法都很相似。上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化，就像下面这样：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Currency <span class="token builtin">int</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
    USD Currency <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment">// 美元</span>
    EUR                 <span class="token comment">// 欧元</span>
    GBP                 <span class="token comment">// 英镑</span>
    RMB                 <span class="token comment">// 人民币</span>
<span class="token punctuation">)</span>

symbol <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span>USD<span class="token punctuation">:</span> <span class="token string">"$"</span><span class="token punctuation">,</span> EUR<span class="token punctuation">:</span> <span class="token string">"€"</span><span class="token punctuation">,</span> GBP<span class="token punctuation">:</span> <span class="token string">"￡"</span><span class="token punctuation">,</span> RMB<span class="token punctuation">:</span> <span class="token string">"￥"</span><span class="token punctuation">&#125;</span>

fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>RMB<span class="token punctuation">,</span> symbol<span class="token punctuation">[</span>RMB<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// "3 ￥"</span></code></pre>

<p>在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而且没用到的索引可以省略，和前面提到的规则一样，未指定初始值的元素将用零值初始化。例如，</p>
<pre class="language-go" data-language="go"><code class="language-go">r <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">99</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span></code></pre>

<p>定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</p>
<p>如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过&#x3D;&#x3D;比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。不相等比较运算符!&#x3D;遵循同样的规则。</p>
<pre class="language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>
b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>
c <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">,</span> a <span class="token operator">==</span> c<span class="token punctuation">,</span> b <span class="token operator">==</span> c<span class="token punctuation">)</span> <span class="token comment">// "true false false"</span>
d <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> d<span class="token punctuation">)</span> <span class="token comment">// compile error: cannot compare [2]int == [3]int</span></code></pre>

<p>作为一个真实的例子，<code>crypto/sha256</code>包的<code>Sum256</code>函数对一个任意的字节slice类型的数据生成一个对应的消息摘要。消息摘要有256bit大小，因此对应<code>[32]byte</code>数组类型。如果两个消息摘要是相同的，那么可以认为两个消息本身也是相同（译注：理论上有HASH码碰撞的情况，但是实际应用可以基本忽略）；如果消息摘要不同，那么消息本身必然也是不同的。下面的例子用SHA256算法分别生成<code>&quot;x&quot;</code>和<code>&quot;X&quot;</code>两个信息的摘要：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"crypto/sha256"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    c1 <span class="token operator">:=</span> sha256<span class="token punctuation">.</span><span class="token function">Sum256</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    c2 <span class="token operator">:=</span> sha256<span class="token punctuation">.</span><span class="token function">Sum256</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"X"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%x\n%x\n%t\n%T\n"</span><span class="token punctuation">,</span> c1<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> c1 <span class="token operator">==</span> c2<span class="token punctuation">,</span> c1<span class="token punctuation">)</span>
    <span class="token comment">// Output:</span>
    <span class="token comment">// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881</span>
    <span class="token comment">// 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015</span>
    <span class="token comment">// false</span>
    <span class="token comment">// [32]uint8</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>上面例子中，两个消息虽然只有一个字符的差异，但是生成的消息摘要则几乎有一半的bit位是不相同的。需要注意<code>Printf</code>函数的<code>%x</code>副词参数，它用于指定以十六进制的格式打印数组或slice全部的元素，<code>%t</code>副词参数是用于打印布尔型数据，<code>%T</code>副词参数是用于显示一个值对应的数据类型。</p>
<p>对于Go语言，当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。因为函数参数传递的机制导致传递大的数组类型将是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量。</p>
<p>当然，我们可以显式地传入一个数组指针，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者。下面的函数用于给<code>[32]byte</code>类型的数组清零：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">zero</span><span class="token punctuation">(</span>ptr <span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> ptr <span class="token punctuation">&#123;</span>
        ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>其实数组字面值<code>[32]byte&#123;&#125;</code>就可以生成一个32字节的数组。而且每个数组的元素都是零值初始化，也就是0。因此，我们可以将上面的zero函数写的更简洁一点：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">zero</span><span class="token punctuation">(</span>ptr <span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息。上面的<code>zero</code>函数并不能接收指向<code>[16]byte</code>类型数组的指针，而且也没有任何添加或删除数组元素的方法。由于这些原因，除了像SHA256这类需要处理特定大小数组的特例外，数组依然很少用作函数参数；相反，我们一般使用slice来替代数组。</p>
<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作<code>[]T</code>，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。</p>
<p>数组和slice之间有着紧密的联系。一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的<code>len</code>和<code>cap</code>函数分别返回slice的长度和容量。</p>
<p>多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。图4.1显示了表示一年中每个月份名字的字符串数组，还有重叠引用了该数组的两个slice。</p>
<p><img src="/2022/notes-of-gopl/ch4-01.png" alt="图4.1"></p>
<p>数组这样定义：</p>
<pre class="language-go" data-language="go"><code class="language-go">months <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">"January"</span><span class="token punctuation">,</span> <span class="token comment">/* ... */</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">:</span> <span class="token string">"December"</span><span class="token punctuation">&#125;</span></code></pre>

<p>因此一月份是<code>months[1]</code>，十二月份是<code>months[12]</code>。通常，数组的第一个元素从索引0开始，但是月份一般是从1开始的，因此我们声明数组时直接跳过第0个元素，第0个元素会被自动初始化为空字符串。</p>
<p>slice的切片操作<code>s[i:j]</code>，其中<code>0 ≤ i≤ j≤ cap(s)</code>，用于创建一个新的slice，引用<code>s</code>的从第<code>i</code>个元素开始到第<code>j-1</code>个元素的子序列。新的slice将只有<code>j-i</code>个元素。如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用<code>len(s)</code>代替。因此，<code>months[1:13]</code>切片操作将引用全部有效的月份，和<code>months[1:]</code>操作等价；<code>months[:]</code>切片操作则是引用整个数组。让我们分别定义表示第二季度和北方夏天月份的slice，它们有重叠部分：</p>
<pre class="language-go" data-language="go"><code class="language-go">Q2 <span class="token operator">:=</span> months<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">]</span>
summer <span class="token operator">:=</span> months<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">]</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>Q2<span class="token punctuation">)</span>     <span class="token comment">// ["April" "May" "June"]</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>summer<span class="token punctuation">)</span> <span class="token comment">// ["June" "July" "August"]</span></code></pre>

<p>两个slice都包含了六月份，下面的代码是一个包含相同月份的测试（性能较低）：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> s <span class="token operator">:=</span> <span class="token keyword">range</span> summer <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> q <span class="token operator">:=</span> <span class="token keyword">range</span> Q2 <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> s <span class="token operator">==</span> q <span class="token punctuation">&#123;</span>
            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s appears in both\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>如果切片操作超出<code>cap(s)</code>的上限将导致一个panic异常，但是超出<code>len(s)</code>则是意味着扩展了slice，因为新slice的长度会变大：</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>summer<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// panic: out of range</span>

endlessSummer <span class="token operator">:=</span> summer<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token comment">// extend a slice (within capacity)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>endlessSummer<span class="token punctuation">)</span>  <span class="token comment">// "[June July August September October]"</span></code></pre>

<p>另外，字符串的切片操作和[]byte字节类型切片的切片操作是类似的。都写作x[m:n]，并且都是返回一个原始字节序列的子序列，底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度。x[m:n]切片操作对于字符串则生成一个新字符串，如果x是[]byte的话则生成一个新的[]byte。</p>
<p>因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名。下面的reverse函数在原内存空间将<code>[]int</code>类型的slice反转，而且它可以用于任意长度的slice。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// reverse reverses a slice of ints in place.</span>
<span class="token keyword">func</span> <span class="token function">reverse</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token punctuation">,</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">&#123;</span>
        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>这里我们反转数组的应用：</p>
<pre class="language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span>
<span class="token function">reverse</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// "[5 4 3 2 1 0]"</span></code></pre>

<p>和数组不同的是，slice之间不能比较，因此我们不能使用&#x3D;&#x3D;操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的<code>bytes.Equal</code>函数来判断两个字节型slice是否相等（<code>[]byte</code>），但是对于其他类型的slice，我们必须自己展开每个元素进行比较：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">equal</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">len</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> x <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>为何slice不直接支持比较运算符呢？这方面有两个原因。</p>
<p>第一个原因，一个slice的元素是间接引用的，一个slice甚至可以包含自身（译注：当slice声明为[]interface{}时，slice的元素可以是自身）。虽然有很多办法处理这种情形，但是没有一个是简单有效的。</p>
<p>第二个原因，因为slice的元素是间接引用的，一个固定的slice值（译注：指slice本身的值，不是元素的值）在不同的时刻可能包含不同的元素，因为底层数组的元素可能会被修改。而例如Go语言中map的key只做简单的浅拷贝，它要求key在整个生命周期内保持不变性（译注：例如slice扩容，就会导致其本身的值&#x2F;地址变化）。而用深度相等判断的话，显然在map的key这种场合不合适。对于像指针或chan之类的引用类型，<code>==</code>相等测试可以判断两个是否是引用相同的对象。一个针对slice的浅相等测试的<code>==</code>操作符可能是有一定用处的，也能临时解决map类型的key问题，但是slice和数组不同的相等测试行为会让人困惑。因此，安全的做法是直接禁止slice之间的比较操作。</p>
</blockquote>
<p>slice唯一合法的比较操作是和nil比较，例如：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> summer <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span></code></pre>

<p>一个零值的slice等于<code>nil</code>。<strong>一个<code>nil</code>值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非<code>nil</code>值的slice的长度和容量也是0的，例如<code>[]int&#123;&#125;</code>或<code>make([]int, 3)[3:]</code>。</strong> 与任意类型的<code>nil</code>值一样，我们可以用<code>[]int(nil)</code>类型转换表达式来生成一个对应类型slice的<code>nil</code>值。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>    <span class="token comment">// len(s) == 0, s == nil</span>
s <span class="token operator">=</span> <span class="token boolean">nil</span>        <span class="token comment">// len(s) == 0, s == nil</span>
s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">int</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// len(s) == 0, s == nil</span>
s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// len(s) == 0, s != nil</span></code></pre>

<p><strong>如果你需要测试一个slice是否是空的，使用<code>len(s) == 0</code>来判断，而不应该用<code>s == nil</code>来判断。</strong> 除了和<code>nil</code>相等比较外，一个<code>nil</code>值的slice的行为和其它任意0长度的slice一样；例如<code>reverse(nil)</code>也是安全的。除了文档已经明确说明的地方，所有的Go语言函数应该以相同的方式对待<code>nil</code>值的slice和0长度的slice。</p>
<p><strong>内置的<code>make</code>函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>T<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">)</span>
<span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>T<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token punctuation">)</span> <span class="token comment">// same as make([]T, cap)[:len]</span></code></pre>

<p>在底层，<code>make</code>创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。在第一种语句中，slice是整个数组的view。在第二个语句中，slice只引用了底层数组的前<code>len</code>个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的。</p>
<h3 id="append函数"><a href="#append函数" class="headerlink" title="append函数"></a>append函数</h3><p>内置的<code>append</code>函数用于向slice追加元素：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> runes <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">rune</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> r <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token string">"Hello, 世界"</span> <span class="token punctuation">&#123;</span>
    runes <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>runes<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%q\n"</span><span class="token punctuation">,</span> runes<span class="token punctuation">)</span> <span class="token comment">// "['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']"</span></code></pre>

<p>在循环中使用<code>append</code>函数构建一个由9个rune字符构成的slice，当然对应这个特殊的问题我们可以通过Go语言内置的<code>[]rune(&quot;Hello, 世界&quot;)</code>转换操作完成。</p>
<p><strong>通常我们并不知道append调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。因此，通常是将append返回的结果直接赋值给输入的slice变量：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">runes <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>runes<span class="token punctuation">,</span> r<span class="token punctuation">)</span></code></pre>

<p>更新slice变量不仅对调用append函数是必要的，实际上对应任何可能导致长度、容量或底层数组变化的操作都是必要的。要正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是slice对应结构体本身的指针、长度和容量部分是直接访问的。要更新这些信息需要像上面例子那样一个显式的赋值操作。从这个角度看，slice并不是一个纯粹的引用类型，它实际上是一个类似下面结构体的聚合类型：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> IntSlice <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    ptr      <span class="token operator">*</span><span class="token builtin">int</span>
    <span class="token builtin">len</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>内置的<code>append</code>函数则可以追加多个元素，甚至追加一个slice。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
x <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
x <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
x <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>
x <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// append the slice x</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>      <span class="token comment">// "[1 2 3 4 5 6 1 2 3 4 5 6]"</span></code></pre>

<h3 id="Slice内存技巧"><a href="#Slice内存技巧" class="headerlink" title="Slice内存技巧"></a>Slice内存技巧</h3><p>让我们看看更多的例子。给定一个字符串列表，下面的<code>nonempty</code>函数将在原有slice内存空间之上返回不包含空字符串的列表：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Nonempty is an example of an in-place slice algorithm.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token comment">// nonempty returns a slice holding only the non-empty strings.</span>
<span class="token comment">// The underlying array is modified during the call.</span>
<span class="token keyword">func</span> <span class="token function">nonempty</span><span class="token punctuation">(</span>strings <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
    i <span class="token operator">:=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> s <span class="token operator">:=</span> <span class="token keyword">range</span> strings <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> s <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>
            strings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s
            i<span class="token operator">++</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> strings<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>比较微妙的地方是，输入的slice和输出的slice共享一个底层数组。这可以避免分配另一个数组，不过原来的数据将可能会被覆盖，正如下面两个打印语句看到的那样：</p>
<pre class="language-go" data-language="go"><code class="language-go">data <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%q\n"</span><span class="token punctuation">,</span> <span class="token function">nonempty</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// `["one" "three"]`</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%q\n"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>           <span class="token comment">// `["one" "three" "three"]`</span></code></pre>

<p>因此我们通常会这样使用<code>nonempty</code>函数：<code>data = nonempty(data)</code>。</p>
<p><code>nonempty</code>函数也可以使用<code>append</code>函数实现：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">nonempty2</span><span class="token punctuation">(</span>strings <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
    out <span class="token operator">:=</span> strings<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// zero-length slice of original</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> s <span class="token operator">:=</span> <span class="token keyword">range</span> strings <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> s <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>
            out <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> s<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> out
<span class="token punctuation">&#125;</span></code></pre>

<p>无论如何实现，以这种方式重用一个slice一般都要求最多为每个输入值产生一个输出值，事实上很多这类算法都是用来过滤或合并序列中相邻的元素。这种slice用法是比较复杂的技巧，虽然使用到了slice的一些技巧，但是对于某些场合是比较清晰和有效的。</p>
<p>一个slice可以用来模拟一个stack。最初给定的空slice对应一个空的stack，然后可以使用<code>append</code>函数将新的值压入stack：</p>
<pre class="language-go" data-language="go"><code class="language-go">stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token comment">// push v</span></code></pre>

<p>stack的顶部位置对应slice的最后一个元素：</p>
<pre class="language-go" data-language="go"><code class="language-go">top <span class="token operator">:=</span> stack<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// top of stack</span></code></pre>

<p>通过收缩stack可以弹出栈顶的元素</p>
<pre class="language-go" data-language="go"><code class="language-go">stack <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// pop</span></code></pre>

<p>要删除slice中间的某个元素并保存原有的元素顺序，可以通过内置的<code>copy</code>函数将后面的子slice向前依次移动一位完成：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">remove</span><span class="token punctuation">(</span>slice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    <span class="token function">copy</span><span class="token punctuation">(</span>slice<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> slice<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> slice<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">&#125;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">remove</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "[5 6 8 9]"</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>如果删除元素后不用保持原来顺序的话，我们可以简单的用最后一个元素覆盖被删除的元素：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">remove</span><span class="token punctuation">(</span>slice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    slice<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> slice<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> slice<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">&#125;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">remove</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "[5 6 9 8]</span></code></pre>

<p><strong>练习 4.3：</strong> 重写reverse函数，使用数组指针代替slice。</p>
<p><strong>练习 4.4：</strong> 编写一个rotate函数，通过一次循环完成旋转。</p>
<p><strong>练习 4.5：</strong> 写一个函数在原地完成消除<code>[]string</code>中相邻重复的字符串的操作。</p>
<p><strong>练习 4.6：</strong> 编写一个函数，原地将一个UTF-8编码的<code>[]byte</code>类型的slice中相邻的空格（参考<code>unicode.IsSpace</code>）替换成一个空格返回</p>
<p><strong>练习 4.7：</strong> 修改reverse函数用于原地反转UTF-8编码的<code>[]byte</code>。是否可以不用分配额外的内存？</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">reverse</span><span class="token punctuation">(</span>strings <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">rune</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">rune</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token function">len</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
		strings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> strings<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> strings<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> strings<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> strings
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	s <span class="token operator">:=</span> <span class="token string">"Hello, 世界"</span>
	s1 <span class="token operator">:=</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 界世 ,olleH</span>
<span class="token punctuation">&#125;</span></code></pre>



<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>哈希表是一种巧妙并且实用的数据结构。它是一个无序的key&#x2F;value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。</p>
<p>在Go语言中，一个map就是一个哈希表的引用，map类型可以写为<code>map[K]V</code>，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持<code>==</code>比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法，正如第三章提到的，最坏的情况是可能出现的NaN和任何浮点数都不相等。对于V对应的value数据类型则没有任何的限制。</p>
<p>内置的<code>make</code>函数可以创建一个map：</p>
<pre class="language-go" data-language="go"><code class="language-go">ages <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// mapping from strings to ints</span></code></pre>

<p>我们也可以用map字面值的语法创建map，同时还可以指定一些最初的key&#x2F;value：</p>
<pre class="language-go" data-language="go"><code class="language-go">ages <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span>
    <span class="token string">"alice"</span><span class="token punctuation">:</span>   <span class="token number">31</span><span class="token punctuation">,</span>
    <span class="token string">"charlie"</span><span class="token punctuation">:</span> <span class="token number">34</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>这相当于</p>
<pre class="language-go" data-language="go"><code class="language-go">ages <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
ages<span class="token punctuation">[</span><span class="token string">"alice"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">31</span>
ages<span class="token punctuation">[</span><span class="token string">"charlie"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">34</span></code></pre>

<p>因此，另一种创建空的map的表达式是<code>map[string]int&#123;&#125;</code>。</p>
<p>Map中的元素通过key对应的下标语法访问：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">ages[&quot;alice&quot;] &#x3D; 32
fmt.Println(ages[&quot;alice&quot;]) &#x2F;&#x2F; &quot;32&quot;</code></pre>

<p>使用内置的delete函数可以删除元素：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">delete(ages, &quot;alice&quot;) &#x2F;&#x2F; remove element ages[&quot;alice&quot;]</code></pre>

<p>所有这些操作是安全的，即使这些元素不在map中也没有关系；如果一个查找失败将返回value类型对应的零值，例如，即使map中不存在“bob”下面的代码也可以正常工作，因为<code>ages[&quot;bob&quot;]</code>失败时将返回0。</p>
<pre class="language-go" data-language="go"><code class="language-go">ages<span class="token punctuation">[</span><span class="token string">"bob"</span><span class="token punctuation">]</span> <span class="token operator">=</span> ages<span class="token punctuation">[</span><span class="token string">"bob"</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">// 1</span></code></pre>

<p>而且<code>x += y</code>和<code>x++</code>等简短赋值语法也可以用在map上，所以上面的代码可以改写成</p>
<pre class="language-go" data-language="go"><code class="language-go">ages<span class="token punctuation">[</span><span class="token string">"bob"</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span></code></pre>

<p>更简单的写法</p>
<pre class="language-go" data-language="go"><code class="language-go">ages<span class="token punctuation">[</span><span class="token string">"bob"</span><span class="token punctuation">]</span><span class="token operator">++</span></code></pre>

<p><strong>但是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token boolean">_</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>ages<span class="token punctuation">[</span><span class="token string">"bob"</span><span class="token punctuation">]</span> <span class="token comment">// compile error: cannot take address of map element</span></code></pre>

<p>禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</p>
<p>要想遍历map中全部的key&#x2F;value对的话，可以使用range风格的for循环实现，和之前的slice遍历语法类似。下面的迭代语句将在每次迭代时设置name和age变量，它们对应下一个键&#x2F;值对：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> name<span class="token punctuation">,</span> age <span class="token operator">:=</span> <span class="token keyword">range</span> ages <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s\t%d\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key&#x2F;value对，我们必须显式地对key进行排序，可以使用<code>sort</code>包的<code>Strings</code>函数对字符串slice进行排序。下面是常见的处理方式：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"sort"</span>

<span class="token keyword">var</span> names <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token keyword">for</span> name <span class="token operator">:=</span> <span class="token keyword">range</span> ages <span class="token punctuation">&#123;</span>
    names <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
sort<span class="token punctuation">.</span><span class="token function">Strings</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> name <span class="token operator">:=</span> <span class="token keyword">range</span> names <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s\t%d\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> ages<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>因为我们一开始就知道names的最终大小，因此给slice分配一个合适的大小将会更有效。下面的代码创建了一个空的slice，但是slice的容量刚好可以放下map中全部的key：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">names :&#x3D; make([]string, 0, len(ages))</code></pre>

<p>在上面的第一个range循环中，我们只关心map中的key，所以我们忽略了第二个循环变量。在第二个循环中，我们只关心names中的名字，所以我们使用“_”空白标识符来忽略第一个循环变量，也就是迭代slice时的索引。</p>
<p>map类型的零值是nil，也就是没有引用任何哈希表。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">var ages map[string]int
fmt.Println(ages &#x3D;&#x3D; nil)    &#x2F;&#x2F; &quot;true&quot;
fmt.Println(len(ages) &#x3D;&#x3D; 0) &#x2F;&#x2F; &quot;true&quot;</code></pre>

<p>map上的大部分操作，包括查找、删除、<code>len</code>和<code>range</code>循环都可以安全工作在<code>nil</code>值的map上，它们的行为和一个空的map类似。<strong>但是向一个<code>nil</code>值的map存入元素将导致一个panic异常：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">ages<span class="token punctuation">[</span><span class="token string">"carol"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">21</span> <span class="token comment">// panic: assignment to entry in nil map</span></code></pre>

<p>如果元素类型是一个数字，你可能需要区分一个已经存在的0，和不存在而返回零值的0，可以像下面这样测试：</p>
<pre class="language-go" data-language="go"><code class="language-go">age<span class="token punctuation">,</span> ok <span class="token operator">:=</span> ages<span class="token punctuation">[</span><span class="token string">"bob"</span><span class="token punctuation">]</span>
<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span> <span class="token comment">/* "bob" is not a key in this map; age == 0. */</span> <span class="token punctuation">&#125;</span></code></pre>

<p>你会经常看到将这两个结合起来使用，像这样：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> age<span class="token punctuation">,</span> ok <span class="token operator">:=</span> ages<span class="token punctuation">[</span><span class="token string">"bob"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span></code></pre>

<p>在这种场景下，map的下标语法将产生两个值；第二个是一个布尔值，用于报告元素是否真的存在。布尔变量一般命名为<code>ok</code>，特别适合马上用于if条件判断部分。</p>
<p><strong>和slice一样，map之间也不能进行相等比较；唯一的例外是和nil进行比较。要判断两个map是否包含相同的key和value，我们必须通过一个循环实现：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">equal</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">len</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> k<span class="token punctuation">,</span> xv <span class="token operator">:=</span> <span class="token keyword">range</span> x <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> yv<span class="token punctuation">,</span> ok <span class="token operator">:=</span> y<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token operator">||</span> yv <span class="token operator">!=</span> xv <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>从例子中可以看到如何用<code>!ok</code>来区分元素不存在，与元素存在但为0的。我们不能简单地用<code>xv != y[k]</code>判断，那样会导致在判断下面两个map时产生错误的结果：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; True if equal is written incorrectly.
equal(map[string]int&#123;&quot;A&quot;: 0&#125;, map[string]int&#123;&quot;B&quot;: 42&#125;)</code></pre>

<p>Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能。为了说明这一点，下面的dedup程序读取多行输入，但是只打印第一次出现的行。（它是1.3节中出现的dup程序的变体。）dedup程序通过map来表示所有的输入行所对应的set集合，以确保已经在集合存在的行不会被重复打印。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">func main() &#123;
    seen :&#x3D; make(map[string]bool) &#x2F;&#x2F; a set of strings
    input :&#x3D; bufio.NewScanner(os.Stdin)
    for input.Scan() &#123;
        line :&#x3D; input.Text()
        if !seen[line] &#123;
            seen[line] &#x3D; true
            fmt.Println(line)
        &#125;
    &#125;

    if err :&#x3D; input.Err(); err !&#x3D; nil &#123;
        fmt.Fprintf(os.Stderr, &quot;dedup: %v\n&quot;, err)
        os.Exit(1)
    &#125;
&#125;</code></pre>

<p>Go程序员将这种忽略value的map当作一个字符串集合，并非所有<code>map[string]bool</code>类型value都是无关紧要的；有一些则可能会同时包含true和false的值。</p>
<p>有时候我们需要一个map或set的key是slice类型，但是map的key必须是可比较的类型，但是slice并不满足这个条件。不过，我们可以通过两个步骤绕过这个限制。第一步，定义一个辅助函数k，将slice转为map对应的string类型的key，确保只有x和y相等时k(x) &#x3D;&#x3D; k(y)才成立。然后创建一个key为string类型的map，在每次对map操作时先用k辅助函数将slice转化为string类型。</p>
<p>下面的例子演示了如何使用map来记录提交相同的字符串列表的次数。它使用了fmt.Sprintf函数将字符串列表转换为一个字符串以用于map的key，通过%q参数忠实地记录每个字符串元素的信息：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">var m &#x3D; make(map[string]int)

func k(list []string) string &#123; return fmt.Sprintf(&quot;%q&quot;, list) &#125;

func Add(list []string)       &#123; m[k(list)]++ &#125;
func Count(list []string) int &#123; return m[k(list)] &#125;</code></pre>

<p>使用同样的技术可以处理任何不可比较的key类型，而不仅仅是slice类型。这种技术对于想使用自定义key比较函数的时候也很有用，例如在比较字符串的时候忽略大小写。同时，辅助函数<code>k(x)</code>也不一定是字符串类型，它可以返回任何可比较的类型，例如整数、数组或结构体等。</p>
<p>这是map的另一个例子，下面的程序用于统计输入中每个Unicode码点出现的次数。虽然Unicode全部码点的数量巨大，但是出现在特定文档中的字符种类并没有多少，使用map可以用比较自然的方式来跟踪那些出现过的字符的次数。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; Charcount computes counts of Unicode characters.
package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;os&quot;
    &quot;unicode&quot;
    &quot;unicode&#x2F;utf8&quot;
)

func main() &#123;
    counts :&#x3D; make(map[rune]int)    &#x2F;&#x2F; counts of Unicode characters
    var utflen [utf8.UTFMax + 1]int &#x2F;&#x2F; count of lengths of UTF-8 encodings
    invalid :&#x3D; 0                    &#x2F;&#x2F; count of invalid UTF-8 characters

    in :&#x3D; bufio.NewReader(os.Stdin)
    for &#123;
        r, n, err :&#x3D; in.ReadRune() &#x2F;&#x2F; returns rune, nbytes, error
        if err &#x3D;&#x3D; io.EOF &#123;
            break
        &#125;
        if err !&#x3D; nil &#123;
            fmt.Fprintf(os.Stderr, &quot;charcount: %v\n&quot;, err)
            os.Exit(1)
        &#125;
        if r &#x3D;&#x3D; unicode.ReplacementChar &amp;&amp; n &#x3D;&#x3D; 1 &#123;
            invalid++
            continue
        &#125;
        counts[r]++
        utflen[n]++
    &#125;
    fmt.Printf(&quot;rune\tcount\n&quot;)
    for c, n :&#x3D; range counts &#123;
        fmt.Printf(&quot;%q\t%d\n&quot;, c, n)
    &#125;
    fmt.Print(&quot;\nlen\tcount\n&quot;)
    for i, n :&#x3D; range utflen &#123;
        if i &gt; 0 &#123;
            fmt.Printf(&quot;%d\t%d\n&quot;, i, n)
        &#125;
    &#125;
    if invalid &gt; 0 &#123;
        fmt.Printf(&quot;\n%d invalid UTF-8 characters\n&quot;, invalid)
    &#125;
&#125;</code></pre>

<p><code>ReadRune</code>方法执行UTF-8解码并返回三个值：解码的rune字符的值，字符UTF-8编码后的长度，和一个错误值。我们可预期的错误值只有对应文件结尾的<code>io.EOF</code>。如果输入的是无效的UTF-8编码的字符，返回的将是<code>unicode.ReplacementChar</code>表示无效字符，并且编码长度是1。</p>
<p>charcount程序同时打印不同UTF-8编码长度的字符数目。对此，map并不是一个合适的数据结构；因为UTF-8编码的长度总是从1到<code>utf8.UTFMax</code>（最大是4个字节），使用数组将更有效。</p>
<p>Map的value类型也可以是一个聚合类型，比如是一个map或slice。在下面的代码中，图graph的key类型是一个字符串，value类型<code>map[string]bool</code>代表一个字符串集合。从概念上讲，graph将一个字符串类型的key映射到一组相关的字符串集合，它们指向新的graph的key。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">var graph &#x3D; make(map[string]map[string]bool)

func addEdge(from, to string) &#123;
    edges :&#x3D; graph[from]
    if edges &#x3D;&#x3D; nil &#123;
        edges &#x3D; make(map[string]bool)
        graph[from] &#x3D; edges
    &#125;
    edges[to] &#x3D; true
&#125;

func hasEdge(from, to string) bool &#123;
    return graph[from][to]
&#125;</code></pre>

<p>其中<code>addEdge</code>函数惰性初始化map是一个惯用方式，也就是说在每个值首次作为key时才初始化。<code>addEdge</code>函数显示了如何让map的零值也能正常工作；即使<code>from</code>到<code>to</code>的边不存在，<code>graph[from][to]</code>依然可以返回一个有意义的结果。</p>
<p><strong>练习 4.8：</strong> 修改charcount程序，使用<code>unicode.IsLetter</code>等相关的函数，统计字母、数字等Unicode中不同的字符类别。</p>
<p><strong>练习 4.9：</strong> 编写一个程序wordfreq程序，报告输入文本中每个单词出现的频率。在第一次调用Scan前先调用<code>input.Split(bufio.ScanWords)</code>函数，这样可以按单词而不是按行输入。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。用结构体的经典案例是处理公司的员工信息，每个员工信息包含一个唯一的员工编号、员工的名字、家庭住址、出生日期、工作岗位、薪资、上级领导等等。所有的这些信息都需要绑定到一个实体中，可以作为一个整体单元被复制，作为函数的参数或返回值，或者是被存储到数组中，等等。</p>
<p>下面两个语句声明了一个叫Employee的命名的结构体类型，并且声明了一个Employee类型的变量<code>dilbert</code>：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Employee <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    ID        <span class="token builtin">int</span>
    Name      <span class="token builtin">string</span>
    Address   <span class="token builtin">string</span>
    DoB       time<span class="token punctuation">.</span>Time
    Position  <span class="token builtin">string</span>
    Salary    <span class="token builtin">int</span>
    ManagerID <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> dilbert Employee</code></pre>

<p>dilbert结构体变量的成员可以通过点操作符访问，比如<code>dilbert.Name</code>和<code>dilbert.DoB</code>。因为dilbert是一个变量，它所有的成员也同样是变量，我们可以直接对每个成员赋值：</p>
<pre class="language-go" data-language="go"><code class="language-go">dilbert<span class="token punctuation">.</span>Salary <span class="token operator">-=</span> <span class="token number">5000</span> <span class="token comment">// demoted, for writing too few lines of code</span></code></pre>

<p>或者是对成员取地址，然后通过指针访问：</p>
<pre class="language-go" data-language="go"><code class="language-go">position <span class="token operator">:=</span> <span class="token operator">&amp;</span>dilbert<span class="token punctuation">.</span>Position
<span class="token operator">*</span>position <span class="token operator">=</span> <span class="token string">"Senior "</span> <span class="token operator">+</span> <span class="token operator">*</span>position <span class="token comment">// promoted, for outsourcing to Elbonia</span></code></pre>

<p>点操作符也可以和指向结构体的指针一起工作：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> employeeOfTheMonth <span class="token operator">*</span>Employee <span class="token operator">=</span> <span class="token operator">&amp;</span>dilbert
employeeOfTheMonth<span class="token punctuation">.</span>Position <span class="token operator">+=</span> <span class="token string">" (proactive team player)"</span></code></pre>

<p>相当于下面语句</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token punctuation">(</span><span class="token operator">*</span>employeeOfTheMonth<span class="token punctuation">)</span><span class="token punctuation">.</span>Position <span class="token operator">+=</span> <span class="token string">" (proactive team player)"</span></code></pre>

<p>下面的<code>EmployeeByID</code>函数将根据给定的员工ID返回对应的员工信息结构体的指针。我们可以使用点操作符来访问它里面的成员：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">EmployeeByID</span><span class="token punctuation">(</span>id <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>Employee <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span>

fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">EmployeeByID</span><span class="token punctuation">(</span>dilbert<span class="token punctuation">.</span>ManagerID<span class="token punctuation">)</span><span class="token punctuation">.</span>Position<span class="token punctuation">)</span> <span class="token comment">// "Pointy-haired boss"</span>

id <span class="token operator">:=</span> dilbert<span class="token punctuation">.</span>ID
<span class="token function">EmployeeByID</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span>Salary <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// fired for... no real reason</span></code></pre>

<p>后面的语句通过<code>EmployeeByID</code>返回的结构体指针更新了Employee结构体的成员。如果将<code>EmployeeByID</code>函数的返回值从<code>*Employee</code>指针类型改为Employee值类型，那么更新语句将不能编译通过，因为在赋值语句的左边并不确定是一个变量（译注：调用函数返回的是值，并不是一个可取地址的变量）。</p>
<p>通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行，就像下面的Name和Address成员那样：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Employee <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    ID            <span class="token builtin">int</span>
    Name<span class="token punctuation">,</span> Address <span class="token builtin">string</span>
    DoB           time<span class="token punctuation">.</span>Time
    Position      <span class="token builtin">string</span>
    Salary        <span class="token builtin">int</span>
    ManagerID     <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>结构体成员的输入顺序也有重要的意义。</strong>我们也可以将Position成员合并（因为也是字符串类型），或者是交换Name和Address出现的先后顺序，<strong>那样的话就是定义了不同的结构体类型。</strong>通常，我们只是将相关的成员写到一起。</p>
<p><strong>如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。</strong></p>
<p><strong>一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适用于数组。）但是S类型的结构体可以包含<code>*S</code>指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。</strong></p>
<p>在下面的代码中，我们使用一个二叉树来实现一个插入排序：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> tree <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    value       <span class="token builtin">int</span>
    left<span class="token punctuation">,</span> right <span class="token operator">*</span>tree
<span class="token punctuation">&#125;</span>

<span class="token comment">// Sort sorts values in place.</span>
<span class="token keyword">func</span> <span class="token function">Sort</span><span class="token punctuation">(</span>values <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> root <span class="token operator">*</span>tree
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> values <span class="token punctuation">&#123;</span>
        root <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">appendValues</span><span class="token punctuation">(</span>values<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// appendValues appends the elements of t to values in order</span>
<span class="token comment">// and returns the resulting slice.</span>
<span class="token keyword">func</span> <span class="token function">appendValues</span><span class="token punctuation">(</span>values <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> t <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> t <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        values <span class="token operator">=</span> <span class="token function">appendValues</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> t<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        values <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> t<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
        values <span class="token operator">=</span> <span class="token function">appendValues</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> t<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> values
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>t <span class="token operator">*</span>tree<span class="token punctuation">,</span> value <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>tree <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> t <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Equivalent to return &amp;tree&#123;value: value&#125;.</span>
        t <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span>
        t<span class="token punctuation">.</span>value <span class="token operator">=</span> value
        <span class="token keyword">return</span> t
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> value <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>value <span class="token punctuation">&#123;</span>
        t<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>left<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        t<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>right<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> t
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>结构体类型的零值是每个成员都是零值。通常会将零值作为最合理的默认值。</strong>例如，对于<code>bytes.Buffer</code>类型，结构体初始值就是一个随时可用的空缓存，还有<code>sync.Mutex</code>的零值也是有效的未锁定状态。<strong>有时候这种零值可用的特性是自然获得的，但是也有些类型需要一些额外的工作。</strong></p>
<p><strong>如果结构体没有任何成员的话就是空结构体，写作<code>struct&#123;&#125;</code>。它的大小为0，也不包含任何信息，但是有时候依然是有价值的。</strong>有些Go语言程序员用map来模拟set数据结构时，用它来代替map中布尔类型的value，只是强调key的重要性，但是因为节约的空间有限，而且语法比较复杂，所以我们通常会避免这样的用法。</p>
<pre class="language-go" data-language="go"><code class="language-go">seen <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">// set of strings</span>
<span class="token comment">// ...</span>
<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> seen<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>
    seen<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token comment">// ...first time seeing s...</span>
<span class="token punctuation">&#125;</span></code></pre>



<h3 id="结构体字面值"><a href="#结构体字面值" class="headerlink" title="结构体字面值"></a>结构体字面值</h3><p><strong>结构体值也可以用结构体字面值表示，结构体字面值可以指定每个成员的值。</strong></p>
<p><strong>有2种形式的结构体字面值语法：</strong></p>
<ul>
<li>写法1：要求以结构体成员定义的顺序为每个结构体成员指定一个字面值。它要求写代码和读代码的人要记住结构体的每个成员的类型和顺序，不过结构体成员有细微的调整就可能导致上述代码不能编译。因此，上述的语法一般只在定义结构体的包内部使用，或者是在较小的结构体中使用，这些结构体的成员排列比较规则，比如<code>image.Point&#123;x, y&#125;</code>或<code>color.RGBA&#123;red, green, blue, alpha&#125;</code>：</li>
</ul>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Point <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> X<span class="token punctuation">,</span> Y <span class="token builtin">int</span> <span class="token punctuation">&#125;</span>

p <span class="token operator">:=</span> Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span></code></pre>

<ul>
<li>写法2：以成员名字和相应的值来初始化，可以包含部分或全部的成员。如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要。如1.4节的Lissajous程序的写法：</li>
</ul>
<pre class="language-go" data-language="go"><code class="language-go">anim <span class="token operator">:=</span> gif<span class="token punctuation">.</span>GIF<span class="token punctuation">&#123;</span>LoopCount<span class="token punctuation">:</span> nframes<span class="token punctuation">&#125;</span></code></pre>

<p>**2种不同形式的写法不能混合使用。而且，你不能企图在外部包中用第一种顺序赋值的技巧来偷偷地初始化结构体中未导出的成员：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> p
<span class="token keyword">type</span> T <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> a<span class="token punctuation">,</span> b <span class="token builtin">int</span> <span class="token punctuation">&#125;</span> <span class="token comment">// a and b are not exported</span>

<span class="token keyword">package</span> q
<span class="token keyword">import</span> <span class="token string">"p"</span>
<span class="token keyword">var</span> <span class="token boolean">_</span> <span class="token operator">=</span> p<span class="token punctuation">.</span>T<span class="token punctuation">&#123;</span>a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span> <span class="token comment">// compile error: can't reference a, b</span>
<span class="token keyword">var</span> <span class="token boolean">_</span> <span class="token operator">=</span> p<span class="token punctuation">.</span>T<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>       <span class="token comment">// compile error: can't reference a, b</span></code></pre>

<p>虽然上面最后一行代码的编译错误信息中并没有显式提到未导出的成员，但是这样企图隐式使用未导出成员的行为也是不允许的。</p>
<p><strong>结构体可以作为函数的参数和返回值。</strong>例如，这个Scale函数将Point类型的值缩放后返回：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Scale</span><span class="token punctuation">(</span>p Point<span class="token punctuation">,</span> factor <span class="token builtin">int</span><span class="token punctuation">)</span> Point <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> Point<span class="token punctuation">&#123;</span>p<span class="token punctuation">.</span>X <span class="token operator">*</span> factor<span class="token punctuation">,</span> p<span class="token punctuation">.</span>Y <span class="token operator">*</span> factor<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">Scale</span><span class="token punctuation">(</span>Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "&#123;5 10&#125;"</span></code></pre>

<p><strong>如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Bonus</span><span class="token punctuation">(</span>e <span class="token operator">*</span>Employee<span class="token punctuation">,</span> percent <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> e<span class="token punctuation">.</span>Salary <span class="token operator">*</span> percent <span class="token operator">/</span> <span class="token number">100</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">AwardAnnualRaise</span><span class="token punctuation">(</span>e <span class="token operator">*</span>Employee<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    e<span class="token punctuation">.</span>Salary <span class="token operator">=</span> e<span class="token punctuation">.</span>Salary <span class="token operator">*</span> <span class="token number">105</span> <span class="token operator">/</span> <span class="token number">100</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>因为结构体通常通过指针处理，可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">pp <span class="token operator">:=</span> <span class="token operator">&amp;</span>Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span></code></pre>

<p><strong>它和下面的语句是等价的：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">pp <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Point<span class="token punctuation">)</span>
<span class="token operator">*</span>pp <span class="token operator">=</span> Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span></code></pre>

<p>不过<code>&amp;Point&#123;1, 2&#125;</code>写法可以直接在表达式中使用，比如一个函数调用。</p>
<h3 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h3><p><strong>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用<code>==</code>或<code>!=</code>运算符进行比较。相等比较运算符<code>==</code>将比较两个结构体的每个成员，因此下面两个比较的表达式是等价的：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Point <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> X<span class="token punctuation">,</span> Y <span class="token builtin">int</span> <span class="token punctuation">&#125;</span>

p <span class="token operator">:=</span> Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>
q <span class="token operator">:=</span> Point<span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>X <span class="token operator">==</span> q<span class="token punctuation">.</span>X <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>Y <span class="token operator">==</span> q<span class="token punctuation">.</span>Y<span class="token punctuation">)</span> <span class="token comment">// "false"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p <span class="token operator">==</span> q<span class="token punctuation">)</span>                   <span class="token comment">// "false"</span></code></pre>

<p><strong>可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> address <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    hostname <span class="token builtin">string</span>
    port     <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

hits <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span>address<span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
hits<span class="token punctuation">[</span>address<span class="token punctuation">&#123;</span><span class="token string">"golang.org"</span><span class="token punctuation">,</span> <span class="token number">443</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token operator">++</span></code></pre>

<h3 id="结构体嵌入和匿名成员"><a href="#结构体嵌入和匿名成员" class="headerlink" title="结构体嵌入和匿名成员"></a>结构体嵌入和匿名成员</h3><p>使用Go语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，这样就可以通过简单的点运算符<code>x.f</code>来访问匿名成员链中嵌套的<code>x.d.e.f</code>成员。</p>
<p>考虑一个二维的绘图程序，提供了一个各种图形的库，例如矩形、椭圆形、星形和轮形等几何形状。这里是其中两个的定义：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Circle <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> Radius <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Wheel <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> Radius<span class="token punctuation">,</span> Spokes <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>一个Circle代表的圆形类型包含了标准圆心的X和Y坐标信息，和一个Radius表示的半径信息。一个Wheel轮形除了包含Circle类型所有的全部成员外，还增加了Spokes表示径向辐条的数量。我们可以这样创建一个wheel变量：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> w Wheel
w<span class="token punctuation">.</span>X <span class="token operator">=</span> <span class="token number">8</span>
w<span class="token punctuation">.</span>Y <span class="token operator">=</span> <span class="token number">8</span>
w<span class="token punctuation">.</span>Radius <span class="token operator">=</span> <span class="token number">5</span>
w<span class="token punctuation">.</span>Spokes <span class="token operator">=</span> <span class="token number">20</span></code></pre>

<p>随着库中几何形状数量的增多，我们一定会注意到它们之间的相似和重复之处，所以我们可能为了便于维护而将相同的属性独立出来：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Point <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    X<span class="token punctuation">,</span> Y <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Circle <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Center Point
    Radius <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Wheel <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Circle Circle
    Spokes <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>这样改动之后结构体类型变的清晰了，但是这种修改同时也导致了访问每个成员变得繁琐：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> w Wheel
w<span class="token punctuation">.</span>Circle<span class="token punctuation">.</span>Center<span class="token punctuation">.</span>X <span class="token operator">=</span> <span class="token number">8</span>
w<span class="token punctuation">.</span>Circle<span class="token punctuation">.</span>Center<span class="token punctuation">.</span>Y <span class="token operator">=</span> <span class="token number">8</span>
w<span class="token punctuation">.</span>Circle<span class="token punctuation">.</span>Radius <span class="token operator">=</span> <span class="token number">5</span>
w<span class="token punctuation">.</span>Spokes <span class="token operator">=</span> <span class="token number">20</span></code></pre>

<p><strong>Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫<em>匿名成员</em>。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。</strong>下面的代码中，Circle和Wheel各自都有一个匿名成员。我们可以说Point类型被嵌入到了Circle结构体，同时Circle类型被嵌入到了Wheel结构体。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Circle <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Point
    Radius <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Wheel <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Circle
    Spokes <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>得益于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> w Wheel
w<span class="token punctuation">.</span>X <span class="token operator">=</span> <span class="token number">8</span>            <span class="token comment">// equivalent to w.Circle.Point.X = 8</span>
w<span class="token punctuation">.</span>Y <span class="token operator">=</span> <span class="token number">8</span>            <span class="token comment">// equivalent to w.Circle.Point.Y = 8</span>
w<span class="token punctuation">.</span>Radius <span class="token operator">=</span> <span class="token number">5</span>       <span class="token comment">// equivalent to w.Circle.Radius = 5</span>
w<span class="token punctuation">.</span>Spokes <span class="token operator">=</span> <span class="token number">20</span></code></pre>

<p><strong>在右边的注释中给出的显式形式访问这些叶子成员的语法依然有效，因此匿名成员并不是真的无法访问了。其中匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。我们在访问子成员的时候可以忽略任何匿名成员部分。</strong></p>
<p><strong>不幸的是，结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">w <span class="token operator">=</span> Wheel<span class="token punctuation">&#123;</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span>                       <span class="token comment">// compile error: unknown fields</span>
w <span class="token operator">=</span> Wheel<span class="token punctuation">&#123;</span>X<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">,</span> Y<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">,</span> Radius<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> Spokes<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span> <span class="token comment">// compile error: unknown fields</span></code></pre>

<p><strong>结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">w <span class="token operator">=</span> Wheel<span class="token punctuation">&#123;</span>Circle<span class="token punctuation">&#123;</span>Point<span class="token punctuation">&#123;</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span>

w <span class="token operator">=</span> Wheel<span class="token punctuation">&#123;</span>
    Circle<span class="token punctuation">:</span> Circle<span class="token punctuation">&#123;</span>
        Point<span class="token punctuation">:</span>  Point<span class="token punctuation">&#123;</span>X<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">,</span> Y<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        Radius<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    Spokes<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token comment">// NOTE: trailing comma necessary here (and at Radius)</span>
<span class="token punctuation">&#125;</span>

fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v\n"</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span>
<span class="token comment">// Output:</span>
<span class="token comment">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span>

w<span class="token punctuation">.</span>X <span class="token operator">=</span> <span class="token number">42</span>

fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v\n"</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span>
<span class="token comment">// Output:</span>
<span class="token comment">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></code></pre>

<p><strong>需要注意的是<code>Printf</code>函数中<code>%v</code>参数包含的<code>#</code>副词，它表示用和Go语言类似的语法打印值。对于结构体类型来说，将包含每个成员的名字。</strong></p>
<p><strong>因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。</strong></p>
<p><strong>同时，因为成员的名字是由其类型隐式地决定的，所以匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">w<span class="token punctuation">.</span>X <span class="token operator">=</span> <span class="token number">8</span> <span class="token comment">// equivalent to w.circle.point.X = 8</span></code></pre>

<p><strong>但是在包外部，因为circle和point没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。</strong></p>
<p><strong>我们将会看到匿名成员并不要求是结构体类型；其实任何命名的类型都可以作为结构体的匿名成员。</strong>但是为什么要嵌入一个没有任何子成员类型的匿名成员类型呢？</p>
<p><strong>答案是匿名类型的方法集。简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一些有简单行为的对象组合成有复杂行为的对象。组合是Go语言中面向对象编程的核心。</strong></p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。在类似的协议中，JSON并不是唯一的一个标准协议。 XML、ASN.1和Google的Protocol Buffers都是类似的协议，并且有各自的特色，但是由于简洁性、可读性和流行程度等原因，JSON是应用最广泛的一个。</p>
<p>Go语言对于这些标准格式的编码和解码都有良好的支持，由标准库中的<code>encoding/json</code>、<code>encoding/xml</code>、<code>encoding/asn1</code>等包提供支持（译注：Protocol Buffers的支持由 <code>github.com/golang/protobuf</code> 包提供），并且这类包都有着相似的API接口。本节，我们将对重要的<code>encoding/json</code>包的用法做个概述。</p>
<p>JSON是对JavaScript中各种类型的值——字符串、数字、布尔值和对象——Unicode本文编码。它可以用有效可读的方式表示基础数据类型和数组、slice、结构体和map等聚合数据类型。</p>
<p>基本的JSON类型有数字（十进制或科学记数法）、布尔值（<code>true</code>或<code>false</code>）、字符串，其中字符串是以双引号包含的Unicode字符序列，支持和Go语言类似的反斜杠转义特性，不过JSON使用的是<code>\Uhhhh</code>转义数字来表示一个UTF-16编码（译注：UTF-16和UTF-8一样是一种变长的编码，有些Unicode码点较大的字符需要用4个字节表示；而且UTF-16还有大端和小端的问题），而不是Go语言的rune类型。</p>
<p>这些基础类型可以通过JSON的数组和对象类型进行递归组合。一个JSON数组是一个有序的值序列，写在一个方括号中并以逗号分隔；一个JSON数组可以用于编码Go语言的数组和slice。一个JSON对象是一个字符串到值的映射，写成一系列的name:value对形式，用花括号包含并以逗号分隔；JSON的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体。例如：</p>
<pre class="language-go" data-language="go"><code class="language-go">boolean         <span class="token boolean">true</span>
number          <span class="token operator">-</span><span class="token number">273.15</span>
<span class="token builtin">string</span>          <span class="token string">"She said \"Hello, BF\""</span>
array           <span class="token punctuation">[</span><span class="token string">"gold"</span><span class="token punctuation">,</span> <span class="token string">"silver"</span><span class="token punctuation">,</span> <span class="token string">"bronze"</span><span class="token punctuation">]</span>
object          <span class="token punctuation">&#123;</span><span class="token string">"year"</span><span class="token punctuation">:</span> <span class="token number">1980</span><span class="token punctuation">,</span>
                 <span class="token string">"event"</span><span class="token punctuation">:</span> <span class="token string">"archery"</span><span class="token punctuation">,</span>
                 <span class="token string">"medals"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"gold"</span><span class="token punctuation">,</span> <span class="token string">"silver"</span><span class="token punctuation">,</span> <span class="token string">"bronze"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre>

<p>考虑一个应用程序，该程序负责收集各种电影评论并提供反馈功能。它的Movie数据类型和一个典型的表示电影的值列表如下所示。（在结构体声明中，Year和Color成员后面的字符串面值是结构体成员Tag；我们稍后会解释它的作用。）</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Movie <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Title  <span class="token builtin">string</span>
    Year   <span class="token builtin">int</span>  <span class="token string">`json:"released"`</span>
    Color  <span class="token builtin">bool</span> <span class="token string">`json:"color,omitempty"`</span>
    Actors <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> movies <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Movie<span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#123;</span>Title<span class="token punctuation">:</span> <span class="token string">"Casablanca"</span><span class="token punctuation">,</span> Year<span class="token punctuation">:</span> <span class="token number">1942</span><span class="token punctuation">,</span> Color<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        Actors<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"Humphrey Bogart"</span><span class="token punctuation">,</span> <span class="token string">"Ingrid Bergman"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span>Title<span class="token punctuation">:</span> <span class="token string">"Cool Hand Luke"</span><span class="token punctuation">,</span> Year<span class="token punctuation">:</span> <span class="token number">1967</span><span class="token punctuation">,</span> Color<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        Actors<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"Paul Newman"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span>Title<span class="token punctuation">:</span> <span class="token string">"Bullitt"</span><span class="token punctuation">,</span> Year<span class="token punctuation">:</span> <span class="token number">1968</span><span class="token punctuation">,</span> Color<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        Actors<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"Steve McQueen"</span><span class="token punctuation">,</span> <span class="token string">"Jacqueline Bisset"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>这样的数据结构特别适合JSON格式，并且在两者之间相互转换也很容易。将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。编组通过调用<code>json.Marshal</code>函数完成：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">data, err :&#x3D; json.Marshal(movies)
if err !&#x3D; nil &#123;
    log.Fatalf(&quot;JSON marshaling failed: %s&quot;, err)
&#125;
fmt.Printf(&quot;%s\n&quot;, data)</code></pre>

<p>Marshal函数返回一个编码后的字节slice，包含很长的字符串，并且没有空白缩进；我们将它折行以便于显示：</p>
<pre class="language-none"><code class="language-none">[&#123;&quot;Title&quot;:&quot;Casablanca&quot;,&quot;released&quot;:1942,&quot;Actors&quot;:[&quot;Humphrey Bogart&quot;,&quot;Ingr
id Bergman&quot;]&#125;,&#123;&quot;Title&quot;:&quot;Cool Hand Luke&quot;,&quot;released&quot;:1967,&quot;color&quot;:true,&quot;Ac
tors&quot;:[&quot;Paul Newman&quot;]&#125;,&#123;&quot;Title&quot;:&quot;Bullitt&quot;,&quot;released&quot;:1968,&quot;color&quot;:true,&quot;
Actors&quot;:[&quot;Steve McQueen&quot;,&quot;Jacqueline Bisset&quot;]&#125;]</code></pre>

<p>这种紧凑的表示形式虽然包含了全部的信息，但是很难阅读。为了生成便于阅读的格式，另一个json.MarshalIndent函数将产生整齐缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">data, err :&#x3D; json.MarshalIndent(movies, &quot;&quot;, &quot;    &quot;)
if err !&#x3D; nil &#123;
    log.Fatalf(&quot;JSON marshaling failed: %s&quot;, err)
&#125;
fmt.Printf(&quot;%s\n&quot;, data)</code></pre>

<p>上面的代码将产生这样的输出（译注：在最后一个成员或元素后面并没有逗号分隔符）：</p>
<pre class="language-Json" data-language="Json"><code class="language-Json">[
    &#123;
        &quot;Title&quot;: &quot;Casablanca&quot;,
        &quot;released&quot;: 1942,
        &quot;Actors&quot;: [
            &quot;Humphrey Bogart&quot;,
            &quot;Ingrid Bergman&quot;
        ]
    &#125;,
    &#123;
        &quot;Title&quot;: &quot;Cool Hand Luke&quot;,
        &quot;released&quot;: 1967,
        &quot;color&quot;: true,
        &quot;Actors&quot;: [
            &quot;Paul Newman&quot;
        ]
    &#125;,
    &#123;
        &quot;Title&quot;: &quot;Bullitt&quot;,
        &quot;released&quot;: 1968,
        &quot;color&quot;: true,
        &quot;Actors&quot;: [
            &quot;Steve McQueen&quot;,
            &quot;Jacqueline Bisset&quot;
        ]
    &#125;
]</code></pre>

<p>在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。</p>
<p>细心的读者可能已经注意到，其中<code>Year</code>名字的成员在编码后变成了<code>released</code>，还有<code>Color</code>成员编码后变成了小写字母开头的<code>color</code>。这是因为结构体成员Tag所导致的。一个结构体成员Tag是和在编译阶段关联到该成员的元信息字符串：</p>
<pre class="language-go" data-language="go"><code class="language-go">Year  <span class="token builtin">int</span>  <span class="token string">`json:"released"`</span>
Color <span class="token builtin">bool</span> <span class="token string">`json:"color,omitempty"`</span></code></pre>

<p>结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的<code>key:&quot;value&quot;</code>键值对序列；因为值中含有双引号字符，因此成员Tag一般用原生字符串面值的形式书写。<code>json</code>开头键名对应的值用于控制<code>encoding/json</code>包的编码和解码的行为，并且encoding&#x2F;…下面其它的包也遵循这个约定。成员Tag中json对应值的第一部分用于指定JSON对象的名字，比如将Go语言中的<code>TotalCount</code>成员对应到JSON中的<code>total_count</code>对象。Color成员的Tag还带了一个额外的<code>omitempty</code>选项，表示当Go语言结构体成员为空或零值时不生成该JSON对象（这里<code>false</code>为零值）。果然，Casablanca是一个黑白电影，并没有输出Color成员。</p>
<p>编码的逆操作是解码，对应将JSON数据解码为Go语言的数据结构，Go语言中一般叫unmarshaling，通过<code>json.Unmarshal</code>函数完成。下面的代码将JSON格式的电影数据解码为一个结构体slice，结构体中只有Title成员。通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员。当<code>Unmarshal</code>函数调用返回，slice将被只含有Title信息的值填充，其它JSON成员将被忽略。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> titles <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">&#123;</span> Title <span class="token builtin">string</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">if</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token operator">&amp;</span>titles<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
    log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"JSON unmarshaling failed: %s"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>titles<span class="token punctuation">)</span> <span class="token comment">// "[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]"</span></code></pre>

<p>许多web服务都提供JSON接口，通过HTTP接口发送JSON格式请求并返回JSON格式的信息。为了说明这一点，我们通过Github的issue查询服务来演示类似的用法。首先，我们要定义合适的类型和常量：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; Package github provides a Go API for the GitHub issue tracker.
&#x2F;&#x2F; See https:&#x2F;&#x2F;developer.github.com&#x2F;v3&#x2F;search&#x2F;#search-issues.
package github

import &quot;time&quot;

const IssuesURL &#x3D; &quot;https:&#x2F;&#x2F;api.github.com&#x2F;search&#x2F;issues&quot;

type IssuesSearchResult struct &#123;
    TotalCount int &#96;json:&quot;total_count&quot;&#96;
    Items          []*Issue
&#125;

type Issue struct &#123;
    Number    int
    HTMLURL   string &#96;json:&quot;html_url&quot;&#96;
    Title     string
    State     string
    User      *User
    CreatedAt time.Time &#96;json:&quot;created_at&quot;&#96;
    Body      string    &#x2F;&#x2F; in Markdown format
&#125;

type User struct &#123;
    Login   string
    HTMLURL string &#96;json:&quot;html_url&quot;&#96;
&#125;</code></pre>

<p>和前面一样，即使对应的JSON对象名是小写字母，每个结构体的成员名也是声明为大写字母开头的。因为有些JSON成员名字和Go结构体成员名字并不相同，因此需要Go语言结构体成员Tag来指定对应的JSON名字。同样，在解码的时候也需要做同样的处理，GitHub服务返回的信息比我们定义的要多很多。</p>
<p><code>SearchIssues</code>函数发出一个HTTP请求，然后解码返回的JSON格式的结果。因为用户提供的查询条件可能包含类似<code>?</code>和<code>&amp;</code>之类的特殊字符，为了避免对URL造成冲突，我们用<code>url.QueryEscape</code>来对查询中的特殊字符进行转义操作。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">package github

import (
    &quot;encoding&#x2F;json&quot;
    &quot;fmt&quot;
    &quot;net&#x2F;http&quot;
    &quot;net&#x2F;url&quot;
    &quot;strings&quot;
)

&#x2F;&#x2F; SearchIssues queries the GitHub issue tracker.
func SearchIssues(terms []string) (*IssuesSearchResult, error) &#123;
    q :&#x3D; url.QueryEscape(strings.Join(terms, &quot; &quot;))
    resp, err :&#x3D; http.Get(IssuesURL + &quot;?q&#x3D;&quot; + q)
    if err !&#x3D; nil &#123;
        return nil, err
    &#125;

    &#x2F;&#x2F; We must close resp.Body on all execution paths.
    &#x2F;&#x2F; (Chapter 5 presents &#39;defer&#39;, which makes this simpler.)
    if resp.StatusCode !&#x3D; http.StatusOK &#123;
        resp.Body.Close()
        return nil, fmt.Errorf(&quot;search query failed: %s&quot;, resp.Status)
    &#125;

    var result IssuesSearchResult
    if err :&#x3D; json.NewDecoder(resp.Body).Decode(&amp;result); err !&#x3D; nil &#123;
        resp.Body.Close()
        return nil, err
    &#125;
    resp.Body.Close()
    return &amp;result, nil
&#125;</code></pre>

<p>在早些的例子中，我们使用了json.Unmarshal函数来将JSON格式的字符串解码为字节slice。但是这个例子中，我们使用了基于流式的解码器json.Decoder，它可以从一个输入流解码JSON数据，尽管这不是必须的。如您所料，还有一个针对输出流的json.Encoder编码对象。</p>
<p>我们调用Decode方法来填充变量。这里有多种方法可以格式化结构。下面是最简单的一种，以一个固定宽度打印每个issue，但是在下一节我们将看到如何利用模板来输出复杂的格式。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; Issues prints a table of GitHub issues matching the search terms.
package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;os&quot;

    &quot;gopl.io&#x2F;ch4&#x2F;github&quot;
)

func main() &#123;
    result, err :&#x3D; github.SearchIssues(os.Args[1:])
    if err !&#x3D; nil &#123;
        log.Fatal(err)
    &#125;
    fmt.Printf(&quot;%d issues:\n&quot;, result.TotalCount)
    for _, item :&#x3D; range result.Items &#123;
        fmt.Printf(&quot;#%-5d %9.9s %.55s\n&quot;,
            item.Number, item.User.Login, item.Title)
    &#125;
&#125;</code></pre>

<p>通过命令行参数指定检索条件。下面的命令是查询Go语言项目中和JSON解码相关的问题，还有查询返回的结果：</p>
<pre class="language-none"><code class="language-none">$ go build gopl.io&#x2F;ch4&#x2F;issues
$ .&#x2F;issues repo:golang&#x2F;go is:open json decoder
13 issues:
#5680    eaigner encoding&#x2F;json: set key converter on en&#x2F;decoder
#6050  gopherbot encoding&#x2F;json: provide tokenizer
#8658  gopherbot encoding&#x2F;json: use bufio
#8462  kortschak encoding&#x2F;json: UnmarshalText confuses json.Unmarshal
#5901        rsc encoding&#x2F;json: allow override type marshaling
#9812  klauspost encoding&#x2F;json: string tag not symmetric
#7872  extempora encoding&#x2F;json: Encoder internally buffers full output
#9650    cespare encoding&#x2F;json: Decoding gives errPhase when unmarshalin
#6716  gopherbot encoding&#x2F;json: include field name in unmarshal error me
#6901  lukescott encoding&#x2F;json, encoding&#x2F;xml: option to treat unknown fi
#6384    joeshaw encoding&#x2F;json: encode precise floating point integers u
#6647    btracey x&#x2F;tools&#x2F;cmd&#x2F;godoc: display type kind of each named type
#4237  gjemiller encoding&#x2F;base64: URLEncoding padding is optional</code></pre>

<h2 id="文本和HTML模板"><a href="#文本和HTML模板" class="headerlink" title="文本和HTML模板"></a>文本和HTML模板</h2><p>如果只是最简单的格式化，使用<code>Printf</code>是完全足够的。但是有时候会需要复杂的打印格式，这时候一般需要将格式化代码分离出来以便更安全地修改。这些功能是由<code>text/template</code>和<code>html/template</code>等模板包提供的，它们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。</p>
<p>一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的<code>&#123;&#123;action&#125;&#125;</code>对象。大部分的字符串只是按字面值打印，但是对于actions部分将触发其它的行为。每个actions都包含了一个用模板语言书写的表达式，一个action虽然简短但是可以输出复杂的打印值，模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流if-else语句和range循环语句，还有其它实例化模板等诸多特性。下面是一个简单的模板字符串：</p>
<p><em>gopl.io&#x2F;ch4&#x2F;issuesreport</em></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> templ <span class="token operator">=</span> <span class="token string">`&#123;&#123;.TotalCount&#125;&#125; issues:
&#123;&#123;range .Items&#125;&#125;----------------------------------------
Number: &#123;&#123;.Number&#125;&#125;
User:   &#123;&#123;.User.Login&#125;&#125;
Title:  &#123;&#123;.Title | printf "%.64s"&#125;&#125;
Age:    &#123;&#123;.CreatedAt | daysAgo&#125;&#125; days
&#123;&#123;end&#125;&#125;`</span></code></pre>

<p>这个模板先打印匹配到的issue总数，然后打印每个issue的编号、创建用户、标题还有存在的时间。对于每一个action，都有一个当前值的概念，对应点操作符，写作<code>.</code>。当前值“.”最初被初始化为调用模板时的参数，在当前例子中对应<code>github.IssuesSearchResult</code>类型的变量。模板中<code>&#123;&#123;.TotalCount&#125;&#125;</code>对应action将展开为结构体中<code>TotalCount</code>成员以默认的方式打印的值。模板中<code>&#123;&#123;range .Items&#125;&#125;</code>和<code>&#123;&#123;end&#125;&#125;</code>对应一个循环action，因此它们之间的内容可能会被展开多次，循环每次迭代的当前值对应当前的Items元素的值。</p>
<p>在一个action中，<code>|</code>操作符表示将前一个表达式的结果作为后一个函数的输入，类似于UNIX中管道的概念。在<code>Title</code>这一行的<code>action</code>中，第二个操作是一个<code>printf</code>函数，是一个基于<code>fmt.Sprintf</code>实现的内置函数，所有模板都可以直接使用。对于<code>Age</code>部分，第二个动作是一个叫<code>daysAgo</code>的函数，通过<code>time.Since</code>函数将<code>CreatedAt</code>成员转换为过去的时间长度：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">func daysAgo(t time.Time) int &#123;
    return int(time.Since(t).Hours() &#x2F; 24)
&#125;</code></pre>

<p>需要注意的是<code>CreatedAt</code>的参数类型是<code>time.Time</code>，并不是字符串。以同样的方式，我们可以通过定义一些方法来控制字符串的格式化（§2.5），一个类型同样可以定制自己的JSON编码和解码行为。<code>time.Time</code>类型对应的JSON值是一个标准时间格式的字符串。</p>
<p>生成模板的输出需要两个处理步骤。第一步是要分析模板并转为内部表示，然后基于指定的输入执行模板。分析模板部分一般只需要执行一次。下面的代码创建并分析上面定义的模板<code>templ</code>。注意方法调用链的顺序：<code>template.New</code>先创建并返回一个模板；<code>Funcs</code>方法将<code>daysAgo</code>等自定义函数注册到模板中，并返回模板；最后调用<code>Parse</code>函数分析模板。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">report, err :&#x3D; template.New(&quot;report&quot;).
    Funcs(template.FuncMap&#123;&quot;daysAgo&quot;: daysAgo&#125;).
    Parse(templ)
if err !&#x3D; nil &#123;
    log.Fatal(err)
&#125;</code></pre>

<p>因为模板通常在编译时就测试好了，如果模板解析失败将是一个致命的错误。<code>template.Must</code>辅助函数可以简化这个致命错误的处理：它接受一个模板和一个error类型的参数，检测error是否为<code>nil</code>（如果不是nil则发出panic异常），然后返回传入的模板。</p>
<p>一旦模板已经创建、注册了<code>daysAgo</code>函数、并通过分析和检测，我们就可以使用<code>github.IssuesSearchResult</code>作为输入源、<code>os.Stdout</code>作为输出源来执行模板：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">var report &#x3D; template.Must(template.New(&quot;issuelist&quot;).
    Funcs(template.FuncMap&#123;&quot;daysAgo&quot;: daysAgo&#125;).
    Parse(templ))

func main() &#123;
    result, err :&#x3D; github.SearchIssues(os.Args[1:])
    if err !&#x3D; nil &#123;
        log.Fatal(err)
    &#125;
    if err :&#x3D; report.Execute(os.Stdout, result); err !&#x3D; nil &#123;
        log.Fatal(err)
    &#125;
&#125;</code></pre>

<p>程序输出一个纯文本报告：</p>
<pre class="language-none"><code class="language-none">$ go build gopl.io&#x2F;ch4&#x2F;issuesreport
$ .&#x2F;issuesreport repo:golang&#x2F;go is:open json decoder
13 issues:
----------------------------------------
Number: 5680
User:      eaigner
Title:     encoding&#x2F;json: set key converter on en&#x2F;decoder
Age:       750 days
----------------------------------------
Number: 6050
User:      gopherbot
Title:     encoding&#x2F;json: provide tokenizer
Age:       695 days
----------------------------------------
...</code></pre>

<p>现在让我们转到<code>html/template</code>模板包。它使用和<code>text/template</code>包相同的API和模板语言，但是增加了一个将字符串自动转义特性，这可以避免输入字符串和HTML、JavaScript、CSS或URL语法产生冲突的问题。这个特性还可以避免一些长期存在的安全问题，比如通过生成HTML注入攻击，通过构造一个含有恶意代码的问题标题，这些都可能让模板输出错误的输出，从而让他们控制页面。</p>
<p>下面的模板以HTML格式输出issue列表。注意import语句的不同：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"html/template"</span>

<span class="token keyword">var</span> issueList <span class="token operator">=</span> template<span class="token punctuation">.</span><span class="token function">Must</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"issuelist"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token string">`
&lt;h1>&#123;&#123;.TotalCount&#125;&#125; issues&lt;/h1>
&lt;table>
&lt;tr style='text-align: left'>
  &lt;th>#&lt;/th>
  &lt;th>State&lt;/th>
  &lt;th>User&lt;/th>
  &lt;th>Title&lt;/th>
&lt;/tr>
&#123;&#123;range .Items&#125;&#125;
&lt;tr>
  &lt;td>&lt;a href='&#123;&#123;.HTMLURL&#125;&#125;'>&#123;&#123;.Number&#125;&#125;&lt;/a>&lt;/td>
  &lt;td>&#123;&#123;.State&#125;&#125;&lt;/td>
  &lt;td>&lt;a href='&#123;&#123;.User.HTMLURL&#125;&#125;'>&#123;&#123;.User.Login&#125;&#125;&lt;/a>&lt;/td>
  &lt;td>&lt;a href='&#123;&#123;.HTMLURL&#125;&#125;'>&#123;&#123;.Title&#125;&#125;&lt;/a>&lt;/td>
&lt;/tr>
&#123;&#123;end&#125;&#125;
&lt;/table>
`</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<p>下面的命令将在新的模板上执行一个稍微不同的查询：</p>
<pre class="language-none"><code class="language-none">$ go build gopl.io&#x2F;ch4&#x2F;issueshtml
$ .&#x2F;issueshtml repo:golang&#x2F;go commenter:gopherbot json encoder &gt;issues.html</code></pre>

<p>注意，<code>html/template</code>包已经自动将特殊字符转义，因此我们依然可以看到正确的字面值。如果我们使用<code>text/template</code>包的话，这2个issue将会产生错误，其中<code>&amp;lt;</code>四个字符将会被当作小于字符<code>&lt;</code>处理，同时<code>&lt;link&gt;</code>字符串将会被当作一个链接元素处理，它们都会导致HTML文档结构的改变，从而导致有未知的风险。</p>
<p>我们也可以通过对信任的HTML字符串使用<code>template.HTML</code>类型来抑制这种自动转义的行为。还有很多采用类型命名的字符串类型分别对应信任的JavaScript、CSS和URL。下面的程序演示了两个使用不同类型的相同字符串产生的不同结果：A是一个普通字符串，B是一个信任的<code>template.HTML</code>字符串类型。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> templ <span class="token operator">=</span> <span class="token string">`&lt;p>A: &#123;&#123;.A&#125;&#125;&lt;/p>&lt;p>B: &#123;&#123;.B&#125;&#125;&lt;/p>`</span>
    t <span class="token operator">:=</span> template<span class="token punctuation">.</span><span class="token function">Must</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"escape"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>templ<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> data <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
        A <span class="token builtin">string</span>        <span class="token comment">// untrusted plain text</span>
        B template<span class="token punctuation">.</span>HTML <span class="token comment">// trusted HTML</span>
    <span class="token punctuation">&#125;</span>
    data<span class="token punctuation">.</span>A <span class="token operator">=</span> <span class="token string">"&lt;b>Hello!&lt;/b>"</span>
    data<span class="token punctuation">.</span>B <span class="token operator">=</span> <span class="token string">"&lt;b>Hello!&lt;/b>"</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>下图显示了出现在浏览器中的模板输出。我们看到A的黑体标记被转义失效了，但是B没有：</p>
<p><img src="/2022/notes-of-gopl/ch4-06.png" alt="img"></p>
<p>我们这里只讲述了模板系统中最基本的特性。一如既往，如果想了解更多的信息，请自己查看包文档：</p>
<pre class="language-go" data-language="go"><code class="language-go">$ <span class="token keyword">go</span> doc text<span class="token operator">/</span>template
$ <span class="token keyword">go</span> doc html<span class="token operator">/</span>template</code></pre>



<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p><strong>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">name</span><span class="token punctuation">(</span>parameter<span class="token operator">-</span>list<span class="token punctuation">)</span> <span class="token punctuation">(</span>result<span class="token operator">-</span>list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    body
<span class="token punctuation">&#125;</span></code></pre>

<p>形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。返回值列表描述了函数返回值的变量名以及类型。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。在hypot函数中：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">hypot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x <span class="token operator">+</span> y<span class="token operator">*</span>y<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">hypot</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "5"</span></code></pre>

<p>x和y是形参名，3和4是调用时的传入的实参，函数返回了一个float64类型的值。 返回值也可以像形式参数一样被命名。在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为该类型的零值。 如果一个函数在声明时，包含返回值列表，该函数必须以 return语句结尾，除非函数明显无法运行到结尾处。例如函数在结尾时调用了panic异常或函数中存在无限循环。</p>
<p>正如hypot一样，如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。下面2个声明是等价的：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k <span class="token builtin">int</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> t <span class="token builtin">string</span><span class="token punctuation">)</span>                 <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">,</span> k <span class="token builtin">int</span><span class="token punctuation">,</span>  s <span class="token builtin">string</span><span class="token punctuation">,</span> t <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span></code></pre>

<p>下面，我们给出4种方法声明拥有2个int型参数和1个int型返回值的函数.blank identifier(译者注：即下文的_符号)可以强调某个参数未被使用。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span>   <span class="token punctuation">&#123;</span><span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">sub</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>z <span class="token builtin">int</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span> z <span class="token operator">=</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span> <span class="token keyword">return</span><span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">first</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">zero</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span>      <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span>

fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> add<span class="token punctuation">)</span>   <span class="token comment">// "func(int, int) int"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> sub<span class="token punctuation">)</span>   <span class="token comment">// "func(int, int) int"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> first<span class="token punctuation">)</span> <span class="token comment">// "func(int, int) int"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> zero<span class="token punctuation">)</span>  <span class="token comment">// "func(int, int) int"</span></code></pre>

<p><strong>函数的类型被称为函数的签名。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。形参和返回值的变量名不影响函数签名，也不影响它们是否可以以省略参数类型的形式表示。</strong></p>
<p>每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。</p>
<p><strong>在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。</strong></p>
<p><strong>实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。</strong></p>
<p>你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数签名。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> math

<span class="token keyword">func</span> <span class="token function">Sin</span><span class="token punctuation">(</span>x <span class="token builtin">float64</span><span class="token punctuation">)</span> float <span class="token comment">//implemented in assembly language</span></code></pre>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>函数可以是递归的，这意味着函数可以直接或间接的调用自身。对许多问题而言，递归是一种强有力的技术，例如处理递归的数据结构。在4.4节，我们通过遍历二叉树来实现简单的插入排序，在本章节，我们再次使用它来处理HTML文件。</p>
<p>下文的示例代码使用了非标准包 <code>golang.org/x/net/html</code> ，解析HTML。<code>golang.org/x/...</code> 目录下存储了一些由Go团队设计、维护，对网络编程、国际化文件处理、移动平台、图像处理、加密解密、开发者工具提供支持的扩展包。未将这些扩展包加入到标准库原因有二，一是部分包仍在开发中，二是对大多数Go语言的开发者而言，扩展包提供的功能很少被使用。</p>
<p>例子中调用<code>golang.org/x/net/html</code>的部分api如下所示。<code>html.Parse</code>函数读入一组bytes解析后，返回<code>html.Node</code>类型的HTML页面树状结构根节点。HTML拥有很多类型的结点如text（文本）、commnets（注释）类型，在下面的例子中，我们 只关注<code>&lt; name key=&#39;value&#39; &gt;</code>形式的结点。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> html

<span class="token keyword">type</span> Node <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Type                    NodeType
    Data                    <span class="token builtin">string</span>
    Attr                    <span class="token punctuation">[</span><span class="token punctuation">]</span>Attribute
    FirstChild<span class="token punctuation">,</span> NextSibling <span class="token operator">*</span>Node
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> NodeType <span class="token builtin">int32</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
    ErrorNode NodeType <span class="token operator">=</span> <span class="token boolean">iota</span>
    TextNode
    DocumentNode
    ElementNode
    CommentNode
    DoctypeNode
<span class="token punctuation">)</span>

<span class="token keyword">type</span> Attribute <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Key<span class="token punctuation">,</span> Val <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">Parse</span><span class="token punctuation">(</span>r io<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Node<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span></code></pre>

<p>main函数解析HTML标准输入，通过递归函数visit获得links（链接），并打印出这些links：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Findlinks1 prints the links in an HTML document read from standard input.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>

    <span class="token string">"golang.org/x/net/html"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    doc<span class="token punctuation">,</span> err <span class="token operator">:=</span> html<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"findlinks1: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> link <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> doc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>visit函数遍历HTML的节点树，从每一个anchor元素的<code>href</code>属性获得link,将这些links存入字符串数组中，并返回这个字符串数组。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// visit appends to links each link found in n and returns the result.</span>
<span class="token keyword">func</span> <span class="token function">visit</span><span class="token punctuation">(</span>links <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> n <span class="token operator">*</span>html<span class="token punctuation">.</span>Node<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> n<span class="token punctuation">.</span>Type <span class="token operator">==</span> html<span class="token punctuation">.</span>ElementNode <span class="token operator">&amp;&amp;</span> n<span class="token punctuation">.</span>Data <span class="token operator">==</span> <span class="token string">"a"</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> a <span class="token operator">:=</span> <span class="token keyword">range</span> n<span class="token punctuation">.</span>Attr <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> a<span class="token punctuation">.</span>Key <span class="token operator">==</span> <span class="token string">"href"</span> <span class="token punctuation">&#123;</span>
                links <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>links<span class="token punctuation">,</span> a<span class="token punctuation">.</span>Val<span class="token punctuation">)</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> c <span class="token operator">:=</span> n<span class="token punctuation">.</span>FirstChild<span class="token punctuation">;</span> c <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> c <span class="token operator">=</span> c<span class="token punctuation">.</span>NextSibling <span class="token punctuation">&#123;</span>
        links <span class="token operator">=</span> <span class="token function">visit</span><span class="token punctuation">(</span>links<span class="token punctuation">,</span> c<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> links
<span class="token punctuation">&#125;</span></code></pre>

<p>为了遍历结点n的所有后代结点，每次遇到n的孩子结点时，visit递归的调用自身。这些孩子结点存放在FirstChild链表中。</p>
<p>让我们以Go的主页（golang.org）作为目标，运行findlinks。我们以fetch（1.5章）的输出作为findlinks的输入。下面的输出做了简化处理。</p>
<pre class="language-none"><code class="language-none">$ go build gopl.io&#x2F;ch1&#x2F;fetch
$ go build gopl.io&#x2F;ch5&#x2F;findlinks1
$ .&#x2F;fetch https:&#x2F;&#x2F;golang.org | .&#x2F;findlinks1
#
&#x2F;doc&#x2F;
&#x2F;pkg&#x2F;
&#x2F;help&#x2F;
&#x2F;blog&#x2F;
http:&#x2F;&#x2F;play.golang.org&#x2F;
&#x2F;&#x2F;tour.golang.org&#x2F;
https:&#x2F;&#x2F;golang.org&#x2F;dl&#x2F;
&#x2F;&#x2F;blog.golang.org&#x2F;
&#x2F;LICENSE
&#x2F;doc&#x2F;tos.html
http:&#x2F;&#x2F;www.google.com&#x2F;intl&#x2F;en&#x2F;policies&#x2F;privacy&#x2F;</code></pre>

<p>注意在页面中出现的链接格式，在之后我们会介绍如何将这些链接，根据根路径（ <a target="_blank" rel="noopener" href="https://golang.org/">https://golang.org</a> ）生成可以直接访问的url。</p>
<p>在函数outline中，我们通过递归的方式遍历整个HTML结点树，并输出树的结构。在outline内部，每遇到一个HTML元素标签，就将其入栈，并输出。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    doc<span class="token punctuation">,</span> err <span class="token operator">:=</span> html<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"outline: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">outline</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> doc<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">outline</span><span class="token punctuation">(</span>stack <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> n <span class="token operator">*</span>html<span class="token punctuation">.</span>Node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> n<span class="token punctuation">.</span>Type <span class="token operator">==</span> html<span class="token punctuation">.</span>ElementNode <span class="token punctuation">&#123;</span>
        stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> n<span class="token punctuation">.</span>Data<span class="token punctuation">)</span> <span class="token comment">// push tag</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> c <span class="token operator">:=</span> n<span class="token punctuation">.</span>FirstChild<span class="token punctuation">;</span> c <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> c <span class="token operator">=</span> c<span class="token punctuation">.</span>NextSibling <span class="token punctuation">&#123;</span>
        <span class="token function">outline</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> c<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>有一点值得注意：outline有入栈操作，但没有相对应的出栈操作。当outline调用自身时，被调用者接收的是stack的拷贝。被调用者对stack的元素追加操作，修改的是stack的拷贝，其可能会修改slice底层的数组甚至是申请一块新的内存空间进行扩容；但这个过程并不会修改调用方的stack。因此当函数返回时，调用方的stack与其调用自身之前完全一致。</p>
<p>下面是 <a target="_blank" rel="noopener" href="https://golang.org/">https://golang.org</a> 页面的简要结构:</p>
<pre class="language-none"><code class="language-none">$ go build gopl.io&#x2F;ch5&#x2F;outline
$ .&#x2F;fetch https:&#x2F;&#x2F;golang.org | .&#x2F;outline
[html]
[html head]
[html head meta]
[html head title]
[html head link]
[html body]
[html body div]
[html body div]
[html body div div]
[html body div div form]
[html body div div form div]
[html body div div form div a]
...</code></pre>

<p>正如你在上面实验中所见，大部分HTML页面只需几层递归就能被处理，但仍然有些页面需要深层次的递归。</p>
<p>大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与此相反，<strong>Go语言使用可变栈，栈的大小按需增加（初始时很小）。这使得我们使用递归时不必考虑溢出和安全问题。</strong></p>
<h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><p><strong>在Go中，一个函数可以返回多个值。</strong>我们已经在之前例子中看到，许多标准库中的函数返回2个值，一个是期望得到的返回值，另一个是函数出错时的错误信息。下面的例子会展示如何编写多返回值的函数。</p>
<p>下面的程序是findlinks的改进版本。修改后的findlinks可以自己发起HTTP请求，这样我们就不必再运行fetch。因为HTTP请求和解析操作可能会失败，因此findlinks声明了2个返回值：链接列表和错误信息。一般而言，HTML的解析器可以处理HTML页面的错误结点，构造出HTML页面结构，所以解析HTML很少失败。这意味着如果findlinks函数失败了，很可能是由于I&#x2F;O的错误导致的。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> url <span class="token operator">:=</span> <span class="token keyword">range</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
        links<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">findLinks</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
            fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"findlinks2: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
            <span class="token keyword">continue</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> link <span class="token operator">:=</span> <span class="token keyword">range</span> links <span class="token punctuation">&#123;</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// findLinks performs an HTTP GET request for url, parses the</span>
<span class="token comment">// response as HTML, and extracts and returns the links.</span>
<span class="token keyword">func</span> <span class="token function">findLinks</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    resp<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> resp<span class="token punctuation">.</span>StatusCode <span class="token operator">!=</span> http<span class="token punctuation">.</span>StatusOK <span class="token punctuation">&#123;</span>
        resp<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"getting %s: %s"</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> resp<span class="token punctuation">.</span>Status<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    doc<span class="token punctuation">,</span> err <span class="token operator">:=</span> html<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>resp<span class="token punctuation">.</span>Body<span class="token punctuation">)</span>
    resp<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"parsing %s as HTML: %v"</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> doc<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>在findlinks中，有4处return语句，每一处return都返回了一组值。前三处return，将<code>http</code>和<code>html</code>包中的错误信息传递给findlinks的调用者。第一处return直接返回错误信息，其他两处通过<code>fmt.Errorf</code>输出详细的错误信息。如果findlinks成功结束，最后的return语句将一组解析获得的连接返回给用户。</p>
<p><strong>在findlinks中，我们必须确保<code>resp.Body</code>被关闭，释放网络资源。虽然Go的垃圾回收机制会回收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。因此我们必须显式的释放这些资源。</strong></p>
<p><strong>调用多返回值函数时，返回给调用者的是一组值，调用者必须显式的将这些值分配给变量:</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">links<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">findLinks</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span></code></pre>

<p><strong>如果某个值不被使用，可以将其分配给blank identifier:</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">links<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token function">findLinks</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token comment">// errors ignored</span></code></pre>

<p>一个函数内部可以将另一个有多返回值的函数调用作为返回值，下面的例子展示了与findLinks有相同功能的函数，两者的区别在于下面的例子先输出参数：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">findLinksLog</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"findLinks %s"</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">findLinks</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>当你调用接受多参数的函数时，可以将一个返回多参数的函数调用作为该函数的参数。</strong>虽然这很少出现在实际生产代码中，但这个特性在debug时很方便，我们只需要一条语句就可以输出所有的返回值。下面的代码是等价的：</p>
<pre class="language-go" data-language="go"><code class="language-go">log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">findLinks</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span>

links<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">findLinks</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>links<span class="token punctuation">,</span> err<span class="token punctuation">)</span></code></pre>

<p><strong>准确的变量名可以传达函数返回值的含义。尤其在返回值的类型都相同时，就像下面这样：</strong></p>
<pre class="language-Go" data-language="Go"><code class="language-Go">func Size(rect image.Rectangle) (width, height int)
func Split(path string) (dir, file string)
func HourMinSec(t time.Time) (hour, minute, second int)</code></pre>

<p>虽然良好的命名很重要，但你也不必为每一个返回值都取一个适当的名字。比如，按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息，对于这些类似的惯例，我们不必思考合适的命名，它们都无需解释。</p>
<p><strong>如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。</strong></p>
<pre class="language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; CountWordsAndImages does an HTTP GET request for the HTML
&#x2F;&#x2F; document url and returns the number of words and images in it.
func CountWordsAndImages(url string) (words, images int, err error) &#123;
    resp, err :&#x3D; http.Get(url)
    if err !&#x3D; nil &#123;
        return
    &#125;
    doc, err :&#x3D; html.Parse(resp.Body)
    resp.Body.Close()
    if err !&#x3D; nil &#123;
        err &#x3D; fmt.Errorf(&quot;parsing HTML: %s&quot;, err)
        return
    &#125;
    words, images &#x3D; countWordsAndImages(doc)
    return
&#125;
func countWordsAndImages(n *html.Node) (words, images int) &#123; &#x2F;* ... *&#x2F; &#125;</code></pre>

<p>按照返回值列表的次序，返回所有的返回值，在上面的例子中，每一个return语句等价于：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">return words, images, err</code></pre>

<p>当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。举个例子，如果你没有仔细的审查代码，很难发现前2处return等价于 return 0,0,err（Go会将返回值 words和images在函数体的开始处，根据它们的类型，将其初始化为0），最后一处return等价于 return words, image, nil。基于以上原因，不宜过度使用bare return。</p>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>在Go中有一部分函数总是能成功的运行。比如<code>strings.Contains</code>和<code>strconv.FormatBool</code>函数，对各种可能的输入都做了良好的处理，使得运行时几乎不会失败，除非遇到灾难性的、不可预料的情况，比如运行时的内存溢出。导致这种错误的原因很复杂，难以处理，从错误中恢复的可能性也很低。</p>
<p>还有一部分函数只要输入的参数满足一定条件，也能保证运行成功。比如<code>time.Date</code>函数，该函数将年月日等参数构造成<code>time.Time</code>对象，除非最后一个参数（时区）是nil。这种情况下会引发panic异常。panic是来自被调用函数的信号，表示发生了某个已知的bug。一个良好的程序永远不应该发生panic异常。</p>
<p>对于大部分函数而言，永远无法确保能否成功运行。这是因为错误的原因超出了程序员的控制。举个例子，任何进行I&#x2F;O操作的函数都会面临出现错误的可能，<strong>只有没有经验的程序员才会相信读写操作不会失败，即使是简单的读写。</strong>因此，当本该可信的操作出乎意料的失败后，我们必须弄清楚导致失败的原因。</p>
<p>在Go的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。</p>
<p><strong>对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。</strong>比如，<code>cache.Lookup</code>失败的唯一原因是key不存在，那么代码可以按照下面的方式组织：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">value, ok :&#x3D; cache.Lookup(key)
if !ok &#123;
    &#x2F;&#x2F; ...cache[key] does not exist…
&#125;</code></pre>

<p><strong>通常，导致失败的原因不止一种，尤其是对I&#x2F;O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。</strong></p>
<p>内置的error是接口类型。我们将在第七章了解接口类型的含义，以及它对错误处理的影响。现在我们只需要明白error类型可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。对于non-nil的error类型，我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">fmt.Println(err)
fmt.Printf(&quot;%v&quot;, err)</code></pre>

<p><strong>通常，当函数返回non-nil的error时，其他的返回值是未定义的（undefined），这些未定义的返回值应该被忽略。然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。因此对函数的返回值要有清晰的说明，以便于其他人使用。</strong></p>
<p><strong>在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。虽然Go有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误。</strong></p>
<p>Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈跟踪信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。</p>
<p>正因此，Go使用控制流机制（如if和return）处理错误，这使得编码人员能更多的关注错误处理。</p>
<h3 id="错误处理策略"><a href="#错误处理策略" class="headerlink" title="错误处理策略"></a>错误处理策略</h3><p><strong>当一次函数调用返回错误时，调用者应该选择合适的方式处理错误。根据情况的不同，有很多处理方式，让我们来看看常用的5种方式。</strong></p>
<p><strong>第1种错误处理策略：最常用的方式是传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。</strong> 下面，我们以5.3节的findLinks函数作为例子。如果findLinks对<code>http.Get</code>的调用失败，findLinks会直接将这个HTTP错误返回给调用者：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">resp, err :&#x3D; http.Get(url)
if err !&#x3D; nil&#123;
    return nil, err
&#125;</code></pre>

<p>当对<code>html.Parse</code>的调用失败时，findLinks不会直接返回<code>html.Parse</code>的错误，因为缺少两条重要信息：1、发生错误时的解析器（html parser）；2、发生错误的url。因此，findLinks构造了一个新的错误信息，既包含了这两项，也包括了底层的解析出错的信息。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">doc, err :&#x3D; html.Parse(resp.Body)
resp.Body.Close()
if err !&#x3D; nil &#123;
    return nil, fmt.Errorf(&quot;parsing %s as HTML: %v&quot;, url,err)
&#125;</code></pre>

<p><strong><code>fmt.Errorf</code>函数使用<code>fmt.Sprintf</code>格式化错误信息并返回。我们使用该函数添加额外的前缀上下文信息到原始错误信息。</strong>当错误最终由main函数处理时，错误信息应提供清晰的从原因到后果的因果链，就像美国宇航局事故调查时做的那样：</p>
<pre class="language-none"><code class="language-none">genesis: crashed: no parachute: G-switch failed: bad relay orientation</code></pre>

<p>由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。最终的错误信息可能很长，我们可以通过类似grep的工具处理错误信息（译者注：grep是一种文本搜索工具）。</p>
<p>编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。</p>
<p>以<code>os</code>包为例，<code>os</code>包确保文件操作（如<code>os.Open</code>、<code>Read</code>、<code>Write</code>、<code>Close</code>）返回的每个错误的描述不仅仅包含错误的原因（如无权限，文件目录不存在）也包含文件名，这样调用者在构造新的错误信息时无需再添加这些信息。</p>
<p>一般而言，被调用函数<code>f(x)</code>会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者，调用者需要添加一些错误信息中不包含的信息，比如添加<code>url</code>到<code>html.Parse</code>返回的错误中。</p>
<p><strong>第2种错误处理策略：如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。</strong> </p>
<pre class="language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; WaitForServer attempts to contact the server of a URL.
&#x2F;&#x2F; It tries for one minute using exponential back-off.
&#x2F;&#x2F; It reports an error if all attempts fail.
func WaitForServer(url string) error &#123;
    const timeout &#x3D; 1 * time.Minute
    deadline :&#x3D; time.Now().Add(timeout)
    for tries :&#x3D; 0; time.Now().Before(deadline); tries++ &#123;
        _, err :&#x3D; http.Head(url)
        if err &#x3D;&#x3D; nil &#123;
            return nil &#x2F;&#x2F; success
        &#125;
        log.Printf(&quot;server not responding (%s);retrying…&quot;, err)
        time.Sleep(time.Second &lt;&lt; uint(tries)) &#x2F;&#x2F; exponential back-off
    &#125;
    return fmt.Errorf(&quot;server %s failed to respond after %s&quot;, url, timeout)
&#125;</code></pre>

<p><strong>第3种错误处理策略： 如果错误发生后，程序无法继续运行，则输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。</strong></p>
<pre class="language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; (In function main.)
if err :&#x3D; WaitForServer(url); err !&#x3D; nil &#123;
    fmt.Fprintf(os.Stderr, &quot;Site is down: %v\n&quot;, err)
    os.Exit(1)
&#125;</code></pre>

<p>调用<code>log.Fatalf</code>可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">if err :&#x3D; WaitForServer(url); err !&#x3D; nil &#123;
    log.Fatalf(&quot;Site is down: %v\n&quot;, err)
&#125;</code></pre>

<p>长时间运行的服务器常采用默认的时间格式，而交互式工具很少采用包含如此多信息的格式。</p>
<pre class="language-none"><code class="language-none">2006&#x2F;01&#x2F;02 15:04:05 Site is down: no such domain:
bad.gopl.io</code></pre>

<p>我们可以设置log的前缀信息屏蔽时间信息，一般而言，前缀信息会被设置成命令名。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">log.SetPrefix(&quot;wait: &quot;)
log.SetFlags(0)</code></pre>

<p><strong>第4种错误处理策略：有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。</strong> 我们可以通过log包提供函数</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">if err :&#x3D; Ping(); err !&#x3D; nil &#123;
    log.Printf(&quot;ping failed: %v; networking disabled&quot;,err)
&#125;</code></pre>

<p>或者标准错误流输出错误信息。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">if err :&#x3D; Ping(); err !&#x3D; nil &#123;
    fmt.Fprintf(os.Stderr, &quot;ping failed: %v; networking disabled\n&quot;, err)
&#125;</code></pre>

<p>log包中的所有函数会为没有换行符的字符串增加换行符。</p>
<p><strong>第5种错误处理策略：我们可以直接忽略掉错误。</strong></p>
<pre class="language-Go" data-language="Go"><code class="language-Go">dir, err :&#x3D; ioutil.TempDir(&quot;&quot;, &quot;scratch&quot;)
if err !&#x3D; nil &#123;
    return fmt.Errorf(&quot;failed to create temp dir: %v&quot;,err)
&#125;
&#x2F;&#x2F; ...use temp dir…
os.RemoveAll(dir) &#x2F;&#x2F; ignore errors; $TMPDIR is cleaned periodically</code></pre>

<p>尽管<code>os.RemoveAll</code>会失败，但上面的例子并没有做错误处理。这是因为操作系统会定期的清理临时目录。正因如此，虽然程序没有处理错误，但程序的逻辑不会因此受到影响。我们应该在每次函数调用后，都养成考虑错误处理的习惯，当你决定忽略某个错误时，你应该清晰地写下你的意图。</p>
<p><strong>在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。</strong></p>
<h3 id="文件结尾错误（EOF）"><a href="#文件结尾错误（EOF）" class="headerlink" title="文件结尾错误（EOF）"></a>文件结尾错误（EOF）</h3><p>函数经常会返回多种错误，这对终端用户来说可能会很有趣，但对程序而言，这使得情况变得复杂。很多时候，程序必须根据错误类型，作出不同的响应。让我们考虑这样一个例子：从文件中读取n个字节。如果n等于文件的长度，读取过程的任何错误都表示失败。如果n小于文件的长度，调用者会重复的读取固定大小的数据直到文件结束。这会导致调用者必须分别处理由文件结束引起的各种错误。基于这样的原因，<code>io</code>包保证任何由文件结束引起的读取失败都返回同一个错误——<code>io.EOF</code>，该错误在<code>io</code>包中定义：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">package io

import &quot;errors&quot;

&#x2F;&#x2F; EOF is the error returned by Read when no more input is available.
var EOF &#x3D; errors.New(&quot;EOF&quot;)</code></pre>

<p>调用者只需通过简单的比较，就可以检测出这个错误。下面的例子展示了如何从标准输入中读取字符，以及判断文件结束。（4.3的chartcount程序展示了更加复杂的代码）</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">in :&#x3D; bufio.NewReader(os.Stdin)
for &#123;
    r, _, err :&#x3D; in.ReadRune()
    if err &#x3D;&#x3D; io.EOF &#123;
        break &#x2F;&#x2F; finished reading
    &#125;
    if err !&#x3D; nil &#123;
        return fmt.Errorf(&quot;read failed:%v&quot;, err)
    &#125;
    &#x2F;&#x2F; ...use r…
&#125;</code></pre>

<p>因为文件结束这种错误不需要更多的描述，所以<code>io.EOF</code>有固定的错误信息——“EOF”。对于其他错误，我们可能需要在错误信息中描述错误的类型和数量，这使得我们不能像<code>io.EOF</code>一样采用固定的错误信息。</p>
<h2 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h2><p><strong>在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。</strong>例子如下：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">square</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> n <span class="token operator">*</span> n <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">negative</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">-</span>n <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">product</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m <span class="token operator">*</span> n <span class="token punctuation">&#125;</span>

f <span class="token operator">:=</span> square
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "9"</span>

f <span class="token operator">=</span> negative
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">// "-3"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token comment">// "func(int) int"</span>

f <span class="token operator">=</span> product <span class="token comment">// compile error: can't assign func(int, int) int to func(int) int</span></code></pre>

<p><strong>函数类型的零值是nil。调用值为nil的函数值会引起panic错误：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// 此处f的值为nil, 会引起panic错误</span></code></pre>

<p>函数值可以与nil比较：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
<span class="token keyword">if</span> f <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
  <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>但是函数值之间是不可比较的，也不能用函数值作为map的key。</strong></p>
<p>函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为。标准库中包含许多这样的例子。下面的代码展示了如何使用这个技巧。<code>strings.Map</code>对字符串中的每个字符调用<code>add1</code>函数，并将每个<code>add1</code>函数的返回值组成一个新的字符串返回给调用者。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">add1</span><span class="token punctuation">(</span>r <span class="token builtin">rune</span><span class="token punctuation">)</span> <span class="token builtin">rune</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> r <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span>

fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Map</span><span class="token punctuation">(</span>add1<span class="token punctuation">,</span> <span class="token string">"HAL-9000"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "IBM.:111"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Map</span><span class="token punctuation">(</span>add1<span class="token punctuation">,</span> <span class="token string">"VMS"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">// "WNT"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Map</span><span class="token punctuation">(</span>add1<span class="token punctuation">,</span> <span class="token string">"Admix"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// "Benjy"</span></code></pre>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p><strong>拥有函数名的函数只能在包级语法块中被声明，我们可以使用函数字面量（function literal）来绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别在于<code>func</code>关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数（anonymous function）。</strong></p>
<p><strong>函数字面量允许我们在使用函数时，再定义它。通过这种技巧，我们可以改写之前对<code>strings.Map</code>的调用：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">strings<span class="token punctuation">.</span><span class="token function">Map</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>r <span class="token builtin">rune</span><span class="token punctuation">)</span> <span class="token builtin">rune</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> r <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"HAL-9000"</span><span class="token punctuation">)</span></code></pre>

<p><strong>更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量，如下例所示：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// squares返回一个匿名函数。</span>
<span class="token comment">// 该匿名函数每次被调用时都会返回下一个数的平方。</span>
<span class="token keyword">func</span> <span class="token function">squares</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> x <span class="token builtin">int</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
        x<span class="token operator">++</span>
        <span class="token keyword">return</span> x <span class="token operator">*</span> x
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    f <span class="token operator">:=</span> <span class="token function">squares</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "1"</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "4"</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "9"</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "16"</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>函数squares返回另一个类型为 <code>func() int</code> 的函数。对squares的一次调用会生成一个局部变量x并返回一个匿名函数。每次调用匿名函数时，该函数都会先使x的值加1，再返回x的平方。第二次调用squares时，会生成第二个x变量，并返回一个新的匿名函数。新匿名函数操作的是第二个x变量。</p>
<p><strong>squares的例子证明，函数值不仅仅是一串代码，还记录了状态。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。</strong></p>
<p>通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。</p>
<h3 id="警告：捕获迭代变量"><a href="#警告：捕获迭代变量" class="headerlink" title="警告：捕获迭代变量"></a>警告：捕获迭代变量</h3><p>本节，将介绍Go词法作用域的一个陷阱。请务必仔细的阅读，弄清楚发生问题的原因。即使是经验丰富的程序员也会在这个问题上犯错误。</p>
<p>考虑这样一个问题：你被要求首先创建一些目录，再将目录删除。在下面的例子中我们用函数值来完成删除操作。下面的示例代码需要引入<code>os</code>包。为了使代码简单，我们忽略了所有的异常处理。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> rmdirs <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> d <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">tempDirs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    dir <span class="token operator">:=</span> d <span class="token comment">// NOTE: necessary!</span>
    os<span class="token punctuation">.</span><span class="token function">MkdirAll</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> <span class="token number">0755</span><span class="token punctuation">)</span> <span class="token comment">// creates parent directories too</span>
    rmdirs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>rmdirs<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        os<span class="token punctuation">.</span><span class="token function">RemoveAll</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// ...do some work…</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> rmdir <span class="token operator">:=</span> <span class="token keyword">range</span> rmdirs <span class="token punctuation">&#123;</span>
    <span class="token function">rmdir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// clean up</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>你可能会感到困惑，为什么要在循环体中用循环变量<code>d</code>赋值一个新的局部变量，而不是像下面的代码一样直接使用循环变量<code>dir</code>。&#x3D;&#x3D;需要注意，下面的代码是错误的。&#x3D;&#x3D;</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> rmdirs <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> dir <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">tempDirs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    os<span class="token punctuation">.</span><span class="token function">MkdirAll</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> <span class="token number">0755</span><span class="token punctuation">)</span>
    rmdirs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>rmdirs<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        os<span class="token punctuation">.</span><span class="token function">RemoveAll</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span> <span class="token comment">// NOTE: incorrect!</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>问题的原因在于循环变量的作用域。在上面的程序中，for循环语句引入了新的词法块，循环变量<code>dir</code>在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。&#x3D;&#x3D;需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。&#x3D;&#x3D;以<code>dir</code>为例，后续的迭代会不断更新<code>dir</code>的值，当删除操作执行时，for循环已完成，<code>dir</code>中存储的值等于最后一次迭代的值。这意味着，每次对<code>os.RemoveAll</code>的调用删除的都是相同的目录。</strong></p>
<p>通常，为了解决这个问题，我们会引入一个与循环变量同名的局部变量，作为循环变量的副本。比如下面的变量<code>dir</code>，虽然这看起来很奇怪，但却很有用。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> dir <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">tempDirs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    dir <span class="token operator">:=</span> dir <span class="token comment">// declares inner dir, initialized to outer dir</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>这个问题不仅存在基于range的循环，在下面的例子中，对循环变量<code>i</code>的使用也存在同样的问题：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> rmdirs <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
dirs <span class="token operator">:=</span> <span class="token function">tempDirs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>dirs<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
    os<span class="token punctuation">.</span><span class="token function">MkdirAll</span><span class="token punctuation">(</span>dirs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0755</span><span class="token punctuation">)</span> <span class="token comment">// OK</span>
    rmdirs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>rmdirs<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        os<span class="token punctuation">.</span><span class="token function">RemoveAll</span><span class="token punctuation">(</span>dirs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// NOTE: incorrect!</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>如果你使用go语句（第八章）或者defer语句（5.8节）会经常遇到此类问题。<strong>这不是go或defer本身导致的，而是因为它们都会等待循环结束后，再执行函数值。</strong></p>
<p>下例更加清楚的展示几种对range语句迭代变量引用方式的不同：</p>
<pre class="language-go" data-language="go"><code class="language-go">s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"yoyo"</span><span class="token punctuation">,</span> <span class="token string">"haha"</span><span class="token punctuation">,</span> <span class="token string">"lol"</span><span class="token punctuation">&#125;</span>
	<span class="token keyword">var</span> arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">&#123;</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"1:"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token comment">// 匿名函数外</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>val <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token string">"2:"</span> <span class="token operator">+</span> val <span class="token punctuation">&#125;</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 通过传参给匿名函数</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token string">"3:"</span> <span class="token operator">+</span> v <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 在闭包中直接引用</span>
		arr <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token string">"4:"</span> <span class="token operator">+</span> v <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">// 在闭包中直接引用，并延迟执行闭包</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> f <span class="token operator">:=</span> <span class="token keyword">range</span> arr <span class="token punctuation">&#123;</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//延迟执行闭包</span>
	<span class="token punctuation">&#125;</span></code></pre>

<p>执行结果如下：</p>
<pre class="language-none"><code class="language-none">1: yoyo
2:yoyo
3:yoyo
1: haha
2:haha
3:haha
1: lol
2:lol
3:lol
4:lol
4:lol
4:lol</code></pre>

<p>因为所有闭包引用的是变量迭代<code>v</code>的地址，而每次迭代后，变量<code>v</code>都被重新赋了新值，所以当迭代结束后，闭包中引用的变量<code>v</code>值为最后一次迭代时的值。而所有延迟执行的闭包都输出了<code>v</code>最后一次被赋值的值。</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p><strong>参数数量可变的函数称为 <em>可变参数函数</em> 。</strong>典型的例子就是<code>fmt.Printf</code>和类似函数。<code>Printf</code>首先接收一个必备的参数，之后接收任意个数的后续参数。</p>
<p><strong>在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号<code>...</code>，这表示该函数会接收任意数量的该类型参数。</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">sum</span><span class="token punctuation">(</span>vals <span class="token operator">...</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    total <span class="token operator">:=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> val <span class="token operator">:=</span> <span class="token keyword">range</span> vals <span class="token punctuation">&#123;</span>
        total <span class="token operator">+=</span> val
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> total
<span class="token punctuation">&#125;</span></code></pre>

<p><code>sum</code>函数返回任意个<code>int</code>型参数的和。在函数体中，<code>vals</code>被看作是类型为<code>[] int</code>的切片。<code>sum</code>可以接收任意数量的int型参数：</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token comment">// "0"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment">// "3"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "10"</span></code></pre>

<p>在上面的代码中，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调用函数。<strong>如果原始参数已经是切片类型，只需在最后一个参数后加上省略符。</strong> 下面的代码功能与上个例子中最后一条语句相同。</p>
<pre class="language-go" data-language="go"><code class="language-go">values <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>values<span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "10"</span></code></pre>

<p>虽然在可变参数函数内部，<code>...int</code> 型参数的行为看起来很像切片类型，但实际上，可变参数函数和以切片作为参数的函数是不同的。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token comment">// "func(...int)"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token comment">// "func([]int)"</span></code></pre>

<p>可变参数函数经常被用于格式化字符串。下面的<code>errorf</code>函数构造了一个以行号开头的，经过格式化的错误信息。函数名的后缀f是一种通用的命名规范，代表该可变参数函数可以接收<code>Printf</code>风格的格式化字符串。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">errorf</span><span class="token punctuation">(</span>linenum <span class="token builtin">int</span><span class="token punctuation">,</span> format <span class="token builtin">string</span><span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"Line %d: "</span><span class="token punctuation">,</span> linenum<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
linenum<span class="token punctuation">,</span> name <span class="token operator">:=</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token string">"count"</span>
<span class="token function">errorf</span><span class="token punctuation">(</span>linenum<span class="token punctuation">,</span> <span class="token string">"undefined: %s"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token comment">// "Line 12: undefined: count"</span></code></pre>

<p><code>interface&#123;&#125;</code>表示函数的最后一个参数可以接收任意类型。</p>
<p><strong>练习5.15：</strong> 编写类似<code>sum</code>的可变参数函数<code>max</code>和<code>min</code>。考虑不传参时，<code>max</code>和<code>min</code>该如何处理，再编写至少接收1个参数的版本。</p>
<p><strong>练习5.16：</strong>编写多参数版本的<code>strings.Join</code>。</p>
<p><strong>练习5.17：</strong>编写多参数版本的<code>ElementsByTagName</code>，函数接收一个HTML结点树以及任意数量的标签名，返回与这些标签名匹配的所有元素。下面给出了2个例子：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ElementsByTagName</span><span class="token punctuation">(</span>doc <span class="token operator">*</span>html<span class="token punctuation">.</span>Node<span class="token punctuation">,</span> name<span class="token operator">...</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>html<span class="token punctuation">.</span>Node
images <span class="token operator">:=</span> <span class="token function">ElementsByTagName</span><span class="token punctuation">(</span>doc<span class="token punctuation">,</span> <span class="token string">"img"</span><span class="token punctuation">)</span>
headings <span class="token operator">:=</span> <span class="token function">ElementsByTagName</span><span class="token punctuation">(</span>doc<span class="token punctuation">,</span> <span class="token string">"h1"</span><span class="token punctuation">,</span> <span class="token string">"h2"</span><span class="token punctuation">,</span> <span class="token string">"h3"</span><span class="token punctuation">,</span> <span class="token string">"h4"</span><span class="token punctuation">)</span></code></pre>

<h2 id="Deferred函数"><a href="#Deferred函数" class="headerlink" title="Deferred函数"></a>Deferred函数</h2><p>在findLinks的例子中，我们用<code>http.Get</code>的输出作为<code>html.Parse</code>的输入。只有url的内容的确是HTML格式的，<code>html.Parse</code>才可以正常工作，但实际上，url指向的内容很丰富，可能是图片，纯文本或是其他。将这些格式的内容传递给<code>html.parse</code>，会产生不良后果。</p>
<p>下面的例子获取HTML页面并输出页面的标题。title函数会检查服务器返回的Content-Type字段，如果发现页面不是HTML，将终止函数运行，返回错误。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">title</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
    resp<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> err
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// Check Content-Type is HTML (e.g., "text/html;charset=utf-8").</span>
    ct <span class="token operator">:=</span> resp<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> ct <span class="token operator">!=</span> <span class="token string">"text/html"</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span>ct<span class="token punctuation">,</span><span class="token string">"text/html;"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        resp<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"%s has type %s, not text/html"</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span> ct<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    doc<span class="token punctuation">,</span> err <span class="token operator">:=</span> html<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>resp<span class="token punctuation">.</span>Body<span class="token punctuation">)</span>
    resp<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"parsing %s as HTML: %v"</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    visitNode <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>n <span class="token operator">*</span>html<span class="token punctuation">.</span>Node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> n<span class="token punctuation">.</span>Type <span class="token operator">==</span> html<span class="token punctuation">.</span>ElementNode <span class="token operator">&amp;&amp;</span> n<span class="token punctuation">.</span>Data <span class="token operator">==</span> <span class="token string">"title"</span><span class="token operator">&amp;&amp;</span>n<span class="token punctuation">.</span>FirstChild <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>FirstChild<span class="token punctuation">.</span>Data<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">forEachNode</span><span class="token punctuation">(</span>doc<span class="token punctuation">,</span> visitNode<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>下面展示了运行效果：</p>
<pre class="language-none"><code class="language-none">$ go build gopl.io&#x2F;ch5&#x2F;title1
$ .&#x2F;title1 http:&#x2F;&#x2F;gopl.io
The Go Programming Language
$ .&#x2F;title1 https:&#x2F;&#x2F;golang.org&#x2F;doc&#x2F;effective_go.html
Effective Go - The Go Programming Language
$ .&#x2F;title1 https:&#x2F;&#x2F;golang.org&#x2F;doc&#x2F;gopher&#x2F;frontpage.png
title1: https:&#x2F;&#x2F;golang.org&#x2F;doc&#x2F;gopher&#x2F;frontpage.png has type image&#x2F;png, not text&#x2F;html</code></pre>

<p><strong><code>resp.Body.close</code>调用了多次，这是为了确保title在所有执行路径下（即使函数运行失败）都关闭了网络连接。随着函数变得复杂，需要处理的错误也变多，维护清理逻辑变得越来越困难。而Go语言独有的defer机制可以让事情变得简单。</strong></p>
<p><strong>你只需要在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。</strong></p>
<p><strong>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。</strong> 在下面的代码中，一条defer语句替代了之前的所有<code>resp.Body.Close</code></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">title</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
    resp<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> err
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">defer</span> resp<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    ct <span class="token operator">:=</span> resp<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> ct <span class="token operator">!=</span> <span class="token string">"text/html"</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span>ct<span class="token punctuation">,</span><span class="token string">"text/html;"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"%s has type %s, not text/html"</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span> ct<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    doc<span class="token punctuation">,</span> err <span class="token operator">:=</span> html<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>resp<span class="token punctuation">.</span>Body<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"parsing %s as HTML: %v"</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// ...print doc's title element…</span>
    <span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>在处理其他资源时，也可以采用defer机制，比如对文件的操作：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> ioutil
<span class="token keyword">func</span> <span class="token function">ReadFile</span><span class="token punctuation">(</span>filename <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">defer</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">ReadAll</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>或是处理互斥锁：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex
<span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token function">lookup</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">defer</span> mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> m<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>调试复杂程序时，defer机制也常被用于记录何时进入和退出函数。下例中的<code>bigSlowOperation</code>函数，直接调用<code>trace</code>记录函数的被调情况。<code>bigSlowOperation</code>被调时，<code>trace</code>会返回一个函数值，该函数值会在<code>bigSlowOperation</code>退出时被调用。通过这种方式， 我们可以只通过一条语句控制函数的入口和所有的出口，甚至可以记录函数的运行时间，如例子中的<code>start</code>。需要注意一点：不要忘记defer语句后的圆括号，否则本该在进入时执行的操作会在退出时执行，而本该在退出时执行的，永远不会被执行。</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">bigSlowOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">defer</span> <span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"bigSlowOperation"</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// don't forget the extra parentheses</span>
    <span class="token comment">// ...lots of work…</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token comment">// simulate slow operation by sleeping</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">trace</span><span class="token punctuation">(</span>msg <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    start <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"enter %s"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
        log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"exit %s (%s)"</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span>time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span> 
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>每一次<code>bigSlowOperation</code>被调用，程序都会记录函数的进入，退出，持续时间。（我们用<code>time.Sleep</code>模拟一个耗时的操作）</p>
<pre class="language-go" data-language="go"><code class="language-go">$ <span class="token keyword">go</span> build gopl<span class="token punctuation">.</span>io<span class="token operator">/</span>ch5<span class="token operator">/</span>trace
$ <span class="token punctuation">.</span><span class="token operator">/</span>trace
<span class="token number">2015</span><span class="token operator">/</span><span class="token number">11</span><span class="token operator">/</span><span class="token number">18</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">53</span><span class="token punctuation">:</span><span class="token number">26</span> enter bigSlowOperation
<span class="token number">2015</span><span class="token operator">/</span><span class="token number">11</span><span class="token operator">/</span><span class="token number">18</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">53</span><span class="token punctuation">:</span><span class="token number">36</span> exit bigSlowOperation <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">.</span>000589217s<span class="token punctuation">)</span></code></pre>

<p>我们知道，defer语句中的函数会在return语句更新返回值变量后再执行，又因为在函数中定义的匿名函数可以访问该函数包括返回值变量在内的所有变量，所以，对匿名函数采用defer机制，可以使其观察函数的返回值。</p>
<p>我们只需要首先命名double的返回值，再增加defer语句，我们就可以在double每次被调用时，输出参数以及返回值。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">double</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>result <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"double(%d) = %d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span>result<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> x
<span class="token punctuation">&#125;</span>
<span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">double</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token comment">// Output:</span>
<span class="token comment">// "double(4) = 8"</span></code></pre>

<p>可能double函数过于简单，看不出这个小技巧的作用，但对于有许多return语句的函数而言，这个技巧很有用。</p>
<p><strong>被延迟执行的匿名函数甚至可以修改函数返回给调用者的返回值：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">triple</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>result <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> result <span class="token operator">+=</span> x <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">double</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">triple</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "12"</span></code></pre>

<p><strong>在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行。下面的代码会导致系统的文件描述符耗尽，因为在所有文件都被处理之前，没有文件会被关闭。</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> filename <span class="token operator">:=</span> <span class="token keyword">range</span> filenames <span class="token punctuation">&#123;</span>
    f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> err
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">defer</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// NOTE: risky; could run out of file descriptors</span>
    <span class="token comment">// ...process f…</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>一种解决方法是将循环体中的defer语句移至另外一个函数。在每次循环时，调用这个函数。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> filename <span class="token operator">:=</span> <span class="token keyword">range</span> filenames <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">doFile</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> err
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">doFile</span><span class="token punctuation">(</span>filename <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
    f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> err
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">defer</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// ...process f…</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>下面的代码是fetch（1.5节）的改进版，我们将http响应信息写入本地文件而不是从标准输出流输出。我们通过<code>path.Base</code>提出url路径的最后一段作为文件名。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// Fetch downloads the URL and returns the</span>
<span class="token comment">// name and length of the local file.</span>
<span class="token keyword">func</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>filename <span class="token builtin">string</span><span class="token punctuation">,</span> n <span class="token builtin">int64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    resp<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> err
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">defer</span> resp<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    local <span class="token operator">:=</span> path<span class="token punctuation">.</span><span class="token function">Base</span><span class="token punctuation">(</span>resp<span class="token punctuation">.</span>Request<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>
    <span class="token keyword">if</span> local <span class="token operator">==</span> <span class="token string">"/"</span> <span class="token punctuation">&#123;</span>
        local <span class="token operator">=</span> <span class="token string">"index.html"</span>
    <span class="token punctuation">&#125;</span>
    f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> err
    <span class="token punctuation">&#125;</span>
    n<span class="token punctuation">,</span> err <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> resp<span class="token punctuation">.</span>Body<span class="token punctuation">)</span>
    <span class="token comment">// Close file, but prefer error from Copy, if any.</span>
    <span class="token keyword">if</span> closeErr <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        err <span class="token operator">=</span> closeErr
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> local<span class="token punctuation">,</span> n<span class="token punctuation">,</span> err
<span class="token punctuation">&#125;</span></code></pre>

<p>对<code>resp.Body.Close</code>延迟调用我们已经见过了，在此不做解释。上例中，通过<code>os.Create</code>打开文件进行写入，在关闭文件时，我们没有对<code>f.close</code>采用defer机制，因为这会产生一些微妙的错误。许多文件系统，尤其是NFS，写入文件时发生的错误会被延迟到文件关闭时反馈。如果没有检查文件关闭时的反馈信息，可能会导致数据丢失，而我们还误以为写入操作成功。如果<code>io.Copy</code>和<code>f.close</code>都失败了，我们倾向于将<code>io.Copy</code>的错误信息反馈给调用者，因为它先于<code>f.close</code>发生，更有可能接近问题的本质。</p>
<p>下面例子更加清楚的展示了defer的机制：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token function">deferDemo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">deferDemo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"enter"</span><span class="token punctuation">)</span>
	n <span class="token operator">:=</span> <span class="token number">1</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"n ="</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>
	<span class="token keyword">defer</span> <span class="token function">yoyo</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
	n <span class="token operator">=</span> <span class="token number">2</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"n ="</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"exit"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">yoyo</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"yoyo n ="</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>通过下面输出可以发现，defer在调用时取得n等于1的值，之后n再次被赋值对defer也没有影响了，但等到函数<code>deferDemo1</code>退出后，函数<code>yoyo</code>才真正执行：</p>
<pre class="language-none"><code class="language-none">enter
n &#x3D; 1
n &#x3D; 2
exit
yoyo n &#x3D; 1</code></pre>

<p>下面例子更进一步：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token function">deferDemo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">deferDemo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"enter"</span><span class="token punctuation">)</span>
	n <span class="token operator">:=</span> <span class="token number">1</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"n ="</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>
	<span class="token keyword">defer</span> <span class="token function">haha</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	n <span class="token operator">=</span> <span class="token number">2</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"n ="</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"exit"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">haha</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"haha n ="</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"lol n + 2 ="</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>从下面输出结果可以看出，<code>defer haha(n)</code>在取得<code>n</code>等于1之后立即被运行，并输出结果，但是其返回的匿名函数在函数<code>deferDemo2</code>退出后才执行：</p>
<pre class="language-none"><code class="language-none">enter
n &#x3D; 1
haha n &#x3D; 1
n &#x3D; 2
exit
lol n + 2 &#x3D; 3</code></pre>

<h2 id="Panic异常"><a href="#Panic异常" class="headerlink" title="Panic异常"></a>Panic异常</h2><p><strong>Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。</strong></p>
<p><strong>一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。panic value通常是某种错误信息。对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。</strong>通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据。因此，在我们填写问题报告时，一般会将panic异常和日志信息一并记录。</p>
<p><strong>不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用panic。</strong>比如，当程序到达了某条逻辑上不可能到达的路径：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">switch</span> s <span class="token operator">:=</span> <span class="token function">suit</span><span class="token punctuation">(</span><span class="token function">drawCard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> s <span class="token punctuation">&#123;</span>
<span class="token keyword">case</span> <span class="token string">"Spades"</span><span class="token punctuation">:</span>                                <span class="token comment">// ...</span>
<span class="token keyword">case</span> <span class="token string">"Hearts"</span><span class="token punctuation">:</span>                                <span class="token comment">// ...</span>
<span class="token keyword">case</span> <span class="token string">"Diamonds"</span><span class="token punctuation">:</span>                              <span class="token comment">// ...</span>
<span class="token keyword">case</span> <span class="token string">"Clubs"</span><span class="token punctuation">:</span>                                 <span class="token comment">// ...</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token function">panic</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"invalid suit %q"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Joker?</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>断言函数必须满足的前置条件是明智的做法，但这很容易被滥用。除非你能提供更多的错误信息，或者能更快速的发现错误，否则不需要使用断言，编译器在运行时会帮你检查代码。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Reset</span><span class="token punctuation">(</span>x <span class="token operator">*</span>Buffer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"x is nil"</span><span class="token punctuation">)</span> <span class="token comment">// unnecessary!</span>
    <span class="token punctuation">&#125;</span>
    x<span class="token punctuation">.</span>elements <span class="token operator">=</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>虽然Go的panic机制类似于其他语言的异常，但panic的适用场景有一些不同。由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致。勤奋的程序员认为任何崩溃都表明代码中存在漏洞，所以对于大部分漏洞，我们应该使用Go提供的错误机制，而不是panic，尽量避免程序的崩溃。在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的I&#x2F;O操作都应该被优雅的处理，最好的处理方式，就是使用Go的错误机制。</p>
<p>考虑<code>regexp.Compile</code>函数，该函数将正则表达式编译成有效的可匹配格式。当输入的正则表达式不合法时，该函数会返回一个错误。当调用者明确的知道正确的输入不会引起函数错误时，要求调用者检查这个错误是不必要和累赘的。我们应该假设函数的输入一直合法，就如前面的断言一样：当调用者输入了不应该出现的输入时，触发panic异常。</p>
<p>在程序源码中，大多数正则表达式是字符串字面值（string literals），因此<code>regexp</code>包提供了包装函数<code>regexp.MustCompile</code>检查输入的合法性。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">package regexp
func Compile(expr string) (*Regexp, error) &#123; &#x2F;* ... *&#x2F; &#125;
func MustCompile(expr string) *Regexp &#123;
    re, err :&#x3D; Compile(expr)
    if err !&#x3D; nil &#123;
        panic(err)
    &#125;
    return re
&#125;</code></pre>

<p>包装函数使得调用者可以便捷的用一个编译后的正则表达式为包级别的变量赋值：</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">var httpSchemeRE &#x3D; regexp.MustCompile(&#96;^https?:&#96;) &#x2F;&#x2F;&quot;http:&quot; or &quot;https:&quot;</code></pre>

<p>显然，<code>MustCompile</code>不能接收不合法的输入。函数名中的Must前缀是一种针对此类函数的命名约定，比如<code>template.Must</code>。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">func main() &#123;
    f(3)
&#125;
func f(x int) &#123;
    fmt.Printf(&quot;f(%d)\n&quot;, x+0&#x2F;x) &#x2F;&#x2F; panics if x &#x3D;&#x3D; 0
    defer fmt.Printf(&quot;defer %d\n&quot;, x)
    f(x - 1)
&#125;</code></pre>

<p>上例中的运行输出如下：</p>
<pre class="language-none"><code class="language-none">f(3)
f(2)
f(1)
defer 1
defer 2
defer 3</code></pre>

<p>当<code>f(0)</code>被调用时，发生panic异常，之前被延迟执行的3个<code>fmt.Printf</code>被调用。程序中断执行后，panic信息和堆栈信息会被输出（下面是简化的输出）：</p>
<pre class="language-none"><code class="language-none">panic: runtime error: integer divide by zero
main.f(0)
src&#x2F;gopl.io&#x2F;ch5&#x2F;defer1&#x2F;defer.go:14
main.f(1)
src&#x2F;gopl.io&#x2F;ch5&#x2F;defer1&#x2F;defer.go:16
main.f(2)
src&#x2F;gopl.io&#x2F;ch5&#x2F;defer1&#x2F;defer.go:16
main.f(3)
src&#x2F;gopl.io&#x2F;ch5&#x2F;defer1&#x2F;defer.go:16
main.main()
src&#x2F;gopl.io&#x2F;ch5&#x2F;defer1&#x2F;defer.go:10</code></pre>

<p>我们在下一节将看到，如何使程序从panic异常中恢复，阻止程序的崩溃。</p>
<p>为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在<code>main</code>函数中延迟调用<code>printStack</code>输出堆栈信息。</p>
<pre class="language-Go" data-language="Go"><code class="language-Go">func main() &#123;
    defer printStack()
    f(3)
&#125;
func printStack() &#123;
    var buf [4096]byte
    n :&#x3D; runtime.Stack(buf[:], false)
    os.Stdout.Write(buf[:n])
&#125;</code></pre>

<p><code>printStack</code>的简化输出如下（下面只是<code>printStack</code>的输出，不包括panic的日志信息）：</p>
<pre class="language-none"><code class="language-none">goroutine 1 [running]:
main.printStack()
src&#x2F;gopl.io&#x2F;ch5&#x2F;defer2&#x2F;defer.go:20
main.f(0)
src&#x2F;gopl.io&#x2F;ch5&#x2F;defer2&#x2F;defer.go:27
main.f(1)
src&#x2F;gopl.io&#x2F;ch5&#x2F;defer2&#x2F;defer.go:29
main.f(2)
src&#x2F;gopl.io&#x2F;ch5&#x2F;defer2&#x2F;defer.go:29
main.f(3)
src&#x2F;gopl.io&#x2F;ch5&#x2F;defer2&#x2F;defer.go:29
main.main()
src&#x2F;gopl.io&#x2F;ch5&#x2F;defer2&#x2F;defer.go:15</code></pre>

<p>将panic机制类比其他语言异常机制的读者可能会惊讶，<code>runtime.Stack</code>为何能输出已经被释放函数的信息？<strong>在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。</strong></p>
<h2 id="Recover捕获异常"><a href="#Recover捕获异常" class="headerlink" title="Recover捕获异常"></a>Recover捕获异常</h2><p>通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭；如果不做任何处理，会使得客户端一直处于等待状态。如果web服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。</p>
<p><strong>如果在deferred函数中调用了内置函数recover，并且定义该defer语句所在的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。</strong></p>
<p>让我们以语言解析器为例，说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Parse</span><span class="token punctuation">(</span>input <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Syntax<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> p <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
            err <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"internal error: %v"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// ...parser...</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>deferred函数帮助Parse从panic中恢复。在deferred函数内部，panic value被附加到错误信息中；并用err变量接收错误信息，返回给调用者。我们也可以通过调用<code>runtime.Stack</code>往错误信息中添加完整的堆栈调用信息。</p>
<p><strong>不加区分的恢复所有的panic异常，不是可取的做法；因为在panic之后，无法保证包级变量的状态仍然和我们预期一致。比如，对数据结构的一次重要更新没有被完整完成、文件或者网络连接没有被关闭、获得的锁没有被释放。此外，如果写日志时产生的panic被不加区分的恢复，可能会导致漏洞被忽略。</strong></p>
<p>虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。</p>
<p>有时我们很难完全遵循规范，举个例子，<code>net/http</code>包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。</p>
<p>基于以上原因，安全的做法是有选择性的recover。换句话说，只恢复应该被恢复的panic异常，此外，这些异常所占的比例应该尽可能的低。为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为error处理，如果不是，则按照正常的panic进行处理（在下面的例子中，我们会看到这种方式）。</p>
<p>下面的例子是title函数的变形，如果HTML页面包含多个<code>&lt;title&gt;</code>，该函数会给调用者返回一个错误（error）。在soleTitle内部处理时，如果检测到有多个<code>&lt;title&gt;</code>，会调用panic，阻止函数继续递归，并将特殊类型bailout作为panic的参数。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// soleTitle returns the text of the first non-empty title element</span>
<span class="token comment">// in doc, and an error if there was not exactly one.</span>
<span class="token keyword">func</span> <span class="token function">soleTitle</span><span class="token punctuation">(</span>doc <span class="token operator">*</span>html<span class="token punctuation">.</span>Node<span class="token punctuation">)</span> <span class="token punctuation">(</span>title <span class="token builtin">string</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">type</span> bailout <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">switch</span> p <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token punctuation">&#123;</span>
        <span class="token keyword">case</span> <span class="token boolean">nil</span><span class="token punctuation">:</span>       <span class="token comment">// no panic</span>
        <span class="token keyword">case</span> bailout<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">:</span> <span class="token comment">// "expected" panic</span>
            err <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"multiple title elements"</span><span class="token punctuation">)</span>
        <span class="token keyword">default</span><span class="token punctuation">:</span>
            <span class="token function">panic</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment">// unexpected panic; carry on panicking</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// Bail out of recursion if we find more than one nonempty title.</span>
    <span class="token function">forEachNode</span><span class="token punctuation">(</span>doc<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>n <span class="token operator">*</span>html<span class="token punctuation">.</span>Node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> n<span class="token punctuation">.</span>Type <span class="token operator">==</span> html<span class="token punctuation">.</span>ElementNode <span class="token operator">&amp;&amp;</span> n<span class="token punctuation">.</span>Data <span class="token operator">==</span> <span class="token string">"title"</span> <span class="token operator">&amp;&amp;</span>
            n<span class="token punctuation">.</span>FirstChild <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> title <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>
                <span class="token function">panic</span><span class="token punctuation">(</span>bailout<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">// multiple title elements</span>
            <span class="token punctuation">&#125;</span>
            title <span class="token operator">=</span> n<span class="token punctuation">.</span>FirstChild<span class="token punctuation">.</span>Data
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> title <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"no title element"</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> title<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>在上例中，deferred函数调用recover，并检查panic value。当panic value是<code>bailout&#123;&#125;</code>类型时，deferred函数生成一个error返回给调用者。当panic value是其他non-nil值时，表示发生了未知的panic异常，deferred函数将调用panic函数并将当前的panic value作为参数传入；此时，等同于recover没有做任何操作。（请注意：在例子中，对可预期的错误采用了panic，这违反了之前的建议，我们在此只是想向读者演示这种机制。）</p>
<p>有些情况下，我们无法恢复。某些致命错误会导致Go在运行时终止程序，如内存不足。</p>
<p><strong>练习5.19：</strong> 使用panic和recover编写一个不包含return语句但能返回一个非零值的函数。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    a <span class="token operator">:=</span> <span class="token function">noReturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">noReturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>result <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        p <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        result <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>想知道上面代码的原理，可以观察一下下面代码：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>	
	s <span class="token operator">:=</span> <span class="token function">deferDemo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T %q"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token comment">// string "set in defer"</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">func</span> <span class="token function">deferDemo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		s <span class="token operator">=</span> <span class="token string">"set in defer"</span> <span class="token comment">// 可以在defer调用中对返回值进行修改</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token string">"on return"</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>从输出结果可以看到，我们可以在defer调用中对命名返回值进行修改。因此，再观察下面代码：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	s <span class="token operator">:=</span> <span class="token function">causePanic</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T %q"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token comment">// string ""</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">causePanic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> p <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
			fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"recover from panic: %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"oops!"</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token string">"after panic"</span> <span class="token comment">// 永远不会执行到</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>输出结果为：</p>
<pre class="language-none"><code class="language-none">recover from panic: oops!
string &quot;&quot;</code></pre>

<p>虽然函数<code>causePanic</code>的return语句因为panic导致永远无法达到，但是由于函数定义了返回值，且自动被初始化为字符串零值，所以<code>main</code>函数中变量<code>s</code>依然获得了返回值<code>&quot;&quot;</code>。</p>
<p>因此，如果返回值是命名返回值（返回值有名字），则可以在panic终止了函数<code>causePanic</code>继续运行后，同样可以在defer调用中对返回值进行修改，前提是必须是返回值必须有名字。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	s <span class="token operator">:=</span> <span class="token function">causePanic</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T %q"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token comment">// string "set in defer"</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">causePanic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> p <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
			fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"recover from panic: %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>
      s <span class="token operator">=</span> <span class="token string">"set in defer"</span> <span class="token comment">// 在defer中对返回值s进行修改</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"oops!"</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token string">"after panic"</span> <span class="token comment">// 永远不会执行到</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>输出结果为：</p>
<pre class="language-none"><code class="language-none">recover from panic: oops!
string &quot;set in defer&quot;</code></pre>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h2><p>在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。</p>
<p>下面来写我们第一个方法的例子，这个例子在<code>package geometry</code>下：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> geometry

<span class="token keyword">import</span> <span class="token string">"math"</span>

<span class="token keyword">type</span> Point <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> X<span class="token punctuation">,</span> Y <span class="token builtin">float64</span> <span class="token punctuation">&#125;</span>

<span class="token comment">// traditional function</span>
<span class="token keyword">func</span> <span class="token function">Distance</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> q Point<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> math<span class="token punctuation">.</span><span class="token function">Hypot</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>X<span class="token operator">-</span>p<span class="token punctuation">.</span>X<span class="token punctuation">,</span> q<span class="token punctuation">.</span>Y<span class="token operator">-</span>p<span class="token punctuation">.</span>Y<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// same thing, but as a method of the Point type</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p Point<span class="token punctuation">)</span> <span class="token function">Distance</span><span class="token punctuation">(</span>q Point<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> math<span class="token punctuation">.</span><span class="token function">Hypot</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>X<span class="token operator">-</span>p<span class="token punctuation">.</span>X<span class="token punctuation">,</span> q<span class="token punctuation">.</span>Y<span class="token operator">-</span>p<span class="token punctuation">.</span>Y<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>上面的代码里那个附加的参数p，叫做<strong>方法的接收器（receiver）</strong>，早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。</p>
<p><strong>在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。这里的建议是可以使用其类型的第一个字母，比如这里使用了Point的首字母p。</strong></p>
<p><strong>在方法调用过程中，接收器参数一般会在方法名之前出现。这和方法声明是一样的，都是接收器参数在方法名字之前。</strong>下面是例子：</p>
<pre class="language-go" data-language="go"><code class="language-go">p <span class="token operator">:=</span> Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>
q <span class="token operator">:=</span> Point<span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">Distance</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "5", function call</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// "5", method call</span></code></pre>

<p>可以看到，上面的两个函数调用都是Distance，但是却没有发生冲突。第一个Distance的调用实际上用的是包级别的函数<code>geometry.Distance</code>，而第二个则是使用刚刚声明的Point，调用的是Point类下声明的<code>Point.Distance</code>方法。</p>
<p>这种<code>p.Distance</code>的表达式叫做 <strong>选择器</strong>，因为他会选择合适的对应p这个对象的Distance方法来执行。选择器也会被用来选择一个struct类型的字段，比如<code>p.X</code>。<strong>由于方法和字段都是在同一命名空间，所以如果我们在这里声明一个<code>X</code>方法的话，编译器会报错，因为在调用<code>p.X</code>时会有歧义。</strong></p>
<p>因为每种类型都有其方法的命名空间，我们在用Distance这个名字的时候，不同的Distance调用指向了不同类型里的Distance方法。让我们来定义一个Path类型，这个Path代表一个线段的集合，并且也给这个Path定义一个叫Distance的方法。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// A Path is a journey connecting the points with straight lines.</span>
<span class="token keyword">type</span> Path <span class="token punctuation">[</span><span class="token punctuation">]</span>Point
<span class="token comment">// Distance returns the distance traveled along the path.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>path Path<span class="token punctuation">)</span> <span class="token function">Distance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span>
    sum <span class="token operator">:=</span> <span class="token number">0.0</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> path <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
            sum <span class="token operator">+=</span> path<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> sum
<span class="token punctuation">&#125;</span></code></pre>

<p>Path是一个命名的slice类型，而不是Point那样的struct类型，然而我们依然可以为它定义方法。在能够给任意类型定义方法这一点上，Go和很多其它的面向对象的语言不太一样。<strong>因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型（译注：这个例子里，底层类型是指[]Point这个slice，Path就是命名类型）不是指针或者interface。</strong></p>
<p>两个Distance方法有不同的类型。他们两个方法之间没有任何关系，尽管Path的Distance方法会在内部调用<code>Point.Distance</code>方法来计算每个连接邻接点的线段的长度。</p>
<p>让我们来调用一个新方法，计算三角形的周长：</p>
<pre class="language-go" data-language="go"><code class="language-go">perim <span class="token operator">:=</span> Path<span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>perim<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "12"</span></code></pre>

<p>在上面两个对Distance名字的方法的调用中，编译器会根据方法的名字以及接收器来决定具体调用的是哪一个函数。第一个例子中<code>path[i-1]</code>数组中的类型是Point，因此<code>Point.Distance</code>这个方法被调用；在第二个例子中perim的类型是Path，因此Distance调用的是<code>Path.Distance</code>。</p>
<p>对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名，比如我们这里Point和Path就都有Distance这个名字的方法；所以我们没有必要非在方法名之前加类型名来消除歧义，比如PathDistance。这里我们已经看到了方法比之函数的一些好处：方法名可以简短。当我们在包外调用的时候这种好处就会被放大，因为我们可以使用这个短名字，而可以省略掉包的名字，下面是例子：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"gopl.io/ch6/geometry"</span>

perim <span class="token operator">:=</span> geometry<span class="token punctuation">.</span>Path<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>geometry<span class="token punctuation">.</span><span class="token function">PathDistance</span><span class="token punctuation">(</span>perim<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "12", standalone function</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>perim<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token comment">// "12", method of geometry.Path</span></code></pre>

<h2 id="基于指针对象的方法"><a href="#基于指针对象的方法" class="headerlink" title="基于指针对象的方法"></a>基于指针对象的方法</h2><p><strong>当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。当我们要对接收者变量本身进行修改时，我可以用其指针而不是对象来声明方法：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Point<span class="token punctuation">)</span> <span class="token function">ScaleBy</span><span class="token punctuation">(</span>factor <span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    p<span class="token punctuation">.</span>X <span class="token operator">*=</span> factor
    p<span class="token punctuation">.</span>Y <span class="token operator">*=</span> factor
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>这个方法的名字是<code>(*Point).ScaleBy</code>。这里的括号是必须的；没有括号的话这个表达式可能会被理解为<code>*(Point.ScaleBy)</code>。</strong></p>
<p>在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。我们在这里打破了这个约定只是为了展示一下两种方法的异同而已。</p>
<p><strong>只有类型（如<code>Point</code>）或指向类型的指针（如<code>*Point</code>），才能成为方法声明中的接收器。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，比如下面这个例子：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> P <span class="token operator">*</span><span class="token builtin">int</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>P<span class="token punctuation">)</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span> <span class="token comment">// compile error: invalid receiver type</span></code></pre>

<p>想要调用指针类型方法<code>(*Point).ScaleBy</code>，只要提供一个Point类型的指针即可，像下面这样。</p>
<pre class="language-go" data-language="go"><code class="language-go">r <span class="token operator">:=</span> <span class="token operator">&amp;</span>Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>
r<span class="token punctuation">.</span><span class="token function">ScaleBy</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>r<span class="token punctuation">)</span> <span class="token comment">// "&#123;2, 4&#125;"</span></code></pre>

<p>或者这样：</p>
<pre class="language-go" data-language="go"><code class="language-go">p <span class="token operator">:=</span> Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>
pptr <span class="token operator">:=</span> <span class="token operator">&amp;</span>p
pptr<span class="token punctuation">.</span><span class="token function">ScaleBy</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment">// "&#123;2, 4&#125;"</span></code></pre>

<p>或者这样:</p>
<pre class="language-go" data-language="go"><code class="language-go">p <span class="token operator">:=</span> Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ScaleBy</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment">// "&#123;2, 4&#125;"</span></code></pre>

<p>不过后面两种方法有些笨拙。幸运的是，go语言本身在这种地方会帮到我们。<strong>如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">p<span class="token punctuation">.</span><span class="token function">ScaleBy</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre>

<p><strong>编译器会隐式地帮我们用<code>&amp;p</code>去调用<code>ScaleBy</code>这个方法。这种简写方法只适用于“变量”，包括struct里的字段比如<code>p.X</code>，以及array和slice内的元素比如<code>perim[0]</code>。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">ScaleBy</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// compile error: can't take address of Point literal</span></code></pre>

<p><strong>我们也可以用一个<code>*Point</code>这样的接收器来调用Point的方法，因为我们可以通过地址来找到这个变量，只要用解引用符号<code>*</code>来取到该变量即可。编译器在这里也会给我们隐式地插入<code>*</code>这个操作符，所以下面这两种写法等价的：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">pptr<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">*</span>pptr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span></code></pre>

<p><strong>总结：在每一个合法的方法调用表达式中，也就是下面三种情况里的任意一种情况都是可以的：</strong></p>
<p>要么接收器的实际参数和其形式参数是相同的类型，比如两者都是类型T或者都是类型<code>*T</code>：</p>
<pre class="language-go" data-language="go"><code class="language-go">Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token comment">//  Point</span>
pptr<span class="token punctuation">.</span><span class="token function">ScaleBy</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>         <span class="token comment">// *Point</span></code></pre>

<p>或者接收器实参是类型T，但接收器形参是类型<code>*T</code>，这种情况下编译器会隐式地为我们取变量的地址：</p>
<pre class="language-go" data-language="go"><code class="language-go">p<span class="token punctuation">.</span><span class="token function">ScaleBy</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// implicit (&amp;p)</span></code></pre>

<p>或者接收器实参是类型<code>*T</code>，形参是类型T。编译器会隐式地为我们解引用，取到指针指向的实际变量：</p>
<pre class="language-go" data-language="go"><code class="language-go">pptr<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token comment">// implicit (*pptr)</span></code></pre>

<p>如果自定义类型T的所有方法都是用T类型自己来做接收器（而不是<code>*T</code>），那么拷贝这种类型的实例就是安全的；调用他的任何一个方法也就会产生一个值的拷贝。比如<code>time.Duration</code>的这个类型，在调用其方法时就会被全部拷贝一份，包括在作为参数传入函数的时候。但是如果一个方法使用指针作为接收器，你需要避免对其进行拷贝，因为这样可能会破坏掉该类型内部的不变性。比如你对<code>bytes.Buffer</code>对象进行了拷贝，那么可能会引起原始对象和拷贝对象只是别名而已，实际上它们指向的对象是一样的。紧接着对拷贝后的变量进行修改可能会有让你有意外的结果。</p>
<blockquote>
<p> <strong>译注：</strong> 作者这里说的比较绕，其实有两点：</p>
<ol>
<li>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针&#x2F;非指针类型进行调用的，编译器会帮你做类型转换。</li>
<li>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型保存的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。</li>
</ol>
</blockquote>
<h3 id="nil也是一个合法的接收器类型"><a href="#nil也是一个合法的接收器类型" class="headerlink" title="nil也是一个合法的接收器类型"></a><code>nil</code>也是一个合法的接收器类型</h3><p>就像一些函数允许nil指针作为参数一样，方法理论上也可以用nil指针作为其接收器，尤其当nil对于对象来说是合法的零值时，比如map或者slice。在下面的简单int链表的例子里，nil代表的是空链表：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// An IntList is a linked list of integers.</span>
<span class="token comment">// A nil *IntList represents the empty list.</span>
<span class="token keyword">type</span> IntList <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Value <span class="token builtin">int</span>
    Tail  <span class="token operator">*</span>IntList
<span class="token punctuation">&#125;</span>
<span class="token comment">// Sum returns the sum of the list elements.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>list <span class="token operator">*</span>IntList<span class="token punctuation">)</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> list <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> list<span class="token punctuation">.</span>Value <span class="token operator">+</span> list<span class="token punctuation">.</span>Tail<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的，就像我们上面例子里做的这样。</p>
<p>下面是<code>net/url</code>包里Values类型定义的一部分。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> url

<span class="token comment">// Values maps a string key to a list of values.</span>
<span class="token keyword">type</span> Values <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token comment">// Get returns the first value associated with the given key,</span>
<span class="token comment">// or "" if there are none.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>v Values<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> vs <span class="token operator">:=</span> v<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">len</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> vs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token string">""</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// Add adds the value to key.</span>
<span class="token comment">// It appends to any existing values associated with key.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>v Values<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    v<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>这个定义向外部暴露了一个map的命名类型，并且提供了一些能够简单操作这个map的方法。这个map的value字段是一个string的slice，所以这个Values是一个多维map。客户端使用这个变量的时候可以使用map固有的一些操作（make，切片，<code>m[key]</code>等等），也可以使用这里提供的操作方法，或者两者并用，都是可以的：</p>
<pre class="language-go" data-language="go"><code class="language-go">m <span class="token operator">:=</span> url<span class="token punctuation">.</span>Values<span class="token punctuation">&#123;</span><span class="token string">"lang"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">"en"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">// direct construction</span>
m<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span>
m<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span>

fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"lang"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "en"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"q"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// ""</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "1"      (first value)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span><span class="token string">"item"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token comment">// "[1 2]"  (direct map access)</span>

m <span class="token operator">=</span> <span class="token boolean">nil</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ""</span>
m<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span>         <span class="token comment">// panic: assignment to entry in nil map</span></code></pre>

<p>对Get的最后一次调用中，nil接收器的行为即是一个空map的行为。我们可以等价地将这个操作写成<code>Value(nil).Get(&quot;item&quot;)</code>，但是如果你直接写<code>nil.Get(&quot;item&quot;)</code>的话是无法通过编译的，因为nil的字面量编译器无法判断其准确类型。所以相比之下，最后的那行<code>m.Add</code>的调用就会产生一个panic，因为他尝试更新一个空map。</p>
<p>由于<code>url.Values</code>是一个map类型，并且间接引用了其key&#x2F;value对，因此<code>url.Values.Add</code>对这个map里的元素做任何的更新、删除操作对调用方都是可见的。实际上，就像在普通函数中一样，虽然可以通过引用来操作内部值，但在方法想要修改引用本身时是不会影响原始值的，比如把他置换为<code>nil</code>，或者让这个引用指向了其它的对象，调用方都不会受影响。（译注：因为传入的是存储了内存地址的变量，你改变这个变量本身是影响不了原始的变量的，想想C语言，是差不多的）</p>
<h2 id="通过嵌入结构体来扩展类型"><a href="#通过嵌入结构体来扩展类型" class="headerlink" title="通过嵌入结构体来扩展类型"></a>通过嵌入结构体来扩展类型</h2><p>来看看<code>ColoredPoint</code>这个类型：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"image/color"</span>

<span class="token keyword">type</span> Point <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> X<span class="token punctuation">,</span> Y <span class="token builtin">float64</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> ColoredPoint <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Point
    Color color<span class="token punctuation">.</span>RGBA
<span class="token punctuation">&#125;</span></code></pre>

<p>我们完全可以将<code>ColoredPoint</code>定义为一个有三个字段的struct，但是我们却将<code>Point</code>这个类型嵌入到<code>ColoredPoint</code>来提供<code>X</code>和<code>Y</code>这两个字段。像我们在4.4节中看到的那样，内嵌可以使我们在定义<code>ColoredPoint</code>时得到一种句法上的简写形式，并使其包含<code>Point</code>类型所具有的一切字段，然后再定义一些自己的。如果我们想要的话，我们可以直接认为通过嵌入的字段就是<code>ColoredPoint</code>自身的字段，而完全不需要在调用时指出<code>Point</code>，比如下面这样。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> cp ColoredPoint
cp<span class="token punctuation">.</span>X <span class="token operator">=</span> <span class="token number">1</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>cp<span class="token punctuation">.</span>Point<span class="token punctuation">.</span>X<span class="token punctuation">)</span> <span class="token comment">// "1"</span>
cp<span class="token punctuation">.</span>Point<span class="token punctuation">.</span>Y <span class="token operator">=</span> <span class="token number">2</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>cp<span class="token punctuation">.</span>Y<span class="token punctuation">)</span> <span class="token comment">// "2"</span></code></pre>

<p>对于Point中的方法我们也有类似的用法，我们可以把ColoredPoint类型当作接收器来调用Point里的方法，即使ColoredPoint里没有声明这些方法：</p>
<pre class="language-go" data-language="go"><code class="language-go">red <span class="token operator">:=</span> color<span class="token punctuation">.</span>RGBA<span class="token punctuation">&#123;</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">&#125;</span>
blue <span class="token operator">:=</span> color<span class="token punctuation">.</span>RGBA<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> ColoredPoint<span class="token punctuation">&#123;</span>Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> red<span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> q <span class="token operator">=</span> ColoredPoint<span class="token punctuation">&#123;</span>Point<span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> blue<span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>Point<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "5"</span>
p<span class="token punctuation">.</span><span class="token function">ScaleBy</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
q<span class="token punctuation">.</span><span class="token function">ScaleBy</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>Point<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "10"</span></code></pre>

<p><strong><code>Point</code>类的方法也被引入了<code>ColoredPoint</code>。用这种方式，内嵌可以使我们定义字段特别多的复杂类型，我们可以将字段先按小类型分组，然后定义小类型的方法，之后再把它们组合起来。</strong></p>
<p><strong>读者如果对基于类来实现面向对象的语言比较熟悉的话，可能会倾向于将Point看作一个基类，而<code>ColoredPoint</code>看作其子类或者继承类，或者将<code>ColoredPoint</code>看作”is a” <code>Point</code>类型。但这是错误的理解。请注意上面例子中对<code>Distance</code>方法的调用。<code>Distance</code>有一个参数是<code>Point</code>类型，但<code>q</code>并不是一个<code>Point</code>类，所以尽管<code>q</code>有着<code>Point</code>这个内嵌类型，我们也必须要显式地选择它。尝试直接传<code>q</code>的话你会看到下面这样的错误：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">p<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token comment">// compile error: cannot use q (ColoredPoint) as Point</span></code></pre>

<p><strong>一个<code>ColoredPoint</code>并不是一个<code>Point</code>，但他”has a”Point，并且它有从<code>Point</code>类里引入的<code>Distance</code>和<code>ScaleBy</code>方法。如果你喜欢从实现的角度来考虑问题，内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法，和下面的形式是等价的：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>p ColoredPoint<span class="token punctuation">)</span> <span class="token function">Distance</span><span class="token punctuation">(</span>q Point<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">.</span>Point<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>ColoredPoint<span class="token punctuation">)</span> <span class="token function">ScaleBy</span><span class="token punctuation">(</span>factor <span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    p<span class="token punctuation">.</span>Point<span class="token punctuation">.</span><span class="token function">ScaleBy</span><span class="token punctuation">(</span>factor<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>当<code>Point.Distance</code>被第一个包装方法调用时，它的接收器值是<code>p.Point</code>，而不是<code>p</code>，当然了，在<code>Point</code>类的方法里，你是访问不到<code>ColoredPoint</code>的任何字段的。</p>
<p><strong>在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中（译注：访问需要通过该指针指向的对象去取）。添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。下面这个<code>ColoredPoint</code>的声明内嵌了一个<code>*Point</code>的指针。</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ColoredPoint <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">*</span>Point
    Color color<span class="token punctuation">.</span>RGBA
<span class="token punctuation">&#125;</span>

p <span class="token operator">:=</span> ColoredPoint<span class="token punctuation">&#123;</span><span class="token operator">&amp;</span>Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> red<span class="token punctuation">&#125;</span>
q <span class="token operator">:=</span> ColoredPoint<span class="token punctuation">&#123;</span><span class="token operator">&amp;</span>Point<span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> blue<span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span><span class="token operator">*</span>q<span class="token punctuation">.</span>Point<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "5"</span>
q<span class="token punctuation">.</span>Point <span class="token operator">=</span> p<span class="token punctuation">.</span>Point                 <span class="token comment">// p and q now share the same Point</span>
p<span class="token punctuation">.</span><span class="token function">ScaleBy</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">.</span>Point<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">.</span>Point<span class="token punctuation">)</span> <span class="token comment">// "&#123;2 2&#125; &#123;2 2&#125;"</span></code></pre>

<p>一个struct类型也可能会有多个匿名字段。我们将<code>ColoredPoint</code>定义为下面这样：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ColoredPoint <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Point
    color<span class="token punctuation">.</span>RGBA
<span class="token punctuation">&#125;</span></code></pre>

<p>然后这种类型的值便会拥有<code>Point</code>和<code>RGBA</code>类型的所有方法，以及直接定义在<code>ColoredPoint</code>中的方法。当编译器解析一个选择器到方法时，比如<code>p.ScaleBy</code>，它会首先去找直接定义在这个类型里的<code>ScaleBy</code>方法，然后找被<code>ColoredPoint</code>的内嵌字段们引入的方法，然后去找<code>Point</code>和<code>RGBA</code>的内嵌字段引入的方法，然后一直递归向下找。如果选择器有二义性的话编译器会报错，比如你在同一级里有两个同名的方法。</p>
<p>方法只能在命名类型（像<code>Point</code>）或者指向类型的指针上定义，但是多亏了内嵌，有些时候我们给匿名struct类型来定义方法也有了手段。</p>
<p>下面是一个小trick。这个例子展示了简单的cache，其使用两个包级别的变量来实现，一个mutex互斥量（§9.2）和它所操作的cache：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>
    mu sync<span class="token punctuation">.</span>Mutex <span class="token comment">// guards mapping</span>
    mapping <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">Lookup</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
    mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    v <span class="token operator">:=</span> mapping<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> v
<span class="token punctuation">&#125;</span></code></pre>

<p>下面这个版本在功能上是一致的，但将两个包级别的变量放在了cache这个struct一组内：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> cache <span class="token operator">=</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    sync<span class="token punctuation">.</span>Mutex
    mapping <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span>
    mapping<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">func</span> <span class="token function">Lookup</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
    cache<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    v <span class="token operator">:=</span> cache<span class="token punctuation">.</span>mapping<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    cache<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> v
<span class="token punctuation">&#125;</span></code></pre>

<p>我们给新的变量起了一个更具表达性的名字：cache。因为<code>sync.Mutex</code>字段也被嵌入到了这个struct里，其<code>Lock</code>和<code>Unlock</code>方法也就都被引入到了这个匿名结构中了，这让我们能够以一个简单明了的语法来对其进行加锁解锁操作。</p>
<h2 id="方法值和方法表达式"><a href="#方法值和方法表达式" class="headerlink" title="方法值和方法表达式"></a>方法值和方法表达式</h2><p><strong>我们经常选择一个方法，并且在同一个表达式里执行，比如常见的<code>p.Distance()</code>形式，实际上将其分成两步来执行也是可能的。<code>p.Distance</code>叫作“选择器”，选择器会返回一个方法“值”——一个将方法（<code>Point.Distance</code>）绑定到特定接收器变量的函数。这个函数可以不通过指定其接收器即可被调用；即调用时不需要指定接收器，只要传入函数的参数即可：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">p <span class="token operator">:=</span> Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>
q <span class="token operator">:=</span> Point<span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span>

distanceFromP <span class="token operator">:=</span> p<span class="token punctuation">.</span>Distance        <span class="token comment">// method value</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">distanceFromP</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">// "5"</span>
<span class="token keyword">var</span> origin Point                   <span class="token comment">// &#123;0, 0&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">distanceFromP</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "2.23606797749979", sqrt(5)</span>

scaleP <span class="token operator">:=</span> p<span class="token punctuation">.</span>ScaleBy <span class="token comment">// method value</span>
<span class="token function">scaleP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>           <span class="token comment">// p becomes (2, 4)</span>
<span class="token function">scaleP</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>           <span class="token comment">//      then (6, 12)</span>
<span class="token function">scaleP</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>          <span class="token comment">//      then (60, 120)</span></code></pre>

<p>在一个包的API需要一个函数值、且调用方希望操作的是某一个绑定了对象的方法的话，方法“值”会非常实用。举例来说，下面例子中的<code>time.AfterFunc</code>这个函数的功能是在指定的延迟时间之后来执行一个函数。且这个函数操作的是一个<code>Rocket</code>对象<code>r</code>：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Rocket <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Rocket<span class="token punctuation">)</span> <span class="token function">Launch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span>
r <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Rocket<span class="token punctuation">)</span>
time<span class="token punctuation">.</span><span class="token function">AfterFunc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> r<span class="token punctuation">.</span><span class="token function">Launch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre>

<p>直接用方法“值”传入<code>AfterFunc</code>的话可以更为简短：</p>
<pre class="language-go" data-language="go"><code class="language-go">time<span class="token punctuation">.</span><span class="token function">AfterFunc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">,</span> r<span class="token punctuation">.</span>Launch<span class="token punctuation">)</span></code></pre>

<p><strong>和方法“值”相关的还有 <em>方法表达式</em> 。当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器（<code>p.Distance</code>）语法来指定方法的接收器。</strong></p>
<p><strong>当T是一个类型时，方法表达式可能会写作<code>T.f</code>或者<code>(*T).f</code>，会返回一个函数“值”，这种函数会将其第一个参数用作接收器，所以可以用通常（译注：不写选择器）的方式来对其进行调用：</strong> </p>
<pre class="language-go" data-language="go"><code class="language-go">p <span class="token operator">:=</span> Point<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>
q <span class="token operator">:=</span> Point<span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span>

distance <span class="token operator">:=</span> Point<span class="token punctuation">.</span>Distance   <span class="token comment">// method expression</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">distance</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// "5"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> distance<span class="token punctuation">)</span> <span class="token comment">// "func(Point, Point) float64"</span>

scale <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>Point<span class="token punctuation">)</span><span class="token punctuation">.</span>ScaleBy
<span class="token function">scale</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>            <span class="token comment">// "&#123;2 4&#125;"</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> scale<span class="token punctuation">)</span> <span class="token comment">// "func(*Point, float64)"</span>

<span class="token comment">// 译注：这个Distance实际上是指定了Point对象为接收器的一个方法func (p Point) Distance()，</span>
<span class="token comment">// 但通过Point.Distance得到的函数需要比实际的Distance方法多一个参数，</span>
<span class="token comment">// 即其需要用第一个额外参数指定接收器，后面排列Distance方法的参数。</span>
<span class="token comment">// 看起来本书中函数和方法的区别是指有没有接收器，而不像其他语言那样是指有没有返回值。</span></code></pre>

<p>当你根据一个变量来决定调用同一个类型的哪个函数时，方法表达式就显得很有用了。你可以根据选择来调用接收器各不相同的方法。下面的例子，变量<code>op</code>代表<code>Point</code>类型的<code>Add</code>或者<code>Sub</code>方法，<code>Path.TranslateBy</code>方法会为其Path数组中的每一个<code>Point</code>来调用对应的方法：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Point <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> X<span class="token punctuation">,</span> Y <span class="token builtin">float64</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p Point<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>q Point<span class="token punctuation">)</span> Point <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> Point<span class="token punctuation">&#123;</span>p<span class="token punctuation">.</span>X <span class="token operator">+</span> q<span class="token punctuation">.</span>X<span class="token punctuation">,</span> p<span class="token punctuation">.</span>Y <span class="token operator">+</span> q<span class="token punctuation">.</span>Y<span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p Point<span class="token punctuation">)</span> <span class="token function">Sub</span><span class="token punctuation">(</span>q Point<span class="token punctuation">)</span> Point <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> Point<span class="token punctuation">&#123;</span>p<span class="token punctuation">.</span>X <span class="token operator">-</span> q<span class="token punctuation">.</span>X<span class="token punctuation">,</span> p<span class="token punctuation">.</span>Y <span class="token operator">-</span> q<span class="token punctuation">.</span>Y<span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Path <span class="token punctuation">[</span><span class="token punctuation">]</span>Point

<span class="token keyword">func</span> <span class="token punctuation">(</span>path Path<span class="token punctuation">)</span> <span class="token function">TranslateBy</span><span class="token punctuation">(</span>offset Point<span class="token punctuation">,</span> add <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> op <span class="token keyword">func</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> q Point<span class="token punctuation">)</span> Point
    <span class="token keyword">if</span> add <span class="token punctuation">&#123;</span>
        op <span class="token operator">=</span> Point<span class="token punctuation">.</span>Add
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        op <span class="token operator">=</span> Point<span class="token punctuation">.</span>Sub
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> path <span class="token punctuation">&#123;</span>
        <span class="token comment">// Call either path[i].Add(offset) or path[i].Sub(offset).</span>
        path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">op</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> offset<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>



<h2 id="示例-Bit数组"><a href="#示例-Bit数组" class="headerlink" title="示例: Bit数组"></a>示例: Bit数组</h2><p>Go语言里的集合一般会用<code>map[T]bool</code>这种形式来表示，T代表元素类型。集合用map类型来表示虽然非常灵活，但我们可以以一种更好的形式来表示它。例如在数据流分析领域，集合元素通常是一个非负整数，集合会包含很多元素，并且集合会经常进行并集、交集操作，这种情况下，bit数组会比map表现更加理想。（译注：这里再补充一个例子，比如我们执行一个http下载任务，把文件按照16kb一块划分为很多块，需要有一个全局变量来标识哪些块下载完成了，这种时候也需要用到bit数组。）</p>
<p>一个bit数组通常会用一个无符号数或者称之为“字”的slice来表示，每一个元素的每一位都表示集合里的一个值。当集合的第<code>i</code>位被设置时，我们才说这个集合包含元素<code>i</code>。下面的这个程序展示了一个简单的bit数组类型，并且实现了三个函数来对这个bit数组来进行操作：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// An IntSet is a set of small non-negative integers.</span>
<span class="token comment">// Its zero value represents the empty set.</span>
<span class="token keyword">type</span> IntSet <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    words <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">uint64</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Has reports whether the set contains the non-negative value x.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>IntSet<span class="token punctuation">)</span> <span class="token function">Has</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
    word<span class="token punctuation">,</span> bit <span class="token operator">:=</span> x<span class="token operator">/</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token function">uint</span><span class="token punctuation">(</span>x<span class="token operator">%</span><span class="token number">64</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> word <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>words<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span>words<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>bit<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Add adds the non-negative value x to the set.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>IntSet<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    word<span class="token punctuation">,</span> bit <span class="token operator">:=</span> x<span class="token operator">/</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token function">uint</span><span class="token punctuation">(</span>x<span class="token operator">%</span><span class="token number">64</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> word <span class="token operator">>=</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>words<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        s<span class="token punctuation">.</span>words <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>words<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    s<span class="token punctuation">.</span>words<span class="token punctuation">[</span>word<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> bit
<span class="token punctuation">&#125;</span>

<span class="token comment">// UnionWith sets s to the union of s and t.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>IntSet<span class="token punctuation">)</span> <span class="token function">UnionWith</span><span class="token punctuation">(</span>t <span class="token operator">*</span>IntSet<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> i<span class="token punctuation">,</span> tword <span class="token operator">:=</span> <span class="token keyword">range</span> t<span class="token punctuation">.</span>words <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>words<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            s<span class="token punctuation">.</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">|=</span> tword
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            s<span class="token punctuation">.</span>words <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>words<span class="token punctuation">,</span> tword<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>因为每一个字都有64个二进制位，所以为了定位<code>x</code>的bit位，我们用了<code>x/64</code>的商作为字的下标，并且用x%64得到的值作为这个字内的bit的所在位置。<code>UnionWith</code>这个方法里用到了bit位的“或”逻辑操作符号|来一次完成64个元素的或计算。（在练习6.5中我们还会有程序用到这个64位字的例子。）</p>
<p>当前这个实现还缺少了很多必要的特性，我们把其中一些作为练习题列在本小节之后。但是有一个方法如果缺失的话我们的bit数组可能会比较难混：将<code>IntSet</code>作为一个字符串来打印。这里我们来实现它，让我们来给上面的例子添加一个<code>String</code>方法，类似2.5节中做的那样：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// String returns the set as a string of the form "&#123;1 2 3&#125;".</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>IntSet<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> buf bytes<span class="token punctuation">.</span>Buffer
    buf<span class="token punctuation">.</span><span class="token function">WriteByte</span><span class="token punctuation">(</span><span class="token char">'&#123;'</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i<span class="token punctuation">,</span> word <span class="token operator">:=</span> <span class="token keyword">range</span> s<span class="token punctuation">.</span>words <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> word <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">continue</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">64</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> word<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token function">uint</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> buf<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token function">len</span><span class="token punctuation">(</span><span class="token string">"&#123;"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    buf<span class="token punctuation">.</span><span class="token function">WriteByte</span><span class="token punctuation">(</span><span class="token char">' '</span><span class="token punctuation">)</span>
                <span class="token punctuation">&#125;</span>
                fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    buf<span class="token punctuation">.</span><span class="token function">WriteByte</span><span class="token punctuation">(</span><span class="token char">'&#125;'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> buf<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>这里留意一下<code>String</code>方法，是不是和3.5.4节中的<code>intsToString</code>方法很相似；<code>bytes.Buffer</code>在<code>String</code>方法里经常这么用。当你为一个复杂的类型定义了一个<code>String</code>方法时，<code>fmt</code>包就会特殊对待这种类型的值，这样可以让这些类型在打印的时候看起来更加友好，而不是直接打印其原始的值。<code>fmt</code>会直接调用用户定义的<code>String</code>方法。这种机制依赖于接口和类型断言，在第7章中我们会详细介绍。</p>
<p>现在我们就可以在实战中直接用上面定义好的<code>IntSet</code>了：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x<span class="token punctuation">,</span> y IntSet
x<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
x<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">144</span><span class="token punctuation">)</span>
x<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "&#123;1 9 144&#125;"</span>

y<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>
y<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "&#123;9 42&#125;"</span>

x<span class="token punctuation">.</span><span class="token function">UnionWith</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "&#123;1 9 42 144&#125;"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">Has</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span><span class="token function">Has</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "true false"</span></code></pre>

<p>这里要注意：我们声明的<code>String</code>和<code>Has</code>两个方法都是以指针类型<code>*IntSet</code>来作为接收器的，但实际上对于这两个类型来说，把接收器声明为指针类型也没什么必要。不过另外两个函数就不是这样了，因为另外两个函数操作的是<code>s.words</code>对象，如果你不把接收器声明为指针对象，那么实际操作的是拷贝对象，而不是原来的那个对象。因此，因为我们的<code>String</code>方法定义在<code>IntSet</code>指针上，所以当我们的变量是<code>IntSet</code>类型而不是<code>IntSet</code>指针时，可能会有下面这样让人意外的情况：</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span>         <span class="token comment">// "&#123;1 9 42 144&#125;"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "&#123;1 9 42 144&#125;"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>          <span class="token comment">// "&#123;[4398046511618 0 65536]&#125;"</span></code></pre>

<p>在第一个<code>Println</code>中，我们打印一个<code>*IntSet</code>的指针，这个类型的指针确实有自定义的String方法。第二<code>Println</code>，我们直接调用了x变量的<code>String()</code>方法；这种情况下编译器会隐式地在x前插入<code>&amp;</code>操作符，这样相当于我们还是调用的<code>IntSet</code>指针的<code>String</code>方法。在第三个<code>Println</code>中，因为<code>IntSet</code>类型没有<code>String</code>方法，所以<code>Println</code>方法会直接以原始的方式理解并打印。所以在这种情况下<code>&amp;</code>符号是不能忘的。在我们这种场景下，你把<code>String</code>方法绑定到<code>IntSet</code>对象上，而不是<code>IntSet</code>指针上可能会更合适一些，不过这也需要具体问题具体分析。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为<strong>“封装”</strong>。封装有时候也被叫做<strong>信息隐藏</strong>，同时也是面向对象编程最关键的一个方面。</p>
<p><strong>Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。</strong></p>
<p>这也就是前面的小节中<code>IntSet</code>被定义为struct类型的原因，尽管它只有一个字段：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> IntSet <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    words <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">uint64</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>当然，我们也可以把<code>IntSet</code>定义为一个slice类型，但这样我们就需要把代码中所有方法里用到的<code>s.words</code>用<code>*s</code>替换掉了：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> IntSet <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">uint64</span></code></pre>

<p>尽管这个版本的<code>IntSet</code>在本质上是一样的，但它也允许其它包中可以直接读取并编辑这个slice。换句话说，相对于<code>*s</code>这个表达式会出现在所有的包中，<code>s.words</code>只需要在定义<code>IntSet</code>的包中出现。</p>
<p><strong>这种基于名字的手段使得在语言中最小的封装单元是package，而不是像其它语言一样的类型。一个struct类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。</strong></p>
<p>封装提供了3个优点：</p>
<ul>
<li><p>因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。</p>
</li>
<li><p>隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的API情况下能得到更大的自由。</p>
</li>
<li><p>阻止了外部调用方对对象内部的值任意地进行修改。</p>
</li>
</ul>
<p>把<code>bytes.Buffer</code>这个类型作为例子来考虑。这个类型在做短字符串叠加的时候很常用，所以在设计的时候可以做一些预先的优化，比如提前预留一部分空间，来避免反复的内存分配。又因为Buffer是一个struct类型，这些额外的空间可以用附加的字节数组来保存，且放在一个小写字母开头的字段中。这样在外部的调用方只能看到性能的提升，但并不会得到这个附加变量。Buffer和其增长算法我们列在这里，为了简洁性稍微做了一些精简：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Buffer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    buf     <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
    initial <span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
    <span class="token comment">/* ... */</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Grow expands the buffer's capacity, if necessary,</span>
<span class="token comment">// to guarantee space for another n bytes. [...]</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Buffer<span class="token punctuation">)</span> <span class="token function">Grow</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> b<span class="token punctuation">.</span>buf <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        b<span class="token punctuation">.</span>buf <span class="token operator">=</span> b<span class="token punctuation">.</span>initial<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// use preallocated space initially</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>buf<span class="token punctuation">)</span><span class="token operator">+</span>n <span class="token operator">></span> <span class="token function">cap</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>buf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span><span class="token function">cap</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>buf<span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token punctuation">)</span>
        <span class="token function">copy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> b<span class="token punctuation">.</span>buf<span class="token punctuation">)</span>
        b<span class="token punctuation">.</span>buf <span class="token operator">=</span> buf
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>封装的第三个优点也是最重要的优点，是阻止了外部调用方对对象内部的值任意地进行修改。因为对象内部变量只可以被同一个包内的函数修改，所以包的作者可以让这些函数确保对象内部的一些值的不变性。比如下面的<code>Counter</code>类型允许调用方来增加<code>n</code>变量的值，并且允许将这个值<code>reset</code>为<code>0</code>，但是不允许从包外随便设置这个值：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Counter <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> n <span class="token builtin">int</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Counter<span class="token punctuation">)</span> <span class="token function">N</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>     <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span>n <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Counter<span class="token punctuation">)</span> <span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> c<span class="token punctuation">.</span>n<span class="token operator">++</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Counter<span class="token punctuation">)</span> <span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span> c<span class="token punctuation">.</span>n <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span></code></pre>

<p>只用来访问或修改内部变量的函数被称为<code>setter</code>或者<code>getter</code>，例子如下，比如log包里的Logger类型对应的一些函数。在命名一个<code>getter</code>方法时，我们通常会省略掉前面的<code>Get</code>前缀。这种简洁上的偏好也可以推广到各种类型的前缀比如<code>Fetch</code>，<code>Find</code>或者<code>Lookup</code>。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> log
<span class="token keyword">type</span> Logger <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    flags  <span class="token builtin">int</span>
    prefix <span class="token builtin">string</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>Logger<span class="token punctuation">)</span> <span class="token function">Flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>Logger<span class="token punctuation">)</span> <span class="token function">SetFlags</span><span class="token punctuation">(</span>flag <span class="token builtin">int</span><span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>Logger<span class="token punctuation">)</span> <span class="token function">Prefix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>Logger<span class="token punctuation">)</span> <span class="token function">SetPrefix</span><span class="token punctuation">(</span>prefix <span class="token builtin">string</span><span class="token punctuation">)</span></code></pre>

<p>Go的编码风格不禁止直接导出字段。当然，一旦进行了导出，就没有办法在保证API兼容的情况下去除对其的导出，所以在一开始的选择一定要经过深思熟虑并且要考虑到包内部的一些不变量的保证，未来可能的变化，以及调用方的代码质量是否会因为包的一点修改而变差。</p>
<p>封装并不总是理想的。 虽然封装在有些情况是必要的，但有时候我们也需要暴露一些内部内容，比如：<code>time.Duration</code>将其表现暴露为一个int64数字的纳秒，使得我们可以用一般的数值操作来对时间进行对比，甚至可以定义这种类型的常量：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> day <span class="token operator">=</span> <span class="token number">24</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Hour
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>day<span class="token punctuation">.</span><span class="token function">Seconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "86400"</span></code></pre>

<p>另一个例子，将<code>IntSet</code>和本章开头的<code>geometry.Path</code>进行对比。Path被定义为一个slice类型，这允许其调用slice的字面方法来对其内部的<code>points</code>用range进行迭代遍历；在这一点上，<code>IntSet</code>是没有办法让你这么做的。</p>
<p>这两种类型决定性的不同：<code>geometry.Path</code>的本质是一个坐标点的序列，不多也不少，我们可以预见到之后也并不会给他增加额外的字段，所以在<code>geometry</code>包中将<code>Path</code>暴露为一个slice。相比之下，<code>IntSet</code>仅仅是在这里用了一个<code>[]uint64</code>的slice。这个类型还可以用<code>[]uint</code>类型来表示，或者我们甚至可以用其它完全不同的占用更小内存空间的东西来表示这个集合，所以我们可能还会需要额外的字段来在这个类型中记录元素的个数。也正是因为这些原因，我们让<code>IntSet</code>对调用方不透明。</p>
<p>在这章中，我们学到了如何将方法与命名类型进行组合，并且知道了如何调用这些方法。尽管方法对于OOP编程来说至关重要，但他们只是OOP编程里的半边天。为了完成OOP，我们还需要接口。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口约定"><a href="#接口约定" class="headerlink" title="接口约定"></a>接口约定</h2><p>目前为止，我们看到的类型都是具体的类型。一个具体的类型可以准确的描述它所代表的值，并且展示出对类型本身的一些操作方式：就像数字类型的算术操作，切片类型的取下标、添加元素和范围获取操作。具体的类型还可以通过它的内置方法提供额外的行为操作。总的来说，当你拿到一个具体的类型时你就知道它的本身是什么和你可以用它来做什么。</p>
<p><strong>在Go语言中还存在着另外一种类型：<em>接口类型</em>。<em>接口类型</em> 是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。</strong></p>
<p>在本书中，我们一直使用两个相似的函数来进行字符串的格式化：<code>fmt.Printf</code>，它会把结果写到标准输出，和<code>fmt.Sprintf</code>，它会把结果以字符串的形式返回。得益于使用接口，我们不必可悲的因为返回结果在使用方式上的一些浅显不同就必需把格式化这个最困难的过程复制一份。实际上，这两个函数都使用了另一个函数<code>fmt.Fprintf</code>来进行封装。<code>fmt.Fprintf</code>这个函数对它的计算结果会被怎么使用是完全不知道的。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> fmt

<span class="token keyword">func</span> <span class="token function">Fprintf</span><span class="token punctuation">(</span>w io<span class="token punctuation">.</span>Writer<span class="token punctuation">,</span> format <span class="token builtin">string</span><span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token function">Printf</span><span class="token punctuation">(</span>format <span class="token builtin">string</span><span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token function">Sprintf</span><span class="token punctuation">(</span>format <span class="token builtin">string</span><span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> buf bytes<span class="token punctuation">.</span>Buffer
    <span class="token function">Fprintf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> buf<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><code>Fprintf</code>的前缀F表示文件（File）也表明格式化输出结果应该被写入第1个参数提供的文件中。在<code>Printf</code>函数中的第1个参数<code>os.Stdout</code>是<code>*os.File</code>类型；在<code>Sprintf</code>函数中的第1个参数<code>&amp;buf</code>是一个指向可以写入字节的内存缓冲区，然而它并不是一个文件类型尽管它在某种意义上和文件类型相似。</p>
<p>即使<code>Fprintf</code>函数中的第1个参数也不是一个文件类型。<strong>它是<code>io.Writer</code>类型，这是一个接口类型定义如下：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> io

<span class="token comment">// Writer is the interface that wraps the basic Write method.</span>
<span class="token keyword">type</span> Writer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// Write writes len(p) bytes from p to the underlying data stream.</span>
    <span class="token comment">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))</span>
    <span class="token comment">// and any error encountered that caused the write to stop early.</span>
    <span class="token comment">// Write must return a non-nil error if it returns n &lt; len(p).</span>
    <span class="token comment">// Write must not modify the slice data, even temporarily.</span>
    <span class="token comment">//</span>
    <span class="token comment">// Implementations must not retain p.</span>
    <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><code>io.Writer</code>类型定义了函数<code>Fprintf</code>和这个函数调用者之间的约定。一方面这个约定需要调用者提供具体类型的值就像<code>*os.File</code>和<code>*bytes.Buffer</code>，这些类型都有一个特定签名和行为的<code>Write</code>的函数。另一方面这个约定保证了<code>Fprintf</code>接受任何满足<code>io.Writer</code>接口的值都可以工作。<code>Fprintf</code>函数可能没有假定写入的是一个文件或是一段内存，而是写入一个可以调用<code>Write</code>函数的值。</p>
<p>因为<code>fmt.Fprintf</code>函数没有对具体操作的值做任何假设，而是仅仅通过<code>io.Writer</code>接口的约定来保证行为，所以第1个参数可以安全地传入一个只需要满足<code>io.Writer</code>接口的任意具体类型的值。一个类型可以自由地被另一个满足相同接口的类型替换，被称作可替换性（LSP里氏替换）。这是一个面向对象的特征。</p>
<p>让我们通过一个新的类型来进行校验，下面<code>*ByteCounter</code>类型里的<code>Write</code>方法，仅仅在丢弃写向它的字节前统计它们的长度。（在这个<code>+=</code>赋值语句中，让<code>len(p)</code>的类型和<code>*c</code>的类型匹配的转换是必须的。）</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ByteCounter <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>ByteCounter<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">*</span>c <span class="token operator">+=</span> <span class="token function">ByteCounter</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// convert int to ByteCounter</span>
    <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>因为<code>*ByteCounter</code>满足<code>io.Writer</code>的约定，我们可以把它传入<code>Fprintf</code>函数中；<code>Fprintf</code>函数执行字符串格式化的过程不会去关注<code>ByteCounter</code>正确的累加结果的长度。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> c ByteCounter
c<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">// "5", = len("hello")</span>
c <span class="token operator">=</span> <span class="token number">0</span>          <span class="token comment">// reset the counter</span>
<span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"Dolly"</span>
fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">,</span> <span class="token string">"hello, %s"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">// "12", = len("hello, Dolly")</span></code></pre>

<p>除了<code>io.Writer</code>这个接口类型，还有另一个对<code>fmt</code>包很重要的接口类型。<code>Fprintf</code>和<code>Fprintln</code>函数向类型提供了一种控制它们值输出的途径。在2.5节中，我们为<code>Celsius</code>类型提供了一个<code>String</code>方法以便于可以打印成这样”100°C” ，在6.5节中我们给<code>*IntSet</code>添加一个<code>String</code>方法，这样集合可以用传统的符号来进行表示就像<code>&quot;&#123;1 2 3&#125;&quot;</code>。<strong>给一个类型定义<code>String</code>方法，可以让它满足最广泛使用之一的接口类型<code>fmt.Stringer</code>：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> fmt

<span class="token comment">// The String method is used to print values passed</span>
<span class="token comment">// as an operand to any format that accepts a string</span>
<span class="token comment">// or to an unformatted printer such as Print.</span>
<span class="token keyword">type</span> Stringer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span></code></pre>



<h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p><strong>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。</strong></p>
<p><code>io.Writer</code>类型是用得最广泛的接口之一，因为它提供了所有类型的写入bytes的抽象，包括文件类型，内存缓冲区，网络链接，HTTP客户端，压缩工具，哈希等等。<code>io</code>包中定义了很多其它有用的接口类型。<code>Reader</code>可以代表任意可以读取bytes的类型，<code>Closer</code>可以是任意可以关闭的值，例如一个文件或是网络链接。（到现在你可能注意到了很多Go语言中单方法接口的命名习惯）</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> io
<span class="token keyword">type</span> Reader <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">type</span> Closer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>再往下看，我们发现有些新的接口类型通过组合已有的接口来定义。下面是两个例子：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ReadWriter <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    Reader
    Writer
<span class="token punctuation">&#125;</span>
<span class="token keyword">type</span> ReadWriteCloser <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    Reader
    Writer
    Closer
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>上面用到的语法和结构内嵌相似，我们可以用这种方式以一个简写命名一个接口，而不用声明它所有的方法。这种方式称为接口内嵌。</strong>尽管略失简洁，我们可以像下面这样，不使用内嵌来声明<code>io.ReadWriter</code>接口。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ReadWriter <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>或者甚至使用一种混合的风格：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ReadWriter <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
    Writer
<span class="token punctuation">&#125;</span></code></pre>

<p>上面3种定义方式都是一样的效果。方法顺序的变化也没有影响，唯一重要的就是这个集合里面的方法。</p>
<h2 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h2><p><strong>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。</strong> 例如，<code>*os.File</code>类型实现了<code>io.Reader</code>，<code>Writer</code>，<code>Closer</code>，和<code>ReadWriter</code>接口。<code>*bytes.Buffer</code>实现了<code>Reader</code>，<code>Writer</code>，和<code>ReadWriter</code>这些接口，但是它没有实现<code>Closer</code>接口因为它不具有<code>Close</code>方法。Go的程序员经常会简要的把一个具体的类型描述成一个特定的接口类型。举个例子，<code>*bytes.Buffer</code>是<code>io.Writer</code>；<code>*os.Files</code>是<code>io.ReadWriter</code>。</p>
<p><strong>接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口。</strong> 所以：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> w io<span class="token punctuation">.</span>Writer
w <span class="token operator">=</span> os<span class="token punctuation">.</span>Stdout           <span class="token comment">// OK: *os.File has Write method</span>
w <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span>   <span class="token comment">// OK: *bytes.Buffer has Write method</span>
w <span class="token operator">=</span> time<span class="token punctuation">.</span>Second         <span class="token comment">// compile error: time.Duration lacks Write method</span>

<span class="token keyword">var</span> rwc io<span class="token punctuation">.</span>ReadWriteCloser
rwc <span class="token operator">=</span> os<span class="token punctuation">.</span>Stdout         <span class="token comment">// OK: *os.File has Read, Write, Close methods</span>
rwc <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span> <span class="token comment">// compile error: *bytes.Buffer lacks Close method</span></code></pre>

<p>这个规则甚至适用于等式右边本身也是一个接口类型</p>
<pre class="language-go" data-language="go"><code class="language-go">w <span class="token operator">=</span> rwc                 <span class="token comment">// OK: io.ReadWriteCloser has Write method</span>
rwc <span class="token operator">=</span> w                 <span class="token comment">// compile error: io.Writer lacks Close method</span></code></pre>

<p>因为<code>ReadWriter</code>和<code>ReadWriteCloser</code>包含有<code>Writer</code>的方法，所以任何实现了<code>ReadWriter</code>和<code>ReadWriteCloser</code>的类型必定也实现了<code>Writer</code>接口。</p>
<p>在进一步学习前，必须先解释一个类型持有一个方法的表示当中的细节。回想在6.2章中，对于每一个命名过的具体类型T；它的一些方法的接收者是类型T本身然而另一些则是一个<code>*T</code>的指针。还记得在T类型的参数上调用一个<code>*T</code>的方法是合法的，只要这个参数是一个变量；编译器隐式的获取了它的地址。<strong>但这仅仅是一个语法糖：T类型的值不拥有所有<code>*T</code>指针的方法，这样它就可能只实现了更少的接口。</strong></p>
<p>举个例子可能会更清晰一点。在第6.5章中，**<code>IntSet</code>类型的<code>String</code>方法的接收者是一个指针类型，所以我们不能在一个不能寻址的<code>IntSet</code>值上调用这个方法：**</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> IntSet <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>IntSet<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token keyword">var</span> <span class="token boolean">_</span> <span class="token operator">=</span> IntSet<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// compile error: String requires *IntSet receiver</span></code></pre>

<p>但是我们可以在一个<code>IntSet</code>变量上调用这个方法：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s IntSet
<span class="token keyword">var</span> <span class="token boolean">_</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// OK: s is a variable and &amp;s has a String method</span></code></pre>

<p><strong>然而，由于只有<code>*IntSet</code>类型有<code>String</code>方法，所以也只有<code>*IntSet</code>类型实现了<code>fmt.Stringer</code>接口：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> <span class="token boolean">_</span> fmt<span class="token punctuation">.</span>Stringer <span class="token operator">=</span> <span class="token operator">&amp;</span>s <span class="token comment">// OK</span>
<span class="token keyword">var</span> <span class="token boolean">_</span> fmt<span class="token punctuation">.</span>Stringer <span class="token operator">=</span> s  <span class="token comment">// compile error: IntSet lacks String method</span></code></pre>

<p>12.8章包含了一个打印出任意值的所有方法的程序，然后可以使用<code>godoc -analysis=type tool</code>(§10.7.4)展示每个类型的方法和具体类型和接口之间的关系。</p>
<p><strong>就像信封封装和隐藏起信件来一样，接口类型封装和隐藏具体类型和它的值。即使具体类型有其它的方法，也只有接口类型暴露出来的方法会被调用到：</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">os<span class="token punctuation">.</span>Stdout<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// OK: *os.File has Write method</span>
os<span class="token punctuation">.</span>Stdout<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment">// OK: *os.File has Close method</span>

<span class="token keyword">var</span> w io<span class="token punctuation">.</span>Writer
w <span class="token operator">=</span> os<span class="token punctuation">.</span>Stdout
w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// OK: io.Writer has Write method</span>
w<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment">// compile error: io.Writer lacks Close method</span></code></pre>

<p>一个有更多方法的接口类型，比如<code>io.ReadWriter</code>，和少一些方法的接口类型例如<code>io.Reader</code>，进行对比；更多方法的接口类型会告诉我们更多关于它的值持有的信息，并且对实现它的类型要求更加严格。</p>
<p><strong>那么关于<code>interface&#123;&#125;</code>类型，它没有任何方法。这看上去好像没有用，但实际上<code>interface&#123;&#125;</code>被称为 <em>空接口类型</em> 是不可或缺的。因为空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> any <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
any <span class="token operator">=</span> <span class="token boolean">true</span>
any <span class="token operator">=</span> <span class="token number">12.34</span>
any <span class="token operator">=</span> <span class="token string">"hello"</span>
any <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token string">"one"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>
any <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span></code></pre>

<p>尽管不是很明显，从本书最早的例子中我们就已经在使用空接口类型。它允许像<code>fmt.Println</code>或者5.7章中的<code>errorf</code>函数接受任何类型的参数。</p>
<p><strong>对于创建的一个<code>interface&#123;&#125;</code>值持有一个boolean，float，string，map，pointer，或者任意其它的类型；我们当然不能直接对它持有的值做操作，因为<code>interface&#123;&#125;</code>没有任何方法。我们会用 <em>类型断言</em> 来获取<code>interface&#123;&#125;</code>中值的方法。</strong></p>
<p>因为接口与实现只依赖于判断两个类型的方法，所以没有必要定义一个具体类型和它实现的接口之间的关系。也就是说，有意地在文档里说明或者程序上断言这种关系偶尔是有用的，但程序上不强制这么做。下面的定义在编译期断言一个<code>*bytes.Buffer</code>的值实现了<code>io.Writer</code>接口类型:</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// *bytes.Buffer must satisfy io.Writer</span>
<span class="token keyword">var</span> w io<span class="token punctuation">.</span>Writer <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span></code></pre>

<p>因为任意<code>*bytes.Buffer</code>的值，甚至包括nil通过<code>(*bytes.Buffer)(nil)</code>进行显示的转换都实现了这个接口，所以我们不必分配一个新的变量。并且因为我们绝不会引用变量w，我们可以使用空标识符来进行代替。总的看，这些变化可以让我们得到一个更朴素的版本：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// *bytes.Buffer must satisfy io.Writer</span>
<span class="token keyword">var</span> <span class="token boolean">_</span> io<span class="token punctuation">.</span>Writer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span></code></pre>

<p>非空的接口类型比如io.Writer经常被指针类型实现，尤其当一个或多个接口方法像Write方法那样隐式的给接收者带来变化的时候。一个结构体的指针是非常常见的承载方法的类型。</p>
<p><strong>但是并不意味着只有指针类型满足接口类型，甚至连一些有设置方法的接口类型也可能会被Go语言中其它的引用类型实现。</strong>我们已经看过slice类型的方法（<code>geometry.Path</code>，§6.1）和map类型的方法（<code>url.Values</code>，§6.2.1），后面还会看到函数类型的方法的例子（<code>http.HandlerFunc</code>，§7.7）。<strong>甚至基本的类型也可能会实现一些接口；</strong>就如我们在7.4章中看到的<code>time.Duration</code>类型实现了<code>fmt.Stringer</code>接口。</p>
<p>一个具体的类型可能实现了很多不相关的接口。考虑在一个组织出售数字文化产品比如音乐，电影和书籍的程序中可能定义了下列的具体类型：</p>
<pre class="language-none"><code class="language-none">Album
Book
Movie
Magazine
Podcast
TVEpisode
Track</code></pre>

<p>我们可以把每个抽象的特点用接口来表示。一些特性对于所有的这些文化产品都是共通的，例如标题，创作日期和作者列表。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Artifact <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Title</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
    <span class="token function">Creators</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>
    <span class="token function">Created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> time<span class="token punctuation">.</span>Time
<span class="token punctuation">&#125;</span></code></pre>

<p>其它的一些特性只对特定类型的文化产品才有。和文字排版特性相关的只有books和magazines，还有只有movies和TV剧集和屏幕分辨率相关。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Text <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Pages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
    <span class="token function">Words</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
    <span class="token function">PageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">type</span> Audio <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token function">RunningTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> time<span class="token punctuation">.</span>Duration
    <span class="token function">Format</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token comment">// e.g., "MP3", "WAV"</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">type</span> Video <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token function">RunningTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> time<span class="token punctuation">.</span>Duration
    <span class="token function">Format</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token comment">// e.g., "MP4", "WMV"</span>
    <span class="token function">Resolution</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>这些接口不止是一种有用的方式来分组相关的具体类型和表示他们之间的共同特点。我们后面可能会发现其它的分组。举例，如果我们发现我们需要以同样的方式处理Audio和Video，我们可以定义一个Streamer接口来代表它们之间相同的部分而不必对已经存在的类型做改变。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Streamer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token function">RunningTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> time<span class="token punctuation">.</span>Duration
    <span class="token function">Format</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>每一个具体类型的组基于它们相同的行为可以表示成一个接口类型。不像基于类的语言，他们一个类实现的接口集合需要进行显式的定义，在Go语言中我们可以在需要的时候定义一个新的抽象或者特定特点的组，而不需要修改具体类型的定义。当具体的类型来自不同的作者时这种方式会特别有用。当然也确实没有必要在具体的类型中指出这些共性。</p>
<h2 id="flag-Value接口"><a href="#flag-Value接口" class="headerlink" title="flag.Value接口"></a>flag.Value接口</h2><p>在本章，我们会学到另一个标准的接口类型<code>flag.Value</code>是怎么帮助命令行标记定义新的符号的。思考下面这个会休眠特定时间的程序：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> period <span class="token operator">=</span> flag<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span><span class="token string">"period"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">,</span> <span class="token string">"sleep period"</span><span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Sleeping for %v..."</span><span class="token punctuation">,</span> <span class="token operator">*</span>period<span class="token punctuation">)</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token operator">*</span>period<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>在它休眠前它会打印出休眠的时间周期。<code>fmt</code>包调用<code>time.Duration</code>的<code>String</code>方法打印这个时间周期是以用户友好的注解方式，而不是一个纳秒数字：</p>
<pre class="language-none"><code class="language-none">$ go build gopl.io&#x2F;ch7&#x2F;sleep
$ .&#x2F;sleep
Sleeping for 1s...</code></pre>

<p>默认情况下，休眠周期是一秒，但是可以通过 <code>-period</code> 这个命令行标记来控制。<code>flag.Duration</code>函数创建一个<code>time.Duration</code>类型的标记变量并且允许用户通过多种用户友好的方式来设置这个变量的大小，这种方式还包括和<code>String</code>方法相同的符号排版形式。这种对称设计使得用户交互良好。</p>
<pre class="language-none"><code class="language-none">$ .&#x2F;sleep -period 50ms
Sleeping for 50ms...
$ .&#x2F;sleep -period 2m30s
Sleeping for 2m30s...
$ .&#x2F;sleep -period 1.5h
Sleeping for 1h30m0s...
$ .&#x2F;sleep -period &quot;1 day&quot;
invalid value &quot;1 day&quot; for flag -period: time: invalid duration 1 day</code></pre>

<p>因为时间周期标记值非常的有用，所以这个特性被构建到了<code>flag</code>包中。<strong>通过实现<code>flag.Value</code>接口，我们可以为我们自己的数据类型定义新的标记符号。</strong> 如下：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> flag

<span class="token comment">// Value is the interface to the value stored in a flag.</span>
<span class="token keyword">type</span> Value <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
    <span class="token function">Set</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><code>String</code>方法格式化标记的值用在命令行帮助消息中；这样每一个<code>flag.Value</code>也是一个<code>fmt.Stringer</code>。<code>Set</code>方法解析它的字符串参数并且更新标记变量的值。实际上，<code>Set</code>方法和<code>String</code>是两个相反的操作，所以最好的办法就是对他们使用相同的注解方式。</p>
<p>让我们定义一个允许通过摄氏度或者华氏温度变换的形式指定温度的<code>celsiusFlag</code>类型。注意<code>celsiusFlag</code>内嵌了一个<code>Celsius</code>类型（§2.5），因此不用实现本身就已经有<code>String</code>方法了。为了实现<code>flag.Value</code>，我们只需要定义<code>Set</code>方法：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// *celsiusFlag satisfies the flag.Value interface.</span>
<span class="token keyword">type</span> celsiusFlag <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> Celsius <span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>celsiusFlag<span class="token punctuation">)</span> <span class="token function">Set</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> unit <span class="token builtin">string</span>
    <span class="token keyword">var</span> value <span class="token builtin">float64</span>
    fmt<span class="token punctuation">.</span><span class="token function">Sscanf</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"%f%s"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>unit<span class="token punctuation">)</span> <span class="token comment">// no error check needed</span>
    <span class="token keyword">switch</span> unit <span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"°C"</span><span class="token punctuation">:</span>
        f<span class="token punctuation">.</span>Celsius <span class="token operator">=</span> <span class="token function">Celsius</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span>
    <span class="token keyword">case</span> <span class="token string">"F"</span><span class="token punctuation">,</span> <span class="token string">"°F"</span><span class="token punctuation">:</span>
        f<span class="token punctuation">.</span>Celsius <span class="token operator">=</span> <span class="token function">FToC</span><span class="token punctuation">(</span><span class="token function">Fahrenheit</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"invalid temperature %q"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>调用<code>fmt.Sscanf</code>函数从输入<code>s</code>中解析一个浮点数（value）和一个字符串（unit）。虽然通常必须检查<code>Sscanf</code>的错误返回，但是在这个例子中我们不需要，因为如果有错误发生，就没有switch case会匹配到。</p>
<p>下面的<code>CelsiusFlag</code>函数将所有逻辑都封装在一起。它返回一个内嵌在<code>celsiusFlag</code>变量<code>f</code>中的<code>Celsius</code>指针给调用者。<code>Celsius</code>字段是一个会通过<code>Set</code>方法在标记处理的过程中更新的变量。调用<code>Var</code>方法将标记加入应用的命令行标记集合中，有异常复杂命令行接口的全局变量<code>flag.CommandLine.Programs</code>可能有几个这个类型的变量。调用<code>Var</code>方法将一个<code>*celsiusFlag</code>参数赋值给一个<code>flag.Value</code>参数，导致编译器去检查<code>*celsiusFlag</code>是否有必须的方法。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">// CelsiusFlag defines a Celsius flag with the specified name,</span>
<span class="token comment">// default value, and usage, and returns the address of the flag variable.</span>
<span class="token comment">// The flag argument must have a quantity and a unit, e.g., "100C".</span>
<span class="token keyword">func</span> <span class="token function">CelsiusFlag</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> value Celsius<span class="token punctuation">,</span> usage <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>Celsius <span class="token punctuation">&#123;</span>
    f <span class="token operator">:=</span> celsiusFlag<span class="token punctuation">&#123;</span>value<span class="token punctuation">&#125;</span>
    flag<span class="token punctuation">.</span>CommandLine<span class="token punctuation">.</span><span class="token function">Var</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>f<span class="token punctuation">,</span> name<span class="token punctuation">,</span> usage<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>f<span class="token punctuation">.</span>Celsius
<span class="token punctuation">&#125;</span></code></pre>

<p>现在我们可以开始在我们的程序中使用新的标记：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> temp <span class="token operator">=</span> tempconv<span class="token punctuation">.</span><span class="token function">CelsiusFlag</span><span class="token punctuation">(</span><span class="token string">"temp"</span><span class="token punctuation">,</span> <span class="token number">20.0</span><span class="token punctuation">,</span> <span class="token string">"the temperature"</span><span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>temp<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>下面是典型的场景：</p>
<pre class="language-none"><code class="language-none">$ go build gopl.io&#x2F;ch7&#x2F;tempflag
$ .&#x2F;tempflag
20°C
$ .&#x2F;tempflag -temp -18C
-18°C
$ .&#x2F;tempflag -temp 212°F
100°C
$ .&#x2F;tempflag -temp 273.15K
invalid value &quot;273.15K&quot; for flag -temp: invalid temperature &quot;273.15K&quot;
Usage of .&#x2F;tempflag:
  -temp value
        the temperature (default 20°C)
$ .&#x2F;tempflag -help
Usage of .&#x2F;tempflag:
  -temp value
        the temperature (default 20°C)</code></pre>

<h2 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h2><p><strong><em>接口值</em> 由2个部分组成：一个具体的类型和这个类型的值。它们被称为接口的动态类型和动态值。</strong>对于像Go语言这种静态类型的语言，类型是编译期的概念；因此一个类型不是一个值。在我们的概念模型中，一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符。</p>
<p>下面4个语句中，变量<code>w</code>得到了3个不同的值。（开始和最后的值是相同的）</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> w io<span class="token punctuation">.</span>Writer  <span class="token comment">// 由于隐式初始化，等价于 var w io.Writer = nil</span>
w <span class="token operator">=</span> os<span class="token punctuation">.</span>Stdout
w <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span>
w <span class="token operator">=</span> <span class="token boolean">nil</span></code></pre>

<p>让我们进一步观察在每一个语句后的<code>w</code>变量的值和动态行为。第一个语句定义了变量<code>w</code>:</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> w io<span class="token punctuation">.</span>Writer</code></pre>

<p><strong>在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是<code>nil</code>（如图7.1）。</strong></p>
<p><img src="/2022/notes-of-gopl/ch7-01.png" alt="img"></p>
<p><strong>一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值（接口值为<code>nil</code>）。你可以通过使用<code>w==nil</code>或者<code>w!=nil</code>来判断接口值是否为空。调用一个空接口值（接口值为<code>nil</code>）上的任意方法都会产生panic:</strong></p>
<pre class="language-go" data-language="go"><code class="language-go">w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// panic: nil pointer dereference</span></code></pre>

<p>第二个语句将一个<code>*os.File</code>类型的值赋给变量<code>w</code>:</p>
<pre class="language-go" data-language="go"><code class="language-go">w <span class="token operator">=</span> os<span class="token punctuation">.</span>Stdout</code></pre>

<p>这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用<code>io.Writer(os.Stdout)</code>是等价的。这类转换不管是显式的还是隐式的，都会刻画出操作到的类型和值。这个接口值的动态类型被设为<code>*os.File</code>指针的类型描述符，它的动态值持有<code>os.Stdout</code>的拷贝；这是一个代表处理标准输出的<code>os.File</code>类型变量的指针（如图7.2）。</p>
<p><img src="/2022/notes-of-gopl/ch7-02.png" alt="img"></p>
<p>调用一个包含<code>*os.File</code>类型指针的接口值的<code>Write</code>方法，使得<code>(*os.File).Write</code>方法被调用。这个调用输出“hello”。</p>
<pre class="language-go" data-language="go"><code class="language-go">w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "hello"</span></code></pre>

<p>通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法<code>Write</code>上，然后间接调用那个地址。这个调用的接收者是一个接口动态值的拷贝<code>os.Stdout</code>。效果和下面这个直接调用一样：</p>
<pre class="language-go" data-language="go"><code class="language-go">os<span class="token punctuation">.</span>Stdout<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "hello"</span></code></pre>

<p>第三个语句给接口值赋了一个<code>*bytes.Buffer</code>类型的值：</p>
<pre class="language-go" data-language="go"><code class="language-go">w <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span></code></pre>

<p>现在动态类型是<code>*bytes.Buffer</code>并且动态值是一个指向新分配的缓冲区的指针（图7.3）。</p>
<p><img src="/2022/notes-of-gopl/ch7-03.png" alt="img"></p>
<p><code>Write</code>方法的调用也使用了和之前一样的机制：</p>
<pre class="language-go" data-language="go"><code class="language-go">w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// writes "hello" to the bytes.Buffers</span></code></pre>

<p>这次类型描述符是<code>*bytes.Buffer</code>，所以调用了<code>(*bytes.Buffer).Write</code>方法，并且接收者是该缓冲区的地址。这个调用把字符串“hello”添加到缓冲区中。</p>
<p>最后，第四个语句将<code>nil</code>赋给了接口值：</p>
<pre class="language-go" data-language="go"><code class="language-go">w <span class="token operator">=</span> <span class="token boolean">nil</span></code></pre>

<p>这个重置将它所有的部分都设为<code>nil</code>值，把变量<code>w</code>恢复到和它之前定义时相同的状态，在图7.1中可以看到。</p>
<p>一个接口值可以持有任意大的动态值。例如，表示时间实例的<code>time.Time</code>类型，这个类型有几个对外不公开的字段。我们从它上面创建一个接口值：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>

<p>结果可能和图7.4相似。从概念上讲，不论接口值多大，动态值总是可以容下它。（这只是一个概念上的模型；具体的实现可能会非常不同）</p>
<p><img src="/2022/notes-of-gopl/ch7-04.png" alt="img"></p>
<p><strong>接口值可以使用<code>==</code>和<code>!＝</code>来进行比较。两个接口值相等仅当它们都是<code>nil</code>值，或者它们的动态类型相同并且动态值也根据这个动态类型的<code>==</code>操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。</strong></p>
<p><strong>然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token comment">// panic: comparing uncomparable type []int</span></code></pre>

<p><strong>考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值。</strong></p>
<p>当我们处理错误或者调试的过程中，得知接口值的动态类型是非常有帮助的。所以我们使用<code>fmt</code>包的<code>%T</code>动作:</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> w io<span class="token punctuation">.</span>Writer
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span> <span class="token comment">// "&lt;nil>"</span>
w <span class="token operator">=</span> os<span class="token punctuation">.</span>Stdout
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span> <span class="token comment">// "*os.File"</span>
w <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span> <span class="token comment">// "*bytes.Buffer"</span></code></pre>

<p>在<code>fmt</code>包内部，使用反射来获取接口动态类型的名称。</p>
<h3 id="警告：一个包含nil指针的接口不是nil接口"><a href="#警告：一个包含nil指针的接口不是nil接口" class="headerlink" title="警告：一个包含nil指针的接口不是nil接口"></a>警告：一个包含<code>nil</code>指针的接口不是<code>nil</code>接口</h3><p><strong>一个不包含任何值的<code>nil</code>接口值和一个刚好包含<code>nil</code>指针的接口值是不同的。</strong>这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。</p>
<p>思考下面的程序。当<code>debug</code>变量设置为<code>true</code>时，<code>main</code>函数会将<code>f</code>函数的输出收集到一个<code>bytes.Buffer</code>类型中。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> debug <span class="token operator">=</span> <span class="token boolean">true</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> buf <span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer
    <span class="token keyword">if</span> debug <span class="token punctuation">&#123;</span>
        buf <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span> <span class="token comment">// enable collection of output</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token comment">// NOTE: subtly incorrect!</span>
    <span class="token keyword">if</span> debug <span class="token punctuation">&#123;</span>
        <span class="token comment">// ...use buf...</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// If out is non-nil, output will be written to it.</span>
<span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>out io<span class="token punctuation">.</span>Writer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// ...do something...</span>
    <span class="token keyword">if</span> out <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        out<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"done!\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>我们可能会预计当把变量<code>debug</code>设置为<code>false</code>时可以禁止对输出的收集，但是实际上在<code>out.Write</code>方法调用时程序发生了panic：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> out <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
    out<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"done!\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// panic: nil pointer dereference</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>当<code>main</code>函数调用函数<code>f</code>时，它给<code>f</code>函数的<code>out</code>参数赋了一个<code>*bytes.Buffer</code>的空指针，所以<code>out</code>的动态值是<code>nil</code>。然而，它的动态类型是<code>*bytes.Buffer</code>，意思就是<code>out</code>变量是一个包含空指针值的非空接口（如图7.5），所以防御性检查<code>out!=nil</code>的结果依然是<code>true</code>。</strong></p>
<p><img src="/2022/notes-of-gopl/ch7-05.png" alt="img"></p>
<p><strong>动态分配机制依然决定<code>(*bytes.Buffer).Write</code>的方法会被调用，但是这次的接收者的值是<code>nil</code>。对于一些如<code>*os.File</code>的类型，<code>nil</code>是一个有效的接收者（§6.2.1），但是<code>*bytes.Buffer</code>类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。</strong></p>
<p>问题在于尽管一个<code>nil</code>的<code>*bytes.Buffer</code>指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了<code>(*bytes.Buffer).Write</code>方法隐含的先决条件，即，它的接收者不能是<code>nil</code>；所以将<code>nil</code>指针赋给这个接口是错误的。解决方案就是将<code>main</code>函数中的变量<code>buf</code>的类型改为<code>io.Writer</code>，因此可以避免一开始就将一个不完整的值赋给这个接口：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> buf io<span class="token punctuation">.</span>Writer
<span class="token keyword">if</span> debug <span class="token punctuation">&#123;</span>
    buf <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span> <span class="token comment">// enable collection of output</span>
<span class="token punctuation">&#125;</span>
<span class="token function">f</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token comment">// OK</span></code></pre>

<p>打印前文中的代码，似乎只有当接口的动态类型和动态值都为<code>nil</code>时，<code>w == nil</code>才为真：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> w io<span class="token punctuation">.</span>Writer
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

w <span class="token operator">=</span> os<span class="token punctuation">.</span>Stdout
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// false</span>

w <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// false</span>

w <span class="token operator">=</span> <span class="token boolean">nil</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// true</span></code></pre>

<h2 id="sort-Interface接口"><a href="#sort-Interface接口" class="headerlink" title="sort.Interface接口"></a><code>sort.Interface</code>接口</h2><p><code>sort</code>包内置的提供了根据一些排序函数来对任何序列排序的功能。它的设计非常独到。在很多语言中，排序算法都是和序列数据类型关联，同时排序函数和具体类型元素关联。相比之下，Go语言的<code>sort.Sort</code>函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型<code>sort.Interface</code>来指定通用的排序算法和可能被排序到的序列类型之间的约定。这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片。</p>
<p>一个内置的排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式；这就是<code>sort.Interface</code>的三个方法：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> sort

<span class="token keyword">type</span> Interface <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
    <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token comment">// i, j are indices of sequence elements</span>
    <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用<code>sort.Sort</code>函数。思考对一个字符串切片进行排序，这可能是最简单的例子了。下面是这个新的类型<code>StringSlice</code>和它的<code>Len</code>，<code>Less</code>和<code>Swap</code>方法</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> StringSlice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p StringSlice<span class="token punctuation">)</span> <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>           <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p StringSlice<span class="token punctuation">)</span> <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p StringSlice<span class="token punctuation">)</span> <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">&#125;</span></code></pre>

<p>现在我们可以通过像下面这样将一个切片转换为一个<code>StringSlice</code>类型来进行排序：</p>
<pre class="language-go" data-language="go"><code class="language-go">sort<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span><span class="token function">StringSlice</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<p>这个转换得到一个相同长度，容量，和基于<code>names</code>数组的切片值；并且这个切片值的类型有三个排序需要的方法。</p>
<p>对字符串切片的排序是很常用的需要，所以<code>sort</code>包提供了<code>StringSlice</code>类型，也提供了<code>Strings</code>函数能让上面这些调用简化成<code>sort.Strings(names)</code>。</p>
<p>这里用到的技术很容易适用到其它排序序列中，例如我们可以忽略大小写或者含有的特殊字符。（本书使用Go程序对索引词和页码进行排序也用到了这个技术，对罗马数字做了额外逻辑处理。）对于更复杂的排序，我们使用相同的方法，但是会用更复杂的数据结构和更复杂地实现<code>sort.Interface</code>的方法。</p>
<p>我们会运行上面的例子来对一个表格中的音乐播放列表进行排序。每个track都是单独的一行，每一列都是这个track的属性像艺术家，标题，和运行时间。想象一个图形用户界面来呈现这个表格，并且点击一个属性的顶部会使这个列表按照这个属性进行排序；再一次点击相同属性的顶部会进行逆向排序。让我们看下每个点击会发生什么响应。</p>
<p>下面的变量<code>tracks</code>包含了一个播放列表。（One of the authors apologizes for the other author’s musical tastes.）每个元素都不是<code>Track</code>本身而是指向它的指针。尽管我们在下面的代码中直接存储<code>Tracks</code>也可以工作，<code>sort</code>函数会交换很多对元素，所以如果每个元素都是指针而不是<code>Track</code>类型会更快，指针是一个机器字码长度而<code>Track</code>类型可能是八个或更多。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Track <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Title  <span class="token builtin">string</span>
    Artist <span class="token builtin">string</span>
    Album  <span class="token builtin">string</span>
    Year   <span class="token builtin">int</span>
    Length time<span class="token punctuation">.</span>Duration
<span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> tracks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Track<span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#123;</span><span class="token string">"Go"</span><span class="token punctuation">,</span> <span class="token string">"Delilah"</span><span class="token punctuation">,</span> <span class="token string">"From the Roots Up"</span><span class="token punctuation">,</span> <span class="token number">2012</span><span class="token punctuation">,</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token string">"3m38s"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span><span class="token string">"Go"</span><span class="token punctuation">,</span> <span class="token string">"Moby"</span><span class="token punctuation">,</span> <span class="token string">"Moby"</span><span class="token punctuation">,</span> <span class="token number">1992</span><span class="token punctuation">,</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token string">"3m37s"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span><span class="token string">"Go Ahead"</span><span class="token punctuation">,</span> <span class="token string">"Alicia Keys"</span><span class="token punctuation">,</span> <span class="token string">"As I Am"</span><span class="token punctuation">,</span> <span class="token number">2007</span><span class="token punctuation">,</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token string">"4m36s"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span><span class="token string">"Ready 2 Go"</span><span class="token punctuation">,</span> <span class="token string">"Martin Solveig"</span><span class="token punctuation">,</span> <span class="token string">"Smash"</span><span class="token punctuation">,</span> <span class="token number">2011</span><span class="token punctuation">,</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token string">"4m24s"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">length</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> time<span class="token punctuation">.</span>Duration <span class="token punctuation">&#123;</span>
    d<span class="token punctuation">,</span> err <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">ParseDuration</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token function">panic</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> d
<span class="token punctuation">&#125;</span></code></pre>

<p><code>printTracks</code>函数将播放列表打印成一个表格。一个图形化的展示可能会更好点，但是这个小程序使用<code>text/tabwriter</code>包来生成一个列整齐对齐和隔开的表格，像下面展示的这样。注意到<code>*tabwriter.Writer</code>是满足<code>io.Writer</code>接口的。它会收集每一片写向它的数据；它的<code>Flush</code>方法会格式化整个表格并且将它写向<code>os.Stdout</code>（标准输出）。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">printTracks</span><span class="token punctuation">(</span>tracks <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Track<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> format <span class="token operator">=</span> <span class="token string">"%v\t%v\t%v\t%v\t%v\t\n"</span>
    tw <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>tabwriter<span class="token punctuation">.</span>Writer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Init</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>tw<span class="token punctuation">,</span> format<span class="token punctuation">,</span> <span class="token string">"Title"</span><span class="token punctuation">,</span> <span class="token string">"Artist"</span><span class="token punctuation">,</span> <span class="token string">"Album"</span><span class="token punctuation">,</span> <span class="token string">"Year"</span><span class="token punctuation">,</span> <span class="token string">"Length"</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>tw<span class="token punctuation">,</span> format<span class="token punctuation">,</span> <span class="token string">"-----"</span><span class="token punctuation">,</span> <span class="token string">"------"</span><span class="token punctuation">,</span> <span class="token string">"-----"</span><span class="token punctuation">,</span> <span class="token string">"----"</span><span class="token punctuation">,</span> <span class="token string">"------"</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> t <span class="token operator">:=</span> <span class="token keyword">range</span> tracks <span class="token punctuation">&#123;</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>tw<span class="token punctuation">,</span> format<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Title<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Artist<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Album<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Year<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Length<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    tw<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// calculate column widths and print table</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>为了能按照<code>Artist</code>字段对播放列表进行排序，我们会像对<code>StringSlice</code>那样定义一个新的带有必须的<code>Len</code>，<code>Less</code>和<code>Swap</code>方法的切片类型。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> byArtist <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Track
<span class="token keyword">func</span> <span class="token punctuation">(</span>x byArtist<span class="token punctuation">)</span> <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>           <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>x byArtist<span class="token punctuation">)</span> <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Artist <span class="token operator">&lt;</span> x<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>Artist <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>x byArtist<span class="token punctuation">)</span> <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">&#125;</span></code></pre>

<p>为了调用通用的排序程序，我们必须先将<code>tracks</code>转换为新的<code>byArtist</code>类型，它定义了具体的排序：</p>
<pre class="language-go" data-language="go"><code class="language-go">sort<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span><span class="token function">byArtist</span><span class="token punctuation">(</span>tracks<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<p>在按照<code>artist</code>对这个切片进行排序后，<code>printTrack</code>的输出如下</p>
<pre class="language-none"><code class="language-none">Title       Artist          Album               Year Length
-----       ------          -----               ---- ------
Go Ahead    Alicia Keys     As I Am             2007 4m36s
Go          Delilah         From the Roots Up   2012 3m38s
Ready 2 Go  Martin Solveig  Smash               2011 4m24s
Go          Moby            Moby                1992 3m37s</code></pre>

<p>如果用户第二次请求“按照artist排序”，我们会对<code>tracks</code>进行逆向排序。然而我们不需要定义一个有颠倒<code>Less</code>方法的新类型<code>byReverseArtist</code>，因为<code>sort</code>包中提供了<code>Reverse</code>函数将排序顺序转换成逆序。</p>
<pre class="language-go" data-language="go"><code class="language-go">sort<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span>sort<span class="token punctuation">.</span><span class="token function">Reverse</span><span class="token punctuation">(</span><span class="token function">byArtist</span><span class="token punctuation">(</span>tracks<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<p>在按照<code>artist</code>对这个切片进行逆向排序后，<code>printTrack</code>的输出如下</p>
<pre class="language-none"><code class="language-none">Title       Artist          Album               Year Length
-----       ------          -----               ---- ------
Go          Moby            Moby                1992 3m37s
Ready 2 Go  Martin Solveig  Smash               2011 4m24s
Go          Delilah         From the Roots Up   2012 3m38s
Go Ahead    Alicia Keys     As I Am             2007 4m36s</code></pre>

<p><code>sort.Reverse</code>函数值得进行更近一步的学习，因为它使用了（§6.3）章中的组合，这是一个重要的思路。<code>sort</code>包定义了一个不公开的struct类型reverse，它嵌入了一个<code>sort.Interface</code>。<code>reverse</code>的<code>Less</code>方法调用了内嵌的<code>sort.Interface</code>值的<code>Less</code>方法，但是通过交换索引的方式使排序结果变成逆序。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> sort

<span class="token keyword">type</span> reverse <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> Interface <span class="token punctuation">&#125;</span> <span class="token comment">// that is, sort.Interface</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>r reverse<span class="token punctuation">)</span> <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> r<span class="token punctuation">.</span>Interface<span class="token punctuation">.</span><span class="token function">Less</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">Reverse</span><span class="token punctuation">(</span>data Interface<span class="token punctuation">)</span> Interface <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> reverse<span class="token punctuation">&#123;</span>data<span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></code></pre>

<p><code>reverse</code>的另外两个方法<code>Len</code>和<code>Swap</code>隐式地由原有内嵌的<code>sort.Interface</code>提供。因为<code>reverse</code>是一个不公开的类型，所以导出函数<code>Reverse</code>返回一个包含原有<code>sort.Interface</code>值的<code>reverse</code>类型实例。</p>
<p>为了可以按照不同的列进行排序，我们必须定义一个新的类型例如<code>byYear</code>：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> byYear <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Track
<span class="token keyword">func</span> <span class="token punctuation">(</span>x byYear<span class="token punctuation">)</span> <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>           <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>x byYear<span class="token punctuation">)</span> <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Year <span class="token operator">&lt;</span> x<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>Year <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>x byYear<span class="token punctuation">)</span> <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">&#125;</span></code></pre>

<p>在使用<code>sort.Sort(byYear(tracks))</code>按照年对<code>tracks</code>进行排序后，<code>printTrack</code>展示了一个按时间先后顺序的列表：</p>
<pre class="language-none"><code class="language-none">Title       Artist          Album               Year Length
-----       ------          -----               ---- ------
Go          Moby            Moby                1992 3m37s
Go Ahead    Alicia Keys     As I Am             2007 4m36s
Ready 2 Go  Martin Solveig  Smash               2011 4m24s
Go          Delilah         From the Roots Up   2012 3m38s</code></pre>

<p>对于我们需要的每个切片元素类型和每个排序函数，我们需要定义一个新的<code>sort.Interface</code>实现。如你所见，<code>Len</code>和<code>Swap</code>方法对于所有的切片类型都有相同的定义。下个例子，具体的类型<code>customSort</code>会将一个切片和函数结合，使我们只需要写比较函数就可以定义一个新的排序。<strong>顺便说下，实现了<code>sort.Interface</code>的具体类型不一定是切片类型；<code>customSort</code>是一个结构体类型。</strong></p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> customSort <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    t    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Track
    less <span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">*</span>Track<span class="token punctuation">)</span> <span class="token builtin">bool</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>x customSort<span class="token punctuation">)</span> <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>           <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>t<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>x customSort<span class="token punctuation">)</span> <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token punctuation">.</span><span class="token function">less</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span>t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>x customSort<span class="token punctuation">)</span> <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> x<span class="token punctuation">.</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span>t<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">.</span>t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">&#125;</span></code></pre>

<p>让我们定义一个多层的排序函数，它主要的排序键是标题，第二个键是年，第三个键是运行时间<code>Length</code>。下面是该排序的调用，其中这个排序使用了匿名排序函数：</p>
<pre class="language-go" data-language="go"><code class="language-go">sort<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span>customSort<span class="token punctuation">&#123;</span>tracks<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">*</span>Track<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> x<span class="token punctuation">.</span>Title <span class="token operator">!=</span> y<span class="token punctuation">.</span>Title <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">.</span>Title <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>Title
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> x<span class="token punctuation">.</span>Year <span class="token operator">!=</span> y<span class="token punctuation">.</span>Year <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">.</span>Year <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>Year
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> x<span class="token punctuation">.</span>Length <span class="token operator">!=</span> y<span class="token punctuation">.</span>Length <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">.</span>Length <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>Length
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre>

<p>这下面是排序的结果。注意到两个标题是“Go”的<code>track</code>按照标题排序是相同的顺序，但是在按照<code>year</code>排序上更久的那个<code>track</code>优先。</p>
<pre class="language-none"><code class="language-none">Title       Artist          Album               Year Length
-----       ------          -----               ---- ------
Go          Moby            Moby                1992 3m37s
Go          Delilah         From the Roots Up   2012 3m38s
Go Ahead    Alicia Keys     As I Am             2007 4m36s
Ready 2 Go  Martin Solveig  Smash               2011 4m24s</code></pre>

<p>尽管对长度为n的序列排序需要 O(n log n)次比较操作，检查一个序列是否已经有序至少需要n-1次比较。**<code>sort</code>包中的<code>IsSorted</code>函数可以检查一个序列是否已经有序。像<code>sort.Sort</code>一样，它也使用<code>sort.Interface</code>对这个序列和它的排序函数进行抽象，但是它从不会调用<code>Swap</code>方法。** 这段代码示范了<code>IntsAreSorted</code>和<code>Ints</code>函数在<code>IntSlice</code>类型上的使用：</p>
<pre class="language-go" data-language="go"><code class="language-go">values <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>sort<span class="token punctuation">.</span><span class="token function">IntsAreSorted</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "false"</span>
sort<span class="token punctuation">.</span><span class="token function">Ints</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span>                     <span class="token comment">// "[1 1 3 4]"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>sort<span class="token punctuation">.</span><span class="token function">IntsAreSorted</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "true"</span>
sort<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span>sort<span class="token punctuation">.</span><span class="token function">Reverse</span><span class="token punctuation">(</span>sort<span class="token punctuation">.</span><span class="token function">IntSlice</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span>                     <span class="token comment">// "[4 3 1 1]"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>sort<span class="token punctuation">.</span><span class="token function">IntsAreSorted</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "false"</span></code></pre>

<p>为了使用方便，<code>sort</code>包为<code>[]int</code>、<code>[]string</code>和<code>[]float64</code>的正常排序提供了特定版本的函数和类型。对于其他类型，例如<code>[]int64</code>或者<code>[]uint</code>，尽管路径也很简单，还是依赖我们自己实现。</p>
<h2 id="http-Handler接口"><a href="#http-Handler接口" class="headerlink" title="http.Handler接口"></a>http.Handler接口</h2><p>在第一章中，我们粗略的了解了怎么用<code>net/http</code>包去实现网络客户端（§1.5）和服务器（§1.7）。在这个小节中，我们会对那些基于<code>http.Handler</code>接口的服务器API做更进一步的学习：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> http

<span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span>address <span class="token builtin">string</span><span class="token punctuation">,</span> h Handler<span class="token punctuation">)</span> <span class="token builtin">error</span></code></pre>

<p><code>ListenAndServe</code>函数需要一个例如<code>&quot;localhost:8000&quot;</code>的服务器地址，和一个所有请求都可以分派的Handler接口实例。它会一直运行，直到这个服务因为一个错误而失败（或者启动失败），它的返回值一定是一个非空的错误。</p>
<p>想象一个电子商务网站，为了销售，将数据库中物品的价格映射成美元。下面这个程序可能是能想到的最简单的实现了。它将库存清单模型化为一个命名为database的map类型，我们给这个类型一个<code>ServeHttp</code>方法，这样它可以满足<code>http.Handler</code>接口。这个handler会遍历整个map并输出物品信息。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    db <span class="token operator">:=</span> database<span class="token punctuation">&#123;</span><span class="token string">"shoes"</span><span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token string">"socks"</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">&#125;</span>
    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"localhost:8000"</span><span class="token punctuation">,</span> db<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> dollars <span class="token builtin">float32</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>d dollars<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"$%.2f"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> database <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>dollars

<span class="token keyword">func</span> <span class="token punctuation">(</span>db database<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> item<span class="token punctuation">,</span> price <span class="token operator">:=</span> <span class="token keyword">range</span> db <span class="token punctuation">&#123;</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"%s: %s\n"</span><span class="token punctuation">,</span> item<span class="token punctuation">,</span> price<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>如果我们启动这个服务，</p>
<pre class="language-none"><code class="language-none">$ go build gopl.io&#x2F;ch7&#x2F;http1
$ .&#x2F;http1 &amp;</code></pre>

<p>然后用1.5节中的获取程序（如果你更喜欢可以使用web浏览器）来连接服务器，我们得到下面的输出：</p>
<pre class="language-none"><code class="language-none">$ go build gopl.io&#x2F;ch1&#x2F;fetch
$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000
shoes: $50.00
socks: $5.00</code></pre>

<p>目前为止，这个服务器不考虑URL，只能为每个请求列出它全部的库存清单。更真实的服务器会定义多个不同的URL，每一个都会触发一个不同的行为。让我们使用<code>/list</code>来调用已经存在的这个行为并且增加另一个<code>/price</code>调用表明单个货品的价格，像这样<code>/price?item=socks</code>来指定一个请求参数。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>db database<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">switch</span> req<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path <span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> <span class="token string">"/list"</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> item<span class="token punctuation">,</span> price <span class="token operator">:=</span> <span class="token keyword">range</span> db <span class="token punctuation">&#123;</span>
            fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"%s: %s\n"</span><span class="token punctuation">,</span> item<span class="token punctuation">,</span> price<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token keyword">case</span> <span class="token string">"/price"</span><span class="token punctuation">:</span>
        item <span class="token operator">:=</span> req<span class="token punctuation">.</span>URL<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">)</span>
        price<span class="token punctuation">,</span> ok <span class="token operator">:=</span> db<span class="token punctuation">[</span>item<span class="token punctuation">]</span>
        <span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>
            w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusNotFound<span class="token punctuation">)</span> <span class="token comment">// 404</span>
            fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"no such item: %q\n"</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">&#125;</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span> price<span class="token punctuation">)</span>
    <span class="token keyword">default</span><span class="token punctuation">:</span>
        w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusNotFound<span class="token punctuation">)</span> <span class="token comment">// 404</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"no such page: %s\n"</span><span class="token punctuation">,</span> req<span class="token punctuation">.</span>URL<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>现在handler基于URL的路径部分（<code>req.URL.Path</code>）来决定执行什么逻辑。如果这个handler不能识别这个路径，它会通过调用<code>w.WriteHeader(http.StatusNotFound)</code>返回客户端一个HTTP错误；这个检查应该在向w写入任何值前完成。（顺便提一下，<code>http.ResponseWriter</code>是另一个接口。它在<code>io.Writer</code>上增加了发送HTTP相应头的方法。）等效地，我们可以使用实用的<code>http.Error</code>函数：</p>
<pre class="language-go" data-language="go"><code class="language-go">msg <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"no such page: %s\n"</span><span class="token punctuation">,</span> req<span class="token punctuation">.</span>URL<span class="token punctuation">)</span>
http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusNotFound<span class="token punctuation">)</span> <span class="token comment">// 404</span></code></pre>

<p><code>/price</code>的case会调用URL的Query方法来将HTTP请求参数解析为一个map，或者更准确地说一个<code>net/url</code>包中<code>url.Values</code>类型的多重映射。然后找到第一个<code>item</code>参数并查找它的价格。如果这个货品没有找到会返回一个错误。</p>
<p>这里是一个和新服务器会话的例子：</p>
<pre class="language-none"><code class="language-none">$ go build gopl.io&#x2F;ch7&#x2F;http2
$ go build gopl.io&#x2F;ch1&#x2F;fetch
$ .&#x2F;http2 &amp;
$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;list
shoes: $50.00
socks: $5.00
$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;price?item&#x3D;socks
$5.00
$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;price?item&#x3D;shoes
$50.00
$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;price?item&#x3D;hat
no such item: &quot;hat&quot;
$ .&#x2F;fetch http:&#x2F;&#x2F;localhost:8000&#x2F;help
no such page: &#x2F;help</code></pre>

<p>显然我们可以继续向<code>ServeHTTP</code>方法中添加case，但在一个实际的应用中，将每个case中的逻辑定义到一个分开的方法或函数中会很实用。此外，相近的URL可能需要相似的逻辑；例如几个图片文件可能有形如<code>/images/*.png的</code>URL。因为这些原因，<code>net/http</code>包提供了一个请求多路器<code>ServeMux</code>来简化URL和handlers的联系。一个<code>ServeMux</code>将一批<code>http.Handler</code>聚集到一个单一的<code>http.Handler</code>中。再一次，我们可以看到满足同一接口的不同类型是可替换的：web服务器将请求指派给任意的<code>http.Handler</code> 而不需要考虑它后面的具体类型。</p>
<p>对于更复杂的应用，一些<code>ServeMux</code>可以通过组合来处理更加错综复杂的路由需求。Go语言目前没有一个权威的web框架，类似Ruby语言有Rails和python有Django。这并不是说这样的框架不存在，而是Go语言标准库中的构建模块就已经非常灵活以至于这些框架都是不必要的。此外，尽管在一个项目早期使用框架是非常方便的，但是它们带来额外的复杂度会使长期的维护更加困难。</p>
<p>在下面的程序中，我们创建一个<code>ServeMux</code>并且使用它将URL和相应处理<code>/list</code>和<code>/price</code>操作的handler联系起来，这些操作逻辑都已经被分到不同的方法中。然后我们在调用<code>ListenAndServe</code>函数中使用<code>ServeMux</code>为主要的handler。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    db <span class="token operator">:=</span> database<span class="token punctuation">&#123;</span><span class="token string">"shoes"</span><span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token string">"socks"</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">&#125;</span>
    mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewServeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/list"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span><span class="token function">HandlerFunc</span><span class="token punctuation">(</span>db<span class="token punctuation">.</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span>
    mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/price"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span><span class="token function">HandlerFunc</span><span class="token punctuation">(</span>db<span class="token punctuation">.</span>price<span class="token punctuation">)</span><span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"localhost:8000"</span><span class="token punctuation">,</span> mux<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> database <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>dollars

<span class="token keyword">func</span> <span class="token punctuation">(</span>db database<span class="token punctuation">)</span> <span class="token function">list</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> item<span class="token punctuation">,</span> price <span class="token operator">:=</span> <span class="token keyword">range</span> db <span class="token punctuation">&#123;</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"%s: %s\n"</span><span class="token punctuation">,</span> item<span class="token punctuation">,</span> price<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>db database<span class="token punctuation">)</span> <span class="token function">price</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    item <span class="token operator">:=</span> req<span class="token punctuation">.</span>URL<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">)</span>
    price<span class="token punctuation">,</span> ok <span class="token operator">:=</span> db<span class="token punctuation">[</span>item<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>
        w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusNotFound<span class="token punctuation">)</span> <span class="token comment">// 404</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"no such item: %q\n"</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">&#125;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span> price<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>让我们关注这两个注册到handlers上的调用。第一个<code>db.list</code>是一个方法值（§6.4），它是下面这个类型的值。</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span></code></pre>

<p>也就是说<code>db.list</code>的调用会援引一个接收者是db的<code>database.list</code>方法。所以<code>db.list</code>是一个实现了handler类似行为的函数，但是因为它没有方法（理解：该方法没有它自己的方法），所以它不满足<code>http.Handler</code>接口并且不能直接传给<code>mux.Handle</code>。</p>
<p>语句<code>http.HandlerFunc(db.list)</code>是一个转换而非一个函数调用，因为<code>http.HandlerFunc</code>是一个类型。它有如下的定义：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> http

<span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><code>HandlerFunc</code>显示了在Go语言接口机制中一些不同寻常的特点。这是一个实现了接口<code>http.Handler</code>的方法的函数类型。<code>ServeHTTP</code>方法的行为是调用了它的函数本身。因此<code>HandlerFunc</code>是一个让函数值满足一个接口的适配器，这里函数和这个接口仅有的方法有相同的函数签名。实际上，这个技巧让一个单一的类型例如database以多种方式满足<code>http.Handler</code>接口：一种通过它的<code>list</code>方法，一种通过它的<code>price</code>方法等等。</p>
<p>因为handler通过这种方式注册非常普遍，<code>ServeMux</code>有一个方便的<code>HandleFunc</code>方法，它帮我们简化handler注册代码成这样：</p>
<pre class="language-go" data-language="go"><code class="language-go">mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/list"</span><span class="token punctuation">,</span> db<span class="token punctuation">.</span>list<span class="token punctuation">)</span>
mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/price"</span><span class="token punctuation">,</span> db<span class="token punctuation">.</span>price<span class="token punctuation">)</span></code></pre>

<p>从上面的代码很容易看出应该怎么构建一个程序：由两个不同的web服务器监听不同的端口，并且定义不同的URL将它们指派到不同的handler。我们只要构建另外一个<code>ServeMux</code>并且再调用一次<code>ListenAndServe</code>（可能并行的）。但是在大多数程序中，一个web服务器就足够了。此外，在一个应用程序的多个文件中定义HTTP handler也是非常典型的，如果它们必须全部都显式地注册到这个应用的<code>ServeMux</code>实例上会比较麻烦。</p>
<p>所以为了方便，<code>net/http</code>包提供了一个全局的<code>ServeMux</code>实例<code>DefaultServerMux</code>和包级别的<code>http.Handle</code>和<code>http.HandleFunc</code>函数。现在，为了使用<code>DefaultServeMux</code>作为服务器的主handler，我们不需要将它传给<code>ListenAndServe</code>函数；<code>nil</code>值就可以工作。</p>
<p>然后服务器的主函数可以简化成：</p>
<pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    db <span class="token operator">:=</span> database<span class="token punctuation">&#123;</span><span class="token string">"shoes"</span><span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token string">"socks"</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">&#125;</span>
    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/list"</span><span class="token punctuation">,</span> db<span class="token punctuation">.</span>list<span class="token punctuation">)</span>
    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/price"</span><span class="token punctuation">,</span> db<span class="token punctuation">.</span>price<span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">"localhost:8000"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>最后，一个重要的提示：就像我们在1.7节中提到的，web服务器在一个新的协程中调用每一个handler，所以当handler获取其它协程或者这个handler本身的其它请求也可以访问到变量时，一定要使用预防措施，比如锁机制。我们后面的两章中将讲到并发相关的知识。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="filefi 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="filefi 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>filefi
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://ifelif.cn/2022/notes-of-gopl/" title="《The Go Programming Language》学习笔记">https://ifelif.cn/2022/notes-of-gopl/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Golang/" rel="tag"># Golang</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/from_A-Tour-of-Go_to_Effective-Go/" rel="prev" title="从《A Tour of Go》到《Effective Go》">
                  <i class="fa fa-chevron-left"></i> 从《A Tour of Go》到《Effective Go》
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/How-does-the-Recycle-Bin-in-Windows-work/" rel="next" title="How does the Recycle Bin in Windows work?">
                  How does the Recycle Bin in Windows work? <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">filefi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/filefi" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.45" zIndex="-1" src="/plugins/ribbon.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.14.0/source/js/comments.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.14.0/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.14.0/source/js/schemes/muse.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.14.0/source/js/next-boot.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.14.0/source/js/third-party/search/local-search.min.js"></script>





  





</body>
</html>
